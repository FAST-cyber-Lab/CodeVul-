instruction,input,output
Detect whether the following code contains vulnerabilities.,"static int read_is_valid ( const uint8_t * start , size_t len , const uint8_t * end ) {
 return len != 0 && len <= ( size_t ) ( end - start ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int _tiffMapProc ( thandle_t fd , void * * pbase , toff_t * psize ) {
 uint64 size ;
 tmsize_t sizem ;
 HANDLE hMapFile ;
 size = _tiffSizeProc ( fd ) ;
 sizem = ( tmsize_t ) size ;
 if ( ( uint64 ) sizem != size ) return ( 0 ) ;
 hMapFile = CreateFileMapping ( fd , NULL , PAGE_READONLY , 0 , 0 , NULL ) ;
 if ( hMapFile == NULL ) return ( 0 ) ;
 * pbase = MapViewOfFile ( hMapFile , FILE_MAP_READ , 0 , 0 , 0 ) ;
 CloseHandle ( hMapFile ) ;
 if ( * pbase == NULL ) return ( 0 ) ;
 * psize = size ;
 return ( 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int h261_decode_mb_skipped ( H261Context * h , int mba1 , int mba2 ) {
 MpegEncContext * const s = & h -> s ;
 int i ;
 s -> mb_intra = 0 ;
 for ( i = mba1 ;
 i < mba2 ;
 i ++ ) {
 int j , xy ;
 s -> mb_x = ( ( h -> gob_number - 1 ) % 2 ) * 11 + i % 11 ;
 s -> mb_y = ( ( h -> gob_number - 1 ) / 2 ) * 3 + i / 11 ;
 xy = s -> mb_x + s -> mb_y * s -> mb_stride ;
 ff_init_block_index ( s ) ;
 ff_update_block_index ( s ) ;
 for ( j = 0 ;
 j < 6 ;
 j ++ ) s -> block_last_index [ j ] = - 1 ;
 s -> mv_dir = MV_DIR_FORWARD ;
 s -> mv_type = MV_TYPE_16X16 ;
 s -> current_picture . f . mb_type [ xy ] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0 ;
 s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;
 s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;
 s -> mb_skipped = 1 ;
 h -> mtype &= ~ MB_TYPE_H261_FIL ;
 ff_MPV_decode_mb ( s , s -> block ) ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * allocString ( uint32_t length ) {
 uint32_t top = stringTop + length ;
 char * p ;
 if ( top > STRING_STORE_SIZE ) {
 fprintf ( stderr , ""gencmn: out of memory\n"" ) ;
 exit ( U_MEMORY_ALLOCATION_ERROR ) ;
 }
 p = stringStore + stringTop ;
 stringTop = top ;
 return p ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int jbig2_word_stream_buf_get_next_word ( Jbig2WordStream * self , int offset , uint32_t * word ) {
 Jbig2WordStreamBuf * z = ( Jbig2WordStreamBuf * ) self ;
 const byte * data = z -> data ;
 uint32_t result ;
 if ( offset + 4 < z -> size ) result = ( data [ offset ] << 24 ) | ( data [ offset + 1 ] << 16 ) | ( data [ offset + 2 ] << 8 ) | data [ offset + 3 ] ;
 else if ( offset > z -> size ) return - 1 ;
 else {
 int i ;
 result = 0 ;
 for ( i = 0 ;
 i < z -> size - offset ;
 i ++ ) result |= data [ offset + i ] << ( ( 3 - i ) << 3 ) ;
 }
 * word = result ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline dma_addr_t xhci_addr64 ( uint32_t low , uint32_t high ) {
 if ( sizeof ( dma_addr_t ) == 4 ) {
 return low ;
 }
 else {
 return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int isoent_find_out_boot_file ( struct archive_write * a , struct isoent * rootent ) {
 struct iso9660 * iso9660 = a -> format_data ;
 iso9660 -> el_torito . boot = isoent_find_entry ( rootent , iso9660 -> el_torito . boot_filename . s ) ;
 if ( iso9660 -> el_torito . boot == NULL ) {
 archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Can't find the boot image file ``%s''"" , iso9660 -> el_torito . boot_filename . s ) ;
 return ( ARCHIVE_FATAL ) ;
 }
 iso9660 -> el_torito . boot -> file -> boot = BOOT_IMAGE ;
 return ( ARCHIVE_OK ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {
 OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;
 }
 static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {
 OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;
 }
 LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {
 OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;
 }
 LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( BrowsingDataRemoverImplTest , RemoveChannelIDLastHour ) {
 RemoveChannelIDTester tester ( GetBrowserContext ( ) ) ;
 base : : Time now = base : : Time : : Now ( ) ;
 tester . AddChannelID ( kTestOrigin1 ) ;
 tester . AddChannelIDWithTimes ( kTestOrigin2 , now - base : : TimeDelta : : FromHours ( 2 ) ) ;
 EXPECT_EQ ( 0 , tester . ssl_config_changed_count ( ) ) ;
 EXPECT_EQ ( 2 , tester . ChannelIDCount ( ) ) ;
 BlockUntilBrowsingDataRemoved ( AnHourAgo ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , false ) ;
 EXPECT_EQ ( BrowsingDataRemover : : REMOVE_CHANNEL_IDS , GetRemovalMask ( ) ) ;
 EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;
 EXPECT_EQ ( 1 , tester . ssl_config_changed_count ( ) ) ;
 ASSERT_EQ ( 1 , tester . ChannelIDCount ( ) ) ;
 net : : ChannelIDStore : : ChannelIDList channel_ids ;
 tester . GetChannelIDList ( & channel_ids ) ;
 ASSERT_EQ ( 1U , channel_ids . size ( ) ) ;
 EXPECT_EQ ( kTestOrigin2 , channel_ids . front ( ) . server_identifier ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void linux_udev_hotplug_poll ( void ) {
 struct udev_device * udev_dev ;
 usbi_mutex_static_lock ( & linux_hotplug_lock ) ;
 do {
 udev_dev = udev_monitor_receive_device ( udev_monitor ) ;
 if ( udev_dev ) {
 usbi_dbg ( ""Handling hotplug event from hotplug_poll"" ) ;
 udev_hotplug_event ( udev_dev ) ;
 }
 }
 while ( udev_dev ) ;
 usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void k12_close ( wtap * wth ) {
 k12_t * k12 = ( k12_t * ) wth -> priv ;
 destroy_k12_file_data ( k12 ) ;
 wth -> priv = NULL ;
 # ifdef DEBUG_K12 K12_DBG ( 5 , ( ""k12_close: CLOSED"" ) ) ;
 if ( env_file ) fclose ( dbg_out ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 char inputbuf [ 4096 ] ;
 unsigned char * buf ;
 size_t len ;
 gpg_error_t err ;
 if ( argc == 2 && ! strcmp ( argv [ 1 ] , ""--to-str"" ) ) {
 fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;
 if ( ! feof ( stdin ) ) fail ( ""read error or input too large"" ) ;
 fail ( ""no yet implemented"" ) ;
 }
 else if ( argc == 2 && ! strcmp ( argv [ 1 ] , ""--to-der"" ) ) {
 fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;
 if ( ! feof ( stdin ) ) fail ( ""read error or input too large"" ) ;
 err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;
 fail_if_err ( err ) ;
 fwrite ( buf , len , 1 , stdout ) ;
 }
 else if ( argc == 1 ) {
 test_0 ( ) ;
 test_1 ( ) ;
 test_2 ( ) ;
 }
 else {
 fprintf ( stderr , ""usage: t-dnparser [--to-str|--to-der]\n"" ) ;
 return 1 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"jpc_pchglist_t * jpc_pchglist_copy ( jpc_pchglist_t * pchglist ) {
 jpc_pchglist_t * newpchglist ;
 jpc_pchg_t * newpchg ;
 int pchgno ;
 if ( ! ( newpchglist = jpc_pchglist_create ( ) ) ) {
 return 0 ;
 }
 for ( pchgno = 0 ;
 pchgno < pchglist -> numpchgs ;
 ++ pchgno ) {
 if ( ! ( newpchg = jpc_pchg_copy ( pchglist -> pchgs [ pchgno ] ) ) || jpc_pchglist_insert ( newpchglist , - 1 , newpchg ) ) {
 jpc_pchglist_destroy ( newpchglist ) ;
 return 0 ;
 }
 }
 return newpchglist ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void mspack_fmap_close ( struct mspack_file * file ) {
 struct mspack_handle * mspack_handle = ( struct mspack_handle * ) file ;
 if ( ! mspack_handle ) return ;
 if ( mspack_handle -> type == FILETYPE_FILENAME ) fclose ( mspack_handle -> f ) ;
 free ( mspack_handle ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_non_myanmar_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestClearProfileState ) {
 base : : DictionaryValue prefs ;
 prefs . SetBoolean ( ""tel"" , true ) ;
 profile_ -> GetPrefs ( ) -> Set ( prefs : : kExcludedSchemes , prefs ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 ExternalProtocolHandler : : ClearData ( profile_ . get ( ) ) ;
 EXPECT_TRUE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dtap_cc_call_proceed ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {
 guint32 curr_offset ;
 guint32 consumed ;
 guint curr_len ;
 curr_offset = offset ;
 curr_len = len ;
 is_uplink = IS_UPLINK_FALSE ;
 ELEM_OPT_TV_SHORT ( 0xd0 , GSM_A_PDU_TYPE_DTAP , DE_REPEAT_IND , "" BC repeat indicator"" ) ;
 ELEM_OPT_TLV ( 0x04 , GSM_A_PDU_TYPE_DTAP , DE_BEARER_CAP , "" 1"" ) ;
 ELEM_OPT_TLV ( 0x04 , GSM_A_PDU_TYPE_DTAP , DE_BEARER_CAP , "" 2"" ) ;
 ELEM_OPT_TLV ( 0x1c , GSM_A_PDU_TYPE_DTAP , DE_FACILITY , NULL ) ;
 ELEM_OPT_TLV ( 0x1e , GSM_A_PDU_TYPE_DTAP , DE_PROG_IND , NULL ) ;
 ELEM_OPT_TV_SHORT ( 0x80 , GSM_A_PDU_TYPE_COMMON , DE_PRIO , NULL ) ;
 ELEM_OPT_TLV ( 0x2f , GSM_A_PDU_TYPE_DTAP , DE_NET_CC_CAP , NULL ) ;
 EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Https ) {
 StartHttpsServer ( false ) ;
 base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( https_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void ohci_hard_reset ( OHCIState * ohci ) {
 ohci_soft_reset ( ohci ) ;
 ohci -> ctl = 0 ;
 ohci_roothub_reset ( ohci ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 gpg_error_t err ;
 if ( argc ) {
 argc -- ;
 argv ++ ;
 }
 if ( argc ) {
 unsigned char * buffer ;
 size_t n , buflen ;
 for ( ;
 argc ;
 argc -- , argv ++ ) {
 err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;
 if ( err ) {
 fprintf ( stderr , ""can't convert `%s': %s\n"" , * argv , gpg_strerror ( err ) ) ;
 return 1 ;
 }
 printf ( ""%s ->"" , * argv ) ;
 for ( n = 0 ;
 n < buflen ;
 n ++ ) printf ( "" %02X"" , buffer [ n ] ) ;
 putchar ( '\n' ) ;
 free ( buffer ) ;
 }
 }
 else {
 char * buffer ;
 size_t buflen ;
 char * result ;
 buffer = read_into_buffer ( stdin , & buflen ) ;
 result = ksba_oid_to_str ( buffer , buflen ) ;
 free ( buffer ) ;
 printf ( ""%s\n"" , result ? result : ""[malloc failed]"" ) ;
 free ( result ) ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int do_rawv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen ) {
 struct raw6_sock * rp = raw6_sk ( sk ) ;
 int val , len ;
 if ( get_user ( len , optlen ) ) return - EFAULT ;
 switch ( optname ) {
 case IPV6_CHECKSUM : if ( rp -> checksum == 0 ) val = - 1 ;
 else val = rp -> offset ;
 break ;
 default : return - ENOPROTOOPT ;
 }
 len = min_t ( unsigned int , sizeof ( int ) , len ) ;
 if ( put_user ( len , optlen ) ) return - EFAULT ;
 if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void nautilus_directory_get_info_for_new_files ( NautilusDirectory * directory , GList * location_list ) {
 NewFilesState * state ;
 GFile * location ;
 GList * l ;
 if ( location_list == NULL ) {
 return ;
 }
 state = g_new ( NewFilesState , 1 ) ;
 state -> directory = directory ;
 state -> cancellable = g_cancellable_new ( ) ;
 state -> count = 0 ;
 for ( l = location_list ;
 l != NULL ;
 l = l -> next ) {
 location = l -> data ;
 state -> count ++ ;
 g_file_query_info_async ( location , NAUTILUS_FILE_DEFAULT_ATTRIBUTES , 0 , G_PRIORITY_DEFAULT , state -> cancellable , new_files_callback , state ) ;
 }
 directory -> details -> new_files_in_progress = g_list_prepend ( directory -> details -> new_files_in_progress , state ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void band_destroy ( jpc_enc_band_t * band ) {
 jpc_enc_prc_t * prc ;
 jpc_enc_rlvl_t * rlvl ;
 uint_fast32_t prcno ;
 if ( band -> prcs ) {
 rlvl = band -> rlvl ;
 for ( prcno = 0 , prc = band -> prcs ;
 prcno < rlvl -> numprcs ;
 ++ prcno , ++ prc ) {
 prc_destroy ( prc ) ;
 }
 jas_free ( band -> prcs ) ;
 }
 if ( band -> data ) {
 jas_seq2d_destroy ( band -> data ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_pcp_message_user_auth ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {
 col_append_fstr ( pinfo -> cinfo , COL_INFO , ""[%s]"" , val_to_str ( PCP_PDU_USER_AUTH , packettypenames , ""Unknown Type:0x%02x"" ) ) ;
 proto_tree_add_item ( tree , hf_pcp_user_auth_payload , tvb , offset , - 1 , ENC_NA ) ;
 return tvb_reported_length ( tvb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void traverse_bitmap_commit_list ( show_reachable_fn show_reachable ) {
 assert ( bitmap_git . result ) ;
 show_objects_for_type ( bitmap_git . result , bitmap_git . commits , OBJ_COMMIT , show_reachable ) ;
 show_objects_for_type ( bitmap_git . result , bitmap_git . trees , OBJ_TREE , show_reachable ) ;
 show_objects_for_type ( bitmap_git . result , bitmap_git . blobs , OBJ_BLOB , show_reachable ) ;
 show_objects_for_type ( bitmap_git . result , bitmap_git . tags , OBJ_TAG , show_reachable ) ;
 show_extended_objects ( bitmap_git . result , show_reachable ) ;
 bitmap_free ( bitmap_git . result ) ;
 bitmap_git . result = NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"inline UChar * toUCharPtr ( char16_t * p ) {
 # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;
 # endif return reinterpret_cast < UChar * > ( p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"double vp9_convert_qindex_to_q ( int qindex ) {
 return vp9_ac_quant ( qindex , 0 ) / 4.0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int tile_worker_hook ( void * arg1 , void * arg2 ) {
 TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;
 const TileInfo * const tile = ( TileInfo * ) arg2 ;
 int mi_row , mi_col ;
 for ( mi_row = tile -> mi_row_start ;
 mi_row < tile -> mi_row_end ;
 mi_row += MI_BLOCK_SIZE ) {
 vp9_zero ( tile_data -> xd . left_context ) ;
 vp9_zero ( tile_data -> xd . left_seg_context ) ;
 for ( mi_col = tile -> mi_col_start ;
 mi_col < tile -> mi_col_end ;
 mi_col += MI_BLOCK_SIZE ) {
 decode_partition ( tile_data -> cm , & tile_data -> xd , tile , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ;
 }
 }
 return ! tile_data -> xd . corrupted ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_IsupNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_IsupNumber , IsupNumber_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int parse_CCategorizationSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 proto_item * item ;
 proto_tree * tree ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCategorizationSpec , & item , txt ) ;
 offset = parse_CColumnSet ( tvb , offset , tree , ""csColumns"" ) ;
 offset = parse_CCategSpec ( tvb , offset , tree , pad_tree , ""Spec"" ) ;
 offset = parse_CAggregSet ( tvb , offset , tree , pad_tree , ""AggregSet"" ) ;
 offset = parse_CSortAggregSet ( tvb , offset , tree , pad_tree , ""SortAggregSet"" ) ;
 offset = parse_CInGroupSortAggregSets ( tvb , offset , tree , pad_tree , ""InGroupSortAggregSets"" ) ;
 proto_tree_add_item ( tree , hf_mswsp_categorizationspec_cmaxres , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;
 offset += 4 ;
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , ftruncate ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 long size ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""l"" , & size ) == FAILURE ) {
 return ;
 }
 if ( ! php_stream_truncate_supported ( intern -> u . file . stream ) ) {
 zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , ""Can't truncate file %s"" , intern -> file_name ) ;
 RETURN_FALSE ;
 }
 RETURN_BOOL ( 0 == php_stream_truncate_set_size ( intern -> u . file . stream , size ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline __uint16_t __uint16_identity ( __uint16_t __x ) {
 return __x ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l )",1
Detect whether the following code contains vulnerabilities.,"static void set_pseudo_header_frame6 ( wtap * wth , union wtap_pseudo_header * pseudo_header , struct frame6_rec * frame6 _U_ ) {
 switch ( wth -> file_encap ) {
 case WTAP_ENCAP_ETHERNET : pseudo_header -> eth . fcs_len = - 1 ;
 break ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static struct FrameData * fd_create ( void * buf , size_t size , vpx_codec_frame_flags_t flags ) {
 struct FrameData * const frame_data = ( struct FrameData * ) vpx_malloc ( sizeof ( * frame_data ) ) ;
 if ( frame_data == NULL ) {
 return NULL ;
 }
 frame_data -> buf = vpx_malloc ( size ) ;
 if ( frame_data -> buf == NULL ) {
 vpx_free ( frame_data ) ;
 return NULL ;
 }
 vpx_memcpy ( frame_data -> buf , buf , size ) ;
 frame_data -> size = size ;
 frame_data -> flags = flags ;
 return frame_data ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline uint32_t vga_read_dword_le ( VGACommonState * vga , uint32_t addr ) {
 uint32_t offset = addr & vga -> vbe_size_mask & ~ 3 ;
 uint32_t * ptr = ( uint32_t * ) ( vga -> vram_ptr + offset ) ;
 return ldl_le_p ( ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dump_sp ( struct xfrm_policy * xp , int dir , int count , void * ptr ) {
 struct pfkey_sock * pfk = ptr ;
 struct sk_buff * out_skb ;
 struct sadb_msg * out_hdr ;
 int err ;
 if ( ! pfkey_can_dump ( & pfk -> sk ) ) return - ENOBUFS ;
 out_skb = pfkey_xfrm_policy2msg_prep ( xp ) ;
 if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;
 err = pfkey_xfrm_policy2msg ( out_skb , xp , dir ) ;
 if ( err < 0 ) return err ;
 out_hdr = ( struct sadb_msg * ) out_skb -> data ;
 out_hdr -> sadb_msg_version = pfk -> dump . msg_version ;
 out_hdr -> sadb_msg_type = SADB_X_SPDDUMP ;
 out_hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ;
 out_hdr -> sadb_msg_errno = 0 ;
 out_hdr -> sadb_msg_seq = count + 1 ;
 out_hdr -> sadb_msg_pid = pfk -> dump . msg_portid ;
 if ( pfk -> dump . skb ) pfkey_broadcast ( pfk -> dump . skb , GFP_ATOMIC , BROADCAST_ONE , & pfk -> sk , sock_net ( & pfk -> sk ) ) ;
 pfk -> dump . skb = out_skb ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_INTEGER_1_255 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 255U , NULL , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * ptvcursor_add_no_advance ( ptvcursor_t * ptvc , int hf , gint length , const guint encoding ) {
 proto_item * item ;
 item = proto_tree_add_item ( ptvc -> tree , hf , ptvc -> tvb , ptvc -> offset , length , encoding ) ;
 return item ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void U_CALLCONV normalizationCorrectionsLineFn ( void * context , char * fields [ ] [ 2 ] , int32_t fieldCount , UErrorCode * pErrorCode ) {
 uint32_t mapping [ 40 ] ;
 char * end , * s ;
 uint32_t code ;
 int32_t length ;
 UVersionInfo version ;
 UVersionInfo thisVersion ;
 code = ( uint32_t ) uprv_strtoul ( fields [ 0 ] [ 0 ] , & end , 16 ) ;
 if ( U_FAILURE ( * pErrorCode ) ) {
 fprintf ( stderr , ""gensprep: error parsing NormalizationCorrections.txt mapping at %s\n"" , fields [ 0 ] [ 0 ] ) ;
 exit ( * pErrorCode ) ;
 }
 s = fields [ 1 ] [ 0 ] ;
 length = u_parseCodePoints ( s , mapping , sizeof ( mapping ) / 4 , pErrorCode ) ;
 u_versionFromString ( version , fields [ 3 ] [ 0 ] ) ;
 u_versionFromString ( thisVersion , ""3.2.0"" ) ;
 if ( U_FAILURE ( * pErrorCode ) ) {
 fprintf ( stderr , ""gensprep error parsing NormalizationCorrections.txt of U+%04lx - %s\n"" , ( long ) code , u_errorName ( * pErrorCode ) ) ;
 exit ( * pErrorCode ) ;
 }
 if ( version [ 0 ] > thisVersion [ 0 ] || ( ( version [ 0 ] == thisVersion [ 0 ] ) && ( version [ 1 ] > thisVersion [ 1 ] ) ) ) {
 storeMapping ( code , mapping , length , USPREP_MAP , pErrorCode ) ;
 }
 setUnicodeVersionNC ( version ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vacuum_all_databases ( vacuumingOptions * vacopts , bool analyze_in_stages , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , int concurrentCons , const char * progname , bool echo , bool quiet ) {
 PGconn * conn ;
 PGresult * result ;
 int stage ;
 int i ;
 conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;
 result = executeQuery ( conn , ""SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;
"" , progname , echo ) ;
 PQfinish ( conn ) ;
 if ( analyze_in_stages ) {
 for ( stage = 0 ;
 stage < ANALYZE_NUM_STAGES ;
 stage ++ ) {
 for ( i = 0 ;
 i < PQntuples ( result ) ;
 i ++ ) {
 const char * dbname ;
 dbname = PQgetvalue ( result , i , 0 ) ;
 vacuum_one_database ( dbname , vacopts , stage , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;
 }
 }
 }
 else {
 for ( i = 0 ;
 i < PQntuples ( result ) ;
 i ++ ) {
 const char * dbname ;
 dbname = PQgetvalue ( result , i , 0 ) ;
 vacuum_one_database ( dbname , vacopts , ANALYZE_NO_STAGE , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;
 }
 }
 PQclear ( result ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_h225_CryptoH323Token ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_CryptoH323Token , CryptoH323Token_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void mp_flush ( MPADecodeContext * ctx ) {
 memset ( ctx -> synth_buf , 0 , sizeof ( ctx -> synth_buf ) ) ;
 ctx -> last_buf_size = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int unreference_pic ( H264Context * h , Picture * pic , int refmask ) {
 int i ;
 if ( pic -> f . reference &= refmask ) {
 return 0 ;
 }
 else {
 for ( i = 0 ;
 h -> delayed_pic [ i ] ;
 i ++ ) if ( pic == h -> delayed_pic [ i ] ) {
 pic -> f . reference = DELAYED_PIC_REF ;
 break ;
 }
 return 1 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int s_aos_available ( stream * s , gs_offset_t * pl ) {
 * pl = ( ( aos_state_t * ) s -> state ) -> file_sz - stell ( s ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) {
 MACROBLOCKD * const xd = & x -> e_mbd ;
 const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 struct rdcost_block_args args ;
 vp9_zero ( args ) ;
 args . x = x ;
 args . best_rd = ref_best_rd ;
 args . use_fast_coef_costing = use_fast_coef_casting ;
 if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;
 vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ;
 args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ;
 vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ;
 if ( args . skip ) {
 * rate = INT_MAX ;
 * distortion = INT64_MAX ;
 * sse = INT64_MAX ;
 * skippable = 0 ;
 }
 else {
 * distortion = args . this_dist ;
 * rate = args . this_rate ;
 * sse = args . this_sse ;
 * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_usb_vid_control_info ( proto_tree * tree , tvbuff_t * tvb , int offset ) {
 static const int * capability_bits [ ] = {
 & hf_usb_vid_control_info_D [ 0 ] , & hf_usb_vid_control_info_D [ 1 ] , & hf_usb_vid_control_info_D [ 2 ] , & hf_usb_vid_control_info_D [ 3 ] , & hf_usb_vid_control_info_D [ 4 ] , & hf_usb_vid_control_info_D [ 5 ] , & hf_usb_vid_control_info_D [ 6 ] , NULL }
 ;
 DISSECTOR_ASSERT ( array_length ( capability_bits ) == ( 1 + array_length ( hf_usb_vid_control_info_D ) ) ) ;
 proto_tree_add_bitmask ( tree , tvb , offset , hf_usb_vid_control_info , ett_control_capabilities , capability_bits , ENC_NA ) ;
 return offset + 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST ( BuildTime , DateLooksValid ) {
 # if ! defined ( DONT_EMBED_BUILD_METADATA ) char build_date [ ] = __DATE__ ;
 # else char build_date [ ] = ""Sep 02 2008"" ;
 # endif EXPECT_EQ ( 11u , strlen ( build_date ) ) ;
 EXPECT_EQ ( ' ' , build_date [ 3 ] ) ;
 EXPECT_EQ ( ' ' , build_date [ 6 ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cpu_signal ( int sig ) {
 if ( cpu_single_env ) {
 cpu_exit ( ENV_GET_CPU ( cpu_single_env ) ) ;
 }
 exit_request = 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 VP9_COMP * const cpi = ctx -> cpi ;
 vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ;
 if ( params == NULL || params -> spatial_layer < 0 || params -> spatial_layer >= cpi -> svc . number_spatial_layers ) return VPX_CODEC_INVALID_PARAM ;
 if ( params -> spatial_layer == 0 ) {
 int i ;
 for ( i = 0 ;
 i < cpi -> svc . number_spatial_layers ;
 ++ i ) {
 cpi -> svc . layer_context [ i ] . svc_params_received . spatial_layer = - 1 ;
 }
 }
 cpi -> svc . layer_context [ params -> spatial_layer ] . svc_params_received = * params ;
 return VPX_CODEC_OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void restore_stack_limit ( lua_State * L ) {
 lua_assert ( L -> stack_last - L -> stack == L -> stacksize - EXTRA_STACK - 1 ) ;
 if ( L -> size_ci > LUAI_MAXCALLS ) {
 int inuse = cast_int ( L -> ci - L -> base_ci ) ;
 if ( inuse + 1 < LUAI_MAXCALLS ) luaD_reallocCI ( L , LUAI_MAXCALLS ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {
 vpx_codec_ctx_t codec ;
 int frame_count = 0 ;
 vpx_fixed_buf_t stats = {
 NULL , 0 }
 ;
 if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , ""Failed to initialize encoder"" ) ;
 while ( vpx_img_read ( raw , infile ) ) {
 ++ frame_count ;
 get_frame_stats ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;
 }
 while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {
 }
 printf ( ""Pass 0 complete. Processed %d frames.\n"" , frame_count ) ;
 if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed to destroy codec."" ) ;
 return stats ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int nb_add_time ( char * * ret_buffer , size_t * ret_buffer_len , uint16_t type , double value ) {
 uint64_t cdtime_value = ( uint64_t ) ( value * 1073741824.0 ) ;
 return ( nb_add_number ( ret_buffer , ret_buffer_len , type , cdtime_value ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void U_CALLCONV _ISCIIReset ( UConverter * cnv , UConverterResetChoice choice ) {
 UConverterDataISCII * data = ( UConverterDataISCII * ) ( cnv -> extraInfo ) ;
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> toUnicodeStatus = missingCharMarker ;
 cnv -> mode = 0 ;
 data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;
 data -> currentMaskToUnicode = data -> defMaskToUnicode ;
 data -> contextCharToUnicode = NO_CHAR_MARKER ;
 data -> prevToUnicodeStatus = 0x0000 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUChar32 = 0x0000 ;
 data -> contextCharFromUnicode = 0x00 ;
 data -> currentMaskFromUnicode = data -> defMaskToUnicode ;
 data -> currentDeltaFromUnicode = data -> defDeltaToUnicode ;
 data -> isFirstBuffer = TRUE ;
 data -> resetToDefaultToUnicode = FALSE ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void make_bands ( int16_t * bands , int start , int stop , int num_bands ) {
 int k , previous , present ;
 float base , prod ;
 base = powf ( ( float ) stop / start , 1.0f / num_bands ) ;
 prod = start ;
 previous = start ;
 for ( k = 0 ;
 k < num_bands - 1 ;
 k ++ ) {
 prod *= base ;
 present = lrintf ( prod ) ;
 bands [ k ] = present - previous ;
 previous = present ;
 }
 bands [ num_bands - 1 ] = stop - previous ;
 }",1
Detect whether the following code contains vulnerabilities.,"kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {
 kadm5_server_handle_t handle = server_handle ;
 osa_policy_ent_t entry ;
 int ret ;
 CHECK_HANDLE ( server_handle ) ;
 krb5_clear_error_message ( handle -> context ) ;
 if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;
 if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;
 ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;
 if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;
 else if ( ret ) return ret ;
 if ( entry -> policy_refcnt != 0 ) {
 krb5_db_free_policy ( handle -> context , entry ) ;
 return KADM5_POLICY_REF ;
 }
 krb5_db_free_policy ( handle -> context , entry ) ;
 ret = krb5_db_delete_policy ( handle -> context , name ) ;
 if ( ret == KRB5_KDB_POLICY_REF ) ret = KADM5_POLICY_REF ;
 return ( ret == 0 ) ? KADM5_OK : ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_double_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 int32_t len ;
 double num ;
 UNumberFormat * format ;
 int32_t parsePos = 0 ;
 int32_t skipped ;
 UErrorCode status = U_ZERO_ERROR ;
 skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 ufile_fill_uchar_buffer ( input ) ;
 len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;
 if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;
 format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_DECIMAL ) ;
 if ( format == 0 ) return 0 ;
 skipped += u_scanf_skip_leading_positive_sign ( input , format , & status ) ;
 num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;
 if ( ! info -> fSkipArg ) {
 if ( info -> fIsLong ) * ( double * ) ( args [ 0 ] . ptrValue ) = num ;
 else if ( info -> fIsLongDouble ) * ( long double * ) ( args [ 0 ] . ptrValue ) = num ;
 else * ( float * ) ( args [ 0 ] . ptrValue ) = ( float ) num ;
 }
 input -> str . fPos += parsePos ;
 * argConverted = ! info -> fSkipArg ;
 return parsePos + skipped ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void mark_trusted_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {
 MarkTrustedJob * job = task_data ;
 CommonJob * common ;
 common = ( CommonJob * ) job ;
 nautilus_progress_info_start ( job -> common . progress ) ;
 mark_desktop_file_trusted ( common , cancellable , job -> file , job -> interactive ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void setup_masks_arabic ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font HB_UNUSED ) {
 HB_BUFFER_ALLOCATE_VAR ( buffer , arabic_shaping_action ) ;
 const arabic_shape_plan_t * arabic_plan = ( const arabic_shape_plan_t * ) plan -> data ;
 arabic_joining ( buffer ) ;
 if ( plan -> props . script == HB_SCRIPT_MONGOLIAN ) mongolian_variation_selectors ( buffer ) ;
 unsigned int count = buffer -> len ;
 hb_glyph_info_t * info = buffer -> info ;
 for ( unsigned int i = 0 ;
 i < count ;
 i ++ ) info [ i ] . mask |= arabic_plan -> mask_array [ info [ i ] . arabic_shaping_action ( ) ] ;
 HB_BUFFER_DEALLOCATE_VAR ( buffer , arabic_shaping_action ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void ber_rewind ( BerElement * ber ) {
 ber -> ber_rwptr = NULL ;
 ber -> ber_sos_ptr = NULL ;
 ber -> ber_end = ber -> ber_ptr ;
 ber -> ber_ptr = ber -> ber_buf ;
 # if 0 ber -> ber_tag = LBER_DEFAULT ;
 ber -> ber_usertag = 0 ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"VirtIOS390Bus * s390_virtio_bus_init ( ram_addr_t * ram_size ) {
 VirtIOS390Bus * bus ;
 BusState * _bus ;
 DeviceState * dev ;
 dev = qdev_create ( NULL , ""s390-virtio-bridge"" ) ;
 qdev_init_nofail ( dev ) ;
 _bus = qbus_create ( & s390_virtio_bus_info , dev , ""s390-virtio"" ) ;
 bus = DO_UPCAST ( VirtIOS390Bus , bus , _bus ) ;
 bus -> dev_page = * ram_size ;
 bus -> dev_offs = bus -> dev_page ;
 bus -> next_ring = bus -> dev_page + TARGET_PAGE_SIZE ;
 * ram_size += S390_DEVICE_PAGES * TARGET_PAGE_SIZE ;
 return bus ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMainContextDuringShutdown ) {
 StartActiveFetcherDuringProfileShutdownTest ( browser ( ) -> profile ( ) -> GetRequestContext ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int qemuMonitorJSONGetBlockJobInfo ( virJSONValuePtr reply , const char * device , virDomainBlockJobInfoPtr info ) {
 virJSONValuePtr data ;
 int nr_results , i ;
 if ( ! info ) return - 1 ;
 if ( ( data = virJSONValueObjectGet ( reply , ""return"" ) ) == NULL ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""reply was missing return data"" ) ) ;
 return - 1 ;
 }
 if ( data -> type != VIR_JSON_TYPE_ARRAY ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""urecognized format of block job information"" ) ) ;
 return - 1 ;
 }
 if ( ( nr_results = virJSONValueArraySize ( data ) ) < 0 ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""unable to determine array size"" ) ) ;
 return - 1 ;
 }
 for ( i = 0 ;
 i < nr_results ;
 i ++ ) {
 virJSONValuePtr entry = virJSONValueArrayGet ( data , i ) ;
 if ( ! entry ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""missing array element"" ) ) ;
 return - 1 ;
 }
 if ( qemuMonitorJSONGetBlockJobInfoOne ( entry , device , info ) == 0 ) return 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestAcceptWithChecked ) {
 ShowDialog ( ) ;
 SetChecked ( true ) ;
 EXPECT_TRUE ( dialog_ -> Accept ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_TRUE ( accept_ ) ;
 EXPECT_FALSE ( cancel_ ) ;
 EXPECT_TRUE ( dont_block_ ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 1 , 1 ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : CHECKED_LAUNCH , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decrypt ( MPI output , MPI a , MPI b , ELG_secret_key * skey ) {
 MPI t1 = mpi_alloc_secure ( mpi_get_nlimbs ( skey -> p ) ) ;
 mpi_normalize ( a ) ;
 mpi_normalize ( b ) ;
 mpi_powm ( t1 , a , skey -> x , skey -> p ) ;
 mpi_invm ( t1 , t1 , skey -> p ) ;
 mpi_mulm ( output , b , t1 , skey -> p ) ;
 # if 0 if ( DBG_CIPHER ) {
 log_mpidump ( ""elg decrypted x= "" , skey -> x ) ;
 log_mpidump ( ""elg decrypted p= "" , skey -> p ) ;
 log_mpidump ( ""elg decrypted a= "" , a ) ;
 log_mpidump ( ""elg decrypted b= "" , b ) ;
 log_mpidump ( ""elg decrypted M= "" , output ) ;
 }
 # endif mpi_free ( t1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void finish_object ( struct object * obj , const struct name_path * path , const char * name , void * cb_data ) {
 struct rev_list_info * info = cb_data ;
 if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( ""missing blob object '%s'"" , oid_to_hex ( & obj -> oid ) ) ;
 if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void nlm_print_msgres_request ( packet_info * pinfo , proto_tree * tree , tvbuff_t * tvb ) {
 nlm_msg_res_matched_data * md ;
 md = ( nlm_msg_res_matched_data * ) g_hash_table_lookup ( nlm_msg_res_matched , GINT_TO_POINTER ( pinfo -> fd -> num ) ) ;
 if ( md ) {
 proto_tree_add_uint ( tree , hf_nlm_reply_in , tvb , 0 , 0 , md -> rep_frame ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void do_imdct ( AC3DecodeContext * s , int channels ) {
 int ch ;
 for ( ch = 1 ;
 ch <= channels ;
 ch ++ ) {
 if ( s -> block_switch [ ch ] ) {
 int i ;
 float * x = s -> tmp_output + 128 ;
 for ( i = 0 ;
 i < 128 ;
 i ++ ) x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i ] ;
 s -> imdct_256 . imdct_half ( & s -> imdct_256 , s -> tmp_output , x ) ;
 s -> fdsp . vector_fmul_window ( s -> outptr [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , 128 ) ;
 for ( i = 0 ;
 i < 128 ;
 i ++ ) x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i + 1 ] ;
 s -> imdct_256 . imdct_half ( & s -> imdct_256 , s -> delay [ ch - 1 ] , x ) ;
 }
 else {
 s -> imdct_512 . imdct_half ( & s -> imdct_512 , s -> tmp_output , s -> transform_coeffs [ ch ] ) ;
 s -> fdsp . vector_fmul_window ( s -> outptr [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , 128 ) ;
 memcpy ( s -> delay [ ch - 1 ] , s -> tmp_output + 128 , 128 * sizeof ( float ) ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_simple_percent_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 static const UChar PERCENT [ ] = {
 UP_PERCENT }
 ;
 return handler -> write ( context , PERCENT , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cbracket ( struct vars * v , struct state * lp , struct state * rp ) {
 struct state * left = newstate ( v -> nfa ) ;
 struct state * right = newstate ( v -> nfa ) ;
 NOERR ( ) ;
 bracket ( v , left , right ) ;
 if ( v -> cflags & REG_NLSTOP ) newarc ( v -> nfa , PLAIN , v -> nlcolor , left , right ) ;
 NOERR ( ) ;
 assert ( lp -> nouts == 0 ) ;
 colorcomplement ( v -> nfa , v -> cm , PLAIN , left , lp , rp ) ;
 NOERR ( ) ;
 dropstate ( v -> nfa , left ) ;
 assert ( right -> nins == 0 ) ;
 freestate ( v -> nfa , right ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {
 SvcInternal * const si = get_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {
 return VPX_CODEC_INVALID_PARAM ;
 }
 strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;
 si -> scale_factors [ sizeof ( si -> scale_factors ) - 1 ] = '\0' ;
 return VPX_CODEC_OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"static byte * i_alloc_byte_array_immovable ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {
 gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;
 obj_header_t * obj ;
 # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;
 # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;
 if_debug6m ( 'A' , mem , ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;
 return ( byte * ) obj ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool fpop_ip_dp_needed ( void * opaque ) {
 X86CPU * cpu = opaque ;
 CPUX86State * env = & cpu -> env ;
 return env -> fpop != 0 || env -> fpip != 0 || env -> fpdp != 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {
 syllable_type_t syllable_type = ( syllable_type_t ) ( buffer -> info [ start ] . syllable ( ) & 0x0F ) ;
 switch ( syllable_type ) {
 case consonant_syllable : initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;
 return ;
 case punctuation_cluster : initial_reordering_punctuation_cluster ( plan , face , buffer , start , end ) ;
 return ;
 case broken_cluster : initial_reordering_broken_cluster ( plan , face , buffer , start , end ) ;
 return ;
 case non_myanmar_cluster : initial_reordering_non_myanmar_cluster ( plan , face , buffer , start , end ) ;
 return ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , ReadAllAdvanceFirst ) {
 multibuffer_ . SetMaxWriters ( 1 ) ;
 size_t pos = 0 ;
 size_t end = 10000 ;
 multibuffer_ . SetFileSize ( 10000 ) ;
 multibuffer_ . SetMustReadWholeFile ( true ) ;
 media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;
 reader . SetMaxBuffer ( 2000 , 5000 ) ;
 reader . SetPreload ( 1000 , 1000 ) ;
 while ( pos < end ) {
 unsigned char buffer [ 27 ] ;
 buffer [ 17 ] = 17 ;
 size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;
 while ( AdvanceAll ( ) ) ;
 int64_t bytes = reader . TryRead ( buffer , to_read ) ;
 EXPECT_GT ( bytes , 0 ) ;
 EXPECT_EQ ( buffer [ 17 ] , 17 ) ;
 for ( int64_t i = 0 ;
 i < bytes ;
 i ++ ) {
 uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;
 EXPECT_EQ ( expected , buffer [ i ] ) << "" pos = "" << pos ;
 pos ++ ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"gboolean proto_tracking_interesting_fields ( const proto_tree * tree ) {
 GHashTable * interesting_hfids ;
 if ( ! tree ) return FALSE ;
 interesting_hfids = PTREE_DATA ( tree ) -> interesting_hfids ;
 return ( interesting_hfids != NULL ) && g_hash_table_size ( interesting_hfids ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {
 hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * g ;
 return c ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void init_bit_trees ( ) {
 init_bit_tree ( cat1 , 1 ) ;
 init_bit_tree ( cat2 , 2 ) ;
 init_bit_tree ( cat3 , 3 ) ;
 init_bit_tree ( cat4 , 4 ) ;
 init_bit_tree ( cat5 , 5 ) ;
 init_bit_tree ( cat6 , 14 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"METHOD ( x509_t , create_crl_uri_enumerator , enumerator_t * , private_x509_cert_t * this ) {
 return this -> crl_uris -> create_enumerator ( this -> crl_uris ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void upsample_5_4 ( float * out , const float * in , int o_size ) {
 const float * in0 = in - UPS_FIR_SIZE + 1 ;
 int i , j , k ;
 int int_part = 0 , frac_part ;
 i = 0 ;
 for ( j = 0 ;
 j < o_size / 5 ;
 j ++ ) {
 out [ i ] = in [ int_part ] ;
 frac_part = 4 ;
 i ++ ;
 for ( k = 1 ;
 k < 5 ;
 k ++ ) {
 out [ i ] = avpriv_scalarproduct_float_c ( in0 + int_part , upsample_fir [ 4 - frac_part ] , UPS_MEM_SIZE ) ;
 int_part ++ ;
 frac_part -- ;
 i ++ ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void directory_load_state_free ( DirectoryLoadState * state ) {
 if ( state -> enumerator ) {
 if ( ! g_file_enumerator_is_closed ( state -> enumerator ) ) {
 g_file_enumerator_close_async ( state -> enumerator , 0 , NULL , NULL , NULL ) ;
 }
 g_object_unref ( state -> enumerator ) ;
 }
 if ( state -> load_mime_list_hash != NULL ) {
 istr_set_destroy ( state -> load_mime_list_hash ) ;
 }
 nautilus_file_unref ( state -> load_directory_file ) ;
 g_object_unref ( state -> cancellable ) ;
 g_free ( state ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void free_static_shapers ( void ) {
 if ( unlikely ( static_shapers != all_shapers ) ) free ( ( void * ) static_shapers ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) {
 EVP_CIPHER_CTX * ctx ;
 unsigned char * in ;
 long in_len , out_len ;
 VALUE data , str ;
 rb_scan_args ( argc , argv , ""11"" , & data , & str ) ;
 StringValue ( data ) ;
 in = ( unsigned char * ) RSTRING_PTR ( data ) ;
 if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data must not be empty"" ) ;
 GetCipher ( self , ctx ) ;
 out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ;
 if ( out_len <= 0 ) {
 ossl_raise ( rb_eRangeError , ""data too big to make output buffer: %ld bytes"" , in_len ) ;
 }
 if ( NIL_P ( str ) ) {
 str = rb_str_new ( 0 , out_len ) ;
 }
 else {
 StringValue ( str ) ;
 rb_str_resize ( str , out_len ) ;
 }
 if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ;
 assert ( out_len < RSTRING_LEN ( str ) ) ;
 rb_str_set_len ( str , out_len ) ;
 return str ;
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_compute_rd_mult ( const VP9_COMP * cpi , int qindex ) {
 const int q = vp9_dc_quant ( qindex , 0 ) ;
 int rdmult = 88 * q * q / 24 ;
 if ( cpi -> oxcf . pass == 2 && ( cpi -> common . frame_type != KEY_FRAME ) ) {
 const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ;
 const FRAME_UPDATE_TYPE frame_type = gf_group -> update_type [ gf_group -> index ] ;
 const int boost_index = MIN ( 15 , ( cpi -> rc . gfu_boost / 100 ) ) ;
 rdmult = ( rdmult * rd_frame_type_factor [ frame_type ] ) >> 7 ;
 rdmult += ( ( rdmult * rd_boost_factor [ boost_index ] ) >> 7 ) ;
 }
 return rdmult ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void existing_file_removed_callback ( GFile * file , GError * error , gpointer callback_data ) {
 DeleteExistingFileData * data = callback_data ;
 CommonJob * job ;
 GFile * source ;
 GFileType file_type ;
 char * primary ;
 char * secondary ;
 char * details = NULL ;
 int response ;
 job = data -> job ;
 source = data -> source ;
 if ( error == NULL ) {
 nautilus_file_changes_queue_file_removed ( file ) ;
 return ;
 }
 if ( job_aborted ( job ) || job -> skip_all_error ) {
 return ;
 }
 primary = f ( _ ( ""Error while copying “%B”."" ) , source ) ;
 file_type = g_file_query_file_type ( file , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , job -> cancellable ) ;
 if ( file_type == G_FILE_TYPE_DIRECTORY ) {
 secondary = f ( _ ( ""Could not remove the already existing folder %F."" ) , file ) ;
 }
 else {
 secondary = f ( _ ( ""Could not remove the already existing file %F."" ) , file ) ;
 }
 details = error -> message ;
 response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ;
 if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {
 abort_job ( job ) ;
 }
 else if ( response == 1 ) {
 job -> skip_all_error = TRUE ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int qio_channel_websock_close ( QIOChannel * ioc , Error * * errp ) {
 QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( ioc ) ;
 trace_qio_channel_websock_close ( ioc ) ;
 return qio_channel_close ( wioc -> master , errp ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void predict_and_reconstruct_intra_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {
 struct intra_args * const args = ( struct intra_args * ) arg ;
 VP9_COMMON * const cm = args -> cm ;
 MACROBLOCKD * const xd = args -> xd ;
 struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 MODE_INFO * const mi = xd -> mi [ 0 ] ;
 const PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) : mi -> mbmi . uv_mode ;
 int x , y ;
 uint8_t * dst ;
 txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;
 dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ;
 vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ;
 if ( ! mi -> mbmi . skip ) {
 const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ;
 inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void irq_info ( Monitor * mon ) {
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \ {
 return rb_funcall3 ( cASN1 ## klass , rb_intern ( ""new"" ) , argc , argv ) ;
 }
 OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BMPString )",0
Detect whether the following code contains vulnerabilities.,"static CodeBook unpack_codebook ( GetBitContext * gb , unsigned depth , unsigned size ) {
 unsigned i , j ;
 CodeBook cb = {
 0 }
 ;
 if ( ! can_safely_read ( gb , size * 34 ) ) return cb ;
 if ( size >= INT_MAX / sizeof ( MacroBlock ) ) return cb ;
 cb . blocks = av_malloc ( size ? size * sizeof ( MacroBlock ) : 1 ) ;
 if ( ! cb . blocks ) return cb ;
 cb . depth = depth ;
 cb . size = size ;
 for ( i = 0 ;
 i < size ;
 i ++ ) {
 unsigned mask_bits = get_bits ( gb , 4 ) ;
 unsigned color0 = get_bits ( gb , 15 ) ;
 unsigned color1 = get_bits ( gb , 15 ) ;
 for ( j = 0 ;
 j < 4 ;
 j ++ ) {
 if ( mask_bits & ( 1 << j ) ) cb . blocks [ i ] . pixels [ j ] = color1 ;
 else cb . blocks [ i ] . pixels [ j ] = color0 ;
 }
 }
 return cb ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int check_consistent_binlog_pos ( char * binlog_pos_file , char * binlog_pos_offset ) {
 MYSQL_RES * res ;
 MYSQL_ROW row ;
 int found ;
 if ( mysql_query_with_error_report ( mysql , & res , ""SHOW STATUS LIKE 'binlog_snapshot_%'"" ) ) return 0 ;
 found = 0 ;
 while ( ( row = mysql_fetch_row ( res ) ) ) {
 if ( 0 == strcmp ( row [ 0 ] , ""Binlog_snapshot_file"" ) ) {
 if ( binlog_pos_file ) strmake ( binlog_pos_file , row [ 1 ] , FN_REFLEN - 1 ) ;
 found ++ ;
 }
 else if ( 0 == strcmp ( row [ 0 ] , ""Binlog_snapshot_position"" ) ) {
 if ( binlog_pos_offset ) strmake ( binlog_pos_offset , row [ 1 ] , LONGLONG_LEN ) ;
 found ++ ;
 }
 }
 mysql_free_result ( res ) ;
 return ( found == 2 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static AVStream * get_subtitle_pkt ( AVFormatContext * s , AVStream * next_st , AVPacket * pkt ) {
 AVIStream * ast , * next_ast = next_st -> priv_data ;
 int64_t ts , next_ts , ts_min = INT64_MAX ;
 AVStream * st , * sub_st = NULL ;
 int i ;
 next_ts = av_rescale_q ( next_ast -> frame_offset , next_st -> time_base , AV_TIME_BASE_Q ) ;
 for ( i = 0 ;
 i < s -> nb_streams ;
 i ++ ) {
 st = s -> streams [ i ] ;
 ast = st -> priv_data ;
 if ( st -> discard < AVDISCARD_ALL && ast && ast -> sub_pkt . data ) {
 ts = av_rescale_q ( ast -> sub_pkt . dts , st -> time_base , AV_TIME_BASE_Q ) ;
 if ( ts <= next_ts && ts < ts_min ) {
 ts_min = ts ;
 sub_st = st ;
 }
 }
 }
 if ( sub_st ) {
 ast = sub_st -> priv_data ;
 * pkt = ast -> sub_pkt ;
 pkt -> stream_index = sub_st -> index ;
 if ( ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) < 0 ) ast -> sub_pkt . data = NULL ;
 }
 return sub_st ;
 }",0
Detect whether the following code contains vulnerabilities.,"void pic_info ( Monitor * mon ) {
 }",0
Detect whether the following code contains vulnerabilities.,"static bool pv_eoi_msr_needed ( void * opaque ) {
 X86CPU * cpu = opaque ;
 return cpu -> env . pv_eoi_en_msr != 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) {
 char obj_txt [ 128 ] ;
 OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;
 BIO_printf ( bio , ""%s\n"" , obj_txt ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_INTEGER_M262144_262143 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , - 262144 , 262143U , NULL , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * string_decode ( PyStringObject * self , PyObject * args , PyObject * kwargs ) {
 static char * kwlist [ ] = {
 ""encoding"" , ""errors"" , 0 }
 ;
 char * encoding = NULL ;
 char * errors = NULL ;
 PyObject * v ;
 if ( ! PyArg_ParseTupleAndKeywords ( args , kwargs , ""|ss:decode"" , kwlist , & encoding , & errors ) ) return NULL ;
 v = PyString_AsDecodedObject ( ( PyObject * ) self , encoding , errors ) ;
 if ( v == NULL ) goto onError ;
 if ( ! PyString_Check ( v ) && ! PyUnicode_Check ( v ) ) {
 PyErr_Format ( PyExc_TypeError , ""decoder did not return a string/unicode object "" ""(type=%.400s)"" , Py_TYPE ( v ) -> tp_name ) ;
 Py_DECREF ( v ) ;
 return NULL ;
 }
 return v ;
 onError : return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void idcin_decode_vlcs ( IdcinContext * s ) {
 hnode * hnodes ;
 long x , y ;
 int prev ;
 unsigned char v = 0 ;
 int bit_pos , node_num , dat_pos ;
 prev = bit_pos = dat_pos = 0 ;
 for ( y = 0 ;
 y < ( s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;
 y += s -> frame . linesize [ 0 ] ) {
 for ( x = y ;
 x < y + s -> avctx -> width ;
 x ++ ) {
 node_num = s -> num_huff_nodes [ prev ] ;
 hnodes = s -> huff_nodes [ prev ] ;
 while ( node_num >= HUF_TOKENS ) {
 if ( ! bit_pos ) {
 if ( dat_pos >= s -> size ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""Huffman decode error.\n"" ) ;
 return ;
 }
 bit_pos = 8 ;
 v = s -> buf [ dat_pos ++ ] ;
 }
 node_num = hnodes [ node_num ] . children [ v & 0x01 ] ;
 v = v >> 1 ;
 bit_pos -- ;
 }
 s -> frame . data [ 0 ] [ x ] = node_num ;
 prev = node_num ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SafeJsonParserImplTest , Isolation ) {
 for ( int i = 0 ;
 i < 5 ;
 i ++ ) {
 base : : RunLoop run_loop ;
 ParseCallback parse_callback ( run_loop . QuitClosure ( ) ) ;
 SafeJsonParser : : Parse ( connector ( ) , ""[\""awesome\"", \""possum\""]"" , base : : Bind ( & ParseCallback : : OnSuccess , base : : Unretained ( & parse_callback ) ) , base : : Bind ( & ParseCallback : : OnError , base : : Unretained ( & parse_callback ) ) ) ;
 run_loop . Run ( ) ;
 EXPECT_TRUE ( parse_callback . success ( ) ) ;
 EXPECT_EQ ( 2U + i , GetServiceStartCount ( data_decoder : : mojom : : kServiceName ) ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void _pack_alloc_list_del ( void * x ) {
 resource_allocation_response_msg_t * job_info_resp_msg ;
 job_info_resp_msg = ( resource_allocation_response_msg_t * ) x ;
 job_info_resp_msg -> working_cluster_rec = NULL ;
 slurm_free_resource_allocation_response_msg_members ( job_info_resp_msg ) ;
 xfree ( job_info_resp_msg ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void set_ping_group_range ( struct ctl_table * table , gid_t range [ 2 ] ) {
 gid_t * data = table -> data ;
 write_seqlock ( & sysctl_local_ports . lock ) ;
 data [ 0 ] = range [ 0 ] ;
 data [ 1 ] = range [ 1 ] ;
 write_sequnlock ( & sysctl_local_ports . lock ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int selinux_shm_associate ( struct shmid_kernel * shp , int shmflg ) {
 struct ipc_security_struct * isec ;
 struct common_audit_data ad ;
 u32 sid = current_sid ( ) ;
 isec = shp -> shm_perm . security ;
 ad . type = LSM_AUDIT_DATA_IPC ;
 ad . u . ipc_id = shp -> shm_perm . key ;
 return avc_has_perm ( sid , isec -> sid , SECCLASS_SHM , SHM__ASSOCIATE , & ad ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( WebFrameTest , ContextMenuDataSelectAll ) {
 EXPECT_FALSE ( TestSelectAll ( ""<textarea></textarea>"" ) ) ;
 EXPECT_TRUE ( TestSelectAll ( ""<textarea>nonempty</textarea>"" ) ) ;
 EXPECT_FALSE ( TestSelectAll ( ""<input>"" ) ) ;
 EXPECT_TRUE ( TestSelectAll ( ""<input value='nonempty'>"" ) ) ;
 EXPECT_FALSE ( TestSelectAll ( ""<div contenteditable></div>"" ) ) ;
 EXPECT_TRUE ( TestSelectAll ( ""<div contenteditable>nonempty</div>"" ) ) ;
 EXPECT_TRUE ( TestSelectAll ( ""<div contenteditable>\n</div>"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void ff_release_unused_pictures ( MpegEncContext * s , int remove_current ) {
 int i ;
 for ( i = 0 ;
 i < s -> picture_count ;
 i ++ ) {
 if ( s -> picture [ i ] . f . data [ 0 ] && ! s -> picture [ i ] . f . reference && ( ! s -> picture [ i ] . owner2 || s -> picture [ i ] . owner2 == s ) && ( remove_current || & s -> picture [ i ] != s -> current_picture_ptr ) ) {
 free_frame_buffer ( s , & s -> picture [ i ] ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 using std : : string ;
 if ( argc != 2 ) {
 fprintf ( stderr , ""One argument, the input filename, must be provided.\n"" ) ;
 return 1 ;
 }
 string filename ( argv [ 1 ] ) ;
 string outfilename = filename . substr ( 0 , filename . find_last_of ( ""."" ) ) + "".woff2"" ;
 fprintf ( stdout , ""Processing %s => %s\n"" , filename . c_str ( ) , outfilename . c_str ( ) ) ;
 string input = woff2 : : GetFileContent ( filename ) ;
 const uint8_t * input_data = reinterpret_cast < const uint8_t * > ( input . data ( ) ) ;
 size_t output_size = woff2 : : MaxWOFF2CompressedSize ( input_data , input . size ( ) ) ;
 string output ( output_size , 0 ) ;
 uint8_t * output_data = reinterpret_cast < uint8_t * > ( & output [ 0 ] ) ;
 if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {
 fprintf ( stderr , ""Compression failed.\n"" ) ;
 return 1 ;
 }
 output . resize ( output_size ) ;
 woff2 : : SetFileContents ( outfilename , output ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void unlink_thd ( THD * thd ) {
 DBUG_ENTER ( ""unlink_thd"" ) ;
 DBUG_PRINT ( ""enter"" , ( ""thd: 0x%lx"" , ( long ) thd ) ) ;
 thd_cleanup ( thd ) ;
 dec_connection_count ( thd ) ;
 thd -> add_status_to_global ( ) ;
 mysql_mutex_lock ( & LOCK_thread_count ) ;
 thd -> unlink ( ) ;
 DBUG_EXECUTE_IF ( ""sleep_after_lock_thread_count_before_delete_thd"" , sleep ( 5 ) ;
 ) ;
 if ( unlikely ( abort_loop ) ) {
 delete thd ;
 thd = 0 ;
 }
 thread_count -- ;
 mysql_mutex_unlock ( & LOCK_thread_count ) ;
 delete thd ;
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_H245Control_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 368 ""./asn1/h225/h225.cnf"" tvbuff_t * h245_tvb = NULL ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h245_tvb ) ;
 next_tvb_add_handle ( & h245_list , h245_tvb , ( h225_h245_in_tree ) ? tree : NULL , h245dg_handle ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void test_signal_assert ( void ) {
 struct event ev ;
 struct event_base * base = event_init ( ) ;
 test_ok = 0 ;
 printf ( ""Signal handler assert: "" ) ;
 signal_set ( & ev , SIGCONT , signal_cb , & ev ) ;
 signal_add ( & ev , NULL ) ;
 signal_del ( & ev ) ;
 raise ( SIGCONT ) ;
 if ( base -> sig . evsignal_caught ) test_ok = 0 ;
 else test_ok = 1 ;
 event_base_free ( base ) ;
 cleanup_test ( ) ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( WebUsbDetectorTest , UsbDeviceAddedAndRemoved ) {
 base : : string16 product_name = base : : UTF8ToUTF16 ( kProductName_1 ) ;
 GURL landing_page ( kLandingPage_1 ) ;
 scoped_refptr < device : : MockUsbDevice > device ( new device : : MockUsbDevice ( 0 , 1 , ""Google"" , kProductName_1 , ""002"" , landing_page ) ) ;
 std : : string guid = device -> guid ( ) ;
 Initialize ( ) ;
 device_client_ . usb_service ( ) -> AddDevice ( device ) ;
 message_center : : Notification * notification = message_center_ -> FindVisibleNotificationById ( guid ) ;
 ASSERT_TRUE ( notification != nullptr ) ;
 base : : string16 expected_title = base : : ASCIIToUTF16 ( ""Google Product A detected"" ) ;
 EXPECT_EQ ( expected_title , notification -> title ( ) ) ;
 base : : string16 expected_message = base : : ASCIIToUTF16 ( ""Go to www.google.com to connect."" ) ;
 EXPECT_EQ ( expected_message , notification -> message ( ) ) ;
 EXPECT_TRUE ( notification -> delegate ( ) != nullptr ) ;
 device_client_ . usb_service ( ) -> RemoveDevice ( device ) ;
 EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid ) == nullptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSMimeHdrFieldValueDelete ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;
 sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;
 sdk_assert ( idx >= 0 ) ;
 if ( ! isWriteable ( bufp ) ) {
 return TS_ERROR ;
 }
 MIMEFieldSDKHandle * handle = ( MIMEFieldSDKHandle * ) field ;
 HdrHeap * heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;
 mime_field_value_delete_comma_val ( heap , handle -> mh , handle -> field_ptr , idx ) ;
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int vapic_prepare ( VAPICROMState * s ) {
 vapic_map_rom_writable ( s ) ;
 if ( patch_hypercalls ( s ) < 0 ) {
 return - 1 ;
 }
 vapic_enable_tpr_reporting ( true ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int strToMatch ( const char * str , char * retstr ) {
 char * anchor = NULL ;
 const char * anchor1 = NULL ;
 int result = 0 ;
 if ( ( ! str ) || str [ 0 ] == '\0' ) {
 return result ;
 }
 else {
 anchor = retstr ;
 anchor1 = str ;
 while ( ( * str ) != '\0' ) {
 if ( * str == '-' ) {
 * retstr = '_' ;
 }
 else {
 * retstr = tolower ( * str ) ;
 }
 str ++ ;
 retstr ++ ;
 }
 * retstr = '\0' ;
 retstr = anchor ;
 str = anchor1 ;
 result = 1 ;
 }
 return ( result ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evdns_set_log_fn ( evdns_debug_log_fn_type fn ) {
 evdns_log_fn = fn ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * ext_t_0_wml_10 ( tvbuff_t * tvb , guint32 value , guint32 str_tbl ) {
 char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""Variable substitution - escaped: '%s'"" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;
 return str ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {
 if ( check_user_and_ip ( userid , q ) != 0 ) {
 return ;
 }
 users [ userid ] . last_pkt = time ( NULL ) ;
 memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;
 if ( debug >= 1 ) {
 fprintf ( stderr , ""IN ping raw, from user %d\n"" , userid ) ;
 }
 send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vmmouse_get_data ( uint32_t * data ) {
 CPUX86State * env = cpu_single_env ;
 data [ 0 ] = env -> regs [ R_EAX ] ;
 data [ 1 ] = env -> regs [ R_EBX ] ;
 data [ 2 ] = env -> regs [ R_ECX ] ;
 data [ 3 ] = env -> regs [ R_EDX ] ;
 data [ 4 ] = env -> regs [ R_ESI ] ;
 data [ 5 ] = env -> regs [ R_EDI ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void proto_tree_set_system_id ( field_info * fi , const guint8 * value_ptr , gint length ) {
 GByteArray * bytes ;
 DISSECTOR_ASSERT ( value_ptr != NULL || length == 0 ) ;
 bytes = g_byte_array_new ( ) ;
 if ( length > 0 ) {
 g_byte_array_append ( bytes , value_ptr , length ) ;
 }
 fvalue_set_byte_array ( & fi -> value , bytes ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _ISCIIReset ( UConverter * cnv , UConverterResetChoice choice ) {
 UConverterDataISCII * data = ( UConverterDataISCII * ) ( cnv -> extraInfo ) ;
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> toUnicodeStatus = missingCharMarker ;
 cnv -> mode = 0 ;
 data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;
 data -> currentMaskToUnicode = data -> defMaskToUnicode ;
 data -> contextCharToUnicode = NO_CHAR_MARKER ;
 data -> prevToUnicodeStatus = 0x0000 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUChar32 = 0x0000 ;
 data -> contextCharFromUnicode = 0x00 ;
 data -> currentMaskFromUnicode = data -> defMaskToUnicode ;
 data -> currentDeltaFromUnicode = data -> defDeltaToUnicode ;
 data -> isFirstBuffer = TRUE ;
 data -> resetToDefaultToUnicode = FALSE ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelIndex ( const Image * restrict image , const Quantum index , Quantum * restrict pixel ) {
 if ( image -> channel_map [ IndexPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ IndexPixelChannel ] . offset ] = index ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initATTables ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {
 setos2 ( & at -> os2 , at , sf , format ) ;
 if ( at -> opentypemode ) {
 SFFindUnusedLookups ( sf ) ;
 otf_dumpgpos ( at , sf ) ;
 otf_dumpgsub ( at , sf ) ;
 otf_dumpgdef ( at , sf ) ;
 otf_dumpjstf ( at , sf ) ;
 otf_dumpbase ( at , sf ) ;
 otf_dump_math ( at , sf ) ;
 if ( at -> gi . flags & ttf_flag_dummyDSIG ) otf_dump_dummydsig ( at , sf ) ;
 }
 if ( at -> dovariations ) ttf_dumpvariations ( at , sf ) ;
 if ( at -> applemode ) {
 if ( ! at -> opentypemode ) SFFindUnusedLookups ( sf ) ;
 ttf_dumpkerns ( at , sf ) ;
 aat_dumplcar ( at , sf ) ;
 aat_dumpmorx ( at , sf ) ;
 aat_dumpopbd ( at , sf ) ;
 aat_dumpprop ( at , sf ) ;
 aat_dumpbsln ( at , sf ) ;
 }
 if ( ! at -> applemode && ( ! at -> opentypemode || ( at -> gi . flags & ttf_flag_oldkern ) ) ) ttf_dumpkerns ( at , sf ) ;
 dumpnames ( at , sf , format ) ;
 redoos2 ( at ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void draw_char ( AVCodecContext * avctx , int c ) {
 AnsiContext * s = avctx -> priv_data ;
 int fg = s -> fg ;
 int bg = s -> bg ;
 if ( ( s -> attributes & ATTR_BOLD ) ) fg += 8 ;
 if ( ( s -> attributes & ATTR_BLINK ) ) bg += 8 ;
 if ( ( s -> attributes & ATTR_REVERSE ) ) FFSWAP ( int , fg , bg ) ;
 if ( ( s -> attributes & ATTR_CONCEALED ) ) fg = bg ;
 ff_draw_pc_font ( s -> frame . data [ 0 ] + s -> y * s -> frame . linesize [ 0 ] + s -> x , s -> frame . linesize [ 0 ] , s -> font , s -> font_height , c , fg , bg ) ;
 s -> x += FONT_WIDTH ;
 if ( s -> x >= avctx -> width ) {
 s -> x = 0 ;
 hscroll ( avctx ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int mem_draw_thin_line ( gx_device * dev , fixed fx0 , fixed fy0 , fixed fx1 , fixed fy1 , const gx_drawing_color * pdcolor , gs_logical_operation_t lop , fixed adjustx , fixed adjusty ) {
 return gx_default_draw_thin_line ( dev , fx0 , fy0 , fx1 , fy1 , pdcolor , lop , adjustx , adjusty ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void decode_transform_coeffs_ch ( AC3DecodeContext * s , int blk , int ch , mant_groups * m ) {
 if ( ! s -> channel_uses_aht [ ch ] ) {
 ac3_decode_transform_coeffs_ch ( s , ch , m ) ;
 }
 else {
 int bin ;
 if ( ! blk && CONFIG_EAC3_DECODER ) ff_eac3_decode_transform_coeffs_aht_ch ( s , ch ) ;
 for ( bin = s -> start_freq [ ch ] ;
 bin < s -> end_freq [ ch ] ;
 bin ++ ) {
 s -> fixed_coeffs [ ch ] [ bin ] = s -> pre_mantissa [ ch ] [ bin ] [ blk ] >> s -> dexps [ ch ] [ bin ] ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void rds_inc_addref ( struct rds_incoming * inc ) {
 rdsdebug ( ""addref inc %p ref %d\n"" , inc , atomic_read ( & inc -> i_refcount ) ) ;
 atomic_inc ( & inc -> i_refcount ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {
 const unsigned char * buffer ;
 ssize_t avail ;
 int bits_checked ;
 ( void ) self ;
 buffer = __archive_read_filter_ahead ( filter , 2 , & avail ) ;
 if ( buffer == NULL ) return ( 0 ) ;
 bits_checked = 0 ;
 if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;
 bits_checked += 16 ;
 return ( bits_checked ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int create_history_entry ( krb5_context context , krb5_keyblock * hist_key , int n_key_data , krb5_key_data * key_data , osa_pw_hist_ent * hist ) {
 krb5_error_code ret ;
 krb5_keyblock key ;
 krb5_keysalt salt ;
 int i ;
 hist -> key_data = k5calloc ( n_key_data , sizeof ( krb5_key_data ) , & ret ) ;
 if ( hist -> key_data == NULL ) return ret ;
 for ( i = 0 ;
 i < n_key_data ;
 i ++ ) {
 ret = krb5_dbe_decrypt_key_data ( context , NULL , & key_data [ i ] , & key , & salt ) ;
 if ( ret ) return ret ;
 ret = krb5_dbe_encrypt_key_data ( context , hist_key , & key , & salt , key_data [ i ] . key_data_kvno , & hist -> key_data [ i ] ) ;
 if ( ret ) return ret ;
 krb5_free_keyblock_contents ( context , & key ) ;
 }
 hist -> n_key_data = n_key_data ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClickedIncognito ) {
 ReplaceBlank ( browser ( ) ) ;
 Browser * incognito_browser = CreateIncognitoBrowser ( ) ;
 int starting_tab_count_normal = browser ( ) -> tab_strip_model ( ) -> count ( ) ;
 int starting_tab_count_incognito = incognito_browser -> tab_strip_model ( ) -> count ( ) ;
 scoped_ptr < BookmarkBubbleDelegate > delegate ;
 delegate . reset ( new BookmarkBubbleSignInDelegate ( incognito_browser ) ) ;
 delegate -> OnSignInLinkClicked ( ) ;
 int tab_count_normal = browser ( ) -> tab_strip_model ( ) -> count ( ) ;
 EXPECT_EQ ( starting_tab_count_normal + 1 , tab_count_normal ) ;
 int tab_count_incognito = incognito_browser -> tab_strip_model ( ) -> count ( ) ;
 EXPECT_EQ ( starting_tab_count_incognito , tab_count_incognito ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static fz_iccprofile * get_base_icc_profile ( fz_context * ctx , const fz_colorspace * cs ) {
 fz_colorspace * base ;
 fz_cal_colorspace * cal ;
 fz_iccprofile * cal_icc ;
 if ( ! cs || ! cs -> get_base ) return NULL ;
 base = cs -> get_base ( cs ) ;
 if ( base == NULL ) return NULL ;
 if ( fz_colorspace_is_icc ( ctx , base ) ) return base -> data ;
 if ( ! fz_colorspace_is_cal ( ctx , base ) ) return get_base_icc_profile ( ctx , base ) ;
 cal = base -> data ;
 cal_icc = cal -> profile ;
 if ( cal_icc && cal_icc -> cmm_handle == NULL ) fz_cmm_init_profile ( ctx , cal_icc ) ;
 return cal_icc ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void add_frame_default ( AVFrame * f , const uint8_t * src , int src_stride , int linelen , int height ) {
 int i , j ;
 uint8_t * dst = f -> data [ 0 ] ;
 dst += ( height - 1 ) * f -> linesize [ 0 ] ;
 for ( i = height ;
 i ;
 i -- ) {
 for ( j = linelen ;
 j ;
 j -- ) * dst ++ += * src ++ ;
 src += src_stride - linelen ;
 dst -= f -> linesize [ 0 ] + linelen ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int sb_has_motion ( const VP9_COMMON * cm , MODE_INFO * * prev_mi_8x8 , const int motion_thresh ) {
 const int mis = cm -> mi_stride ;
 int block_row , block_col ;
 if ( cm -> prev_mi ) {
 for ( block_row = 0 ;
 block_row < 8 ;
 ++ block_row ) {
 for ( block_col = 0 ;
 block_col < 8 ;
 ++ block_col ) {
 const MODE_INFO * prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] ;
 if ( prev_mi ) {
 if ( abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . row ) > motion_thresh || abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . col ) > motion_thresh ) return 1 ;
 }
 }
 }
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , PREDICTION_MODE * mode_uv ) {
 MACROBLOCK * const x = & cpi -> mb ;
 if ( cpi -> sf . use_uv_intra_rd_estimate ) {
 rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ;
 }
 else {
 rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ;
 }
 * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ;
 }",1
Detect whether the following code contains vulnerabilities.,"static UConverter * _SCSUSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {
 struct cloneSCSUStruct * localClone ;
 int32_t bufferSizeNeeded = sizeof ( struct cloneSCSUStruct ) ;
 if ( U_FAILURE ( * status ) ) {
 return 0 ;
 }
 if ( * pBufferSize == 0 ) {
 * pBufferSize = bufferSizeNeeded ;
 return 0 ;
 }
 localClone = ( struct cloneSCSUStruct * ) stackBuffer ;
 uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( SCSUData ) ) ;
 localClone -> cnv . extraInfo = & localClone -> mydata ;
 localClone -> cnv . isExtraLocal = TRUE ;
 return & localClone -> cnv ;
 }",1
Detect whether the following code contains vulnerabilities.,"void jpc_enc_destroy ( jpc_enc_t * enc ) {
 if ( enc -> curtile ) {
 jpc_enc_tile_destroy ( enc -> curtile ) ;
 }
 if ( enc -> cp ) {
 jpc_enc_cp_destroy ( enc -> cp ) ;
 }
 if ( enc -> cstate ) {
 jpc_cstate_destroy ( enc -> cstate ) ;
 }
 if ( enc -> tmpstream ) {
 jas_stream_close ( enc -> tmpstream ) ;
 }
 jas_free ( enc ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evdns_search_ndots_set ( const int ndots ) {
 if ( ! global_search_state ) global_search_state = search_state_new ( ) ;
 if ( ! global_search_state ) return ;
 global_search_state -> ndots = ndots ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void xan_wc3_output_pixel_run ( XanContext * s , const unsigned char * pixel_buffer , int x , int y , int pixel_count ) {
 int stride ;
 int line_inc ;
 int index ;
 int current_x ;
 int width = s -> avctx -> width ;
 unsigned char * palette_plane ;
 palette_plane = s -> current_frame . data [ 0 ] ;
 stride = s -> current_frame . linesize [ 0 ] ;
 line_inc = stride - width ;
 index = y * stride + x ;
 current_x = x ;
 while ( pixel_count && index < s -> frame_size ) {
 int count = FFMIN ( pixel_count , width - current_x ) ;
 memcpy ( palette_plane + index , pixel_buffer , count ) ;
 pixel_count -= count ;
 index += count ;
 pixel_buffer += count ;
 current_x += count ;
 if ( current_x >= width ) {
 index += line_inc ;
 current_x = 0 ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int get_dwords ( OHCIState * ohci , dma_addr_t addr , uint32_t * buf , int num ) {
 int i ;
 addr += ohci -> localmem_base ;
 for ( i = 0 ;
 i < num ;
 i ++ , buf ++ , addr += sizeof ( * buf ) ) {
 if ( dma_memory_read ( ohci -> as , addr , buf , sizeof ( * buf ) ) ) {
 return - 1 ;
 }
 * buf = le32_to_cpu ( * buf ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"const uint8_t * ff_h263_find_resync_marker ( const uint8_t * restrict p , const uint8_t * restrict end ) {
 assert ( p < end ) ;
 end -= 2 ;
 p ++ ;
 for ( ;
 p < end ;
 p += 2 ) {
 if ( ! * p ) {
 if ( ! p [ - 1 ] && p [ 1 ] ) return p - 1 ;
 else if ( ! p [ 1 ] && p [ 2 ] ) return p ;
 }
 }
 return end + 2 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ContentFaviconDriverTest , LoadIconFromWebManifest ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 GURL url = embedded_test_server ( ) -> GetURL ( ""/favicon/page_with_manifest.html"" ) ;
 GURL icon_url = embedded_test_server ( ) -> GetURL ( ""/favicon/icon.png"" ) ;
 std : : unique_ptr < TestResourceDispatcherHostDelegate > delegate ( new TestResourceDispatcherHostDelegate ( icon_url ) ) ;
 content : : ResourceDispatcherHost : : Get ( ) -> SetDelegate ( delegate . get ( ) ) ;
 PendingTaskWaiter waiter ( web_contents ( ) ) ;
 ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , url , WindowOpenDisposition : : CURRENT_TAB , ui_test_utils : : BROWSER_TEST_NONE ) ;
 waiter . Wait ( ) ;
 # if defined ( OS_ANDROID ) EXPECT_TRUE ( delegate -> was_requested ( ) ) ;
 EXPECT_NE ( nullptr , GetFaviconForPageURL ( url , favicon_base : : IconType : : kWebManifestIcon ) . bitmap_data ) ;
 # else EXPECT_FALSE ( delegate -> was_requested ( ) ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static Py_ssize_t string_buffer_getreadbuf ( PyStringObject * self , Py_ssize_t index , const void * * ptr ) {
 if ( index != 0 ) {
 PyErr_SetString ( PyExc_SystemError , ""accessing non-existent string segment"" ) ;
 return - 1 ;
 }
 * ptr = ( void * ) self -> ob_sval ;
 return Py_SIZE ( self ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) {
 struct usbdevfs_connectinfo ci = {
 . devnum = ps -> dev -> devnum , . slow = ps -> dev -> speed == USB_SPEED_LOW }
 ;
 if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void output_check_banner ( bool live_check ) {
 if ( user_opts . check && live_check ) {
 pg_log ( PG_REPORT , ""Performing Consistency Checks on Old Live Server\n"" ) ;
 pg_log ( PG_REPORT , ""------------------------------------------------\n"" ) ;
 }
 else {
 pg_log ( PG_REPORT , ""Performing Consistency Checks\n"" ) ;
 pg_log ( PG_REPORT , ""-----------------------------\n"" ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"VP9Decoder * vp9_decoder_create ( ) {
 VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;
 VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;
 if ( ! cm ) return NULL ;
 vp9_zero ( * pbi ) ;
 if ( setjmp ( cm -> error . jmp ) ) {
 cm -> error . setjmp = 0 ;
 vp9_decoder_remove ( pbi ) ;
 return NULL ;
 }
 cm -> error . setjmp = 1 ;
 initialize_dec ( ) ;
 vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;
 cm -> current_video_frame = 0 ;
 pbi -> ready_for_new_data = 1 ;
 cm -> bit_depth = VPX_BITS_8 ;
 vp9_init_dequantizer ( cm ) ;
 vp9_loop_filter_init ( cm ) ;
 cm -> error . setjmp = 0 ;
 vp9_get_worker_interface ( ) -> init ( & pbi -> lf_worker ) ;
 return pbi ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {
 int i , k ;
 const int t_HFGen = 8 ;
 const int i_f = 32 ;
 memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;
 for ( k = 0 ;
 k < sbr -> kx [ 1 ] ;
 k ++ ) {
 for ( i = t_HFGen ;
 i < i_f + t_HFGen ;
 i ++ ) {
 X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 0 ] ;
 X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 1 ] ;
 }
 }
 buf_idx = 1 - buf_idx ;
 for ( k = 0 ;
 k < sbr -> kx [ 0 ] ;
 k ++ ) {
 for ( i = 0 ;
 i < t_HFGen ;
 i ++ ) {
 X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 0 ] ;
 X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 1 ] ;
 }
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint64 _tiffSeekProc ( thandle_t fd , uint64 off , int whence ) {
 LARGE_INTEGER offli ;
 DWORD dwMoveMethod ;
 offli . QuadPart = off ;
 switch ( whence ) {
 case SEEK_SET : dwMoveMethod = FILE_BEGIN ;
 break ;
 case SEEK_CUR : dwMoveMethod = FILE_CURRENT ;
 break ;
 case SEEK_END : dwMoveMethod = FILE_END ;
 break ;
 default : dwMoveMethod = FILE_BEGIN ;
 break ;
 }
 offli . LowPart = SetFilePointer ( fd , offli . LowPart , & offli . HighPart , dwMoveMethod ) ;
 if ( ( offli . LowPart == INVALID_SET_FILE_POINTER ) && ( GetLastError ( ) != NO_ERROR ) ) offli . QuadPart = 0 ;
 return ( offli . QuadPart ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_count_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 if ( ! info -> fSkipArg ) {
 if ( info -> fIsShort ) * ( int16_t * ) ( args [ 0 ] . ptrValue ) = ( int16_t ) ( UINT16_MAX & info -> fWidth ) ;
 else if ( info -> fIsLongLong ) * ( int64_t * ) ( args [ 0 ] . ptrValue ) = info -> fWidth ;
 else * ( int32_t * ) ( args [ 0 ] . ptrValue ) = ( int32_t ) ( UINT32_MAX & info -> fWidth ) ;
 }
 * argConverted = 0 ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {
 int y ;
 unsigned char pix ;
 pix = bytestream2_get_byte ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 memset ( s -> pixel_ptr , pix , 8 ) ;
 s -> pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int ttfFont__Open_aux ( ttfFont * self , ttfInterpreter * tti , gx_ttfReader * r , gs_font_type42 * pfont , const gs_matrix * char_tm , const gs_log2_scale_point * log2_scale , bool design_grid ) {
 gs_point char_size , subpix_origin ;
 gs_matrix post_transform ;
 unsigned int nTTC = 0 ;
 bool dg ;
 decompose_matrix ( pfont , char_tm , log2_scale , design_grid , & char_size , & subpix_origin , & post_transform , & dg ) ;
 switch ( ttfFont__Open ( tti , self , & r -> super , nTTC , char_size . x , char_size . y , dg ) ) {
 case fNoError : return 0 ;
 case fMemoryError : return_error ( gs_error_VMerror ) ;
 case fUnimplemented : return_error ( gs_error_unregistered ) ;
 case fBadInstruction : WarnBadInstruction ( pfont , - 1 ) ;
 goto recover ;
 case fPatented : WarnPatented ( pfont , self , ""The font"" ) ;
 recover : self -> patented = true ;
 return 0 ;
 default : {
 int code = r -> super . Error ( & r -> super ) ;
 if ( code < 0 ) return code ;
 return_error ( gs_error_invalidfont ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int gifPutWord ( int w , gdIOCtx * out ) {
 gdPutC ( w & 0xFF , out ) ;
 gdPutC ( ( w >> 8 ) & 0xFF , out ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"size_t print_file_stack ( char * s , const char * end ) {
 char * start = s ;
 struct st_test_file * err_file = cur_file ;
 if ( err_file == file_stack ) return 0 ;
 for ( ;
 ;
 ) {
 err_file -- ;
 s += my_snprintf ( s , end - s , ""included from %s at line %d:\n"" , err_file -> file_name , err_file -> lineno ) ;
 if ( err_file == file_stack ) break ;
 }
 return s - start ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestLaunchSchemeBlockedChromeDefault ) {
 DoTest ( ExternalProtocolHandler : : BLOCK , shell_integration : : IS_DEFAULT , Action : : BLOCK ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int kvm_get_mce_cap_supported ( KVMState * s , uint64_t * mce_cap , int * max_banks ) {
 int r ;
 r = kvm_check_extension ( s , KVM_CAP_MCE ) ;
 if ( r > 0 ) {
 * max_banks = r ;
 return kvm_ioctl ( s , KVM_X86_GET_MCE_CAP_SUPPORTED , mce_cap ) ;
 }
 return - ENOSYS ;
 }",0
Detect whether the following code contains vulnerabilities.,"void OnDangerPromptCreated ( DownloadDangerPrompt * prompt ) {
 prompt -> InvokeActionForTesting ( DownloadDangerPrompt : : ACCEPT ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int BIO_vsnprintf ( char * buf , size_t n , const char * format , va_list args ) {
 size_t retlen ;
 int truncated ;
 _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ;
 if ( truncated ) return - 1 ;
 else return ( retlen <= INT_MAX ) ? ( int ) retlen : - 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gint pad_according_to_type ( gint offset , gint field_starting_offset , gint max_offset , guint8 type ) {
 switch ( type ) {
 case ARG_BYTE : break ;
 case ARG_DOUBLE : case ARG_UINT64 : case ARG_INT64 : case ARG_STRUCT : case ARG_DICT_ENTRY : offset = round_to_8byte ( offset , field_starting_offset ) ;
 break ;
 case ARG_SIGNATURE : break ;
 case ARG_HANDLE : break ;
 case ARG_INT32 : case ARG_UINT32 : case ARG_BOOLEAN : offset = round_to_4byte ( offset , field_starting_offset ) ;
 break ;
 case ARG_INT16 : case ARG_UINT16 : offset = round_to_2byte ( offset , field_starting_offset ) ;
 break ;
 case ARG_STRING : break ;
 case ARG_VARIANT : break ;
 case ARG_OBJ_PATH : break ;
 default : break ;
 }
 if ( offset > max_offset ) {
 offset = max_offset ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateLocalDontBlockCopiedAsIsToProfilePref ) {
 base : : DictionaryValue prefs_local ;
 prefs_local . SetBoolean ( ""tel"" , false ) ;
 local_state_ -> Set ( prefs : : kExcludedSchemes , prefs_local ) ;
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""tel"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs )",1
Detect whether the following code contains vulnerabilities.,"static char * php_zip_make_relative_path ( char * path , int path_len ) {
 char * path_begin = path ;
 size_t i ;
 if ( path_len < 1 || path == NULL ) {
 return NULL ;
 }
 if ( IS_SLASH ( path [ 0 ] ) ) {
 return path + 1 ;
 }
 i = path_len ;
 while ( 1 ) {
 while ( i > 0 && ! IS_SLASH ( path [ i ] ) ) {
 i -- ;
 }
 if ( ! i ) {
 return path ;
 }
 if ( i >= 2 && ( path [ i - 1 ] == '.' || path [ i - 1 ] == ':' ) ) {
 path_begin = path + i + 1 ;
 break ;
 }
 i -- ;
 }
 return path_begin ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void remove_new_subdir ( char * subdir , bool rmtopdir ) {
 char new_path [ MAXPGPATH ] ;
 prep_status ( ""Deleting files from new %s"" , subdir ) ;
 snprintf ( new_path , sizeof ( new_path ) , ""%s/%s"" , new_cluster . pgdata , subdir ) ;
 if ( ! rmtree ( new_path , rmtopdir ) ) pg_fatal ( ""could not delete directory \""%s\""\n"" , new_path ) ;
 check_ok ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void init_mv_penalty_and_fcode ( MpegEncContext * s ) {
 int f_code ;
 int mv ;
 for ( f_code = 1 ;
 f_code <= MAX_FCODE ;
 f_code ++ ) {
 for ( mv = - MAX_MV ;
 mv <= MAX_MV ;
 mv ++ ) {
 int len ;
 if ( mv == 0 ) len = ff_mvtab [ 0 ] [ 1 ] ;
 else {
 int val , bit_size , code ;
 bit_size = f_code - 1 ;
 val = mv ;
 if ( val < 0 ) val = - val ;
 val -- ;
 code = ( val >> bit_size ) + 1 ;
 if ( code < 33 ) {
 len = ff_mvtab [ code ] [ 1 ] + 1 + bit_size ;
 }
 else {
 len = ff_mvtab [ 32 ] [ 1 ] + av_log2 ( code >> 5 ) + 2 + bit_size ;
 }
 }
 mv_penalty [ f_code ] [ mv + MAX_MV ] = len ;
 }
 }
 for ( f_code = MAX_FCODE ;
 f_code > 0 ;
 f_code -- ) {
 for ( mv = - ( 16 << f_code ) ;
 mv < ( 16 << f_code ) ;
 mv ++ ) {
 fcode_tab [ mv + MAX_MV ] = f_code ;
 }
 }
 for ( mv = 0 ;
 mv < MAX_MV * 2 + 1 ;
 mv ++ ) {
 umv_fcode_tab [ mv ] = 1 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void qemu_put_be64s ( QEMUFile * f , const uint64_t * pv ) {
 qemu_put_be64 ( f , * pv ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit )",1
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_register_types ( void ) {
 type_register_static ( & pxa2xx_i2c_slave_info ) ;
 type_register_static ( & pxa2xx_ssp_info ) ;
 type_register_static ( & pxa2xx_i2c_info ) ;
 type_register_static ( & pxa2xx_rtc_sysbus_info ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void stubHashScannerFull ( void * payload , void * data , const xmlChar * name , const xmlChar * name2 ATTRIBUTE_UNUSED , const xmlChar * name3 ATTRIBUTE_UNUSED ) {
 stubData * stubdata = ( stubData * ) data ;
 stubdata -> hashscanner ( payload , stubdata -> data , ( xmlChar * ) name ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSMgmtCounterGet ( const char * var_name , TSMgmtCounter * result ) {
 return RecGetRecordCounter ( ( char * ) var_name , ( RecCounter * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {
 EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;
 OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;
 if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_H221NonStandard ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 790 ""./asn1/h225/h225.cnf"" t35CountryCode = 0 ;
 t35Extension = 0 ;
 manufacturerCode = 0 ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H221NonStandard , H221NonStandard_sequence ) ;
 # line 794 ""./asn1/h225/h225.cnf"" h221NonStandard = ( ( t35CountryCode * 256 ) + t35Extension ) * 65536 + manufacturerCode ;
 proto_tree_add_uint ( tree , hf_h221Manufacturer , tvb , ( offset >> 3 ) - 4 , 4 , h221NonStandard ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void read_sbr_dtdf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {
 get_bits1_vector ( gb , ch_data -> bs_df_env , ch_data -> bs_num_env ) ;
 get_bits1_vector ( gb , ch_data -> bs_df_noise , ch_data -> bs_num_noise ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( WebFrameTest , GetCanonicalUrlForSharing ) {
 FrameTestHelpers : : WebViewHelper web_view_helper ;
 web_view_helper . Initialize ( ) ;
 WebLocalFrameImpl * frame = web_view_helper . LocalMainFrame ( ) ;
 FrameTestHelpers : : LoadHTMLString ( frame , R ""( < head > < link rel = ""canonical"" href = ""https://example.com/canonical.html"" > < / head > ) "", ToKURL("" https : EXPECT_EQ ( WebURL ( ToKURL ( ""https://example.com/canonical.html"" ) ) , frame -> GetDocument ( ) . CanonicalUrlForSharing ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"double histogram_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , int min_hist_size , int n_skip , int * hist_size ) {
 double result ;
 Datum * values ;
 int nvalues ;
 Assert ( n_skip >= 0 ) ;
 Assert ( min_hist_size > 2 * n_skip ) ;
 if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_HISTOGRAM , InvalidOid , NULL , & values , & nvalues , NULL , NULL ) ) {
 * hist_size = nvalues ;
 if ( nvalues >= min_hist_size ) {
 int nmatch = 0 ;
 int i ;
 for ( i = n_skip ;
 i < nvalues - n_skip ;
 i ++ ) {
 if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) nmatch ++ ;
 }
 result = ( ( double ) nmatch ) / ( ( double ) ( nvalues - 2 * n_skip ) ) ;
 }
 else result = - 1 ;
 free_attstatsslot ( vardata -> atttype , values , nvalues , NULL , 0 ) ;
 }
 else {
 * hist_size = 0 ;
 result = - 1 ;
 }
 return result ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_ustring_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 UChar * arg = ( UChar * ) ( args [ 0 ] . ptrValue ) ;
 UChar * alias = arg ;
 int32_t count ;
 int32_t skipped = 0 ;
 UChar c ;
 UBool isNotEOF = FALSE ;
 if ( info -> fIsString ) {
 skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 }
 count = 0 ;
 while ( ( info -> fWidth == - 1 || count < info -> fWidth ) && ( isNotEOF = ufile_getch ( input , & c ) ) && ( ! info -> fIsString || ( c != info -> fPadChar && ! u_isWhitespace ( c ) ) ) ) {
 if ( ! info -> fSkipArg ) {
 * alias ++ = c ;
 }
 ++ count ;
 }
 if ( ! info -> fSkipArg ) {
 if ( ( info -> fWidth == - 1 || count < info -> fWidth ) && isNotEOF ) {
 u_fungetc ( c , input ) ;
 }
 if ( info -> fIsString ) {
 * alias = 0x0000 ;
 }
 }
 * argConverted = ! info -> fSkipArg ;
 return count + skipped ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CPropertyRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CPropertyRestriction * v , const char * fmt , ... ) {
 proto_tree * tree ;
 proto_item * item ;
 const char * txt , * str = NULL ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CPropertyRestriction , & item , txt ) ;
 offset = parse_relop ( tvb , offset , tree , & v -> relop , & str ) ;
 proto_item_append_text ( item , "" Op: %s"" , str ) ;
 offset = parse_CFullPropSpec ( tvb , offset , tree , pad_tree , & v -> property , ""Property"" ) ;
 offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & v -> prval , ""prval"" ) ;
 offset = parse_padding ( tvb , offset , 4 , pad_tree , ""padding_lcid"" ) ;
 v -> lcid = tvb_get_letohl ( tvb , offset ) ;
 offset = parse_lcid ( tvb , offset , tree , ""lcid"" ) ;
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int gic_get_current_cpu ( GICState * s ) {
 if ( s -> num_cpu > 1 ) {
 CPUState * cpu = ENV_GET_CPU ( cpu_single_env ) ;
 return cpu -> cpu_index ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"const mbfl_encoding * mbfl_encoding_detector_judge2 ( mbfl_encoding_detector * identd ) {
 mbfl_identify_filter * filter ;
 const mbfl_encoding * encoding = NULL ;
 int n ;
 if ( identd != NULL ) {
 n = identd -> filter_list_size - 1 ;
 while ( n >= 0 ) {
 filter = identd -> filter_list [ n ] ;
 if ( ! filter -> flag ) {
 if ( ! identd -> strict || ! filter -> status ) {
 encoding = filter -> encoding ;
 }
 }
 n -- ;
 }
 if ( ! encoding ) {
 n = identd -> filter_list_size - 1 ;
 while ( n >= 0 ) {
 filter = identd -> filter_list [ n ] ;
 if ( ! filter -> flag ) {
 encoding = filter -> encoding ;
 }
 n -- ;
 }
 }
 }
 return encoding ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gboolean capture_netbios ( const guchar * pd _U_ , int offset _U_ , int len _U_ , capture_packet_info_t * cpinfo , const union wtap_pseudo_header * pseudo_header _U_ ) {
 capture_dissector_increment_count ( cpinfo , proto_netbios ) ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint16 de_clg_party_bcd_num ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string , int string_len ) {
 const gchar * extr_addr ;
 de_bcd_num ( tvb , tree , pinfo , offset , len , hf_gsm_a_dtap_clg_party_bcd_num , & extr_addr ) ;
 if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , "" - (%s)"" , extr_addr ) ;
 return ( len ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , __construct ) {
 spl_filesystem_object * intern ;
 char * path ;
 int len ;
 zend_error_handling error_handling ;
 zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & path , & len ) == FAILURE ) {
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 return ;
 }
 intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 spl_filesystem_info_set_filename ( intern , path , len , 1 TSRMLS_CC ) ;
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"unsigned int hb_set_get_population ( const hb_set_t * set ) {
 return set -> get_population ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int pxa2xx_fir_load ( QEMUFile * f , void * opaque , int version_id ) {
 PXA2xxFIrState * s = ( PXA2xxFIrState * ) opaque ;
 int i ;
 s -> enable = qemu_get_be32 ( f ) ;
 qemu_get_8s ( f , & s -> control [ 0 ] ) ;
 qemu_get_8s ( f , & s -> control [ 1 ] ) ;
 qemu_get_8s ( f , & s -> control [ 2 ] ) ;
 qemu_get_8s ( f , & s -> status [ 0 ] ) ;
 qemu_get_8s ( f , & s -> status [ 1 ] ) ;
 s -> rx_len = qemu_get_byte ( f ) ;
 s -> rx_start = 0 ;
 for ( i = 0 ;
 i < s -> rx_len ;
 i ++ ) s -> rx_fifo [ i ] = qemu_get_byte ( f ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorTextRemoveNetdev ( qemuMonitorPtr mon , const char * alias ) {
 char * cmd ;
 char * reply = NULL ;
 int ret = - 1 ;
 if ( virAsprintf ( & cmd , ""netdev_del %s"" , alias ) < 0 ) {
 virReportOOMError ( ) ;
 return - 1 ;
 }
 if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {
 qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( ""failed to remove netdev in qemu with '%s'"" ) , cmd ) ;
 goto cleanup ;
 }
 ret = 0 ;
 cleanup : VIR_FREE ( cmd ) ;
 VIR_FREE ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fdct32x32_1_c ( const int16_t * input , int16_t * output , int stride ) {
 int r , c ;
 int16_t sum = 0 ;
 for ( r = 0 ;
 r < 32 ;
 ++ r ) for ( c = 0 ;
 c < 32 ;
 ++ c ) sum += input [ r * stride + c ] ;
 output [ 0 ] = sum >> 3 ;
 output [ 1 ] = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void check_and_dump_old_cluster ( bool live_check ) {
 if ( ! live_check ) start_postmaster ( & old_cluster , true ) ;
 get_db_and_rel_infos ( & old_cluster ) ;
 init_tablespaces ( ) ;
 get_loadable_libraries ( ) ;
 check_is_install_user ( & old_cluster ) ;
 check_proper_datallowconn ( & old_cluster ) ;
 check_for_prepared_transactions ( & old_cluster ) ;
 check_for_reg_data_type_usage ( & old_cluster ) ;
 check_for_isn_and_int8_passing_mismatch ( & old_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 905 ) check_for_pg_role_prefix ( & old_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) == 904 && old_cluster . controldata . cat_ver < JSONB_FORMAT_CHANGE_CAT_VER ) check_for_jsonb_9_4_usage ( & old_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 903 ) old_9_3_check_for_line_data_type_usage ( & old_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 804 ) new_9_0_populate_pg_largeobject_metadata ( & old_cluster , true ) ;
 if ( ! user_opts . check ) generate_old_dump ( ) ;
 if ( ! live_check ) stop_postmaster ( false ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static bool test_if_create_new_users ( THD * thd ) {
 Security_context * sctx = thd -> security_ctx ;
 bool create_new_users = test ( sctx -> master_access & INSERT_ACL ) || ( ! opt_safe_user_create && test ( sctx -> master_access & CREATE_USER_ACL ) ) ;
 if ( ! create_new_users ) {
 TABLE_LIST tl ;
 ulong db_access ;
 bzero ( ( char * ) & tl , sizeof ( tl ) ) ;
 tl . db = ( char * ) ""mysql"" ;
 tl . table_name = ( char * ) ""user"" ;
 create_new_users = 1 ;
 db_access = acl_get ( sctx -> host , sctx -> ip , sctx -> priv_user , tl . db , 0 ) ;
 if ( ! ( db_access & INSERT_ACL ) ) {
 if ( check_grant ( thd , INSERT_ACL , & tl , 0 , UINT_MAX , 1 ) ) create_new_users = 0 ;
 }
 }
 return create_new_users ;
 }",0
Detect whether the following code contains vulnerabilities.,"static double patternjoinsel ( PG_FUNCTION_ARGS , Pattern_Type ptype , bool negate ) {
 return negate ? ( 1.0 - DEFAULT_MATCH_SEL ) : DEFAULT_MATCH_SEL ;
 }",0
Detect whether the following code contains vulnerabilities.,"void hmp_hostfwd_add ( Monitor * mon , const QDict * qdict ) {
 const char * redir_str ;
 SlirpState * s ;
 const char * arg1 = qdict_get_str ( qdict , ""arg1"" ) ;
 const char * arg2 = qdict_get_try_str ( qdict , ""arg2"" ) ;
 const char * arg3 = qdict_get_try_str ( qdict , ""arg3"" ) ;
 if ( arg2 ) {
 s = slirp_lookup ( mon , arg1 , arg2 ) ;
 redir_str = arg3 ;
 }
 else {
 s = slirp_lookup ( mon , NULL , NULL ) ;
 redir_str = arg1 ;
 }
 if ( s ) {
 slirp_hostfwd ( s , redir_str , 0 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int alloc_mi ( VP9_COMMON * cm , int mi_size ) {
 int i ;
 for ( i = 0 ;
 i < 2 ;
 ++ i ) {
 cm -> mip_array [ i ] = ( MODE_INFO * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO ) ) ;
 if ( cm -> mip_array [ i ] == NULL ) return 1 ;
 cm -> mi_grid_base_array [ i ] = ( MODE_INFO * * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO * ) ) ;
 if ( cm -> mi_grid_base_array [ i ] == NULL ) return 1 ;
 }
 cm -> mi_alloc_size = mi_size ;
 cm -> mi_idx = 0 ;
 cm -> prev_mi_idx = 1 ;
 cm -> mip = cm -> mip_array [ cm -> mi_idx ] ;
 cm -> prev_mip = cm -> mip_array [ cm -> prev_mi_idx ] ;
 cm -> mi_grid_base = cm -> mi_grid_base_array [ cm -> mi_idx ] ;
 cm -> prev_mi_grid_base = cm -> mi_grid_base_array [ cm -> prev_mi_idx ] ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {
 ArchiveHandle * clone ;
 clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;
 memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;
 memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;
 clone -> connection = NULL ;
 clone -> connCancel = NULL ;
 clone -> currUser = NULL ;
 clone -> currSchema = NULL ;
 clone -> currTablespace = NULL ;
 clone -> currWithOids = - 1 ;
 if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;
 clone -> public . n_errors = 0 ;
 if ( AH -> mode == archModeRead ) {
 RestoreOptions * ropt = AH -> public . ropt ;
 Assert ( AH -> connection == NULL ) ;
 ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;
 _doSetFixedOutputState ( clone ) ;
 }
 else {
 char * dbname ;
 char * pghost ;
 char * pgport ;
 char * username ;
 Assert ( AH -> connection != NULL ) ;
 dbname = PQdb ( AH -> connection ) ;
 pghost = PQhost ( AH -> connection ) ;
 pgport = PQport ( AH -> connection ) ;
 username = PQuser ( AH -> connection ) ;
 ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;
 }
 ( clone -> ClonePtr ) ( clone ) ;
 Assert ( clone -> connection != NULL ) ;
 return clone ;
 }",1
Detect whether the following code contains vulnerabilities.,"xsltDocumentPtr xsltLoadStyleDocument ( xsltStylesheetPtr style , const xmlChar * URI ) {
 xsltDocumentPtr ret ;
 xmlDocPtr doc ;
 xsltSecurityPrefsPtr sec ;
 if ( ( style == NULL ) || ( URI == NULL ) ) return ( NULL ) ;
 sec = xsltGetDefaultSecurityPrefs ( ) ;
 if ( sec != NULL ) {
 int res ;
 res = xsltCheckRead ( sec , NULL , URI ) ;
 if ( res == 0 ) {
 xsltTransformError ( NULL , NULL , NULL , ""xsltLoadStyleDocument: read rights for %s denied\n"" , URI ) ;
 return ( NULL ) ;
 }
 }
 ret = style -> docList ;
 while ( ret != NULL ) {
 if ( ( ret -> doc != NULL ) && ( ret -> doc -> URL != NULL ) && ( xmlStrEqual ( ret -> doc -> URL , URI ) ) ) return ( ret ) ;
 ret = ret -> next ;
 }
 doc = xsltDocDefaultLoader ( URI , style -> dict , XSLT_PARSE_OPTIONS , ( void * ) style , XSLT_LOAD_STYLESHEET ) ;
 if ( doc == NULL ) return ( NULL ) ;
 ret = xsltNewStyleDocument ( style , doc ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void clamp_indexed ( const fz_colorspace * cs , const float * in , float * out ) {
 struct indexed * idx = cs -> data ;
 * out = fz_clamp ( * in , 0 , idx -> high ) / 255.0f ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( object_nl , T_STRING ) ;
 len = RSTRING_LEN ( object_nl ) ;
 if ( len == 0 ) {
 if ( state -> object_nl ) {
 ruby_xfree ( state -> object_nl ) ;
 state -> object_nl = NULL ;
 }
 }
 else {
 if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;
 state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;
 state -> object_nl_len = len ;
 }
 return Qnil ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int cin_decode_lzss ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) {
 uint16_t cmd ;
 int i , sz , offset , code ;
 unsigned char * dst_end = dst + dst_size , * dst_start = dst ;
 const unsigned char * src_end = src + src_size ;
 while ( src < src_end && dst < dst_end ) {
 code = * src ++ ;
 for ( i = 0 ;
 i < 8 && src < src_end && dst < dst_end ;
 ++ i ) {
 if ( code & ( 1 << i ) ) {
 * dst ++ = * src ++ ;
 }
 else {
 cmd = AV_RL16 ( src ) ;
 src += 2 ;
 offset = cmd >> 4 ;
 if ( ( int ) ( dst - dst_start ) < offset + 1 ) return AVERROR_INVALIDDATA ;
 sz = ( cmd & 0xF ) + 2 ;
 sz = FFMIN ( sz , dst_end - dst ) ;
 while ( sz -- ) {
 * dst = * ( dst - offset - 1 ) ;
 ++ dst ;
 }
 }
 }
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSCacheKeyDigestSet ( TSCacheKey key , const char * input , int length ) {
 sdk_assert ( sdk_sanity_check_cachekey ( key ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_iocore_structure ( ( void * ) input ) == TS_SUCCESS ) ;
 sdk_assert ( length > 0 ) ;
 CacheInfo * ci = reinterpret_cast < CacheInfo * > ( key ) ;
 if ( ci -> magic != CACHE_INFO_MAGIC_ALIVE ) {
 return TS_ERROR ;
 }
 MD5Context ( ) . hash_immediate ( ci -> cache_key , input , length ) ;
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_list_fields ( ) {
 MYSQL_RES * result ;
 int rc ;
 myheader ( ""test_list_fields"" ) ;
 rc = mysql_query ( mysql , ""drop table if exists t1"" ) ;
 myquery ( rc ) ;
 rc = mysql_query ( mysql , ""create table t1(c1 int primary key auto_increment, c2 char(10) default 'mysql')"" ) ;
 myquery ( rc ) ;
 result = mysql_list_fields ( mysql , ""t1"" , NULL ) ;
 mytest ( result ) ;
 rc = my_process_result_set ( result ) ;
 DIE_UNLESS ( rc == 0 ) ;
 verify_prepare_field ( result , 0 , ""c1"" , ""c1"" , MYSQL_TYPE_LONG , ""t1"" , ""t1"" , current_db , 11 , ""0"" ) ;
 verify_prepare_field ( result , 1 , ""c2"" , ""c2"" , MYSQL_TYPE_STRING , ""t1"" , ""t1"" , current_db , 10 , ""mysql"" ) ;
 mysql_free_result ( result ) ;
 myquery ( mysql_query ( mysql , ""drop table t1"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face )",1
Detect whether the following code contains vulnerabilities.,"static int float_compare_desc ( const void * key1 , const void * key2 ) {
 float d1 = * ( ( const float * ) key1 ) ;
 float d2 = * ( ( const float * ) key2 ) ;
 if ( d1 > d2 ) return - 1 ;
 else if ( d1 < d2 ) return 1 ;
 else return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {
 hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * g ;
 return c ;
 }
 static void feature_destroy ( hb_feature_t * g ) {
 free ( g ) ;
 }
 HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy )",1
Detect whether the following code contains vulnerabilities.,"static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {
 hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * g ;
 return c ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int test_save_copy ( const char * origname ) {
 char buf [ TESTBUFSIZE ] ;
 int ret ;
 snprintf_func ( buf , TESTBUFSIZE , ""cp -f %s %s"" , origname , TEST_COPY_FILE ) ;
 if ( ( ret = system ( buf ) ) != 0 ) {
 return XD3_INTERNAL ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * linux_udev_event_thread_main ( void * arg ) {
 char dummy ;
 int r ;
 struct udev_device * udev_dev ;
 struct pollfd fds [ ] = {
 {
 . fd = udev_control_pipe [ 0 ] , . events = POLLIN }
 , {
 . fd = udev_monitor_fd , . events = POLLIN }
 , }
 ;
 usbi_dbg ( ""udev event thread entering."" ) ;
 while ( poll ( fds , 2 , - 1 ) >= 0 ) {
 if ( fds [ 0 ] . revents & POLLIN ) {
 r = usbi_read ( udev_control_pipe [ 0 ] , & dummy , sizeof ( dummy ) ) ;
 if ( r <= 0 ) {
 usbi_warn ( NULL , ""udev control pipe read failed"" ) ;
 }
 break ;
 }
 if ( fds [ 1 ] . revents & POLLIN ) {
 usbi_mutex_static_lock ( & linux_hotplug_lock ) ;
 udev_dev = udev_monitor_receive_device ( udev_monitor ) ;
 if ( udev_dev ) udev_hotplug_event ( udev_dev ) ;
 usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;
 }
 }
 usbi_dbg ( ""udev event thread exiting"" ) ;
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int do_start_slave_sql ( MYSQL * mysql_con ) {
 MYSQL_RES * slave ;
 if ( mysql_query_with_error_report ( mysql_con , & slave , ""SHOW SLAVE STATUS"" ) ) return ( 1 ) ;
 else {
 MYSQL_ROW row = mysql_fetch_row ( slave ) ;
 if ( row && row [ 11 ] ) {
 if ( ! strcmp ( row [ 11 ] , ""Yes"" ) ) {
 mysql_free_result ( slave ) ;
 return ( 0 ) ;
 }
 }
 }
 mysql_free_result ( slave ) ;
 if ( mysql_query_with_error_report ( mysql_con , 0 , ""START SLAVE"" ) ) {
 fprintf ( stderr , ""%s: Error: Unable to start slave\n"" , my_progname_short ) ;
 return 1 ;
 }
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint_fast32_t jpc_abstorelstepsize ( jpc_fix_t absdelta , int scaleexpn ) {
 int p ;
 uint_fast32_t mant ;
 uint_fast32_t expn ;
 int n ;
 if ( absdelta < 0 ) {
 abort ( ) ;
 }
 p = jpc_firstone ( absdelta ) - JPC_FIX_FRACBITS ;
 n = 11 - jpc_firstone ( absdelta ) ;
 mant = ( ( n < 0 ) ? ( absdelta >> ( - n ) ) : ( absdelta << n ) ) & 0x7ff ;
 expn = scaleexpn - p ;
 if ( scaleexpn < p ) {
 abort ( ) ;
 }
 return JPC_QCX_EXPN ( expn ) | JPC_QCX_MANT ( mant ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void ff_MPV_report_decode_progress ( MpegEncContext * s ) {
 if ( s -> pict_type != AV_PICTURE_TYPE_B && ! s -> partitioned_frame && ! s -> er . error_occurred ) ff_thread_report_progress ( & s -> current_picture_ptr -> f , s -> mb_y , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * argv [ ] ) {
 libettercap_init ( ) ;
 ef_globals_alloc ( ) ;
 select_text_interface ( ) ;
 libettercap_ui_init ( ) ;
 fprintf ( stdout , ""\n"" EC_COLOR_BOLD ""%s %s"" EC_COLOR_END "" copyright %s %s\n\n"" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ;
 EF_GBL -> lineno = 1 ;
 parse_options ( argc , argv ) ;
 if ( EF_GBL_OPTIONS -> source_file ) {
 yyin = fopen ( EF_GBL_OPTIONS -> source_file , ""r"" ) ;
 if ( yyin == NULL ) FATAL_ERROR ( ""Input file not found !"" ) ;
 }
 else {
 FATAL_ERROR ( ""No source file."" ) ;
 }
 setbuf ( yyin , NULL ) ;
 setbuf ( stdout , NULL ) ;
 setbuf ( stderr , NULL ) ;
 load_tables ( ) ;
 load_constants ( ) ;
 fprintf ( stdout , ""\n Parsing source file \'%s\' "" , EF_GBL_OPTIONS -> source_file ) ;
 fflush ( stdout ) ;
 ef_debug ( 1 , ""\n"" ) ;
 if ( yyparse ( ) == 0 ) fprintf ( stdout , "" done.\n\n"" ) ;
 else fprintf ( stdout , ""\n\nThe script contains errors...\n\n"" ) ;
 if ( write_output ( ) != E_SUCCESS ) FATAL_ERROR ( ""Cannot write output file (%s)"" , EF_GBL_OPTIONS -> output_file ) ;
 ef_globals_free ( ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void stroke_config ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {
 this -> cred -> cachecrl ( this -> cred , msg -> config . cachecrl ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , DontBlockSubFrame ) {
 BlockHost ( kExampleHost2 ) ;
 BlockHost ( kIframeHost2 ) ;
 WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;
 GURL allowed_url_with_iframes = embedded_test_server ( ) -> GetURL ( kExampleHost , ""/supervised_user/with_iframes.html"" ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , allowed_url_with_iframes ) ;
 EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;
 bool loaded1 = false ;
 ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( tab , ""loaded1()"" , & loaded1 ) ) ;
 EXPECT_TRUE ( loaded1 ) ;
 bool loaded2 = false ;
 ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( tab , ""loaded2()"" , & loaded2 ) ) ;
 EXPECT_TRUE ( loaded2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int pubkey_get_nsig ( int algorithm ) {
 gcry_module_t pubkey ;
 int nsig = 0 ;
 REGISTER_DEFAULT_PUBKEYS ;
 ath_mutex_lock ( & pubkeys_registered_lock ) ;
 pubkey = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;
 if ( pubkey ) {
 nsig = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_sig ) ;
 _gcry_module_release ( pubkey ) ;
 }
 ath_mutex_unlock ( & pubkeys_registered_lock ) ;
 return nsig ;
 }",0
Detect whether the following code contains vulnerabilities.,"void free_grant_table ( GRANT_TABLE * grant_table ) {
 hash_free ( & grant_table -> hash_columns ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static xmlLinkPtr xmlListLowerSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 for ( lk = l -> sentinel -> next ;
 lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) < 0 ;
 lk = lk -> next ) ;
 return lk ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int raster_block_offset ( BLOCK_SIZE plane_bsize , int raster_block , int stride ) {
 const int bw = b_width_log2 ( plane_bsize ) ;
 const int y = 4 * ( raster_block >> bw ) ;
 const int x = 4 * ( raster_block & ( ( 1 << bw ) - 1 ) ) ;
 return y * stride + x ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void fd_list_add ( struct FrameData * * list , struct FrameData * layer_data ) {
 struct FrameData * * p = list ;
 while ( * p != NULL ) p = & ( * p ) -> next ;
 * p = layer_data ;
 layer_data -> next = NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"void min_heap_dtor ( min_heap_t * s ) {
 free ( s -> p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static GList * get_file_list_for_launch_locations ( GList * locations ) {
 GList * files , * l ;
 LaunchLocation * location ;
 files = NULL ;
 for ( l = locations ;
 l != NULL ;
 l = l -> next ) {
 location = l -> data ;
 files = g_list_prepend ( files , nautilus_file_ref ( location -> file ) ) ;
 }
 return g_list_reverse ( files ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE cState_s_allocate ( VALUE klass ) {
 JSON_Generator_State * state ;
 return TypedData_Make_Struct ( klass , JSON_Generator_State , & JSON_Generator_State_type , state ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void sig_message_join ( SERVER_REC * server , const char * channel , const char * nick , const char * address ) {
 CHANNEL_REC * chanrec ;
 chanrec = channel_find ( server , channel ) ;
 if ( chanrec != NULL ) CHANNEL_LAST_MSG_ADD ( chanrec , nick , FALSE ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool config_filter_match_local_name ( const struct config_filter * mask , const char * filter_local_name ) {
 const char * const * local_name = t_strsplit_spaces ( mask -> local_name , "" "" ) ;
 for ( ;
 * local_name != NULL ;
 local_name ++ ) {
 if ( dns_match_wildcard ( filter_local_name , * local_name ) == 0 ) return TRUE ;
 }
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void filter_channel ( MLPDecodeContext * m , unsigned int substr , unsigned int channel ) {
 SubStream * s = & m -> substream [ substr ] ;
 const int32_t * fircoeff = s -> channel_params [ channel ] . coeff [ FIR ] ;
 int32_t state_buffer [ NUM_FILTERS ] [ MAX_BLOCKSIZE + MAX_FIR_ORDER ] ;
 int32_t * firbuf = state_buffer [ FIR ] + MAX_BLOCKSIZE ;
 int32_t * iirbuf = state_buffer [ IIR ] + MAX_BLOCKSIZE ;
 FilterParams * fir = & s -> channel_params [ channel ] . filter_params [ FIR ] ;
 FilterParams * iir = & s -> channel_params [ channel ] . filter_params [ IIR ] ;
 unsigned int filter_shift = fir -> shift ;
 int32_t mask = MSB_MASK ( s -> quant_step_size [ channel ] ) ;
 memcpy ( firbuf , fir -> state , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;
 memcpy ( iirbuf , iir -> state , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;
 m -> dsp . mlp_filter_channel ( firbuf , fircoeff , fir -> order , iir -> order , filter_shift , mask , s -> blocksize , & m -> sample_buffer [ s -> blockpos ] [ channel ] ) ;
 memcpy ( fir -> state , firbuf - s -> blocksize , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;
 memcpy ( iir -> state , iirbuf - s -> blocksize , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {
 const transform_2d IHT_4 [ ] = {
 {
 idct4 , idct4 }
 , {
 iadst4 , idct4 }
 , {
 idct4 , iadst4 }
 , {
 iadst4 , iadst4 }
 }
 ;
 int i , j ;
 int16_t out [ 4 * 4 ] ;
 int16_t * outptr = out ;
 int16_t temp_in [ 4 ] , temp_out [ 4 ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 IHT_4 [ tx_type ] . rows ( input , outptr ) ;
 input += 4 ;
 outptr += 4 ;
 }
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = out [ j * 4 + i ] ;
 IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {
 char myhash [ 16 ] ;
 if ( len < 16 ) return ;
 if ( userid < 0 || userid >= created_users ) return ;
 if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;
 if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;
 if ( debug >= 1 ) {
 fprintf ( stderr , ""IN login raw, len %d, from user %d\n"" , len , userid ) ;
 }
 login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;
 if ( memcmp ( packet , myhash , 16 ) == 0 ) {
 struct sockaddr_in * tempin ;
 users [ userid ] . last_pkt = time ( NULL ) ;
 memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;
 tempin = ( struct sockaddr_in * ) & ( q -> from ) ;
 memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;
 user_set_conn_type ( userid , CONN_RAW_UDP ) ;
 login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;
 send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( RegisterProtocolHandlerBrowserTest , ContextMenuEntryAppearsForHandledUrls ) {
 scoped_ptr < TestRenderViewContextMenu > menu ( CreateContextMenu ( GURL ( ""http://www.google.com/"" ) ) ) ;
 ASSERT_FALSE ( menu -> IsItemPresent ( IDC_CONTENT_CONTEXT_OPENLINKWITH ) ) ;
 AddProtocolHandler ( std : : string ( ""web+search"" ) , GURL ( ""http://www.google.com/%s"" ) , base : : UTF8ToUTF16 ( std : : string ( ""Test handler"" ) ) ) ;
 GURL url ( ""web+search:testing"" ) ;
 ProtocolHandlerRegistry * registry = ProtocolHandlerRegistryFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;
 ASSERT_EQ ( 1u , registry -> GetHandlersFor ( url . scheme ( ) ) . size ( ) ) ;
 menu . reset ( CreateContextMenu ( url ) ) ;
 ASSERT_TRUE ( menu -> IsItemPresent ( IDC_CONTENT_CONTEXT_OPENLINKWITH ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void free_pred_buffer ( PRED_BUFFER * p ) {
 if ( p != NULL ) p -> in_use = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int evutil_make_socket_nonblocking ( int fd ) {
 # ifdef WIN32 {
 unsigned long nonblocking = 1 ;
 ioctlsocket ( fd , FIONBIO , ( unsigned long * ) & nonblocking ) ;
 }
 # else if ( fcntl ( fd , F_SETFL , O_NONBLOCK ) == - 1 ) {
 event_warn ( ""fcntl(O_NONBLOCK)"" ) ;
 return - 1 ;
 }
 # endif return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) {
 GFile * location ;
 gboolean res ;
 if ( ! is_launcher ) {
 return TRUE ;
 }
 if ( nautilus_file_can_execute ( file ) ) {
 return TRUE ;
 }
 res = FALSE ;
 if ( nautilus_file_is_local ( file ) ) {
 location = nautilus_file_get_location ( file ) ;
 res = nautilus_is_in_system_dir ( location ) ;
 g_object_unref ( location ) ;
 }
 return res ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_encode_sb ( MACROBLOCK * x , BLOCK_SIZE bsize ) {
 MACROBLOCKD * const xd = & x -> e_mbd ;
 struct optimize_ctx ctx ;
 MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;
 struct encode_b_args arg = {
 x , & ctx , & mbmi -> skip }
 ;
 int plane ;
 for ( plane = 0 ;
 plane < MAX_MB_PLANE ;
 ++ plane ) {
 if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;
 if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {
 const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd ) : mbmi -> tx_size ;
 vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;
 }
 vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block , & arg ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void fdct4 ( const int16_t * input , int16_t * output ) {
 int16_t step [ 4 ] ;
 int temp1 , temp2 ;
 step [ 0 ] = input [ 0 ] + input [ 3 ] ;
 step [ 1 ] = input [ 1 ] + input [ 2 ] ;
 step [ 2 ] = input [ 1 ] - input [ 2 ] ;
 step [ 3 ] = input [ 0 ] - input [ 3 ] ;
 temp1 = ( step [ 0 ] + step [ 1 ] ) * cospi_16_64 ;
 temp2 = ( step [ 0 ] - step [ 1 ] ) * cospi_16_64 ;
 output [ 0 ] = fdct_round_shift ( temp1 ) ;
 output [ 2 ] = fdct_round_shift ( temp2 ) ;
 temp1 = step [ 2 ] * cospi_24_64 + step [ 3 ] * cospi_8_64 ;
 temp2 = - step [ 2 ] * cospi_8_64 + step [ 3 ] * cospi_24_64 ;
 output [ 1 ] = fdct_round_shift ( temp1 ) ;
 output [ 3 ] = fdct_round_shift ( temp2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int _warc_read ( struct archive_read * a , const void * * buf , size_t * bsz , int64_t * off ) {
 struct warc_s * w = a -> format -> data ;
 const char * rab ;
 ssize_t nrd ;
 if ( w -> cntoff >= w -> cntlen ) {
 eof : * buf = NULL ;
 * bsz = 0U ;
 * off = w -> cntoff + 4U ;
 w -> unconsumed = 0U ;
 return ( ARCHIVE_EOF ) ;
 }
 rab = __archive_read_ahead ( a , 1U , & nrd ) ;
 if ( nrd < 0 ) {
 * bsz = 0U ;
 return ( int ) nrd ;
 }
 else if ( nrd == 0 ) {
 goto eof ;
 }
 else if ( ( size_t ) nrd > w -> cntlen - w -> cntoff ) {
 nrd = w -> cntlen - w -> cntoff ;
 }
 * off = w -> cntoff ;
 * bsz = nrd ;
 * buf = rab ;
 w -> cntoff += nrd ;
 w -> unconsumed = ( size_t ) nrd ;
 return ( ARCHIVE_OK ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) {
 const VP9_COMMON * cm = & cpi -> common ;
 int64_t unused ;
 x -> e_mbd . mi [ 0 ] . src_mi -> mbmi . uv_mode = DC_PRED ;
 super_block_uvrd ( cpi , x , rate_tokenonly , distortion , skippable , & unused , bsize , INT64_MAX ) ;
 * rate = * rate_tokenonly + cpi -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ;
 return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x4 ( IpvideoContext * s ) {
 int x , y ;
 unsigned char B , BL , BH ;
 if ( ! s -> is_16bpp ) {
 B = bytestream2_get_byte ( & s -> stream_ptr ) ;
 }
 else {
 B = bytestream2_get_byte ( & s -> mv_ptr ) ;
 }
 BL = B & 0x0F ;
 BH = ( B >> 4 ) & 0x0F ;
 x = - 8 + BL ;
 y = - 8 + BH ;
 av_dlog ( NULL , "" motion byte = %d, (x, y) = (%d, %d)\n"" , B , x , y ) ;
 return copy_from ( s , & s -> last_frame , x , y ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void proto_reg_handoff_dcerpc_spoolss ( void ) {
 dcerpc_init_uuid ( proto_dcerpc_spoolss , ett_dcerpc_spoolss , & uuid_dcerpc_spoolss , ver_dcerpc_spoolss , dcerpc_spoolss_dissectors , hf_opnum ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_char_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 UChar s [ U16_MAX_LENGTH + 1 ] ;
 int32_t len = 1 , written ;
 unsigned char arg = ( unsigned char ) ( args [ 0 ] . int64Value ) ;
 ufmt_defaultCPToUnicode ( ( const char * ) & arg , 2 , s , UPRV_LENGTHOF ( s ) ) ;
 if ( arg != 0 ) {
 len = u_strlen ( s ) ;
 }
 written = handler -> pad_and_justify ( context , info , s , len ) ;
 return written ;
 }",1
Detect whether the following code contains vulnerabilities.,"static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {
 if ( avt -> nb_seg >= avt -> max_seg ) {
 avt = ( xsltAttrVTPtr ) xmlRealloc ( avt , sizeof ( xsltAttrVT ) + avt -> max_seg * sizeof ( void * ) ) ;
 if ( avt == NULL ) {
 return NULL ;
 }
 memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;
 avt -> max_seg += MAX_AVT_SEG ;
 }
 avt -> segments [ avt -> nb_seg ++ ] = val ;
 return avt ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * shorten_utf8_string ( const char * base , int reduce_by_num_bytes ) {
 int len ;
 char * ret ;
 const char * p ;
 len = strlen ( base ) ;
 len -= reduce_by_num_bytes ;
 if ( len <= 0 ) {
 return NULL ;
 }
 ret = g_new ( char , len + 1 ) ;
 p = base ;
 while ( len ) {
 char * next ;
 next = g_utf8_next_char ( p ) ;
 if ( next - p > len || * next == '\0' ) {
 break ;
 }
 len -= next - p ;
 p = next ;
 }
 if ( p - base == 0 ) {
 g_free ( ret ) ;
 return NULL ;
 }
 else {
 memcpy ( ret , base , p - base ) ;
 ret [ p - base ] = '\0' ;
 return ret ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static const DataHeader * offsetTOCLookupFn ( const UDataMemory * pData , const char * tocEntryName , int32_t * pLength , UErrorCode * pErrorCode ) {
 const UDataOffsetTOC * toc = ( UDataOffsetTOC * ) pData -> toc ;
 if ( toc != NULL ) {
 const char * base = ( const char * ) toc ;
 int32_t number , count = ( int32_t ) toc -> count ;
 # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;
 number < count ;
 ++ number ) {
 fprintf ( stderr , ""\tx%d: %s\n"" , number , & base [ toc -> entry [ number ] . nameOffset ] ) ;
 }
 # endif number = offsetTOCPrefixBinarySearch ( tocEntryName , base , toc -> entry , count ) ;
 if ( number >= 0 ) {
 const UDataOffsetTOCEntry * entry = toc -> entry + number ;
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Found.\n"" , tocEntryName ) ;
 # endif if ( ( number + 1 ) < count ) {
 * pLength = ( int32_t ) ( entry [ 1 ] . dataOffset - entry -> dataOffset ) ;
 }
 else {
 * pLength = - 1 ;
 }
 return ( const DataHeader * ) ( base + entry -> dataOffset ) ;
 }
 else {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Not found.\n"" , tocEntryName ) ;
 # endif return NULL ;
 }
 }
 else {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""returning header\n"" ) ;
 # endif return pData -> pHeader ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , double correction_factor ) {
 const double q = vp9_convert_qindex_to_q ( qindex ) ;
 int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ;
 enumerator += ( int ) ( enumerator * q ) >> 12 ;
 return ( int ) ( enumerator * correction_factor / q ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void * xmlListSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 lk = xmlListLinkSearch ( l , data ) ;
 if ( lk ) return ( lk -> data ) ;
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void free_h225_info ( gpointer p ) {
 h323_calls_info_t * tmp_h323info = ( h323_calls_info_t * ) p ;
 DUMP_PTR2 ( tmp_h323info -> guid ) ;
 g_free ( tmp_h323info -> guid ) ;
 if ( tmp_h323info -> h245_list ) {
 GList * list2 = g_list_first ( tmp_h323info -> h245_list ) ;
 while ( list2 ) {
 h245_address_t * h245_add = ( h245_address_t * ) list2 -> data ;
 g_free ( ( void * ) h245_add -> h245_address . data ) ;
 g_free ( list2 -> data ) ;
 list2 = g_list_next ( list2 ) ;
 }
 g_list_free ( tmp_h323info -> h245_list ) ;
 }
 g_free ( p ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int auth_server_input_done ( struct auth_server_connection * conn ) {
 if ( array_count ( & conn -> available_auth_mechs ) == 0 ) {
 i_error ( ""BUG: Authentication server returned no mechanisms"" ) ;
 return - 1 ;
 }
 if ( conn -> cookie == NULL ) {
 i_error ( ""BUG: Authentication server didn't send a cookie"" ) ;
 return - 1 ;
 }
 timeout_remove ( & conn -> to ) ;
 conn -> handshake_received = TRUE ;
 if ( conn -> client -> connect_notify_callback != NULL ) {
 conn -> client -> connect_notify_callback ( conn -> client , TRUE , conn -> client -> connect_notify_context ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( RegisterProtocolHandlerBrowserTest , CustomHandler ) {
 ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;
 GURL handler_url = test_server ( ) -> GetURL ( ""files/custom_handler_foo.html"" ) ;
 AddProtocolHandler ( ""foo"" , handler_url , base : : UTF8ToUTF16 ( std : : string ( ""Test foo Handler"" ) ) ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( ""foo:test"" ) ) ;
 ASSERT_EQ ( handler_url , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetURL ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int get_result_width ( MYSQL_RES * result ) {
 unsigned int len = 0 ;
 MYSQL_FIELD * field ;
 MYSQL_FIELD_OFFSET offset ;
 # ifndef DBUG_OFF offset = mysql_field_tell ( result ) ;
 DBUG_ASSERT ( offset == 0 ) ;
 # else offset = 0 ;
 # endif while ( ( field = mysql_fetch_field ( result ) ) != NULL ) len += get_field_disp_length ( field ) + 3 ;
 ( void ) mysql_field_seek ( result , offset ) ;
 return len + 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int truemotion1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int ret , buf_size = avpkt -> size ;
 TrueMotion1Context * s = avctx -> priv_data ;
 s -> buf = buf ;
 s -> size = buf_size ;
 if ( ( ret = truemotion1_decode_header ( s ) ) < 0 ) return ret ;
 s -> frame . reference = 1 ;
 s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 if ( compression_types [ s -> compression ] . algorithm == ALGO_RGB24H ) {
 truemotion1_decode_24bit ( s ) ;
 }
 else if ( compression_types [ s -> compression ] . algorithm != ALGO_NOP ) {
 truemotion1_decode_16bit ( s ) ;
 }
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void ctl_putarray ( const char * tag , double * arr , int start ) {
 register char * cp ;
 register const char * cq ;
 char buffer [ 200 ] ;
 int i ;
 cp = buffer ;
 cq = tag ;
 while ( * cq != '\0' ) * cp ++ = * cq ++ ;
 * cp ++ = '=' ;
 i = start ;
 do {
 if ( i == 0 ) i = NTP_SHIFT ;
 i -- ;
 INSIST ( ( cp - buffer ) < ( int ) sizeof ( buffer ) ) ;
 snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "" %.2f"" , arr [ i ] * 1e3 ) ;
 cp += strlen ( cp ) ;
 }
 while ( i != start ) ;
 ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static bool intel_pt_enable_needed ( void * opaque ) {
 X86CPU * cpu = opaque ;
 CPUX86State * env = & cpu -> env ;
 int i ;
 if ( env -> msr_rtit_ctrl || env -> msr_rtit_status || env -> msr_rtit_output_base || env -> msr_rtit_output_mask || env -> msr_rtit_cr3_match ) {
 return true ;
 }
 for ( i = 0 ;
 i < MAX_RTIT_ADDRS ;
 i ++ ) {
 if ( env -> msr_rtit_addrs [ i ] ) {
 return true ;
 }
 }
 return false ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void link_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {
 CopyMoveJob * job ;
 job = user_data ;
 if ( job -> done_callback ) {
 job -> done_callback ( job -> debuting_files , ! job_aborted ( ( CommonJob * ) job ) , job -> done_callback_data ) ;
 }
 g_list_free_full ( job -> files , g_object_unref ) ;
 g_object_unref ( job -> destination ) ;
 g_hash_table_unref ( job -> debuting_files ) ;
 g_free ( job -> icon_positions ) ;
 finalize_common ( ( CommonJob * ) job ) ;
 nautilus_file_changes_consume_changes ( TRUE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) {
 printf ( ""%s : Automata support not compiled in\n"" , argv [ 0 ] ) ;
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void process_gitlink ( struct rev_info * revs , const unsigned char * sha1 , show_object_fn show , struct name_path * path , const char * name , void * cb_data ) {
 }",1
Detect whether the following code contains vulnerabilities.,"static int do_cmd ( xd3_stream * stream , const char * buf ) {
 int ret ;
 if ( ( ret = system ( buf ) ) != 0 ) {
 if ( WIFEXITED ( ret ) ) {
 stream -> msg = ""command exited non-zero"" ;
 IF_DEBUG1 ( XPR ( NT ""command was: %s\n"" , buf ) ) ;
 }
 else {
 stream -> msg = ""abnormal command termination"" ;
 }
 return XD3_INTERNAL ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void gsm_a_sacch_rr_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {
 gsm_a_stat_init ( new_stat , gui_callback , gui_data , ""GSM A-I/F SACCH Statistics"" , gsm_a_rr_short_pd_msg_strings ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int check_authenticated_user_and_ip ( int userid , struct query * q ) {
 int res = check_user_and_ip ( userid , q ) ;
 if ( res ) return res ;
 if ( ! users [ userid ] . authenticated ) return 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int get_current_cpu ( ARMMPTimerState * s ) {
 CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;
 if ( cpu_single_cpu -> cpu_index >= s -> num_cpu ) {
 hw_error ( ""arm_mptimer: num-cpu %d but this cpu is %d!\n"" , s -> num_cpu , cpu_single_cpu -> cpu_index ) ;
 }
 return cpu_single_cpu -> cpu_index ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void Pass2Encode ( VP9_COMP * cpi , size_t * size , uint8_t * dest , unsigned int * frame_flags ) {
 cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ;
 vp9_rc_get_second_pass_params ( cpi ) ;
 encode_frame_to_data_rate ( cpi , size , dest , frame_flags ) ;
 vp9_twopass_postencode_update ( cpi ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void build_config ( char * prefix , struct server * server ) {
 char * path = NULL ;
 int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;
 path = ss_malloc ( path_size ) ;
 snprintf ( path , path_size , ""%s/.shadowsocks_%s.conf"" , prefix , server -> port ) ;
 FILE * f = fopen ( path , ""w+"" ) ;
 if ( f == NULL ) {
 if ( verbose ) {
 LOGE ( ""unable to open config file"" ) ;
 }
 ss_free ( path ) ;
 return ;
 }
 fprintf ( f , ""{
\n"" ) ;
 fprintf ( f , ""\""server_port\"":%d,\n"" , atoi ( server -> port ) ) ;
 fprintf ( f , ""\""password\"":\""%s\"""" , server -> password ) ;
 if ( server -> fast_open [ 0 ] ) fprintf ( f , "",\n\""fast_open\"": %s"" , server -> fast_open ) ;
 if ( server -> mode ) fprintf ( f , "",\n\""mode\"":\""%s\"""" , server -> mode ) ;
 if ( server -> method ) fprintf ( f , "",\n\""method\"":\""%s\"""" , server -> method ) ;
 if ( server -> plugin ) fprintf ( f , "",\n\""plugin\"":\""%s\"""" , server -> plugin ) ;
 if ( server -> plugin_opts ) fprintf ( f , "",\n\""plugin_opts\"":\""%s\"""" , server -> plugin_opts ) ;
 fprintf ( f , ""\n}
\n"" ) ;
 fclose ( f ) ;
 ss_free ( path ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void sbr_reset ( AACContext * ac , SpectralBandReplication * sbr ) {
 int err ;
 err = sbr_make_f_master ( ac , sbr , & sbr -> spectrum_params ) ;
 if ( err >= 0 ) err = sbr_make_f_derived ( ac , sbr ) ;
 if ( err < 0 ) {
 av_log ( ac -> avctx , AV_LOG_ERROR , ""SBR reset failed. Switching SBR to pure upsampling mode.\n"" ) ;
 sbr_turnoff ( sbr ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void proto_reg_handoff_zbee_zcl_identify ( void ) {
 dissector_handle_t identify_handle ;
 identify_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_IDENTIFY ) ;
 dissector_add_uint ( ""zbee.zcl.cluster"" , ZBEE_ZCL_CID_IDENTIFY , identify_handle ) ;
 zbee_zcl_init_cluster ( proto_zbee_zcl_identify , ett_zbee_zcl_identify , ZBEE_ZCL_CID_IDENTIFY , hf_zbee_zcl_identify_attr_id , hf_zbee_zcl_identify_srv_rx_cmd_id , hf_zbee_zcl_identify_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_identify_attr_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void proto_reg_handoff_zbee_zcl_appl_stats ( void ) {
 dissector_handle_t appl_stats_handle ;
 appl_stats_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_APPLSTATS ) ;
 dissector_add_uint ( ""zbee.zcl.cluster"" , ZBEE_ZCL_CID_APPLIANCE_STATISTICS , appl_stats_handle ) ;
 zbee_zcl_init_cluster ( proto_zbee_zcl_appl_stats , ett_zbee_zcl_appl_stats , ZBEE_ZCL_CID_APPLIANCE_STATISTICS , hf_zbee_zcl_appl_stats_attr_id , hf_zbee_zcl_appl_stats_srv_rx_cmd_id , hf_zbee_zcl_appl_stats_srv_tx_cmd_id , NULL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"pdf_xobject * pdf_load_xobject ( fz_context * ctx , pdf_document * doc , pdf_obj * dict ) {
 pdf_xobject * form ;
 if ( ( form = pdf_find_item ( ctx , pdf_drop_xobject_imp , dict ) ) != NULL ) return form ;
 form = fz_malloc_struct ( ctx , pdf_xobject ) ;
 FZ_INIT_STORABLE ( form , 1 , pdf_drop_xobject_imp ) ;
 form -> obj = NULL ;
 form -> iteration = 0 ;
 pdf_store_item ( ctx , dict , form , pdf_xobject_size ( form ) ) ;
 form -> obj = pdf_keep_obj ( ctx , dict ) ;
 return form ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void remoteDispatchCopyError ( remote_error * rerr , virErrorPtr verr ) {
 rerr -> code = verr -> code ;
 rerr -> domain = verr -> domain ;
 rerr -> message = verr -> message ? malloc ( sizeof ( char * ) ) : NULL ;
 if ( rerr -> message ) * rerr -> message = strdup ( verr -> message ) ;
 rerr -> level = verr -> level ;
 rerr -> str1 = verr -> str1 ? malloc ( sizeof ( char * ) ) : NULL ;
 if ( rerr -> str1 ) * rerr -> str1 = strdup ( verr -> str1 ) ;
 rerr -> str2 = verr -> str2 ? malloc ( sizeof ( char * ) ) : NULL ;
 if ( rerr -> str2 ) * rerr -> str2 = strdup ( verr -> str2 ) ;
 rerr -> str3 = verr -> str3 ? malloc ( sizeof ( char * ) ) : NULL ;
 if ( rerr -> str3 ) * rerr -> str3 = strdup ( verr -> str3 ) ;
 rerr -> int1 = verr -> int1 ;
 rerr -> int2 = verr -> int2 ;
 }",0
Detect whether the following code contains vulnerabilities.,"const char * TSUrlSchemeGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {
 return URLPartGet ( bufp , obj , length , & URL : : scheme_get ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"hb_unicode_funcs_t * hb_icu_get_unicode_funcs ( void ) {
 static const hb_unicode_funcs_t _hb_icu_unicode_funcs = {
 HB_OBJECT_HEADER_STATIC , NULL , true , {
 # define HB_UNICODE_FUNC_IMPLEMENT ( name ) hb_icu_unicode_ ## name , HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS # undef HB_UNICODE_FUNC_IMPLEMENT }
 }
 ;
 # if U_ICU_VERSION_MAJOR_NUM >= 49 if ( ! hb_atomic_ptr_get ( & normalizer ) ) {
 UErrorCode icu_err = U_ZERO_ERROR ;
 hb_atomic_ptr_cmpexch ( & normalizer , NULL , unorm2_getNFCInstance ( & icu_err ) ) ;
 }
 # endif return const_cast < hb_unicode_funcs_t * > ( & _hb_icu_unicode_funcs ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , ClosedWhileHidden_Http ) {
 StartHttpServer ( ) ;
 base : : TimeDelta upper_bound = NavigateInForegroundAndCloseInBackgroundWithTiming ( http_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Entity * EntityCreate ( SplinePointList * head , int linecap , int linejoin , real linewidth , real * transform , SplineSet * clippath ) {
 Entity * ent = calloc ( 1 , sizeof ( Entity ) ) ;
 ent -> type = et_splines ;
 ent -> u . splines . splines = head ;
 ent -> u . splines . cap = linecap ;
 ent -> u . splines . join = linejoin ;
 ent -> u . splines . stroke_width = linewidth ;
 ent -> u . splines . fill . col = 0xffffffff ;
 ent -> u . splines . stroke . col = 0xffffffff ;
 ent -> u . splines . fill . opacity = 1.0 ;
 ent -> u . splines . stroke . opacity = 1.0 ;
 ent -> clippath = SplinePointListCopy ( clippath ) ;
 memcpy ( ent -> u . splines . transform , transform , 6 * sizeof ( real ) ) ;
 return ( ent ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) {
 const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;
 if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ;
 else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , getPathInfo ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 zend_class_entry * ce = intern -> info_class ;
 zend_error_handling error_handling ;
 zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|C"" , & ce ) == SUCCESS ) {
 int path_len ;
 char * path = spl_filesystem_object_get_pathname ( intern , & path_len TSRMLS_CC ) ;
 if ( path ) {
 char * dpath = estrndup ( path , path_len ) ;
 path_len = php_dirname ( dpath , path_len ) ;
 spl_filesystem_object_create_info ( intern , dpath , path_len , 1 , ce , return_value TSRMLS_CC ) ;
 efree ( dpath ) ;
 }
 }
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 VP9_COMP * const cpi = ctx -> cpi ;
 vpx_svc_extra_cfg_t * const params = va_arg ( args , vpx_svc_extra_cfg_t * ) ;
 int i ;
 for ( i = 0 ;
 i < cpi -> svc . number_spatial_layers ;
 ++ i ) {
 LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ i ] ;
 lc -> max_q = params -> max_quantizers [ i ] ;
 lc -> min_q = params -> min_quantizers [ i ] ;
 lc -> scaling_factor_num = params -> scaling_factor_num [ i ] ;
 lc -> scaling_factor_den = params -> scaling_factor_den [ i ] ;
 }
 return VPX_CODEC_OK ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PayloadSizeIgnoresDownloads ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 bool prev_io_allowed = base : : ThreadRestrictions : : SetIOAllowed ( true ) ;
 {
 base : : ScopedTempDir downloads_directory ;
 ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;
 browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;
 content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/download_anchor_click.html"" ) ) ;
 downloads_observer . WaitForFinished ( ) ;
 }
 base : : ThreadRestrictions : : SetIOAllowed ( prev_io_allowed ) ;
 NavigateToUntrackedUrl ( ) ;
 histogram_tester_ . ExpectUniqueSample ( internal : : kHistogramPageLoadTotalBytes , 0 , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int answer_from_qmem ( int dns_fd , struct query * q , unsigned char * qmem_cmc , unsigned short * qmem_type , int qmem_len , unsigned char * cmc_to_check ) {
 int i ;
 for ( i = 0 ;
 i < qmem_len ;
 i ++ ) {
 if ( qmem_type [ i ] == T_UNSET ) continue ;
 if ( qmem_type [ i ] != q -> type ) continue ;
 if ( memcmp ( qmem_cmc + i * 4 , cmc_to_check , 4 ) ) continue ;
 if ( debug >= 1 ) fprintf ( stderr , ""OUT from qmem for %s == duplicate, sending illegal reply\n"" , q -> name ) ;
 write_dns ( dns_fd , q , ""x"" , 1 , 'T' ) ;
 q -> id = 0 ;
 return 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"END_TEST START_TEST ( test_find_available_user ) {
 in_addr_t ip ;
 int i ;
 ip = inet_addr ( ""127.0.0.1"" ) ;
 init_users ( ip , 27 ) ;
 for ( i = 0 ;
 i < USERS ;
 i ++ ) {
 fail_unless ( find_available_user ( ) == i ) ;
 }
 for ( i = 0 ;
 i < USERS ;
 i ++ ) {
 fail_unless ( find_available_user ( ) == - 1 ) ;
 }
 users [ 3 ] . active = 0 ;
 fail_unless ( find_available_user ( ) == 3 ) ;
 fail_unless ( find_available_user ( ) == - 1 ) ;
 users [ 3 ] . last_pkt = 55 ;
 fail_unless ( find_available_user ( ) == 3 ) ;
 fail_unless ( find_available_user ( ) == - 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_h225_TunnelledProtocol ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 748 ""./asn1/h225/h225.cnf"" tpOID = """" ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_TunnelledProtocol , TunnelledProtocol_sequence ) ;
 # line 750 ""./asn1/h225/h225.cnf"" tp_handle = dissector_get_string_handle ( tp_dissector_table , tpOID ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) {
 GdkScreen * screen ;
 char * uri ;
 GFile * file ;
 switch ( response_id ) {
 case GTK_RESPONSE_OK : {
 file = nautilus_file_get_location ( parameters -> file ) ;
 nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , ""yes"" ) ;
 nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;
 nautilus_file_invalidate_all_attributes ( parameters -> file ) ;
 screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ;
 uri = nautilus_file_get_uri ( parameters -> file ) ;
 DEBUG ( ""Launching untrusted launcher %s"" , uri ) ;
 nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;
 g_free ( uri ) ;
 g_object_unref ( file ) ;
 }
 break ;
 default : {
 }
 break ;
 }
 gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;
 activate_parameters_desktop_free ( parameters ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void rtp_add_address ( packet_info * pinfo , address * addr , int port , int other_port , const gchar * setup_method , guint32 setup_frame_number , gboolean is_video , GHashTable * rtp_dyn_payload ) {
 srtp_add_address ( pinfo , addr , port , other_port , setup_method , setup_frame_number , is_video , rtp_dyn_payload , NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int64_t unix_to_file_time ( int ti ) {
 int64_t t ;
 t = ti * INT64_C ( 10000000 ) ;
 t += INT64_C ( 116444736000000000 ) ;
 return t ;
 }",0
Detect whether the following code contains vulnerabilities.,"zend_function * spl_filesystem_object_get_method_check ( zval * * object_ptr , char * method , int method_len , const struct _zend_literal * key TSRMLS_DC ) {
 spl_filesystem_object * fsobj = zend_object_store_get_object ( * object_ptr TSRMLS_CC ) ;
 if ( fsobj -> u . dir . entry . d_name [ 0 ] == '\0' && fsobj -> orig_path == NULL ) {
 method = ""_bad_state_ex"" ;
 method_len = sizeof ( ""_bad_state_ex"" ) - 1 ;
 key = NULL ;
 }
 return zend_get_std_object_handlers ( ) -> get_method ( object_ptr , method , method_len , key TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_fht16x16_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {
 if ( tx_type == DCT_DCT ) {
 vp9_fdct16x16_c ( input , output , stride ) ;
 }
 else {
 tran_low_t out [ 256 ] ;
 tran_low_t * outptr = & out [ 0 ] ;
 int i , j ;
 tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;
 const transform_2d ht = FHT_16 [ tx_type ] ;
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;
 }
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = out [ j + i * 16 ] ;
 ht . rows ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) output [ j + i * 16 ] = temp_out [ j ] ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static ssize_t ReadBlobBlock ( Image * image , unsigned char * data ) {
 ssize_t count ;
 unsigned char block_count ;
 assert ( image != ( Image * ) NULL ) ;
 assert ( image -> signature == MagickSignature ) ;
 assert ( data != ( unsigned char * ) NULL ) ;
 count = ReadBlob ( image , 1 , & block_count ) ;
 if ( count != 1 ) return ( 0 ) ;
 count = ReadBlob ( image , ( size_t ) block_count , data ) ;
 if ( count != ( ssize_t ) block_count ) return ( 0 ) ;
 return ( count ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"inline const UChar * toUCharPtr ( const char16_t * p ) {
 # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;
 # endif return reinterpret_cast < const UChar * > ( p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCancelWithChecked ) {
 ShowDialog ( ) ;
 SetChecked ( true ) ;
 EXPECT_TRUE ( dialog_ -> Cancel ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_FALSE ( accept_ ) ;
 EXPECT_TRUE ( cancel_ ) ;
 EXPECT_TRUE ( dont_block_ ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 1 , 1 ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : CHECKED_DONT_LAUNCH , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void erase_screen ( AVCodecContext * avctx ) {
 AnsiContext * s = avctx -> priv_data ;
 int i ;
 for ( i = 0 ;
 i < avctx -> height ;
 i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
 s -> x = s -> y = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dcc_ctcp_resume_parse ( int type , const char * data , const char * nick , FILE_DCC_REC * * dcc , uoff_t * size , int * pasv_id ) {
 char * * params ;
 int paramcount , fileparams ;
 int port ;
 params = g_strsplit ( data , "" "" , - 1 ) ;
 paramcount = g_strv_length ( params ) ;
 if ( paramcount < 3 ) return 0 ;
 fileparams = get_file_params_count_resume ( params , paramcount ) ;
 if ( paramcount >= fileparams + 2 ) {
 port = atoi ( params [ fileparams ] ) ;
 * size = str_to_uofft ( params [ fileparams + 1 ] ) ;
 * pasv_id = ( ( port == 0 ) && ( paramcount == fileparams + 3 ) ) ? atoi ( params [ fileparams + 2 ] ) : - 1 ;
 * dcc = dcc_resume_find ( type , nick , port ) ;
 g_strfreev ( params ) ;
 return ( ( * dcc != NULL ) && ( ( * dcc ) -> pasv_id == * pasv_id ) ) ;
 }
 g_strfreev ( params ) ;
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) {
 int x , y ;
 unsigned char P [ 2 ] ;
 unsigned int flags ;
 P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 if ( P [ 0 ] <= P [ 1 ] ) {
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;
 for ( ;
 flags != 1 ;
 flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;
 s -> pixel_ptr += s -> line_inc ;
 }
 }
 else {
 flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y += 2 ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 , flags >>= 1 ) {
 s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;
 }
 s -> pixel_ptr += s -> stride * 2 ;
 }
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ztype ( i_ctx_t * i_ctx_p ) {
 os_ptr op = osp ;
 ref tnref ;
 int code = array_get ( imemory , op , ( long ) r_btype ( op - 1 ) , & tnref ) ;
 if ( code < 0 ) return code ;
 if ( ! r_has_type ( & tnref , t_name ) ) {
 check_op ( 2 ) ;
 {
 if ( op [ - 1 ] . value . pstruct != 0x00 ) {
 const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;
 int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;
 if ( code < 0 ) return code ;
 }
 else return_error ( gs_error_stackunderflow ) ;
 }
 r_set_attrs ( op - 1 , a_executable ) ;
 }
 else {
 ref_assign ( op - 1 , & tnref ) ;
 }
 pop ( 1 ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void evhttp_connection_done ( struct evhttp_connection * evcon ) {
 struct evhttp_request * req = TAILQ_FIRST ( & evcon -> requests ) ;
 int con_outgoing = evcon -> flags & EVHTTP_CON_OUTGOING ;
 if ( con_outgoing ) {
 int need_close ;
 TAILQ_REMOVE ( & evcon -> requests , req , next ) ;
 req -> evcon = NULL ;
 evcon -> state = EVCON_IDLE ;
 need_close = evhttp_is_connection_close ( req -> flags , req -> input_headers ) || evhttp_is_connection_close ( req -> flags , req -> output_headers ) ;
 if ( need_close ) evhttp_connection_reset ( evcon ) ;
 if ( TAILQ_FIRST ( & evcon -> requests ) != NULL ) {
 if ( ! evhttp_connected ( evcon ) ) evhttp_connection_connect ( evcon ) ;
 else evhttp_request_dispatch ( evcon ) ;
 }
 else if ( ! need_close ) {
 evhttp_connection_start_detectclose ( evcon ) ;
 }
 }
 else {
 evcon -> state = EVCON_WRITING ;
 }
 ( * req -> cb ) ( req , req -> cb_arg ) ;
 if ( con_outgoing ) {
 evhttp_request_free ( req ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestReplaceRemovesStaleHandlers ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/updated-url/%s"" ) , ""test2"" ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/third/%s"" ) , ""test"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;
 ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph3 ) ) ;
 const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( ""mailto"" ) ) ;
 ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;
 registry ( ) -> RemoveHandler ( ph3 ) ;
 ASSERT_TRUE ( registry ( ) -> GetHandlerFor ( ""mailto"" ) . IsEmpty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {
 os_ptr op = osp ;
 ref * arefs = op1 -> value . refs ;
 uint asize = r_size ( op1 ) ;
 uint i ;
 ref * rq ;
 for ( i = 0 , rq = arefs + asize ;
 rq != arefs ;
 ++ i ) {
 const ref * rp = ref_stack_index ( & e_stack , ( long ) i ) ;
 if ( r_has_type_attrs ( rp , t_null , a_executable ) && ! include_marks ) continue ;
 -- rq ;
 ref_assign_old ( op1 , rq , rp , ""execstack"" ) ;
 switch ( r_type ( rq ) ) {
 case t_operator : {
 uint opidx = op_index ( rq ) ;
 if ( opidx == 0 || op_def_is_internal ( op_index_def ( opidx ) ) ) r_clear_attrs ( rq , a_executable ) ;
 break ;
 }
 case t_struct : case t_astruct : {
 const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : ""NULL"" ;
 make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;
 break ;
 }
 default : ;
 }
 }
 pop ( op - op1 ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_tokenize_initialize ( ) {
 TOKENVALUE * const t = dct_value_tokens + DCT_MAX_VALUE ;
 const vp9_extra_bit * const e = vp9_extra_bits ;
 int i = - DCT_MAX_VALUE ;
 int sign = 1 ;
 do {
 if ( ! i ) sign = 0 ;
 {
 const int a = sign ? - i : i ;
 int eb = sign ;
 if ( a > 4 ) {
 int j = 4 ;
 while ( ++ j < 11 && e [ j ] . base_val <= a ) {
 }
 t [ i ] . token = -- j ;
 eb |= ( a - e [ j ] . base_val ) << 1 ;
 }
 else {
 t [ i ] . token = a ;
 }
 t [ i ] . extra = eb ;
 }
 {
 int cost = 0 ;
 const vp9_extra_bit * p = & vp9_extra_bits [ t [ i ] . token ] ;
 if ( p -> base_val ) {
 const int extra = t [ i ] . extra ;
 const int length = p -> len ;
 if ( length ) cost += treed_cost ( p -> tree , p -> prob , extra >> 1 , length ) ;
 cost += vp9_cost_bit ( vp9_prob_half , extra & 1 ) ;
 dct_value_cost [ i + DCT_MAX_VALUE ] = cost ;
 }
 }
 }
 while ( ++ i < DCT_MAX_VALUE ) ;
 vp9_dct_value_tokens_ptr = dct_value_tokens + DCT_MAX_VALUE ;
 vp9_dct_value_cost_ptr = dct_value_cost + DCT_MAX_VALUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CCoercionRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CCoercionRestriction * v , const char * fmt , ... ) {
 proto_tree * tree ;
 proto_item * item ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCoercionRestriction , & item , txt ) ;
 v -> value = tvb_get_letohieee_float ( tvb , offset ) ;
 proto_tree_add_float ( tree , hf_mswsp_ccoercerestrict_value , tvb , offset , 4 , v -> value ) ;
 offset += 4 ;
 offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & v -> child , ""child"" ) ;
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {
 char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;
 const char * command ;
 int len , len2 ;
 va_list ap ;
 command = extcmd_get_name ( id ) ;
 len = snprintf ( cmd , sizeof ( cmd ) - 1 , ""[%lu] %s;
"" , time ( NULL ) , command ) ;
 if ( len < 0 ) return ERROR ;
 if ( fmt ) {
 va_start ( ap , fmt ) ;
 len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;
 va_end ( ap ) ;
 if ( len2 < 0 ) return ERROR ;
 }
 return write_command_to_file ( cmd ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void at1_subband_synthesis ( AT1Ctx * q , AT1SUCtx * su , float * pOut ) {
 float temp [ 256 ] ;
 float iqmf_temp [ 512 + 46 ] ;
 ff_atrac_iqmf ( q -> bands [ 0 ] , q -> bands [ 1 ] , 128 , temp , su -> fst_qmf_delay , iqmf_temp ) ;
 memcpy ( su -> last_qmf_delay , & su -> last_qmf_delay [ 256 ] , sizeof ( float ) * 23 ) ;
 memcpy ( & su -> last_qmf_delay [ 23 ] , q -> bands [ 2 ] , sizeof ( float ) * 256 ) ;
 ff_atrac_iqmf ( temp , su -> last_qmf_delay , 256 , pOut , su -> snd_qmf_delay , iqmf_temp ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static hb_feature_t * feature_reference ( hb_feature_t * g ) {
 hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * g ;
 return c ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {
 MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;
 if ( avctx == avctx_from ) return 0 ;
 dst -> cur_index = src -> next_cur_index ;
 dst -> prev_index = src -> next_prev_index ;
 memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;
 memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;
 memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line32_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 # ifdef HOST_WORDS_BIGENDIAN memcpy ( d , s , width * 4 ) ;
 # else int w ;
 uint32_t r , g , b ;
 w = width ;
 do {
 r = s [ 1 ] ;
 g = s [ 2 ] ;
 b = s [ 3 ] ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 4 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static uint32_t vmsvga_index_read ( void * opaque , uint32_t address ) {
 struct vmsvga_state_s * s = opaque ;
 return s -> index ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) {
 const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;
 const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;
 const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;
 const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ;
 segment_tree_probs [ 0 ] = get_binary_prob ( c01 + c23 , c45 + c67 ) ;
 segment_tree_probs [ 1 ] = get_binary_prob ( c01 , c23 ) ;
 segment_tree_probs [ 2 ] = get_binary_prob ( c45 , c67 ) ;
 segment_tree_probs [ 3 ] = get_binary_prob ( segcounts [ 0 ] , segcounts [ 1 ] ) ;
 segment_tree_probs [ 4 ] = get_binary_prob ( segcounts [ 2 ] , segcounts [ 3 ] ) ;
 segment_tree_probs [ 5 ] = get_binary_prob ( segcounts [ 4 ] , segcounts [ 5 ] ) ;
 segment_tree_probs [ 6 ] = get_binary_prob ( segcounts [ 6 ] , segcounts [ 7 ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 771 ""./asn1/h225/h225.cnf"" gint32 value ;
 nsiOID = """" ;
 h221NonStandard = 0 ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;
 switch ( value ) {
 case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;
 break ;
 case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;
 break ;
 default : nsp_handle = NULL ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * _CompoundTextgetName ( const UConverter * cnv ) {
 return ""x11-compound-text"" ;
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_get_segment_id ( const VP9_COMMON * cm , const uint8_t * segment_ids , BLOCK_SIZE bsize , int mi_row , int mi_col ) {
 const int mi_offset = mi_row * cm -> mi_cols + mi_col ;
 const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;
 const int bh = num_8x8_blocks_high_lookup [ bsize ] ;
 const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ;
 const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ;
 int x , y , segment_id = INT_MAX ;
 for ( y = 0 ;
 y < ymis ;
 y ++ ) for ( x = 0 ;
 x < xmis ;
 x ++ ) segment_id = MIN ( segment_id , segment_ids [ mi_offset + y * cm -> mi_cols + x ] ) ;
 assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ;
 return segment_id ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_rfc2733Mode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_rfc2733Mode , T_rfc2733Mode_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_h223_al_type_al2WithSequenceNumbers ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 309 ""../../asn1/h245/h245.cnf"" if ( h223_lc_params_temp ) h223_lc_params_temp -> al_type = al2WithSequenceNumbers ;
 offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ssize_t _warc_rdlen ( const char * buf , size_t bsz ) {
 static const char _key [ ] = ""\r\nContent-Length:"" ;
 const char * val , * eol ;
 char * on = NULL ;
 long int len ;
 if ( ( val = xmemmem ( buf , bsz , _key , sizeof ( _key ) - 1U ) ) == NULL ) {
 return - 1 ;
 }
 val += sizeof ( _key ) - 1U ;
 if ( ( eol = _warc_find_eol ( val , buf + bsz - val ) ) == NULL ) {
 return - 1 ;
 }
 while ( val < eol && ( * val == ' ' || * val == '\t' ) ) val ++ ;
 if ( ! isdigit ( ( unsigned char ) * val ) ) return - 1 ;
 len = strtol ( val , & on , 10 ) ;
 if ( on != eol ) {
 return - 1 ;
 }
 return ( size_t ) len ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {
 uint32_t value = 0 ;
 CPUPPCState * env = cpu_single_env ;
 addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;
 switch ( addr ) {
 case MPC8544_GUTS_ADDR_PVR : value = env -> spr [ SPR_PVR ] ;
 break ;
 case MPC8544_GUTS_ADDR_SVR : value = env -> spr [ SPR_E500_SVR ] ;
 break ;
 default : fprintf ( stderr , ""guts: Unknown register read: %x\n"" , ( int ) addr ) ;
 break ;
 }
 return value ;
 }",1
Detect whether the following code contains vulnerabilities.,"inline OldUChar * toOldUCharPtr ( char16_t * p ) {
 # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;
 # endif return reinterpret_cast < OldUChar * > ( p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static guint32 dissect_netb_datagram_bcast ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {
 if ( tvb_memeql ( tvb , offset + NB_SENDER_NAME , zeroes , 10 ) == 0 ) {
 proto_tree_add_item ( tree , hf_netb_datagram_bcast_mac , tvb , offset + NB_SENDER_NAME + 10 , 6 , ENC_NA ) ;
 }
 else {
 netbios_add_name ( ""Sender's Name"" , tvb , offset + NB_SENDER_NAME , tree ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dtls1_retrieve_buffered_fragment ( SSL * s , int * ok ) {
 pitem * item ;
 hm_fragment * frag ;
 int al ;
 * ok = 0 ;
 item = pqueue_peek ( s -> d1 -> buffered_messages ) ;
 if ( item == NULL ) return 0 ;
 frag = ( hm_fragment * ) item -> data ;
 if ( frag -> reassembly != NULL ) return 0 ;
 if ( s -> d1 -> handshake_read_seq == frag -> msg_header . seq ) {
 unsigned long frag_len = frag -> msg_header . frag_len ;
 pqueue_pop ( s -> d1 -> buffered_messages ) ;
 al = dtls1_preprocess_fragment ( s , & frag -> msg_header ) ;
 if ( al == 0 ) {
 unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;
 memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;
 }
 dtls1_hm_fragment_free ( frag ) ;
 pitem_free ( item ) ;
 if ( al == 0 ) {
 * ok = 1 ;
 return frag_len ;
 }
 ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;
 s -> init_num = 0 ;
 * ok = 0 ;
 return - 1 ;
 }
 else return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int show_tags ( WriterContext * w , AVDictionary * tags , int section_id ) {
 AVDictionaryEntry * tag = NULL ;
 int ret = 0 ;
 if ( ! tags ) return 0 ;
 writer_print_section_header ( w , section_id ) ;
 while ( ( tag = av_dict_get ( tags , """" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) {
 if ( ( ret = print_str_validate ( tag -> key , tag -> value ) ) < 0 ) break ;
 }
 writer_print_section_footer ( w ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void get_name_from_fullpropspec ( struct CFullPropSpec * v , char * out , int bufsize ) {
 struct GuidPropertySet * pset = GuidPropertySet_find_guid ( & v -> guid ) ;
 const char * id_str , * guid_str ;
 char * dest = out ;
 id_str = pset ? try_val_to_str ( v -> u . propid , pset -> id_map ) : NULL ;
 if ( id_str ) {
 g_snprintf ( dest , bufsize , ""%s"" , id_str ) ;
 }
 else {
 guid_str = guids_get_guid_name ( & v -> guid ) ;
 if ( guid_str ) {
 g_snprintf ( dest , bufsize , ""\""%s\"""" , guid_str ) ;
 }
 else {
 guid_str = guid_to_str ( wmem_packet_scope ( ) , & v -> guid ) ;
 g_snprintf ( dest , bufsize , ""{
%s}
"" , guid_str ) ;
 }
 if ( v -> kind == PRSPEC_LPWSTR ) {
 g_snprintf ( dest , bufsize , ""%s \""%s\"""" , guid_str , v -> u . name ) ;
 }
 else if ( v -> kind == PRSPEC_PROPID ) {
 g_snprintf ( dest , bufsize , ""%s 0x%08x"" , guid_str , v -> u . propid ) ;
 }
 else {
 g_snprintf ( dest , bufsize , ""%s <INVALID>"" , dest ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void setup_masks_indic ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_buffer_t * buffer , hb_font_t * font HB_UNUSED ) {
 HB_BUFFER_ALLOCATE_VAR ( buffer , indic_category ) ;
 HB_BUFFER_ALLOCATE_VAR ( buffer , indic_position ) ;
 unsigned int count = buffer -> len ;
 hb_glyph_info_t * info = buffer -> info ;
 for ( unsigned int i = 0 ;
 i < count ;
 i ++ ) set_indic_properties ( info [ i ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClicked ) {
 ReplaceBlank ( browser ( ) ) ;
 int starting_tab_count = browser ( ) -> tab_strip_model ( ) -> count ( ) ;
 scoped_ptr < BookmarkBubbleDelegate > delegate ;
 delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;
 delegate -> OnSignInLinkClicked ( ) ;
 EXPECT_EQ ( starting_tab_count + 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , int8_t * skip ) {
 struct encode_b_args arg = {
 x , NULL , skip }
 ;
 encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SingleClientSessionsSyncTest , ResponseCodeIsPreserved ) {
 ASSERT_TRUE ( SetupSync ( ) ) << ""SetupSync() failed."" ;
 ASSERT_TRUE ( CheckInitialState ( 0 ) ) ;
 const GURL url ( ""about:version"" ) ;
 ScopedWindowMap windows ;
 ASSERT_TRUE ( OpenTabAndGetLocalWindows ( 0 , url , windows . GetMutable ( ) ) ) ;
 int found_navigations = 0 ;
 for ( SessionWindowMap : : const_iterator it = windows . Get ( ) -> begin ( ) ;
 it != windows . Get ( ) -> end ( ) ;
 ++ it ) {
 for ( std : : vector < sessions : : SessionTab * > : : const_iterator it2 = it -> second -> tabs . begin ( ) ;
 it2 != it -> second -> tabs . end ( ) ;
 ++ it2 ) {
 for ( std : : vector < sessions : : SerializedNavigationEntry > : : const_iterator it3 = ( * it2 ) -> navigations . begin ( ) ;
 it3 != ( * it2 ) -> navigations . end ( ) ;
 ++ it3 ) {
 EXPECT_EQ ( 200 , it3 -> http_status_code ( ) ) ;
 ++ found_navigations ;
 }
 }
 }
 ASSERT_EQ ( 1 , found_navigations ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void xsltFreeDocuments ( xsltTransformContextPtr ctxt ) {
 xsltDocumentPtr doc , cur ;
 cur = ctxt -> docList ;
 while ( cur != NULL ) {
 doc = cur ;
 cur = cur -> next ;
 xsltFreeDocumentKeys ( doc ) ;
 if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;
 xmlFree ( doc ) ;
 }
 cur = ctxt -> styleList ;
 while ( cur != NULL ) {
 doc = cur ;
 cur = cur -> next ;
 xsltFreeDocumentKeys ( doc ) ;
 if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;
 xmlFree ( doc ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static uint16_t U_CALLCONV uprv_readSwapUInt16 ( uint16_t x ) {
 return ( uint16_t ) ( ( x << 8 ) | ( x >> 8 ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_member ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_member , T_member_sequence_of ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {
 size_t need = buf -> misalign + buf -> off + datlen ;
 size_t oldoff = buf -> off ;
 if ( buf -> totallen < need ) {
 if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;
 }
 memcpy ( buf -> buffer + buf -> off , data , datlen ) ;
 buf -> off += datlen ;
 if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {
 VpxVideoInfo info = {
 encoder -> fourcc , cfg -> g_w , cfg -> g_h , {
 cfg -> g_timebase . num , cfg -> g_timebase . den }
 }
 ;
 VpxVideoWriter * writer = NULL ;
 vpx_codec_ctx_t codec ;
 int frame_count = 0 ;
 writer = vpx_video_writer_open ( outfile_name , kContainerIVF , & info ) ;
 if ( ! writer ) die ( ""Failed to open %s for writing"" , outfile_name ) ;
 if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , ""Failed to initialize encoder"" ) ;
 while ( vpx_img_read ( raw , infile ) ) {
 ++ frame_count ;
 encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;
 }
 while ( encode_frame ( & codec , NULL , - 1 , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ) {
 }
 printf ( ""\n"" ) ;
 if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed to destroy codec."" ) ;
 vpx_video_writer_close ( writer ) ;
 printf ( ""Pass 1 complete. Processed %d frames.\n"" , frame_count ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void virLogStackTraceToFd ( int fd ) {
 void * array [ 100 ] ;
 int size ;
 static bool doneWarning ;
 const char * msg = ""Stack trace not available on this platform\n"" ;
 # define STRIP_DEPTH 3 size = backtrace ( array , ARRAY_CARDINALITY ( array ) ) ;
 if ( size ) {
 backtrace_symbols_fd ( array + STRIP_DEPTH , size - STRIP_DEPTH , fd ) ;
 ignore_value ( safewrite ( fd , ""\n"" , 1 ) ) ;
 }
 else if ( ! doneWarning ) {
 ignore_value ( safewrite ( fd , msg , strlen ( msg ) ) ) ;
 doneWarning = true ;
 }
 # undef STRIP_DEPTH }",0
Detect whether the following code contains vulnerabilities.,"static void output ( code_int code , GifCtx * ctx ) {
 ctx -> cur_accum &= masks [ ctx -> cur_bits ] ;
 if ( ctx -> cur_bits > 0 ) {
 ctx -> cur_accum |= ( ( long ) code << ctx -> cur_bits ) ;
 }
 else {
 ctx -> cur_accum = code ;
 }
 ctx -> cur_bits += ctx -> n_bits ;
 while ( ctx -> cur_bits >= 8 ) {
 char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;
 ctx -> cur_accum >>= 8 ;
 ctx -> cur_bits -= 8 ;
 }
 if ( ctx -> free_ent > ctx -> maxcode || ctx -> clear_flg ) {
 if ( ctx -> clear_flg ) {
 ctx -> maxcode = MAXCODE ( ctx -> n_bits = ctx -> g_init_bits ) ;
 ctx -> clear_flg = 0 ;
 }
 else {
 ++ ( ctx -> n_bits ) ;
 if ( ctx -> n_bits == maxbits ) {
 ctx -> maxcode = maxmaxcode ;
 }
 else {
 ctx -> maxcode = MAXCODE ( ctx -> n_bits ) ;
 }
 }
 }
 if ( code == ctx -> EOFCode ) {
 while ( ctx -> cur_bits > 0 ) {
 char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;
 ctx -> cur_accum >>= 8 ;
 ctx -> cur_bits -= 8 ;
 }
 flush_char ( ctx ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xC_16 ( IpvideoContext * s ) {
 int x , y ;
 uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;
 for ( y = 0 ;
 y < 8 ;
 y += 2 ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 ) {
 pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 }
 pixel_ptr += s -> stride * 2 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static UChar32 T_UConverter_getNextUChar_UTF32_BE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {
 const uint8_t * mySource ;
 UChar32 myUChar ;
 int32_t length ;
 mySource = ( const uint8_t * ) args -> source ;
 if ( mySource >= ( const uint8_t * ) args -> sourceLimit ) {
 * err = U_INDEX_OUTOFBOUNDS_ERROR ;
 return 0xffff ;
 }
 length = ( int32_t ) ( ( const uint8_t * ) args -> sourceLimit - mySource ) ;
 if ( length < 4 ) {
 uprv_memcpy ( args -> converter -> toUBytes , mySource , length ) ;
 args -> converter -> toULength = ( int8_t ) length ;
 args -> source = ( const char * ) ( mySource + length ) ;
 * err = U_TRUNCATED_CHAR_FOUND ;
 return 0xffff ;
 }
 myUChar = ( ( UChar32 ) mySource [ 0 ] << 24 ) | ( ( UChar32 ) mySource [ 1 ] << 16 ) | ( ( UChar32 ) mySource [ 2 ] << 8 ) | ( ( UChar32 ) mySource [ 3 ] ) ;
 args -> source = ( const char * ) ( mySource + 4 ) ;
 if ( ( uint32_t ) myUChar <= MAXIMUM_UTF && ! U_IS_SURROGATE ( myUChar ) ) {
 return myUChar ;
 }
 uprv_memcpy ( args -> converter -> toUBytes , mySource , 4 ) ;
 args -> converter -> toULength = 4 ;
 * err = U_ILLEGAL_CHAR_FOUND ;
 return 0xffff ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , BlockMainFrameWithInterstitial ) {
 BlockHost ( kExampleHost2 ) ;
 WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;
 GURL allowed_url = embedded_test_server ( ) -> GetURL ( kExampleHost , ""/supervised_user/simple.html"" ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , allowed_url ) ;
 EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;
 GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost2 , ""/supervised_user/simple.html"" ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;
 EXPECT_TRUE ( tab -> ShowingInterstitialPage ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_appl_evtalt_alerts_struct ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {
 proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_alert_id , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_category , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_status , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_reserved , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_proprietary , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;
 * offset += 3 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int key_notify_policy_flush ( const struct km_event * c ) {
 struct sk_buff * skb_out ;
 struct sadb_msg * hdr ;
 skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ;
 if ( ! skb_out ) return - ENOBUFS ;
 hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ;
 hdr -> sadb_msg_type = SADB_X_SPDFLUSH ;
 hdr -> sadb_msg_seq = c -> seq ;
 hdr -> sadb_msg_pid = c -> portid ;
 hdr -> sadb_msg_version = PF_KEY_V2 ;
 hdr -> sadb_msg_errno = ( uint8_t ) 0 ;
 hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;
 pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"inline GRANT_TABLE * table_hash_search ( const char * host , const char * ip , const char * db , const char * user , const char * tname , bool exact ) {
 return ( GRANT_TABLE * ) name_hash_search ( & column_priv_hash , host , ip , db , user , tname , exact , FALSE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int match_re ( my_regex_t * re , char * str ) {
 while ( my_isspace ( charset_info , * str ) ) str ++ ;
 if ( str [ 0 ] == '/' && str [ 1 ] == '*' ) {
 char * comm_end = strstr ( str , ""*/"" ) ;
 if ( ! comm_end ) die ( ""Statement is unterminated comment"" ) ;
 str = comm_end + 2 ;
 }
 int err = my_regexec ( re , str , ( size_t ) 0 , NULL , 0 ) ;
 if ( err == 0 ) return 1 ;
 else if ( err == REG_NOMATCH ) return 0 ;
 {
 char erbuf [ 100 ] ;
 int len = my_regerror ( err , re , erbuf , sizeof ( erbuf ) ) ;
 die ( ""error %s, %d/%d `%s'\n"" , re_eprint ( err ) , ( int ) len , ( int ) sizeof ( erbuf ) , erbuf ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) {
 gint len , remaining ;
 char * text ;
 if ( offset % 2 ) offset += 2 - ( offset % 2 ) ;
 remaining = tvb_captured_length_remaining ( tvb , offset ) ;
 if ( remaining <= 0 ) {
 if ( data ) * data = g_strdup ( """" ) ;
 return offset ;
 }
 text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;
 len = ( int ) strlen ( text ) ;
 proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ;
 if ( data ) * data = text ;
 else g_free ( text ) ;
 return offset + ( len + 1 ) * 2 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _CompoundTextReset ( UConverter * converter , UConverterResetChoice choice ) {
 }",1
Detect whether the following code contains vulnerabilities.,"static int SRP_user_pwd_set_sv ( SRP_user_pwd * vinfo , const char * s , const char * v ) {
 unsigned char tmp [ MAX_LEN ] ;
 int len ;
 if ( strlen ( s ) > MAX_LEN || strlen ( v ) > MAX_LEN ) return 0 ;
 len = t_fromb64 ( tmp , v ) ;
 if ( NULL == ( vinfo -> v = BN_bin2bn ( tmp , len , NULL ) ) ) return 0 ;
 len = t_fromb64 ( tmp , s ) ;
 return ( ( vinfo -> s = BN_bin2bn ( tmp , len , NULL ) ) != NULL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"gboolean logcat_text_thread_dump_open ( wtap_dumper * wdh , int * err _U_ ) {
 struct dumper_t * dumper ;
 dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;
 dumper -> type = DUMP_THREAD ;
 wdh -> priv = dumper ;
 wdh -> subtype_write = logcat_dump_text ;
 wdh -> subtype_close = NULL ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_SEQUENCE_OF_IntegrityMechanism ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_IntegrityMechanism , SEQUENCE_OF_IntegrityMechanism_sequence_of ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint32_t vmport_cmd_get_version ( void * opaque , uint32_t addr ) {
 CPUX86State * env = cpu_single_env ;
 env -> regs [ R_EBX ] = VMPORT_MAGIC ;
 return 6 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_h225_RasMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 292 ""./asn1/h225/h225.cnf"" gint32 rasmessage_value ;
 h225_packet_info * h225_pi ;
 call_id_guid = NULL ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_RasMessage , RasMessage_choice , & rasmessage_value ) ;
 col_add_fstr ( actx -> pinfo -> cinfo , COL_INFO , ""RAS: %s "" , val_to_str ( rasmessage_value , h225_RasMessage_vals , ""<unknown>"" ) ) ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> msg_tag = rasmessage_value ;
 if ( call_id_guid ) {
 h225_pi -> guid = * call_id_guid ;
 }
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void s390_virtio_register ( void ) {
 s390_virtio_bus_register_withprop ( & s390_virtio_console ) ;
 s390_virtio_bus_register_withprop ( & s390_virtio_blk ) ;
 s390_virtio_bus_register_withprop ( & s390_virtio_net ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void set_p_mv_tables ( MpegEncContext * s , int mx , int my , int mv4 ) {
 const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;
 s -> p_mv_table [ xy ] [ 0 ] = mx ;
 s -> p_mv_table [ xy ] [ 1 ] = my ;
 if ( mv4 ) {
 int mot_xy = s -> block_index [ 0 ] ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 0 ] = mx ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 1 ] = my ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 0 ] = mx ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 1 ] = my ;
 mot_xy += s -> b8_stride ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 0 ] = mx ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 1 ] = my ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 0 ] = mx ;
 s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 1 ] = my ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void xmlListPopBack ( xmlListPtr l ) {
 if ( ! xmlListEmpty ( l ) ) xmlLinkDeallocator ( l , l -> sentinel -> prev ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {
 AnsiContext * s = avctx -> priv_data ;
 int i ;
 for ( i = 0 ;
 i < s -> font_height ;
 i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void IGDstartelt ( void * d , const char * name , int l ) {
 struct IGDdatas * datas = ( struct IGDdatas * ) d ;
 memcpy ( datas -> cureltname , name , l ) ;
 datas -> cureltname [ l ] = '\0' ;
 datas -> level ++ ;
 if ( ( l == 7 ) && ! memcmp ( name , ""service"" , l ) ) {
 datas -> tmp . controlurl [ 0 ] = '\0' ;
 datas -> tmp . eventsuburl [ 0 ] = '\0' ;
 datas -> tmp . scpdurl [ 0 ] = '\0' ;
 datas -> tmp . servicetype [ 0 ] = '\0' ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static UBool action_setRunsOnly ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {
 ubidi_setReorderingMode ( pTransform -> pBidi , UBIDI_REORDER_RUNS_ONLY ) ;
 return FALSE ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( OmniboxViewViewsTest , ScheduledTextEditCommand ) {
 omnibox_textfield ( ) -> SetTextEditCommandForNextKeyEvent ( ui : : TextEditCommand : : MOVE_UP ) ;
 EXPECT_EQ ( ui : : TextEditCommand : : MOVE_UP , scheduled_text_edit_command ( ) ) ;
 ui : : KeyEvent up_pressed ( ui : : ET_KEY_PRESSED , ui : : VKEY_UP , 0 ) ;
 omnibox_textfield ( ) -> OnKeyEvent ( & up_pressed ) ;
 EXPECT_EQ ( ui : : TextEditCommand : : INVALID_COMMAND , scheduled_text_edit_command ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"type_init ( ehci_pci_register_types ) struct ehci_companions {
 const char * name ;
 int func ;
 int port ;
 }
 ;
 static const struct ehci_companions ich9_1d [ ] = {
 {
 . name = ""ich9-usb-uhci1"" , . func = 0 , . port = 0 }
 , {
 . name = ""ich9-usb-uhci2"" , . func = 1 , . port = 2 }
 , {
 . name = ""ich9-usb-uhci3"" , . func = 2 , . port = 4 }
 , }",0
Detect whether the following code contains vulnerabilities.,"byte * _gcry_mpi_get_buffer ( gcry_mpi_t a , unsigned int * nbytes , int * sign ) {
 return do_get_buffer ( a , nbytes , sign , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xC ( IpvideoContext * s ) {
 int x , y ;
 for ( y = 0 ;
 y < 8 ;
 y += 2 ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 ) {
 s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 }
 s -> pixel_ptr += s -> stride * 2 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int64_t cpu_get_icount ( void ) {
 int64_t icount ;
 CPUArchState * env = cpu_single_env ;
 icount = qemu_icount ;
 if ( env ) {
 if ( ! can_do_io ( env ) ) {
 fprintf ( stderr , ""Bad clock read\n"" ) ;
 }
 icount -= ( env -> icount_decr . u16 . low + env -> icount_extra ) ;
 }
 return qemu_icount_bias + ( icount << icount_time_shift ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * xml_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) {
 const char * p ;
 for ( p = src ;
 * p ;
 p ++ ) {
 switch ( * p ) {
 case '&' : av_bprintf ( dst , ""%s"" , ""&amp;
"" ) ;
 break ;
 case '<' : av_bprintf ( dst , ""%s"" , ""&lt;
"" ) ;
 break ;
 case '>' : av_bprintf ( dst , ""%s"" , ""&gt;
"" ) ;
 break ;
 case '""' : av_bprintf ( dst , ""%s"" , ""&quot;
"" ) ;
 break ;
 case '\'' : av_bprintf ( dst , ""%s"" , ""&apos;
"" ) ;
 break ;
 default : av_bprint_chars ( dst , * p , 1 ) ;
 }
 }
 return dst -> str ;
 }",0
Detect whether the following code contains vulnerabilities.,"void dtls1_clear ( SSL * s ) {
 pqueue * buffered_messages ;
 pqueue * sent_messages ;
 unsigned int mtu ;
 unsigned int link_mtu ;
 DTLS_RECORD_LAYER_clear ( & s -> rlayer ) ;
 if ( s -> d1 ) {
 buffered_messages = s -> d1 -> buffered_messages ;
 sent_messages = s -> d1 -> sent_messages ;
 mtu = s -> d1 -> mtu ;
 link_mtu = s -> d1 -> link_mtu ;
 dtls1_clear_queues ( s ) ;
 memset ( s -> d1 , 0 , sizeof ( * s -> d1 ) ) ;
 if ( s -> server ) {
 s -> d1 -> cookie_len = sizeof ( s -> d1 -> cookie ) ;
 }
 if ( SSL_get_options ( s ) & SSL_OP_NO_QUERY_MTU ) {
 s -> d1 -> mtu = mtu ;
 s -> d1 -> link_mtu = link_mtu ;
 }
 s -> d1 -> buffered_messages = buffered_messages ;
 s -> d1 -> sent_messages = sent_messages ;
 }
 ssl3_clear ( s ) ;
 if ( s -> method -> version == DTLS_ANY_VERSION ) s -> version = DTLS_MAX_VERSION ;
 # ifndef OPENSSL_NO_DTLS1_METHOD else if ( s -> options & SSL_OP_CISCO_ANYCONNECT ) s -> client_version = s -> version = DTLS1_BAD_VER ;
 # endif else s -> version = s -> method -> version ;
 }",0
Detect whether the following code contains vulnerabilities.,"int gs_to_exit ( const gs_memory_t * mem , int exit_status ) {
 return gs_to_exit_with_code ( mem , exit_status , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void fill_vaapi_RefPicList ( VAPictureH264 RefPicList [ 32 ] , Picture * ref_list , unsigned int ref_count ) {
 unsigned int i , n = 0 ;
 for ( i = 0 ;
 i < ref_count ;
 i ++ ) if ( ref_list [ i ] . f . reference ) fill_vaapi_pic ( & RefPicList [ n ++ ] , & ref_list [ i ] , 0 ) ;
 for ( ;
 n < 32 ;
 n ++ ) init_vaapi_pic ( & RefPicList [ n ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void curses_connection_purge ( void * conn ) {
 ( void ) conn ;
 DEBUG_MSG ( ""curses_connection_purge"" ) ;
 conntrack_purge ( ) ;
 refresh_connections ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_GatekeeperRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 592 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_GatekeeperRejectReason , GatekeeperRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool rowtype_field_matches ( Oid rowtypeid , int fieldnum , Oid expectedtype , int32 expectedtypmod , Oid expectedcollation ) {
 TupleDesc tupdesc ;
 Form_pg_attribute attr ;
 if ( rowtypeid == RECORDOID ) return true ;
 tupdesc = lookup_rowtype_tupdesc ( rowtypeid , - 1 ) ;
 if ( fieldnum <= 0 || fieldnum > tupdesc -> natts ) {
 ReleaseTupleDesc ( tupdesc ) ;
 return false ;
 }
 attr = tupdesc -> attrs [ fieldnum - 1 ] ;
 if ( attr -> attisdropped || attr -> atttypid != expectedtype || attr -> atttypmod != expectedtypmod || attr -> attcollation != expectedcollation ) {
 ReleaseTupleDesc ( tupdesc ) ;
 return false ;
 }
 ReleaseTupleDesc ( tupdesc ) ;
 return true ;
 }",0
Detect whether the following code contains vulnerabilities.,"void remove_tap_listener_sccp_calls ( void ) {
 remove_tap_listener ( & ( the_tapinfo_struct . sccp_dummy ) ) ;
 have_sccp_tap_listener = FALSE ;
 have_sua_tap_listener = FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_rsl_ie_meas_res_no ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {
 proto_tree * ie_tree ;
 guint8 ie_id ;
 if ( is_mandatory == FALSE ) {
 ie_id = tvb_get_guint8 ( tvb , offset ) ;
 if ( ie_id != RSL_IE_MEAS_RES_NO ) return offset ;
 }
 ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_meas_res_no , NULL , ""Measurement result number IE"" ) ;
 proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;
 offset ++ ;
 proto_tree_add_item ( ie_tree , hf_rsl_meas_res_no , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;
 offset ++ ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void icount_adjust_rt ( void * opaque ) {
 qemu_mod_timer ( icount_rt_timer , qemu_get_clock_ms ( rt_clock ) + 1000 ) ;
 icount_adjust ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int16_t vp9_ac_quant ( int qindex , int delta ) {
 return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_h245Tunnelling ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 454 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_index , & ( h225_pi -> is_h245Tunneling ) ) ;
 # line 462 ""./asn1/h225/h225.cnf"" }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF7Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {
 cnv -> fromUnicodeStatus = UCNV_GET_VERSION ( cnv ) << 28 ;
 _UTF7Reset ( cnv , UCNV_RESET_BOTH ) ;
 }
 else {
 * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Http ) {
 StartHttpServer ( ) ;
 NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( ""/simple.html"" ) , http_test_server_ -> GetURL ( ""/empty.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 2 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __always_inline __le64 __cpu_to_le64p ( const __u64 * p ) {
 return ( __le64 ) * p ;
 }",1
Detect whether the following code contains vulnerabilities.,"const char * TSHttpHdrReasonGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;
 HTTPHdr h ;
 SET_HTTP_HDR ( h , bufp , obj ) ;
 return h . reason_get ( length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int X509_verify ( X509 * a , EVP_PKEY * r ) {
 return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int get_quant ( AVCodecContext * avctx , NuvContext * c , const uint8_t * buf , int size ) {
 int i ;
 if ( size < 2 * 64 * 4 ) {
 av_log ( avctx , AV_LOG_ERROR , ""insufficient rtjpeg quant data\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 for ( i = 0 ;
 i < 64 ;
 i ++ , buf += 4 ) c -> lq [ i ] = AV_RL32 ( buf ) ;
 for ( i = 0 ;
 i < 64 ;
 i ++ , buf += 4 ) c -> cq [ i ] = AV_RL32 ( buf ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static u16 transaction_id_pick ( void ) {
 for ( ;
 ;
 ) {
 const struct request * req = req_head , * started_at ;
 u16 trans_id = trans_id_function ( ) ;
 if ( trans_id == 0xffff ) continue ;
 req = started_at = req_head ;
 if ( req ) {
 do {
 if ( req -> trans_id == trans_id ) break ;
 req = req -> next ;
 }
 while ( req != started_at ) ;
 }
 if ( req == started_at ) return trans_id ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_conferenceGoal ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_conferenceGoal , T_conferenceGoal_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"clump_t * clump_splay_walk_bwd_init ( clump_splay_walker * sw , const gs_ref_memory_t * mem ) {
 clump_t * cp = mem -> root ;
 if ( cp ) {
 SANITY_CHECK ( cp ) ;
 sw -> from = SPLAY_FROM_RIGHT ;
 while ( cp -> right ) {
 cp = cp -> right ;
 }
 }
 sw -> cp = cp ;
 sw -> end = NULL ;
 return cp ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void U_CALLCONV _HZ_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 sa -> addRange ( sa -> set , 0 , 0x7f ) ;
 ucnv_MBCSGetFilteredUnicodeSetForUnicode ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter -> sharedData , sa , which , UCNV_SET_FILTER_HZ , pErrorCode ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void udev_hotplug_event ( struct udev_device * udev_dev ) {
 const char * udev_action ;
 const char * sys_name = NULL ;
 uint8_t busnum = 0 , devaddr = 0 ;
 int detached ;
 int r ;
 do {
 udev_action = udev_device_get_action ( udev_dev ) ;
 if ( ! udev_action ) {
 break ;
 }
 detached = ! strncmp ( udev_action , ""remove"" , 6 ) ;
 r = udev_device_info ( NULL , detached , udev_dev , & busnum , & devaddr , & sys_name ) ;
 if ( LIBUSB_SUCCESS != r ) {
 break ;
 }
 usbi_dbg ( ""udev hotplug event. action: %s."" , udev_action ) ;
 if ( strncmp ( udev_action , ""add"" , 3 ) == 0 ) {
 linux_hotplug_enumerate ( busnum , devaddr , sys_name ) ;
 }
 else if ( detached ) {
 linux_device_disconnected ( busnum , devaddr , sys_name ) ;
 }
 else {
 usbi_err ( NULL , ""ignoring udev action %s"" , udev_action ) ;
 }
 }
 while ( 0 ) ;
 udev_device_unref ( udev_dev ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int loop_filter_row_worker ( void * arg1 , void * arg2 ) {
 TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;
 LFWorkerData * const lf_data = & tile_data -> lfdata ;
 ( void ) arg2 ;
 loop_filter_rows_mt ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only , lf_data -> lf_sync , lf_data -> num_lf_workers ) ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) {
 char obj_txt [ 128 ] ;
 int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;
 BIO_write ( bio , obj_txt , len ) ;
 BIO_write ( bio , ""\n"" , 1 ) ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"VALUE rb_dlhandle_close ( VALUE self ) {
 struct dl_handle * dlhandle ;
 Data_Get_Struct ( self , struct dl_handle , dlhandle ) ;
 dlhandle -> open = 0 ;
 return INT2NUM ( dlclose ( dlhandle -> ptr ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int get_words ( OHCIState * ohci , dma_addr_t addr , uint16_t * buf , int num ) {
 int i ;
 addr += ohci -> localmem_base ;
 for ( i = 0 ;
 i < num ;
 i ++ , buf ++ , addr += sizeof ( * buf ) ) {
 if ( dma_memory_read ( ohci -> as , addr , buf , sizeof ( * buf ) ) ) {
 return - 1 ;
 }
 * buf = le16_to_cpu ( * buf ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"rfbBool rfbSendFileTransferMessage ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length , const char * buffer ) {
 rfbFileTransferMsg ft ;
 ft . type = rfbFileTransfer ;
 ft . contentType = contentType ;
 ft . contentParam = contentParam ;
 ft . pad = 0 ;
 ft . size = Swap32IfLE ( size ) ;
 ft . length = Swap32IfLE ( length ) ;
 FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( """" , cl , FALSE ) ;
 LOCK ( cl -> sendMutex ) ;
 if ( rfbWriteExact ( cl , ( char * ) & ft , sz_rfbFileTransferMsg ) < 0 ) {
 rfbLogPerror ( ""rfbSendFileTransferMessage: write"" ) ;
 rfbCloseClient ( cl ) ;
 UNLOCK ( cl -> sendMutex ) ;
 return FALSE ;
 }
 if ( length > 0 ) {
 if ( rfbWriteExact ( cl , buffer , length ) < 0 ) {
 rfbLogPerror ( ""rfbSendFileTransferMessage: write"" ) ;
 rfbCloseClient ( cl ) ;
 UNLOCK ( cl -> sendMutex ) ;
 return FALSE ;
 }
 }
 UNLOCK ( cl -> sendMutex ) ;
 rfbStatRecordMessageSent ( cl , rfbFileTransfer , sz_rfbFileTransferMsg + length , sz_rfbFileTransferMsg + length ) ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l )",1
Detect whether the following code contains vulnerabilities.,"static void free_frame_buffer ( MpegEncContext * s , Picture * pic ) {
 if ( s -> codec_id != AV_CODEC_ID_WMV3IMAGE && s -> codec_id != AV_CODEC_ID_VC1IMAGE && s -> codec_id != AV_CODEC_ID_MSS2 ) ff_thread_release_buffer ( s -> avctx , & pic -> f ) ;
 else avcodec_default_release_buffer ( s -> avctx , & pic -> f ) ;
 av_freep ( & pic -> hwaccel_picture_private ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void http_suite ( void ) {
 http_base_test ( ) ;
 http_bad_header_test ( ) ;
 http_parse_query_test ( ) ;
 http_basic_test ( ) ;
 http_connection_test ( 0 ) ;
 http_connection_test ( 1 ) ;
 http_close_detection ( 0 ) ;
 http_close_detection ( 1 ) ;
 http_post_test ( ) ;
 http_failure_test ( ) ;
 http_highport_test ( ) ;
 http_dispatcher_test ( ) ;
 http_multi_line_header_test ( ) ;
 http_negative_content_length_test ( ) ;
 http_chunked_test ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int compute_rd_thresh_factor ( int qindex ) {
 const int q = ( int ) ( pow ( vp9_dc_quant ( qindex , 0 ) / 4.0 , RD_THRESH_POW ) * 5.12 ) ;
 return MAX ( q , 8 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static cmsBool WriteOffsetArray ( cmsIOHANDLER * io , _cmsDICarray * a , cmsUInt32Number Count , cmsUInt32Number Length ) {
 cmsUInt32Number i ;
 for ( i = 0 ;
 i < Count ;
 i ++ ) {
 if ( ! WriteOneElem ( io , & a -> Name , i ) ) return FALSE ;
 if ( ! WriteOneElem ( io , & a -> Value , i ) ) return FALSE ;
 if ( Length > 16 ) {
 if ( ! WriteOneElem ( io , & a -> DisplayName , i ) ) return FALSE ;
 }
 if ( Length > 24 ) {
 if ( ! WriteOneElem ( io , & a -> DisplayValue , i ) ) return FALSE ;
 }
 }
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void report_progress_end ( ) {
 if ( last_progress_report_length ) {
 printf ( ""%*s\r"" , last_progress_report_length , """" ) ;
 last_progress_report_length = 0 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_pvfs2_error ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {
 gint32 err ;
 const char * errmsg = NULL ;
 err = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_pvfs_error , tvb , offset , 4 , - err ) ;
 offset += 4 ;
 if ( err != 0 ) {
 errmsg = val_to_str ( - err , names_pvfs_error , ""Unknown error: %u"" ) ;
 col_append_fstr ( pinfo -> cinfo , COL_INFO , "" Error: %s"" , errmsg ) ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int find_unused_picture ( MpegEncContext * s , int shared ) {
 int i ;
 if ( shared ) {
 for ( i = s -> picture_range_start ;
 i < s -> picture_range_end ;
 i ++ ) {
 if ( s -> picture [ i ] . f . data [ 0 ] == NULL && s -> picture [ i ] . f . type == 0 ) return i ;
 }
 }
 else {
 for ( i = s -> picture_range_start ;
 i < s -> picture_range_end ;
 i ++ ) {
 if ( pic_is_unused ( s , & s -> picture [ i ] ) && s -> picture [ i ] . f . type != 0 ) return i ;
 }
 for ( i = s -> picture_range_start ;
 i < s -> picture_range_end ;
 i ++ ) {
 if ( pic_is_unused ( s , & s -> picture [ i ] ) ) return i ;
 }
 }
 return AVERROR_INVALIDDATA ;
 }",1
Detect whether the following code contains vulnerabilities.,"void init_util ( void ) {
 filegen_register ( statsdir , ""peerstats"" , & peerstats ) ;
 filegen_register ( statsdir , ""loopstats"" , & loopstats ) ;
 filegen_register ( statsdir , ""clockstats"" , & clockstats ) ;
 filegen_register ( statsdir , ""rawstats"" , & rawstats ) ;
 filegen_register ( statsdir , ""sysstats"" , & sysstats ) ;
 filegen_register ( statsdir , ""protostats"" , & protostats ) ;
 # ifdef AUTOKEY filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ;
 # endif # ifdef DEBUG_TIMING filegen_register ( statsdir , ""timingstats"" , & timingstats ) ;
 # endif step_callback = & ntpd_time_stepped ;
 # ifdef DEBUG atexit ( & uninit_util ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Http ) {
 StartHttpServer ( ) ;
 NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( ""/simple.html"" ) , GURL ( chrome : : kChromeUIVersionURL ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void * jas_realloc ( void * ptr , size_t size ) {
 void * result ;
 JAS_DBGLOG ( 101 , ( ""jas_realloc called with %x,%zu\n"" , ptr , size ) ) ;
 result = realloc ( ptr , size ) ;
 JAS_DBGLOG ( 100 , ( ""jas_realloc(%p, %zu) -> %p\n"" , ptr , size , result ) ) ;
 return result ;
 }",1
Detect whether the following code contains vulnerabilities.,"rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {
 rfbTextChatMsg tc ;
 int bytesToSend = 0 ;
 memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;
 tc . type = rfbTextChat ;
 tc . length = Swap32IfLE ( length ) ;
 switch ( length ) {
 case rfbTextChatOpen : case rfbTextChatClose : case rfbTextChatFinished : bytesToSend = 0 ;
 break ;
 default : bytesToSend = length ;
 if ( bytesToSend > rfbTextMaxSize ) bytesToSend = rfbTextMaxSize ;
 }
 if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {
 if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;
 }
 memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;
 cl -> ublen += sz_rfbTextChatMsg ;
 if ( bytesToSend > 0 ) {
 memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;
 cl -> ublen += bytesToSend ;
 }
 rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;
 if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ __u64 __arch_swab64 ( __u64 val ) {
 # ifdef __i386__ union {
 struct {
 __u32 a ;
 __u32 b ;
 }
 s ;
 __u64 u ;
 }
 v ;
 v . u = val ;
 __asm__ ( ""bswapl %0 ;
 bswapl %1 ;
 xchgl %0,%1"" : ""=r"" ( v . s . a ) , ""=r"" ( v . s . b ) : ""0"" ( v . s . a ) , ""1"" ( v . s . b ) ) ;
 return v . u ;
 # else __asm__ ( ""bswapq %0"" : ""=r"" ( val ) : ""0"" ( val ) ) ;
 return val ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"fz_default_colorspaces * fz_keep_default_colorspaces ( fz_context * ctx , fz_default_colorspaces * default_cs ) {
 return fz_keep_imp ( ctx , default_cs , & default_cs -> refs ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _HZClose ( UConverter * cnv ) {
 if ( cnv -> extraInfo != NULL ) {
 ucnv_close ( ( ( UConverterDataHZ * ) ( cnv -> extraInfo ) ) -> gbConverter ) ;
 if ( ! cnv -> isExtraLocal ) {
 uprv_free ( cnv -> extraInfo ) ;
 }
 cnv -> extraInfo = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void * evport_init ( struct event_base * base ) {
 struct evport_data * evpd ;
 int i ;
 if ( evutil_getenv ( ""EVENT_NOEVPORT"" ) ) return ( NULL ) ;
 if ( ! ( evpd = calloc ( 1 , sizeof ( struct evport_data ) ) ) ) return ( NULL ) ;
 if ( ( evpd -> ed_port = port_create ( ) ) == - 1 ) {
 free ( evpd ) ;
 return ( NULL ) ;
 }
 evpd -> ed_fds = calloc ( DEFAULT_NFDS , sizeof ( struct fd_info ) ) ;
 if ( evpd -> ed_fds == NULL ) {
 close ( evpd -> ed_port ) ;
 free ( evpd ) ;
 return ( NULL ) ;
 }
 evpd -> ed_nevents = DEFAULT_NFDS ;
 for ( i = 0 ;
 i < EVENTS_PER_GETN ;
 i ++ ) evpd -> ed_pending [ i ] = - 1 ;
 evsignal_init ( base ) ;
 return ( evpd ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line32_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 # ifndef HOST_WORDS_BIGENDIAN memcpy ( d , s , width * 4 ) ;
 # else int w ;
 uint32_t r , g , b ;
 w = width ;
 do {
 b = s [ 0 ] ;
 g = s [ 1 ] ;
 r = s [ 2 ] ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 4 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static void show_object ( struct object * obj , const struct name_path * path , const char * component , void * cb_data ) {
 struct rev_list_info * info = cb_data ;
 finish_object ( obj , path , component , cb_data ) ;
 if ( info -> flags & REV_LIST_QUIET ) return ;
 show_object_with_name ( stdout , obj , path , component ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void SSL3_RECORD_release ( SSL3_RECORD * r , unsigned int num_recs ) {
 unsigned int i ;
 for ( i = 0 ;
 i < num_recs ;
 i ++ ) {
 OPENSSL_free ( r [ i ] . comp ) ;
 r [ i ] . comp = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void dovec ( struct vars * v , struct cvec * cv , struct state * lp , struct state * rp ) {
 chr ch , from , to ;
 const chr * p ;
 int i ;
 for ( p = cv -> chrs , i = cv -> nchrs ;
 i > 0 ;
 p ++ , i -- ) {
 ch = * p ;
 newarc ( v -> nfa , PLAIN , subcolor ( v -> cm , ch ) , lp , rp ) ;
 }
 for ( p = cv -> ranges , i = cv -> nranges ;
 i > 0 ;
 p += 2 , i -- ) {
 from = * p ;
 to = * ( p + 1 ) ;
 if ( from <= to ) subrange ( v , from , to , lp , rp ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDismissingRequest ) {
 content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;
 GetUserMediaAndDismiss ( tab_contents ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace ) ;
 __exctype ( isupper ) ;
 __exctype ( isxdigit ) ;
 extern int tolower ( int __c ) __THROW ;
 extern int toupper ( int __c ) __THROW ;
 # ifdef __USE_ISOC99 __exctype ( isblank )",1
Detect whether the following code contains vulnerabilities.,"static VALUE cState_space_set ( VALUE self , VALUE space ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( space , T_STRING ) ;
 len = RSTRING_LEN ( space ) ;
 if ( len == 0 ) {
 if ( state -> space ) {
 ruby_xfree ( state -> space ) ;
 state -> space = NULL ;
 state -> space_len = 0 ;
 }
 }
 else {
 if ( state -> space ) ruby_xfree ( state -> space ) ;
 state -> space = strdup ( RSTRING_PTR ( space ) ) ;
 state -> space_len = len ;
 }
 return Qnil ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dissect_diameter_other_vendor_exp_res ( tvbuff_t * tvb , proto_tree * tree , diam_sub_dis_t * diam_sub_dis ) {
 proto_item * pi ;
 if ( tree ) {
 pi = proto_tree_add_item ( tree , hf_diameter_other_vendor_exp_res , tvb , 0 , 4 , ENC_BIG_ENDIAN ) ;
 diam_sub_dis -> avp_str = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;
 proto_item_fill_label ( PITEM_FINFO ( pi ) , diam_sub_dis -> avp_str ) ;
 diam_sub_dis -> avp_str = strstr ( diam_sub_dis -> avp_str , "": "" ) + 2 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fdct4x4_1_c ( const int16_t * input , int16_t * output , int stride ) {
 int r , c ;
 int16_t sum = 0 ;
 for ( r = 0 ;
 r < 4 ;
 ++ r ) for ( c = 0 ;
 c < 4 ;
 ++ c ) sum += input [ r * stride + c ] ;
 output [ 0 ] = sum << 1 ;
 output [ 1 ] = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_ber_octet_string_wcb ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , ber_callback func ) {
 tvbuff_t * out_tvb = NULL ;
 offset = dissect_ber_octet_string ( implicit_tag , actx , tree , tvb , offset , hf_id , ( func ) ? & out_tvb : NULL ) ;
 if ( func && out_tvb && ( tvb_reported_length ( out_tvb ) > 0 ) ) {
 if ( hf_id >= 0 ) tree = proto_item_add_subtree ( actx -> created_item , ett_ber_octet_string ) ;
 func ( FALSE , out_tvb , 0 , actx , tree , - 1 ) ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_raw ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 881 ""./asn1/h225/h225.cnf"" tvbuff_t * value_tvb ;
 gef_ctx_t * gefx ;
 proto_item * ti ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) {
 ti = proto_tree_add_string ( tree , hf_h225_debug_dissector_try_string , tvb , offset >> 3 , 0 , gefx -> key ) ;
 PROTO_ITEM_SET_HIDDEN ( ti ) ;
 dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlLinkPtr xmlListEnd ( xmlListPtr l ) {
 if ( l == NULL ) return ( NULL ) ;
 return ( l -> sentinel -> prev ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_mode_info_seg_skip ( MACROBLOCK * x , TX_MODE tx_mode , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {
 MACROBLOCKD * const xd = & x -> e_mbd ;
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 INTERP_FILTER filter_ref ;
 if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ;
 else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] -> mbmi . interp_filter ;
 else filter_ref = EIGHTTAP ;
 mbmi -> sb_type = bsize ;
 mbmi -> mode = ZEROMV ;
 mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;
 mbmi -> skip = 1 ;
 mbmi -> uv_mode = DC_PRED ;
 mbmi -> ref_frame [ 0 ] = LAST_FRAME ;
 mbmi -> ref_frame [ 1 ] = NONE ;
 mbmi -> mv [ 0 ] . as_int = 0 ;
 mbmi -> interp_filter = filter_ref ;
 xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = 0 ;
 x -> skip = 1 ;
 * rate = 0 ;
 * dist = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cmyk2bgr ( fz_context * ctx , fz_color_converter * cc , float * dv , const float * sv ) {
 # ifdef SLOWCMYK float rgb [ 3 ] ;
 cmyk_to_rgb ( ctx , NULL , sv , rgb ) ;
 dv [ 0 ] = rgb [ 2 ] ;
 dv [ 1 ] = rgb [ 1 ] ;
 dv [ 2 ] = rgb [ 0 ] ;
 # else dv [ 0 ] = 1 - fz_min ( sv [ 2 ] + sv [ 3 ] , 1 ) ;
 dv [ 1 ] = 1 - fz_min ( sv [ 1 ] + sv [ 3 ] , 1 ) ;
 dv [ 2 ] = 1 - fz_min ( sv [ 0 ] + sv [ 3 ] , 1 ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void * qemu_kvm_cpu_thread_fn ( void * arg ) {
 CPUState * cpu = arg ;
 int r ;
 qemu_mutex_lock ( & qemu_global_mutex ) ;
 qemu_thread_get_self ( cpu -> thread ) ;
 cpu -> thread_id = qemu_get_thread_id ( ) ;
 cpu_single_env = cpu -> env_ptr ;
 r = kvm_init_vcpu ( cpu ) ;
 if ( r < 0 ) {
 fprintf ( stderr , ""kvm_init_vcpu failed: %s\n"" , strerror ( - r ) ) ;
 exit ( 1 ) ;
 }
 qemu_kvm_init_cpu_signals ( cpu ) ;
 cpu -> created = true ;
 qemu_cond_signal ( & qemu_cpu_cond ) ;
 while ( 1 ) {
 if ( cpu_can_run ( cpu ) ) {
 r = kvm_cpu_exec ( cpu ) ;
 if ( r == EXCP_DEBUG ) {
 cpu_handle_guest_debug ( cpu ) ;
 }
 }
 qemu_kvm_wait_io_event ( cpu ) ;
 }
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int alloc_addbyter ( int output , FILE * data ) {
 struct asprintf * infop = ( struct asprintf * ) data ;
 unsigned char outc = ( unsigned char ) output ;
 if ( ! infop -> buffer ) {
 infop -> buffer = malloc ( 32 ) ;
 if ( ! infop -> buffer ) {
 infop -> fail = 1 ;
 return - 1 ;
 }
 infop -> alloc = 32 ;
 infop -> len = 0 ;
 }
 else if ( infop -> len + 1 >= infop -> alloc ) {
 char * newptr ;
 newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;
 if ( ! newptr ) {
 infop -> fail = 1 ;
 return - 1 ;
 }
 infop -> buffer = newptr ;
 infop -> alloc *= 2 ;
 }
 infop -> buffer [ infop -> len ] = outc ;
 infop -> len ++ ;
 return outc ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int com_use ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {
 char * tmp , buff [ FN_REFLEN + 1 ] ;
 int select_db ;
 bzero ( buff , sizeof ( buff ) ) ;
 strmake_buf ( buff , line ) ;
 tmp = get_arg ( buff , 0 ) ;
 if ( ! tmp || ! * tmp ) {
 put_info ( ""USE must be followed by a database name"" , INFO_ERROR ) ;
 return 0 ;
 }
 get_current_db ( ) ;
 if ( ! current_db || cmp_database ( charset_info , current_db , tmp ) ) {
 if ( one_database ) {
 skip_updates = 1 ;
 select_db = 0 ;
 }
 else select_db = 2 ;
 }
 else {
 skip_updates = 0 ;
 select_db = 1 ;
 }
 if ( select_db ) {
 if ( ! connected && reconnect ( ) ) return opt_reconnect ? - 1 : 1 ;
 if ( mysql_select_db ( & mysql , tmp ) ) {
 if ( mysql_errno ( & mysql ) != CR_SERVER_GONE_ERROR ) return put_error ( & mysql ) ;
 if ( reconnect ( ) ) return opt_reconnect ? - 1 : 1 ;
 if ( mysql_select_db ( & mysql , tmp ) ) return put_error ( & mysql ) ;
 }
 my_free ( current_db ) ;
 current_db = my_strdup ( tmp , MYF ( MY_WME ) ) ;
 # ifdef HAVE_READLINE if ( select_db > 1 ) build_completion_hash ( opt_rehash , 1 ) ;
 # endif }
 put_info ( ""Database changed"" , INFO_INFO ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int show_object_fast ( const unsigned char * sha1 , enum object_type type , int exclude , uint32_t name_hash , struct packed_git * found_pack , off_t found_offset ) {
 fprintf ( stdout , ""%s\n"" , sha1_to_hex ( sha1 ) ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_h4501SupplementaryService_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 736 ""./asn1/h225/h225.cnf"" tvbuff_t * h4501_tvb = NULL ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h4501_tvb ) ;
 if ( h4501_tvb && tvb_reported_length ( h4501_tvb ) ) {
 call_dissector ( h4501_handle , h4501_tvb , actx -> pinfo , tree ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_sb_statfs ( struct dentry * dentry ) {
 const struct cred * cred = current_cred ( ) ;
 struct common_audit_data ad ;
 ad . type = LSM_AUDIT_DATA_DENTRY ;
 ad . u . dentry = dentry -> d_sb -> s_root ;
 return superblock_has_perm ( cred , dentry -> d_sb , FILESYSTEM__GETATTR , & ad ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint )",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l )",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( RecursiveDirectoryIterator , getSubPathname ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 char * sub_name ;
 int len ;
 char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '/' : DEFAULT_SLASH ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( intern -> u . dir . sub_path ) {
 len = spprintf ( & sub_name , 0 , ""%s%c%s"" , intern -> u . dir . sub_path , slash , intern -> u . dir . entry . d_name ) ;
 RETURN_STRINGL ( sub_name , len , 0 ) ;
 }
 else {
 RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CNodeRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CNodeRestriction * v , const char * fmt , ... ) {
 proto_tree * tree ;
 proto_item * item ;
 unsigned i ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CNodeRestriction , & item , txt ) ;
 v -> cNode = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_cnoderestrict_cnode , tvb , offset , 4 , v -> cNode ) ;
 offset += 4 ;
 for ( i = 0 ;
 i < v -> cNode ;
 i ++ ) {
 struct CRestriction r ;
 ZERO_STRUCT ( r ) ;
 offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & r , ""paNode[%u]"" , i ) ;
 offset = parse_padding ( tvb , offset , 4 , tree , ""padding_paNode[%u]"" , i ) ;
 }
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decode_color_temperature ( gchar * s , guint16 value ) {
 g_snprintf ( s , ITEM_LABEL_LENGTH , ""%d [Mired] (%d [K])"" , value , 1000000 / value ) ;
 return ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CRestrictionArray ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 guint8 present , count ;
 proto_tree * tree ;
 proto_item * item ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRestrictionArray , & item , txt ) ;
 pad_tree = tree ;
 count = tvb_get_guint8 ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_crestrictarray_count , tvb , offset , 1 , count ) ;
 offset += 1 ;
 present = tvb_get_guint8 ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_crestrictarray_present , tvb , offset , 1 , present ) ;
 offset += 1 ;
 if ( present ) {
 unsigned i ;
 offset = parse_padding ( tvb , offset , 4 , pad_tree , ""paddingCRestrictionPresent"" ) ;
 for ( i = 0 ;
 i < count ;
 i ++ ) {
 struct CRestriction r ;
 offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & r , ""Restriction[%d]"" , i ) ;
 }
 }
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"void nautilus_file_mark_desktop_file_trusted ( GFile * file , GtkWindow * parent_window , gboolean interactive , NautilusOpCallback done_callback , gpointer done_callback_data ) {
 GTask * task ;
 MarkTrustedJob * job ;
 job = op_job_new ( MarkTrustedJob , parent_window ) ;
 job -> file = g_object_ref ( file ) ;
 job -> interactive = interactive ;
 job -> done_callback = done_callback ;
 job -> done_callback_data = done_callback_data ;
 task = g_task_new ( NULL , NULL , mark_trusted_task_done , job ) ;
 g_task_set_task_data ( task , job , NULL ) ;
 g_task_run_in_thread ( task , mark_trusted_task_thread_func ) ;
 g_object_unref ( task ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int for_pos_int_continue ( i_ctx_t * i_ctx_p ) {
 os_ptr op = osp ;
 register es_ptr ep = esp ;
 int var = ep [ - 3 ] . value . intval ;
 if ( var > ep [ - 1 ] . value . intval ) {
 esp -= 5 ;
 return o_pop_estack ;
 }
 push ( 1 ) ;
 make_int ( op , var ) ;
 ep [ - 3 ] . value . intval = var + ep [ - 2 ] . value . intval ;
 ref_assign_inline ( ep + 2 , ep ) ;
 esp = ep + 2 ;
 return o_push_estack ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleNotSupervisedTest , DontBlock ) {
 BlockHost ( kExampleHost ) ;
 WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;
 GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost , ""/supervised_user/simple.html"" ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;
 EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void get_type_category_preferred ( Oid typid , char * typcategory , bool * typispreferred ) {
 HeapTuple tp ;
 Form_pg_type typtup ;
 tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;
 if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , ""cache lookup failed for type %u"" , typid ) ;
 typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;
 * typcategory = typtup -> typcategory ;
 * typispreferred = typtup -> typispreferred ;
 ReleaseSysCache ( tp ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"hb_face_t * hb_face_create ( hb_blob_t * blob , unsigned int index ) {
 hb_face_t * face ;
 if ( unlikely ( ! blob || ! hb_blob_get_length ( blob ) ) ) return hb_face_get_empty ( ) ;
 hb_face_for_data_closure_t * closure = _hb_face_for_data_closure_create ( OT : : Sanitizer < OT : : OpenTypeFontFile > : : sanitize ( hb_blob_reference ( blob ) ) , index ) ;
 if ( unlikely ( ! closure ) ) return hb_face_get_empty ( ) ;
 face = hb_face_create_for_tables ( _hb_face_for_data_reference_table , closure , ( hb_destroy_func_t ) _hb_face_for_data_closure_destroy ) ;
 hb_face_set_index ( face , index ) ;
 return face ;
 }",1
Detect whether the following code contains vulnerabilities.,"Datum nlikesel ( PG_FUNCTION_ARGS ) {
 PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Like , true ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _doSetSessionAuth ( ArchiveHandle * AH , const char * user ) {
 PQExpBuffer cmd = createPQExpBuffer ( ) ;
 appendPQExpBufferStr ( cmd , ""SET SESSION AUTHORIZATION "" ) ;
 if ( user && * user ) appendStringLiteralAHX ( cmd , user , AH ) ;
 else appendPQExpBufferStr ( cmd , ""DEFAULT"" ) ;
 appendPQExpBufferChar ( cmd , ';
' ) ;
 if ( RestoringToDB ( AH ) ) {
 PGresult * res ;
 res = PQexec ( AH -> connection , cmd -> data ) ;
 if ( ! res || PQresultStatus ( res ) != PGRES_COMMAND_OK ) exit_horribly ( modulename , ""could not set session user to \""%s\"": %s"" , user , PQerrorMessage ( AH -> connection ) ) ;
 PQclear ( res ) ;
 }
 else ahprintf ( AH , ""%s\n\n"" , cmd -> data ) ;
 destroyPQExpBuffer ( cmd ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"char * cluster_conn_opts ( ClusterInfo * cluster ) {
 static char conn_opts [ MAXPGPATH + NAMEDATALEN + 100 ] ;
 if ( cluster -> sockdir ) snprintf ( conn_opts , sizeof ( conn_opts ) , ""--host \""%s\"" --port %d --username \""%s\"""" , cluster -> sockdir , cluster -> port , os_info . user ) ;
 else snprintf ( conn_opts , sizeof ( conn_opts ) , ""--port %d --username \""%s\"""" , cluster -> port , os_info . user ) ;
 return conn_opts ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelYTraits ( Image * image , const PixelTrait traits ) {
 image -> channel_map [ YPixelChannel ] . traits = traits ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , AlwaysInBackground ) {
 StartHttpsServer ( false ) ;
 StartHttpServer ( ) ;
 NavigateInBackgroundAndClose ( https_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 NavigateInBackgroundAndClose ( http_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower )",1
Detect whether the following code contains vulnerabilities.,"static void rtp_dyn_payloads_init ( void ) {
 if ( rtp_dyn_payloads == NULL ) {
 rtp_dyn_payloads = g_hash_table_new ( NULL , NULL ) ;
 wmem_register_callback ( wmem_file_scope ( ) , wmem_rtp_dyn_payload_destroy_cb , NULL ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void fadst4 ( const int16_t * input , int16_t * output ) {
 int x0 , x1 , x2 , x3 ;
 int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;
 x0 = input [ 0 ] ;
 x1 = input [ 1 ] ;
 x2 = input [ 2 ] ;
 x3 = input [ 3 ] ;
 if ( ! ( x0 | x1 | x2 | x3 ) ) {
 output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ;
 return ;
 }
 s0 = sinpi_1_9 * x0 ;
 s1 = sinpi_4_9 * x0 ;
 s2 = sinpi_2_9 * x1 ;
 s3 = sinpi_1_9 * x1 ;
 s4 = sinpi_3_9 * x2 ;
 s5 = sinpi_4_9 * x3 ;
 s6 = sinpi_2_9 * x3 ;
 s7 = x0 + x1 - x3 ;
 x0 = s0 + s2 + s5 ;
 x1 = sinpi_3_9 * s7 ;
 x2 = s1 - s3 + s6 ;
 x3 = s4 ;
 s0 = x0 + x3 ;
 s1 = x1 ;
 s2 = x2 - x3 ;
 s3 = x2 - x0 + x3 ;
 output [ 0 ] = fdct_round_shift ( s0 ) ;
 output [ 1 ] = fdct_round_shift ( s1 ) ;
 output [ 2 ] = fdct_round_shift ( s2 ) ;
 output [ 3 ] = fdct_round_shift ( s3 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CInGroupSortAggregSet ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 proto_item * item ;
 proto_tree * tree ;
 va_list ap ;
 enum CInGroupSortAggregSet_type type ;
 const char * txt ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSet , & item , txt ) ;
 offset = parse_CInGroupSortAggregSet_type ( tvb , offset , tree , & type ) ;
 offset = parse_padding ( tvb , offset , 4 , pad_tree , ""CInGroupSortAggregSet"" ) ;
 if ( type == GroupIdValue ) {
 struct CBaseStorageVariant id ;
 offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & id , ""inGroupId"" ) ;
 }
 offset = parse_CSortSet ( tvb , offset , tree , pad_tree , ""SortSet"" ) ;
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_ReleaseComplete_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 515 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_ReleaseComplete_UUIE , ReleaseComplete_UUIE_sequence ) ;
 # line 519 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_RELEASE_COMPLET ;
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static call_list * call_list_append ( call_list * list , guint16 scallno ) {
 call_list * node = wmem_new0 ( wmem_packet_scope ( ) , call_list ) ;
 node -> scallno = scallno ;
 if ( list ) {
 call_list * cur = list ;
 while ( cur -> next ) {
 cur = cur -> next ;
 }
 cur -> next = node ;
 return list ;
 }
 else {
 return node ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_uchar_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int32_t written = 0 ;
 UChar arg = ( UChar ) ( args [ 0 ] . int64Value ) ;
 written = handler -> pad_and_justify ( context , info , & arg , 1 ) ;
 return written ;
 }",1
Detect whether the following code contains vulnerabilities.,"static FILE * dumpcffstrings ( struct pschars * strs ) {
 FILE * file = tmpfile ( ) ;
 _dumpcffstrings ( file , strs ) ;
 PSCharsFree ( strs ) ;
 return ( file ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void mt_init ( mtrand * mt , uint32_t seed ) {
 int i ;
 mt -> mt_buffer_ [ 0 ] = seed ;
 mt -> mt_index_ = MT_LEN ;
 for ( i = 1 ;
 i < MT_LEN ;
 i ++ ) {
 mt -> mt_buffer_ [ i ] = ( 1812433253UL * ( mt -> mt_buffer_ [ i - 1 ] ^ ( mt -> mt_buffer_ [ i - 1 ] >> 30 ) ) + i ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
 vpx_codec_err_t res = VPX_CODEC_OK ;
 ( void ) data ;
 if ( ctx -> priv == NULL ) {
 vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;
 if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;
 ctx -> priv = ( vpx_codec_priv_t * ) priv ;
 ctx -> priv -> init_flags = ctx -> init_flags ;
 ctx -> priv -> enc . total_encoders = 1 ;
 if ( ctx -> config . enc ) {
 priv -> cfg = * ctx -> config . enc ;
 ctx -> config . enc = & priv -> cfg ;
 }
 priv -> extra_cfg = default_extra_cfg ;
 vp9_initialize_enc ( ) ;
 res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;
 if ( res == VPX_CODEC_OK ) {
 set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;
 priv -> cpi = vp9_create_compressor ( & priv -> oxcf ) ;
 if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;
 else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;
 }
 }
 return res ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ __u64 __fswab64 ( __u64 val ) {
 # if defined ( __arch_swab64 ) return __arch_swab64 ( val ) ;
 # elif defined ( __SWAB_64_THRU_32__ ) __u32 h = val >> 32 ;
 __u32 l = val & ( ( 1ULL << 32 ) - 1 ) ;
 return ( ( ( __u64 ) __fswab32 ( l ) ) << 32 ) | ( ( __u64 ) ( __fswab32 ( h ) ) ) ;
 # else return ___constant_swab64 ( val ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"void cpu_stop_current ( void ) {
 if ( cpu_single_env ) {
 CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;
 cpu_single_cpu -> stop = false ;
 cpu_single_cpu -> stopped = true ;
 cpu_exit ( cpu_single_cpu ) ;
 qemu_cond_signal ( & qemu_pause_cond ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_pvfs2_geteattr_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo _U_ ) {
 offset += 4 ;
 offset = dissect_ds_keyval_array ( tvb , tree , offset ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int kvm_device_msi_assign ( KVMState * s , uint32_t dev_id , int virq ) {
 return kvm_assign_irq_internal ( s , dev_id , KVM_DEV_IRQ_HOST_MSI | KVM_DEV_IRQ_GUEST_MSI , virq ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x3 ( IpvideoContext * s ) {
 unsigned char B ;
 int x , y ;
 if ( ! s -> is_16bpp ) {
 B = bytestream2_get_byte ( & s -> stream_ptr ) ;
 }
 else {
 B = bytestream2_get_byte ( & s -> mv_ptr ) ;
 }
 if ( B < 56 ) {
 x = - ( 8 + ( B % 7 ) ) ;
 y = - ( B / 7 ) ;
 }
 else {
 x = - ( - 14 + ( ( B - 56 ) % 29 ) ) ;
 y = - ( 8 + ( ( B - 56 ) / 29 ) ) ;
 }
 av_dlog ( NULL , "" motion byte = %d, (x, y) = (%d, %d)\n"" , B , x , y ) ;
 return copy_from ( s , & s -> current_frame , x , y ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gpgme_error_t add_io_cb ( engine_gpgsm_t gpgsm , iocb_data_t * iocbd , gpgme_io_cb_t handler ) {
 gpgme_error_t err ;
 TRACE_BEG2 ( DEBUG_ENGINE , ""engine-gpgsm:add_io_cb"" , gpgsm , ""fd %d, dir %d"" , iocbd -> fd , iocbd -> dir ) ;
 err = ( * gpgsm -> io_cbs . add ) ( gpgsm -> io_cbs . add_priv , iocbd -> fd , iocbd -> dir , handler , iocbd -> data , & iocbd -> tag ) ;
 if ( err ) return TRACE_ERR ( err ) ;
 if ( ! iocbd -> dir ) err = _gpgme_io_set_nonblocking ( iocbd -> fd ) ;
 return TRACE_ERR ( err ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"PkRoleEnum pk_transaction_get_role ( PkTransaction * transaction ) {
 g_return_val_if_fail ( PK_IS_TRANSACTION ( transaction ) , FALSE ) ;
 return transaction -> priv -> role ;
 }",0
Detect whether the following code contains vulnerabilities.,"int dissect_h225_CallReferenceValue ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , NULL , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int EVP_CIPHER_CTX_reset ( EVP_CIPHER_CTX * c ) {
 if ( c == NULL ) return 1 ;
 if ( c -> cipher != NULL ) {
 if ( c -> cipher -> cleanup && ! c -> cipher -> cleanup ( c ) ) return 0 ;
 if ( c -> cipher_data && c -> cipher -> ctx_size ) OPENSSL_cleanse ( c -> cipher_data , c -> cipher -> ctx_size ) ;
 }
 OPENSSL_free ( c -> cipher_data ) ;
 # ifndef OPENSSL_NO_ENGINE ENGINE_finish ( c -> engine ) ;
 # endif memset ( c , 0 , sizeof ( * c ) ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int i2d_PUBKEY_bio ( BIO * bp , EVP_PKEY * pkey ) {
 return ASN1_i2d_bio_of ( EVP_PKEY , i2d_PUBKEY , bp , pkey ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void search_stack_free ( void * key , void * data ) {
 ber_memfree_x ( data , NULL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qdev_unplug ( DeviceState * dev ) {
 if ( ! dev -> parent_bus -> allow_hotplug ) {
 qemu_error ( ""Bus %s does not support hotplugging\n"" , dev -> parent_bus -> name ) ;
 return - 1 ;
 }
 assert ( dev -> info -> unplug != NULL ) ;
 return dev -> info -> unplug ( dev ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_nsp_data ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 805 ""./asn1/h225/h225.cnf"" tvbuff_t * next_tvb = NULL ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & next_tvb ) ;
 if ( next_tvb && tvb_reported_length ( next_tvb ) ) {
 call_dissector ( ( nsp_handle ) ? nsp_handle : data_handle , next_tvb , actx -> pinfo , tree ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalOr ( BoolExprState * orExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 List * clauses = orExpr -> args ;
 ListCell * clause ;
 bool AnyNull ;
 if ( isDone ) * isDone = ExprSingleResult ;
 AnyNull = false ;
 foreach ( clause , clauses ) {
 ExprState * clausestate = ( ExprState * ) lfirst ( clause ) ;
 Datum clause_value ;
 clause_value = ExecEvalExpr ( clausestate , econtext , isNull , NULL ) ;
 if ( * isNull ) AnyNull = true ;
 else if ( DatumGetBool ( clause_value ) ) return clause_value ;
 }
 * isNull = AnyNull ;
 return BoolGetDatum ( false ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int __tipc_nl_compat_doit ( struct tipc_nl_compat_cmd_doit * cmd , struct tipc_nl_compat_msg * msg ) {
 int err ;
 struct sk_buff * doit_buf ;
 struct sk_buff * trans_buf ;
 struct nlattr * * attrbuf ;
 struct genl_info info ;
 trans_buf = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ;
 if ( ! trans_buf ) return - ENOMEM ;
 err = ( * cmd -> transcode ) ( cmd , trans_buf , msg ) ;
 if ( err ) goto trans_out ;
 attrbuf = kmalloc ( ( tipc_genl_family . maxattr + 1 ) * sizeof ( struct nlattr * ) , GFP_KERNEL ) ;
 if ( ! attrbuf ) {
 err = - ENOMEM ;
 goto trans_out ;
 }
 err = nla_parse ( attrbuf , tipc_genl_family . maxattr , ( const struct nlattr * ) trans_buf -> data , trans_buf -> len , NULL ) ;
 if ( err ) goto parse_out ;
 doit_buf = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ;
 if ( ! doit_buf ) {
 err = - ENOMEM ;
 goto parse_out ;
 }
 doit_buf -> sk = msg -> dst_sk ;
 memset ( & info , 0 , sizeof ( info ) ) ;
 info . attrs = attrbuf ;
 err = ( * cmd -> doit ) ( doit_buf , & info ) ;
 kfree_skb ( doit_buf ) ;
 parse_out : kfree ( attrbuf ) ;
 trans_out : kfree_skb ( trans_buf ) ;
 return err ;
 }",0
Detect whether the following code contains vulnerabilities.,"Expr * make_orclause ( List * orclauses ) {
 BoolExpr * expr = makeNode ( BoolExpr ) ;
 expr -> boolop = OR_EXPR ;
 expr -> args = orclauses ;
 expr -> location = - 1 ;
 return ( Expr * ) expr ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void write_frame_size ( const VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) {
 vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;
 vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;
 write_display_size ( cm , wb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , fgets ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( spl_filesystem_file_read ( intern , 0 TSRMLS_CC ) == FAILURE ) {
 RETURN_FALSE ;
 }
 RETURN_STRINGL ( intern -> u . file . current_line , intern -> u . file . current_line_len , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"PkTransaction * pk_transaction_new ( GKeyFile * conf , GDBusNodeInfo * introspection ) {
 PkTransaction * transaction ;
 transaction = g_object_new ( PK_TYPE_TRANSACTION , NULL ) ;
 transaction -> priv -> conf = g_key_file_ref ( conf ) ;
 transaction -> priv -> job = pk_backend_job_new ( conf ) ;
 transaction -> priv -> introspection = g_dbus_node_info_ref ( introspection ) ;
 return PK_TRANSACTION ( transaction ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _UTF16BEOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {
 _UTF16BEReset ( cnv , UCNV_RESET_BOTH ) ;
 }
 else {
 * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void * checked_xcalloc ( size_t num , size_t size ) {
 alloc_limit_assert ( ""checked_xcalloc"" , ( num * size ) ) ;
 return xcalloc ( num , size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static hb_user_data_key_t user_data_key_reference ( hb_user_data_key_t l ) {
 return l ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {
 if ( hash_to_nss [ instance -> crypto_hash_type ] ) {
 unsigned char tmp_hash [ hash_len [ instance -> crypto_hash_type ] ] ;
 int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;
 if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {
 return - 1 ;
 }
 if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {
 log_printf ( instance -> log_level_error , ""Digest does not match"" ) ;
 return - 1 ;
 }
 * buf_len = datalen ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void show_object ( struct object * object , const char * name , void * data ) {
 struct bitmap * base = data ;
 int bitmap_pos ;
 bitmap_pos = bitmap_position ( object -> oid . hash ) ;
 if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;
 bitmap_set ( base , bitmap_pos ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_octal_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 int32_t len ;
 int32_t skipped ;
 void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;
 int64_t result ;
 skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 ufile_fill_uchar_buffer ( input ) ;
 len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;
 if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;
 result = ufmt_uto64 ( input -> str . fPos , & len , 8 ) ;
 input -> str . fPos += len ;
 if ( ! info -> fSkipArg ) {
 if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;
 else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;
 else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;
 }
 * argConverted = ! info -> fSkipArg ;
 return len + skipped ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONScreendump ( qemuMonitorPtr mon , const char * file ) {
 int ret ;
 virJSONValuePtr cmd , reply = NULL ;
 cmd = qemuMonitorJSONMakeCommand ( ""screendump"" , ""s:filename"" , file , NULL ) ;
 if ( ! cmd ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"unsigned char clamp_u8 ( float v ) {
 if ( v > 255. ) return 255 ;
 else if ( v < 0 ) return 0 ;
 else return floor ( v + .5 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"gboolean k12_dump_open ( wtap_dumper * wdh , int * err ) {
 k12_dump_t * k12 ;
 if ( ! wtap_dump_file_write ( wdh , k12_file_magic , 8 , err ) ) {
 return FALSE ;
 }
 if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_LEN , SEEK_SET , err ) == - 1 ) return FALSE ;
 wdh -> subtype_write = k12_dump ;
 wdh -> subtype_finish = k12_dump_finish ;
 k12 = ( k12_dump_t * ) g_malloc ( sizeof ( k12_dump_t ) ) ;
 wdh -> priv = ( void * ) k12 ;
 k12 -> file_len = K12_FILE_HDR_LEN ;
 k12 -> num_of_records = 0 ;
 k12 -> file_offset = K12_FILE_HDR_LEN ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"ttfFont * ttfFont__create ( gs_font_dir * dir ) {
 gs_memory_t * mem = dir -> memory -> stable_memory ;
 ttfFont * ttf ;
 if ( dir -> ttm == NULL ) {
 gx_ttfMemory * m = gs_alloc_struct ( mem , gx_ttfMemory , & st_gx_ttfMemory , ""ttfFont__create(gx_ttfMemory)"" ) ;
 if ( ! m ) return 0 ;
 m -> super . alloc_struct = gx_ttfMemory__alloc_struct ;
 m -> super . alloc_bytes = gx_ttfMemory__alloc_bytes ;
 m -> super . free = gx_ttfMemory__free ;
 m -> memory = mem ;
 dir -> ttm = m ;
 }
 if ( ttfInterpreter__obtain ( & dir -> ttm -> super , & dir -> tti ) ) return 0 ;
 if ( gx_san__obtain ( mem , & dir -> san ) ) return 0 ;
 ttf = gs_alloc_struct ( mem , ttfFont , & st_ttfFont , ""ttfFont__create"" ) ;
 if ( ttf == NULL ) return 0 ;
 # ifdef DEBUG ttfFont__init ( ttf , & dir -> ttm -> super , DebugRepaint , ( gs_debug_c ( 'Y' ) ? DebugPrint : NULL ) , mem ) ;
 # else ttfFont__init ( ttf , & dir -> ttm -> super , DebugRepaint , NULL , mem ) ;
 # endif return ttf ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int zcond ( i_ctx_t * i_ctx_p ) {
 os_ptr op = osp ;
 es_ptr ep = esp ;
 if ( ! r_is_array ( op ) ) return_op_typecheck ( op ) ;
 check_execute ( * op ) ;
 if ( ( r_size ( op ) & 1 ) != 0 ) return_error ( gs_error_rangecheck ) ;
 if ( r_size ( op ) == 0 ) return zpop ( i_ctx_p ) ;
 check_estack ( 3 ) ;
 esp = ep += 3 ;
 ref_assign ( ep - 2 , op ) ;
 make_op_estack ( ep - 1 , cond_continue ) ;
 array_get ( imemory , op , 0L , ep ) ;
 esfile_check_cache ( ) ;
 pop ( 1 ) ;
 return o_push_estack ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * U_CALLCONV myMemRealloc ( const void * context , void * mem , size_t size ) {
 char * p = ( char * ) mem ;
 char * retPtr ;
 if ( p != NULL ) {
 p -= sizeof ( ctest_AlignedMemory ) ;
 }
 retPtr = realloc ( p , size + sizeof ( ctest_AlignedMemory ) ) ;
 if ( retPtr != NULL ) {
 p += sizeof ( ctest_AlignedMemory ) ;
 }
 return retPtr ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void openpic_register_types ( void ) {
 type_register_static ( & openpic_info ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * pool_strdup ( const char * s ) {
 char * r = pool_alloc ( strlen ( s ) + 1 ) ;
 strcpy ( r , s ) ;
 return r ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void write_sync_code ( struct vp9_write_bit_buffer * wb ) {
 vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;
 vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;
 vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font )",1
Detect whether the following code contains vulnerabilities.,"static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {
 switch ( error ) {
 case EVCON_HTTP_TIMEOUT : case EVCON_HTTP_EOF : return ( - 1 ) ;
 case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {
 free ( req -> uri ) ;
 req -> uri = NULL ;
 }
 ( * req -> cb ) ( req , req -> cb_arg ) ;
 }
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) {
 const MODE_INFO * mi = xd -> mi [ 0 ] ;
 const MB_MODE_INFO * const mbmi = & mi -> mbmi ;
 if ( mbmi -> sb_type < BLOCK_8X8 ) {
 const int num_4x4_w = num_4x4_blocks_wide_lookup [ mbmi -> sb_type ] ;
 const int num_4x4_h = num_4x4_blocks_high_lookup [ mbmi -> sb_type ] ;
 int idx , idy ;
 for ( idy = 0 ;
 idy < 2 ;
 idy += num_4x4_h ) {
 for ( idx = 0 ;
 idx < 2 ;
 idx += num_4x4_w ) {
 const int i = idy * 2 + idx ;
 if ( mi -> bmi [ i ] . as_mode == NEWMV ) inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ;
 }
 }
 }
 else {
 if ( mbmi -> mode == NEWMV ) inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void prc_destroy ( jpc_enc_prc_t * prc ) {
 jpc_enc_cblk_t * cblk ;
 uint_fast32_t cblkno ;
 if ( prc -> cblks ) {
 for ( cblkno = 0 , cblk = prc -> cblks ;
 cblkno < prc -> numcblks ;
 ++ cblkno , ++ cblk ) {
 cblk_destroy ( cblk ) ;
 }
 jas_free ( prc -> cblks ) ;
 }
 if ( prc -> incltree ) {
 jpc_tagtree_destroy ( prc -> incltree ) ;
 }
 if ( prc -> nlibtree ) {
 jpc_tagtree_destroy ( prc -> nlibtree ) ;
 }
 if ( prc -> savincltree ) {
 jpc_tagtree_destroy ( prc -> savincltree ) ;
 }
 if ( prc -> savnlibtree ) {
 jpc_tagtree_destroy ( prc -> savnlibtree ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static xmlLinkPtr xmlListHigherSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 for ( lk = l -> sentinel -> prev ;
 lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) > 0 ;
 lk = lk -> prev ) ;
 return lk ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void e1000e_read_ps_rx_descr ( E1000ECore * core , uint8_t * desc , hwaddr ( * buff_addr ) [ MAX_PS_BUFFERS ] ) {
 int i ;
 union e1000_rx_desc_packet_split * d = ( union e1000_rx_desc_packet_split * ) desc ;
 for ( i = 0 ;
 i < MAX_PS_BUFFERS ;
 i ++ ) {
 ( * buff_addr ) [ i ] = le64_to_cpu ( d -> read . buffer_addr [ i ] ) ;
 }
 trace_e1000e_rx_desc_ps_read ( ( * buff_addr ) [ 0 ] , ( * buff_addr ) [ 1 ] , ( * buff_addr ) [ 2 ] , ( * buff_addr ) [ 3 ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void dtls1_clear_record_buffer ( SSL * s ) {
 pitem * item ;
 for ( item = pqueue_pop ( s -> d1 -> sent_messages ) ;
 item != NULL ;
 item = pqueue_pop ( s -> d1 -> sent_messages ) ) {
 dtls1_hm_fragment_free ( ( hm_fragment * ) item -> data ) ;
 pitem_free ( item ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelIndexTraits ( Image * image , const PixelTrait traits ) {
 image -> channel_map [ IndexPixelChannel ] . traits = traits ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cgfs_destroy ( void * hdata ) {
 struct cgfs_data * d = hdata ;
 if ( ! d ) return ;
 free ( d -> name ) ;
 lxc_cgroup_process_info_free_and_remove ( d -> info ) ;
 lxc_cgroup_put_meta ( d -> meta ) ;
 free ( d ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"const gchar * nautilus_mime_types_group_get_name ( gint group_index ) {
 g_return_val_if_fail ( group_index < G_N_ELEMENTS ( mimetype_groups ) , NULL ) ;
 return gettext ( mimetype_groups [ group_index ] . name ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int selinux_ismaclabel ( const char * name ) {
 return ( strcmp ( name , XATTR_SELINUX_SUFFIX ) == 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void mspack_fmap_free ( void * mem ) {
 free ( mem ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int finish_frame ( AVCodecContext * avctx , AVFrame * pict ) {
 RV34DecContext * r = avctx -> priv_data ;
 MpegEncContext * s = & r -> s ;
 int got_picture = 0 ;
 ff_er_frame_end ( & s -> er ) ;
 ff_MPV_frame_end ( s ) ;
 s -> mb_num_left = 0 ;
 if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ) ;
 if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {
 * pict = s -> current_picture_ptr -> f ;
 got_picture = 1 ;
 }
 else if ( s -> last_picture_ptr != NULL ) {
 * pict = s -> last_picture_ptr -> f ;
 got_picture = 1 ;
 }
 if ( got_picture ) ff_print_debug_info ( s , pict ) ;
 return got_picture ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gboolean prplcb_ev_remove ( guint id ) {
 b_event_remove ( ( gint ) id ) ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void print_xml_cdata ( FILE * xml_file , const char * str , ulong len ) {
 const char * end ;
 fputs ( ""<![CDATA[\n"" , xml_file ) ;
 for ( end = str + len ;
 str != end ;
 str ++ ) {
 switch ( * str ) {
 case ']' : if ( ( * ( str + 1 ) == ']' ) && ( * ( str + 2 ) == '>' ) ) {
 fputs ( ""]]]]><![CDATA[>"" , xml_file ) ;
 str += 2 ;
 continue ;
 }
 default : fputc ( * str , xml_file ) ;
 break ;
 }
 }
 fputs ( ""\n]]>\n"" , xml_file ) ;
 check_io ( xml_file ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void PNGAPI png_set_compression_buffer_size ( png_structp png_ptr , png_uint_32 size ) {
 if ( png_ptr == NULL ) return ;
 png_free ( png_ptr , png_ptr -> zbuf ) ;
 png_ptr -> zbuf_size = ( png_size_t ) size ;
 png_ptr -> zbuf = ( png_bytep ) png_malloc ( png_ptr , size ) ;
 png_ptr -> zstream . next_out = png_ptr -> zbuf ;
 png_ptr -> zstream . avail_out = ( uInt ) png_ptr -> zbuf_size ;
 }",0
Detect whether the following code contains vulnerabilities.,"static __always_inline __u16 __be16_to_cpup ( const __be16 * p ) {
 return __swab16p ( ( __u16 * ) p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_h245Ip ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 339 ""./asn1/h225/h225.cnf"" tvbuff_t * value_tvb ;
 ipv4_address = 0 ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 4 , 4 , FALSE , & value_tvb ) ;
 if ( value_tvb ) ipv4_address = tvb_get_ipv4 ( value_tvb , 0 ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 UChar * s ;
 UChar buffer [ UFMT_DEFAULT_BUFFER_SIZE ] ;
 int32_t len , written ;
 int32_t argSize ;
 const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;
 if ( arg ) {
 argSize = ( int32_t ) strlen ( arg ) + 1 ;
 if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {
 s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;
 if ( s == NULL ) {
 return 0 ;
 }
 }
 else {
 s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;
 }
 }
 else {
 s = ( UChar * ) gNullStr ;
 }
 len = u_strlen ( s ) ;
 if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {
 len = info -> fPrecision ;
 }
 written = handler -> pad_and_justify ( context , info , s , len ) ;
 if ( gNullStr != s && buffer != s ) {
 uprv_free ( s ) ;
 }
 return written ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) {
 gint len , remaining ;
 char * text ;
 if ( offset % 2 ) offset += 2 - ( offset % 2 ) ;
 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
 if ( remaining <= 0 ) {
 if ( data ) * data = g_strdup ( """" ) ;
 return offset ;
 }
 text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;
 len = ( int ) strlen ( text ) ;
 proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ;
 if ( data ) * data = text ;
 else g_free ( text ) ;
 return offset + ( len + 1 ) * 2 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int decode_rgb24_frame ( CLLCContext * ctx , GetBitContext * gb , AVFrame * pic ) {
 AVCodecContext * avctx = ctx -> avctx ;
 uint8_t * dst ;
 int pred [ 3 ] ;
 int ret ;
 int i , j ;
 VLC vlc [ 3 ] ;
 pred [ 0 ] = 0x80 ;
 pred [ 1 ] = 0x80 ;
 pred [ 2 ] = 0x80 ;
 dst = pic -> data [ 0 ] ;
 skip_bits ( gb , 16 ) ;
 for ( i = 0 ;
 i < 3 ;
 i ++ ) {
 ret = read_code_table ( ctx , gb , & vlc [ i ] ) ;
 if ( ret < 0 ) {
 for ( j = 0 ;
 j <= i ;
 j ++ ) ff_free_vlc ( & vlc [ j ] ) ;
 av_log ( ctx -> avctx , AV_LOG_ERROR , ""Could not read code table %d.\n"" , i ) ;
 return ret ;
 }
 }
 for ( i = 0 ;
 i < avctx -> height ;
 i ++ ) {
 for ( j = 0 ;
 j < 3 ;
 j ++ ) read_rgb24_component_line ( ctx , gb , & pred [ j ] , & vlc [ j ] , & dst [ j ] ) ;
 dst += pic -> linesize [ 0 ] ;
 }
 for ( i = 0 ;
 i < 3 ;
 i ++ ) ff_free_vlc ( & vlc [ i ] ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_DataModeApplication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 523 ""../../asn1/h245/h245.cnf"" gint32 value ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_DataModeApplication , DataModeApplication_choice , & value ) ;
 codec_type = val_to_str ( value , h245_DataModeApplication_vals , ""<unknown>"" ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"void * checked_xmalloc ( size_t size ) {
 alloc_limit_assert ( ""checked_xmalloc"" , size ) ;
 return xmalloc ( size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int arm_cpu_caps ( void ) {
 int flags ;
 int mask ;
 if ( ! arm_cpu_env_flags ( & flags ) ) {
 return flags ;
 }
 mask = arm_cpu_env_mask ( ) ;
 # if HAVE_EDSP flags |= HAS_EDSP ;
 # endif # if HAVE_MEDIA flags |= HAS_MEDIA ;
 # endif # if HAVE_NEON flags |= HAS_NEON ;
 # endif return flags & mask ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pk_transaction_dispose ( GObject * object ) {
 PkTransaction * transaction ;
 g_return_if_fail ( PK_IS_TRANSACTION ( object ) ) ;
 transaction = PK_TRANSACTION ( object ) ;
 if ( transaction -> priv -> waiting_for_auth ) {
 g_cancellable_cancel ( transaction -> priv -> cancellable ) ;
 pk_transaction_error_code_emit ( transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , ""client did not authorize action"" ) ;
 pk_transaction_finished_emit ( transaction , PK_EXIT_ENUM_FAILED , 0 ) ;
 }
 if ( transaction -> priv -> registration_id > 0 ) {
 g_dbus_connection_unregister_object ( transaction -> priv -> connection , transaction -> priv -> registration_id ) ;
 transaction -> priv -> registration_id = 0 ;
 }
 if ( transaction -> priv -> connection != NULL ) {
 g_debug ( ""emitting destroy %s"" , transaction -> priv -> tid ) ;
 g_dbus_connection_emit_signal ( transaction -> priv -> connection , NULL , transaction -> priv -> tid , PK_DBUS_INTERFACE_TRANSACTION , ""Destroy"" , NULL , NULL ) ;
 }
 G_OBJECT_CLASS ( pk_transaction_parent_class ) -> dispose ( object ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void imc_decode_level_coefficients ( IMCContext * q , int * levlCoeffBuf , float * flcoeffs1 , float * flcoeffs2 ) {
 int i , level ;
 float tmp , tmp2 ;
 flcoeffs1 [ 0 ] = 20000.0 / pow ( 2 , levlCoeffBuf [ 0 ] * 0.18945 ) ;
 flcoeffs2 [ 0 ] = log2f ( flcoeffs1 [ 0 ] ) ;
 tmp = flcoeffs1 [ 0 ] ;
 tmp2 = flcoeffs2 [ 0 ] ;
 for ( i = 1 ;
 i < BANDS ;
 i ++ ) {
 level = levlCoeffBuf [ i ] ;
 if ( level == 16 ) {
 flcoeffs1 [ i ] = 1.0 ;
 flcoeffs2 [ i ] = 0.0 ;
 }
 else {
 if ( level < 17 ) level -= 7 ;
 else if ( level <= 24 ) level -= 32 ;
 else level -= 16 ;
 tmp *= imc_exp_tab [ 15 + level ] ;
 tmp2 += 0.83048 * level ;
 flcoeffs1 [ i ] = tmp ;
 flcoeffs2 [ i ] = tmp2 ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_TerminalCapabilitySetRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_TerminalCapabilitySetRelease , TerminalCapabilitySetRelease_sequence ) ;
 # line 596 ""../../asn1/h245/h245.cnf"" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_TermCapSetRls ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_EndpointIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_BMPString ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line16_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t v , r , g , b ;
 w = width ;
 do {
 v = lduw_le_p ( ( void * ) s ) ;
 r = ( v >> 8 ) & 0xf8 ;
 g = ( v >> 3 ) & 0xfc ;
 b = ( v << 3 ) & 0xf8 ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 2 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void xhci_kick_ep ( XHCIState * xhci , unsigned int slotid , unsigned int epid , unsigned int streamid ) {
 XHCIEPContext * epctx ;
 assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;
 assert ( epid >= 1 && epid <= 31 ) ;
 if ( ! xhci -> slots [ slotid - 1 ] . enabled ) {
 DPRINTF ( ""xhci: xhci_kick_ep for disabled slot %d\n"" , slotid ) ;
 return ;
 }
 epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ] ;
 if ( ! epctx ) {
 DPRINTF ( ""xhci: xhci_kick_ep for disabled endpoint %d,%d\n"" , epid , slotid ) ;
 return ;
 }
 xhci_kick_epctx ( epctx , streamid ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"proto_item * parseUInt16 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {
 proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 2 , ENC_LITTLE_ENDIAN ) ;
 * pOffset += 2 ;
 return item ;
 }",0
Detect whether the following code contains vulnerabilities.,"void ff_init_qscale_tab ( MpegEncContext * s ) {
 int8_t * const qscale_table = s -> current_picture . f . qscale_table ;
 int i ;
 for ( i = 0 ;
 i < s -> mb_num ;
 i ++ ) {
 unsigned int lam = s -> lambda_table [ s -> mb_index2xy [ i ] ] ;
 int qp = ( lam * 139 + FF_LAMBDA_SCALE * 64 ) >> ( FF_LAMBDA_SHIFT + 7 ) ;
 qscale_table [ s -> mb_index2xy [ i ] ] = av_clip ( qp , s -> avctx -> qmin , s -> avctx -> qmax ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , ReadAllAdvanceFirst_NeverDefer ) {
 multibuffer_ . SetMaxWriters ( 1 ) ;
 size_t pos = 0 ;
 size_t end = 10000 ;
 multibuffer_ . SetFileSize ( 10000 ) ;
 multibuffer_ . SetMaxBlocksAfterDefer ( - 10000 ) ;
 multibuffer_ . SetRangeSupported ( true ) ;
 media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;
 reader . SetMaxBuffer ( 2000 , 5000 ) ;
 reader . SetPreload ( 1000 , 1000 ) ;
 while ( pos < end ) {
 unsigned char buffer [ 27 ] ;
 buffer [ 17 ] = 17 ;
 size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;
 while ( AdvanceAll ( ) ) ;
 int64_t bytes = reader . TryRead ( buffer , to_read ) ;
 EXPECT_GT ( bytes , 0 ) ;
 EXPECT_EQ ( buffer [ 17 ] , 17 ) ;
 for ( int64_t i = 0 ;
 i < bytes ;
 i ++ ) {
 uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;
 EXPECT_EQ ( expected , buffer [ i ] ) << "" pos = "" << pos ;
 pos ++ ;
 }
 }
 EXPECT_GT ( multibuffer_ . writers_created ( ) , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void gen_vector_table24 ( TrueMotion1Context * s , const uint8_t * sel_vector_table ) {
 int len , i , j ;
 unsigned char delta_pair ;
 for ( i = 0 ;
 i < 1024 ;
 i += 4 ) {
 len = * sel_vector_table ++ / 2 ;
 for ( j = 0 ;
 j < len ;
 j ++ ) {
 delta_pair = * sel_vector_table ++ ;
 s -> y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> ydt ) ;
 s -> c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> cdt ) ;
 s -> fat_y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_ydt ) ;
 s -> fat_c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_cdt ) ;
 }
 s -> y_predictor_table [ i + ( j - 1 ) ] |= 1 ;
 s -> c_predictor_table [ i + ( j - 1 ) ] |= 1 ;
 s -> fat_y_predictor_table [ i + ( j - 1 ) ] |= 1 ;
 s -> fat_c_predictor_table [ i + ( j - 1 ) ] |= 1 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int padr_match ( PCNetState * s , const uint8_t * buf , int size ) {
 struct qemu_ether_header * hdr = ( void * ) buf ;
 uint8_t padr [ 6 ] = {
 s -> csr [ 12 ] & 0xff , s -> csr [ 12 ] >> 8 , s -> csr [ 13 ] & 0xff , s -> csr [ 13 ] >> 8 , s -> csr [ 14 ] & 0xff , s -> csr [ 14 ] >> 8 }
 ;
 int result = ( ! CSR_DRCVPA ( s ) ) && ! memcmp ( hdr -> ether_dhost , padr , 6 ) ;
 # ifdef PCNET_DEBUG_MATCH printf ( ""packet dhost=%02x:%02x:%02x:%02x:%02x:%02x, "" ""padr=%02x:%02x:%02x:%02x:%02x:%02x\n"" , hdr -> ether_dhost [ 0 ] , hdr -> ether_dhost [ 1 ] , hdr -> ether_dhost [ 2 ] , hdr -> ether_dhost [ 3 ] , hdr -> ether_dhost [ 4 ] , hdr -> ether_dhost [ 5 ] , padr [ 0 ] , padr [ 1 ] , padr [ 2 ] , padr [ 3 ] , padr [ 4 ] , padr [ 5 ] ) ;
 printf ( ""padr_match result=%d\n"" , result ) ;
 # endif return result ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( eob > 1 ) vp9_iwht4x4_16_add ( input , dest , stride ) ;
 else vp9_iwht4x4_1_add ( input , dest , stride ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ilbc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 ILBCDecContext * s = avctx -> priv_data ;
 AVFrame * frame = data ;
 int ret ;
 if ( s -> decoder . no_of_bytes > buf_size ) {
 av_log ( avctx , AV_LOG_ERROR , ""iLBC frame too short (%u, should be %u)\n"" , buf_size , s -> decoder . no_of_bytes ) ;
 return AVERROR_INVALIDDATA ;
 }
 frame -> nb_samples = s -> decoder . blockl ;
 if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 WebRtcIlbcfix_DecodeImpl ( ( WebRtc_Word16 * ) frame -> data [ 0 ] , ( const WebRtc_UWord16 * ) buf , & s -> decoder , 1 ) ;
 * got_frame_ptr = 1 ;
 return s -> decoder . no_of_bytes ;
 }",1
Detect whether the following code contains vulnerabilities.,"static double get_prediction_decay_rate ( const VP9_COMMON * cm , const FIRSTPASS_STATS * next_frame ) {
 const double mb_sr_err_diff = ( next_frame -> sr_coded_error - next_frame -> coded_error ) / cm -> MBs ;
 const double second_ref_decay = mb_sr_err_diff <= 512.0 ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) : 0.85 ;
 return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void virtio_net_save ( QEMUFile * f , void * opaque ) {
 VirtIONet * n = opaque ;
 assert ( ! n -> vhost_started ) ;
 virtio_save ( & n -> vdev , f ) ;
 qemu_put_buffer ( f , n -> mac , ETH_ALEN ) ;
 qemu_put_be32 ( f , n -> tx_waiting ) ;
 qemu_put_be32 ( f , n -> mergeable_rx_bufs ) ;
 qemu_put_be16 ( f , n -> status ) ;
 qemu_put_byte ( f , n -> promisc ) ;
 qemu_put_byte ( f , n -> allmulti ) ;
 qemu_put_be32 ( f , n -> mac_table . in_use ) ;
 qemu_put_buffer ( f , n -> mac_table . macs , n -> mac_table . in_use * ETH_ALEN ) ;
 qemu_put_buffer ( f , ( uint8_t * ) n -> vlans , MAX_VLAN >> 3 ) ;
 qemu_put_be32 ( f , n -> has_vnet_hdr ) ;
 qemu_put_byte ( f , n -> mac_table . multi_overflow ) ;
 qemu_put_byte ( f , n -> mac_table . uni_overflow ) ;
 qemu_put_byte ( f , n -> alluni ) ;
 qemu_put_byte ( f , n -> nomulti ) ;
 qemu_put_byte ( f , n -> nouni ) ;
 qemu_put_byte ( f , n -> nobcast ) ;
 qemu_put_byte ( f , n -> has_ufo ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int zcliprestore ( i_ctx_t * i_ctx_p ) {
 return gs_cliprestore ( igs ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {
 directory_config * dcfg = ( directory_config * ) _dcfg ;
 if ( dcfg == NULL ) return NULL ;
 if ( strcasecmp ( p1 , ""on"" ) == 0 ) {
 dcfg -> hash_is_enabled = HASH_ENABLED ;
 dcfg -> hash_enforcement = HASH_ENABLED ;
 }
 else if ( strcasecmp ( p1 , ""off"" ) == 0 ) {
 dcfg -> hash_is_enabled = HASH_DISABLED ;
 dcfg -> hash_enforcement = HASH_DISABLED ;
 }
 else return apr_psprintf ( cmd -> pool , ""ModSecurity: Invalid value for SecRuleEngine: %s"" , p1 ) ;
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * read_into_buffer ( FILE * fp , size_t * r_length ) {
 char * buffer ;
 size_t buflen ;
 size_t nread , bufsize = 0 ;
 * r_length = 0 ;
 # define NCHUNK 8192 # ifdef HAVE_W32_SYSTEM setmode ( fileno ( fp ) , O_BINARY ) ;
 # endif buffer = NULL ;
 buflen = 0 ;
 do {
 bufsize += NCHUNK ;
 buffer = realloc ( buffer , bufsize ) ;
 if ( ! buffer ) {
 perror ( ""realloc failed"" ) ;
 exit ( 1 ) ;
 }
 nread = fread ( buffer + buflen , 1 , NCHUNK , fp ) ;
 if ( nread < NCHUNK && ferror ( fp ) ) {
 perror ( ""fread failed"" ) ;
 exit ( 1 ) ;
 }
 buflen += nread ;
 }
 while ( nread == NCHUNK ) ;
 # undef NCHUNK * r_length = buflen ;
 return buffer ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestSilentlyRegisterHandler ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/1/%s"" ) ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/2/%s"" ) ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""ignore"" , GURL ( ""http://test/%s"" ) ) ;
 ProtocolHandler ph4 = CreateProtocolHandler ( ""ignore"" , GURL ( ""http://test/%s"" ) ) ;
 ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph1 ) ) ;
 ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;
 ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph2 ) ) ;
 ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;
 ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph2 ) ) ;
 ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph3 ) ) ;
 ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;
 registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph3 ) ;
 ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;
 ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph3 ) ) ;
 ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph4 ) ) ;
 ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph4 ) ) ;
 ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph4 ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void proto_reg_handoff_zbee_zcl_on_off ( void ) {
 dissector_handle_t on_off_handle ;
 on_off_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_ONOFF ) ;
 dissector_add_uint ( ""zbee.zcl.cluster"" , ZBEE_ZCL_CID_ON_OFF , on_off_handle ) ;
 zbee_zcl_init_cluster ( proto_zbee_zcl_on_off , ett_zbee_zcl_on_off , ZBEE_ZCL_CID_ON_OFF , hf_zbee_zcl_on_off_attr_id , hf_zbee_zcl_on_off_srv_rx_cmd_id , - 1 , ( zbee_zcl_fn_attr_data ) dissect_zcl_on_off_attr_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void RecordsConfigIterate ( RecordElementCallback callback , void * data ) {
 for ( unsigned i = 0 ;
 i < countof ( RecordsConfig ) ;
 ++ i ) {
 callback ( & RecordsConfig [ i ] , data ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestClose ) {
 ShowDialog ( ) ;
 EXPECT_TRUE ( dialog_ -> Close ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_FALSE ( accept_ ) ;
 EXPECT_TRUE ( cancel_ ) ;
 EXPECT_FALSE ( dont_block_ ) ;
 histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * _UTF16BEGetName ( const UConverter * cnv ) {
 if ( UCNV_GET_VERSION ( cnv ) == 0 ) {
 return ""UTF-16BE"" ;
 }
 else {
 return ""UTF-16BE,version=1"" ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void luaD_reallocstack ( lua_State * L , int newsize ) {
 TValue * oldstack = L -> stack ;
 int realsize = newsize + 1 + EXTRA_STACK ;
 lua_assert ( L -> stack_last - L -> stack == L -> stacksize - EXTRA_STACK - 1 ) ;
 luaM_reallocvector ( L , L -> stack , L -> stacksize , realsize , TValue ) ;
 L -> stacksize = realsize ;
 L -> stack_last = L -> stack + newsize ;
 correctstack ( L , oldstack ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fht4x4_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {
 if ( tx_type == DCT_DCT ) {
 vp9_fdct4x4_c ( input , output , stride ) ;
 }
 else {
 tran_low_t out [ 4 * 4 ] ;
 tran_low_t * outptr = & out [ 0 ] ;
 int i , j ;
 tran_low_t temp_in [ 4 ] , temp_out [ 4 ] ;
 const transform_2d ht = FHT_4 [ tx_type ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;
 if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;
 }
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = out [ j + i * 4 ] ;
 ht . rows ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int _warc_cleanup ( struct archive_read * a ) {
 struct warc_s * w = a -> format -> data ;
 if ( w -> pool . len > 0U ) {
 free ( w -> pool . str ) ;
 }
 archive_string_free ( & w -> sver ) ;
 free ( w ) ;
 a -> format -> data = NULL ;
 return ( ARCHIVE_OK ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void proto_tree_set_uint ( field_info * fi , guint32 value ) {
 header_field_info * hfinfo ;
 guint32 integer ;
 hfinfo = fi -> hfinfo ;
 integer = value ;
 if ( hfinfo -> bitmask ) {
 integer &= ( guint32 ) ( hfinfo -> bitmask ) ;
 integer >>= hfinfo_bitshift ( hfinfo ) ;
 }
 fvalue_set_uinteger ( & fi -> value , integer ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int test_in_memory ( xd3_stream * stream , int ignore ) {
 uint8_t ibuf [ sizeof ( test_text ) ] ;
 uint8_t dbuf [ sizeof ( test_text ) ] ;
 uint8_t obuf [ sizeof ( test_text ) ] ;
 usize_t size = sizeof ( test_text ) ;
 usize_t dsize , osize ;
 int r1 , r2 ;
 int eflags = SECONDARY_DJW ? XD3_SEC_DJW : 0 ;
 memcpy ( ibuf , test_text , size ) ;
 memset ( ibuf + 128 , 0 , 16 ) ;
 r1 = xd3_encode_memory ( ibuf , size , test_text , size , dbuf , & dsize , size , eflags ) ;
 r2 = xd3_decode_memory ( dbuf , dsize , test_text , size , obuf , & osize , size , 0 ) ;
 if ( r1 != 0 || r2 != 0 || dsize >= ( size / 2 ) || dsize < 1 || osize != size ) {
 stream -> msg = ""encode/decode size error"" ;
 return XD3_INTERNAL ;
 }
 if ( memcmp ( obuf , ibuf , size ) != 0 ) {
 stream -> msg = ""encode/decode data error"" ;
 return XD3_INTERNAL ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int qsort_comparison_function_int16 ( const void * a , const void * b ) {
 return * ( const int16_t * ) a - * ( const int16_t * ) b ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint64_t vmport_ioport_read ( void * opaque , hwaddr addr , unsigned size ) {
 VMPortState * s = opaque ;
 CPUX86State * env = cpu_single_env ;
 unsigned char command ;
 uint32_t eax ;
 cpu_synchronize_state ( CPU ( x86_env_get_cpu ( env ) ) ) ;
 eax = env -> regs [ R_EAX ] ;
 if ( eax != VMPORT_MAGIC ) return eax ;
 command = env -> regs [ R_ECX ] ;
 if ( command >= VMPORT_ENTRIES ) return eax ;
 if ( ! s -> func [ command ] ) {
 # ifdef VMPORT_DEBUG fprintf ( stderr , ""vmport: unknown command %x\n"" , command ) ;
 # endif return eax ;
 }
 return s -> func [ command ] ( s -> opaque [ command ] , addr ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void new_files_cancel ( NautilusDirectory * directory ) {
 GList * l ;
 NewFilesState * state ;
 if ( directory -> details -> new_files_in_progress != NULL ) {
 for ( l = directory -> details -> new_files_in_progress ;
 l != NULL ;
 l = l -> next ) {
 state = l -> data ;
 g_cancellable_cancel ( state -> cancellable ) ;
 state -> directory = NULL ;
 }
 g_list_free ( directory -> details -> new_files_in_progress ) ;
 directory -> details -> new_files_in_progress = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void gtkui_inject_user ( int side ) {
 size_t len ;
 len = strescape ( injectbuf , injectbuf ) ;
 if ( side == 1 || side == 2 ) {
 user_inject ( injectbuf , len , curr_conn , side ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"zend_object_iterator * spl_filesystem_tree_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {
 spl_filesystem_iterator * iterator ;
 spl_filesystem_object * dir_object ;
 if ( by_ref ) {
 zend_error ( E_ERROR , ""An iterator cannot be used with foreach by reference"" ) ;
 }
 dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;
 iterator = spl_filesystem_object_to_iterator ( dir_object ) ;
 if ( iterator -> intern . data == NULL ) {
 iterator -> intern . data = object ;
 iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ;
 }
 zval_add_ref ( & object ) ;
 return ( zend_object_iterator * ) iterator ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void spl_filesystem_tree_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {
 spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;
 spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;
 object -> u . dir . index = 0 ;
 if ( object -> u . dir . dirp ) {
 php_stream_rewinddir ( object -> u . dir . dirp ) ;
 }
 do {
 spl_filesystem_dir_read ( object TSRMLS_CC ) ;
 }
 while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;
 if ( iterator -> current ) {
 zval_ptr_dtor ( & iterator -> current ) ;
 iterator -> current = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_RowsBuffer ( tvbuff_t * tvb , int offset , guint32 num_rows , struct CPMSetBindingsIn * bindingsin , struct rows_data * rowsin , gboolean is64bit , proto_tree * parent_tree , const char * fmt , ... ) {
 proto_tree * tree ;
 proto_item * item ;
 guint32 num ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_GetRowsRow , & item , txt ) ;
 for ( num = 0 ;
 num < num_rows ;
 ++ num ) {
 guint32 col ;
 proto_tree * row_tree ;
 row_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 0 , ett_GetRowsRow , NULL , ""Row[%d]"" , num ) ;
 for ( col = 0 ;
 col < bindingsin -> ccolumns ;
 col ++ ) {
 parse_RowsBufferCol ( tvb , offset , num , col , bindingsin , rowsin , is64bit , row_tree , ""Col[%d]"" , col ) ;
 }
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void residual_interp ( int16_t * buf , int16_t * out , int lag , int gain , int * rseed ) {
 int i ;
 if ( lag ) {
 int16_t * vector_ptr = buf + PITCH_MAX ;
 for ( i = 0 ;
 i < lag ;
 i ++ ) out [ i ] = vector_ptr [ i - lag ] * 3 >> 2 ;
 av_memcpy_backptr ( ( uint8_t * ) ( out + lag ) , lag * sizeof ( * out ) , ( FRAME_LEN - lag ) * sizeof ( * out ) ) ;
 }
 else {
 for ( i = 0 ;
 i < FRAME_LEN ;
 i ++ ) {
 * rseed = * rseed * 521 + 259 ;
 out [ i ] = gain * * rseed >> 15 ;
 }
 memset ( buf , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * buf ) ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void _cmd_window_show_opt ( const char * data , int right ) {
 MAIN_WINDOW_REC * parent ;
 WINDOW_REC * window ;
 if ( * data == '\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;
 if ( is_numeric ( data , '\0' ) ) {
 window = window_find_refnum ( atoi ( data ) ) ;
 if ( window == NULL ) {
 printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_REFNUM_NOT_FOUND , data ) ;
 }
 }
 else {
 window = window_find_item ( active_win -> active_server , data ) ;
 }
 if ( window == NULL || is_window_visible ( window ) ) return ;
 if ( WINDOW_GUI ( window ) -> sticky ) {
 if ( ! settings_get_bool ( ""autounstick_windows"" ) ) {
 printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_CANT_SHOW_STICKY_WINDOWS ) ;
 return ;
 }
 }
 parent = mainwindow_create ( right ) ;
 parent -> active = window ;
 gui_window_reparent ( window , parent ) ;
 if ( settings_get_bool ( ""autostick_split_windows"" ) ) gui_window_set_sticky ( window ) ;
 active_mainwin = NULL ;
 window_set_active ( window ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , DocumentWriteBlock ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/document_write_script_block.html"" ) ) ;
 waiter -> Wait ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockParseStartToFirstContentfulPaint , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockCount , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Setup_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 466 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 contains_faststart = FALSE ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Setup_UUIE , Setup_UUIE_sequence ) ;
 # line 471 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_SETUP ;
 if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , ""%s OLC (%s)"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) , h225_pi -> frame_label ) ;
 else g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {
 struct bitmap * base = data ;
 int bitmap_pos ;
 bitmap_pos = bitmap_position ( object -> oid . hash ) ;
 if ( bitmap_pos < 0 ) {
 char * name = path_name ( path , last ) ;
 bitmap_pos = ext_index_add_object ( object , name ) ;
 free ( name ) ;
 }
 bitmap_set ( base , bitmap_pos ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int BIO_printf ( BIO * bio , const char * format , ... ) {
 va_list args ;
 int ret ;
 va_start ( args , format ) ;
 ret = BIO_vprintf ( bio , format , args ) ;
 va_end ( args ) ;
 return ( ret ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void virLogResetOutputs ( void ) {
 virLogOutputListFree ( virLogOutputs , virLogNbOutputs ) ;
 virLogOutputs = NULL ;
 virLogNbOutputs = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInChildFrame ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 GURL a_url ( embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/iframe.html"" ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;
 waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;
 waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;
 waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;
 waiter -> Wait ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_P ( GLES2DecoderTestWithCHROMIUMPathRendering , MatrixLoadfCHROMIUMImmediateValidArgs ) {
 cmds : : MatrixLoadfCHROMIUMImmediate & cmd = * GetImmediateAs < cmds : : MatrixLoadfCHROMIUMImmediate > ( ) ;
 SpecializedSetup < cmds : : MatrixLoadfCHROMIUMImmediate , 0 > ( true ) ;
 GLfloat temp [ 16 ] = {
 0 , }
 ;
 cmd . Init ( GL_PATH_PROJECTION_CHROMIUM , & temp [ 0 ] ) ;
 EXPECT_CALL ( * gl_ , MatrixLoadfEXT ( GL_PATH_PROJECTION_CHROMIUM , PointsToArray ( temp , 16 ) ) ) ;
 EXPECT_EQ ( error : : kNoError , ExecuteImmediateCmd ( cmd , sizeof ( temp ) ) ) ;
 EXPECT_EQ ( GL_NO_ERROR , GetGLError ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MultilinkResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_MultilinkResponse , MultilinkResponse_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_CallProceeding_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 483 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CallProceeding_UUIE , CallProceeding_UUIE_sequence ) ;
 # line 487 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_CALL_PROCEDING ;
 if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , ""%s OLC (%s)"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) , h225_pi -> frame_label ) ;
 else g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void doapr_outch ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , int c ) {
 assert ( * sbuffer != NULL || buffer != NULL ) ;
 assert ( * currlen <= * maxlen ) ;
 if ( buffer && * currlen == * maxlen ) {
 * maxlen += 1024 ;
 if ( * buffer == NULL ) {
 * buffer = OPENSSL_malloc ( * maxlen ) ;
 if ( ! * buffer ) {
 return ;
 }
 if ( * currlen > 0 ) {
 assert ( * sbuffer != NULL ) ;
 memcpy ( * buffer , * sbuffer , * currlen ) ;
 }
 * sbuffer = NULL ;
 }
 else {
 * buffer = OPENSSL_realloc ( * buffer , * maxlen ) ;
 if ( ! * buffer ) {
 return ;
 }
 }
 }
 if ( * currlen < * maxlen ) {
 if ( * sbuffer ) ( * sbuffer ) [ ( * currlen ) ++ ] = ( char ) c ;
 else ( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ;
 }
 return ;
 }",1
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 struct event signal_int ;
 event_init ( ) ;
 event_set ( & signal_int , SIGINT , EV_SIGNAL | EV_PERSIST , signal_cb , & signal_int ) ;
 event_add ( & signal_int , NULL ) ;
 event_dispatch ( ) ;
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp8cx_frame_init_quantizer ( VP8_COMP * cpi ) {
 cpi -> mb . zbin_mode_boost = 0 ;
 vp8cx_mb_init_quantizer ( cpi , & cpi -> mb , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cirrus_vga_register_types ( void ) {
 type_register_static ( & isa_cirrus_vga_info ) ;
 type_register_static ( & cirrus_vga_info ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalCoerceViaIO ( CoerceViaIOState * iostate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 Datum result ;
 Datum inputval ;
 char * string ;
 inputval = ExecEvalExpr ( iostate -> arg , econtext , isNull , isDone ) ;
 if ( isDone && * isDone == ExprEndResult ) return inputval ;
 if ( * isNull ) string = NULL ;
 else string = OutputFunctionCall ( & iostate -> outfunc , inputval ) ;
 result = InputFunctionCall ( & iostate -> infunc , string , iostate -> intypioparam , - 1 ) ;
 return result ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_x509name_eql ( VALUE self , VALUE other ) {
 if ( ! rb_obj_is_kind_of ( other , cX509Name ) ) return Qfalse ;
 return ossl_x509name_cmp0 ( self , other ) == 0 ? Qtrue : Qfalse ;
 }",0
Detect whether the following code contains vulnerabilities.,"void simplestring_addn ( simplestring * target , const char * source , int add_len ) {
 if ( target && source ) {
 if ( ! target -> str ) {
 simplestring_init_str ( target ) ;
 }
 if ( target -> len + add_len + 1 > target -> size ) {
 int newsize = target -> len + add_len + 1 ;
 int incr = target -> size * 2 ;
 newsize = newsize - ( newsize % incr ) + incr ;
 target -> str = ( char * ) realloc ( target -> str , newsize ) ;
 target -> size = target -> str ? newsize : 0 ;
 }
 if ( target -> str ) {
 if ( add_len ) {
 memcpy ( target -> str + target -> len , source , add_len ) ;
 }
 target -> len += add_len ;
 target -> str [ target -> len ] = 0 ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void cdxl_decode_rgb ( CDXLVideoContext * c ) {
 uint32_t * new_palette = ( uint32_t * ) c -> frame . data [ 1 ] ;
 import_palette ( c , new_palette ) ;
 import_format ( c , c -> frame . linesize [ 0 ] , c -> frame . data [ 0 ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static xmlLinkPtr xmlListLinkReverseSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 lk = xmlListHigherSearch ( l , data ) ;
 if ( lk == l -> sentinel ) return NULL ;
 else {
 if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;
 return NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , current ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( ! intern -> u . file . current_line && ! intern -> u . file . current_zval ) {
 spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) ;
 }
 if ( intern -> u . file . current_line && ( ! SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) || ! intern -> u . file . current_zval ) ) {
 RETURN_STRINGL ( intern -> u . file . current_line , intern -> u . file . current_line_len , 1 ) ;
 }
 else if ( intern -> u . file . current_zval ) {
 RETURN_ZVAL ( intern -> u . file . current_zval , 1 , 0 ) ;
 }
 RETURN_FALSE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cdxl_decode_ham6 ( CDXLVideoContext * c ) {
 AVCodecContext * avctx = c -> avctx ;
 uint32_t new_palette [ 16 ] , r , g , b ;
 uint8_t * ptr , * out , index , op ;
 int x , y ;
 ptr = c -> new_video ;
 out = c -> frame . data [ 0 ] ;
 import_palette ( c , new_palette ) ;
 import_format ( c , avctx -> width , c -> new_video ) ;
 for ( y = 0 ;
 y < avctx -> height ;
 y ++ ) {
 r = new_palette [ 0 ] & 0xFF0000 ;
 g = new_palette [ 0 ] & 0xFF00 ;
 b = new_palette [ 0 ] & 0xFF ;
 for ( x = 0 ;
 x < avctx -> width ;
 x ++ ) {
 index = * ptr ++ ;
 op = index >> 4 ;
 index &= 15 ;
 switch ( op ) {
 case 0 : r = new_palette [ index ] & 0xFF0000 ;
 g = new_palette [ index ] & 0xFF00 ;
 b = new_palette [ index ] & 0xFF ;
 break ;
 case 1 : b = index * 0x11 ;
 break ;
 case 2 : r = index * 0x11 << 16 ;
 break ;
 case 3 : g = index * 0x11 << 8 ;
 break ;
 }
 AV_WL24 ( out + x * 3 , r | g | b ) ;
 }
 out += c -> frame . linesize [ 0 ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_H322Caps ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H322Caps , H322Caps_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s ) {
 int x , y ;
 unsigned char P [ 2 ] ;
 unsigned int flags ;
 P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 if ( P [ 0 ] <= P [ 1 ] ) {
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;
 for ( ;
 flags != 1 ;
 flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;
 s -> pixel_ptr += s -> line_inc ;
 }
 }
 else {
 flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y += 2 ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 , flags >>= 1 ) {
 s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;
 }
 s -> pixel_ptr += s -> stride * 2 ;
 }
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void * xcalloc ( size_t num , size_t size ) {
 void * ptr = malloc ( num * size ) ;
 if ( ptr ) {
 memset ( ptr , '\0' , ( num * size ) ) ;
 }
 return ptr ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , getFileInfo ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 zend_class_entry * ce = intern -> info_class ;
 zend_error_handling error_handling ;
 zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|C"" , & ce ) == SUCCESS ) {
 spl_filesystem_object_create_type ( ht , intern , SPL_FS_INFO , ce , return_value TSRMLS_CC ) ;
 }
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void collect_features_myanmar ( hb_ot_shape_planner_t * plan ) {
 hb_ot_map_builder_t * map = & plan -> map ;
 map -> add_gsub_pause ( setup_syllables ) ;
 map -> add_global_bool_feature ( HB_TAG ( 'l' , 'o' , 'c' , 'l' ) ) ;
 map -> add_global_bool_feature ( HB_TAG ( 'c' , 'c' , 'm' , 'p' ) ) ;
 map -> add_gsub_pause ( initial_reordering ) ;
 for ( unsigned int i = 0 ;
 i < ARRAY_LENGTH ( basic_features ) ;
 i ++ ) {
 map -> add_feature ( basic_features [ i ] , 1 , F_GLOBAL | F_MANUAL_ZWJ ) ;
 map -> add_gsub_pause ( NULL ) ;
 }
 map -> add_gsub_pause ( final_reordering ) ;
 for ( unsigned int i = 0 ;
 i < ARRAY_LENGTH ( other_features ) ;
 i ++ ) map -> add_feature ( other_features [ i ] , 1 , F_GLOBAL | F_MANUAL_ZWJ ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_get_preview_raw_frame ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp9_ppflags_t * flags ) {
 VP9_COMMON * cm = & cpi -> common ;
 # if ! CONFIG_VP9_POSTPROC ( void ) flags ;
 # endif if ( ! cm -> show_frame ) {
 return - 1 ;
 }
 else {
 int ret ;
 # if CONFIG_VP9_POSTPROC ret = vp9_post_proc_frame ( cm , dest , flags ) ;
 # else if ( cm -> frame_to_show ) {
 * dest = * cm -> frame_to_show ;
 dest -> y_width = cm -> width ;
 dest -> y_height = cm -> height ;
 dest -> uv_width = cm -> width >> cm -> subsampling_x ;
 dest -> uv_height = cm -> height >> cm -> subsampling_y ;
 ret = 0 ;
 }
 else {
 ret = - 1 ;
 }
 # endif vp9_clear_system_state ( ) ;
 return ret ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int SpoolssEnumJobs_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {
 dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;
 guint32 level ;
 offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_enumjobs_firstjob , NULL ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_enumjobs_numjobs , NULL ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;
 if ( ! pinfo -> fd -> flags . visited ) {
 dcv -> se_data = GUINT_TO_POINTER ( ( int ) level ) ;
 }
 col_append_fstr ( pinfo -> cinfo , COL_INFO , "", level %d"" , level ) ;
 offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int X509_REQ_get_attr_by_OBJ ( const X509_REQ * req , ASN1_OBJECT * obj , int lastpos ) {
 return X509at_get_attr_by_OBJ ( req -> req_info -> attributes , obj , lastpos ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 16 * 16 ] ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 16 ] , temp_out [ 16 ] ;
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 idct16 ( input , outptr ) ;
 input += 16 ;
 outptr += 16 ;
 }
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;
 idct16 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static PHP_NAMED_FUNCTION ( zif_zip_entry_name ) {
 php_zip_entry_get_info ( INTERNAL_FUNCTION_PARAM_PASSTHRU , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void aacsbr_func_ptr_init ( AACSBRContext * c ) {
 c -> sbr_lf_gen = sbr_lf_gen ;
 c -> sbr_hf_assemble = sbr_hf_assemble ;
 c -> sbr_x_gen = sbr_x_gen ;
 c -> sbr_hf_inverse_filter = sbr_hf_inverse_filter ;
 if ( ARCH_MIPS ) ff_aacsbr_func_ptr_init_mips ( c ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultBlock ) {
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""afp"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : BLOCK , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _ISCIIGetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 int32_t idx , script ;
 uint8_t mask ;
 sa -> addRange ( sa -> set , 0 , ASCII_END ) ;
 for ( script = DEVANAGARI ;
 script <= MALAYALAM ;
 script ++ ) {
 mask = ( uint8_t ) ( lookupInitialData [ script ] . maskEnum ) ;
 for ( idx = 0 ;
 idx < DELTA ;
 idx ++ ) {
 if ( ( validityTable [ idx ] & mask ) || ( script == TELUGU && idx == 0x31 ) ) {
 sa -> add ( sa -> set , idx + ( script * DELTA ) + INDIC_BLOCK_BEGIN ) ;
 }
 }
 }
 sa -> add ( sa -> set , DANDA ) ;
 sa -> add ( sa -> set , DOUBLE_DANDA ) ;
 sa -> add ( sa -> set , ZWNJ ) ;
 sa -> add ( sa -> set , ZWJ ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {
 PGconn * conn ;
 PGresult * result ;
 int i ;
 conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;
 result = executeQuery ( conn , ""SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;
"" , progname , echo ) ;
 PQfinish ( conn ) ;
 for ( i = 0 ;
 i < PQntuples ( result ) ;
 i ++ ) {
 char * dbname = PQgetvalue ( result , i , 0 ) ;
 if ( ! quiet ) {
 printf ( _ ( ""%s: reindexing database \""%s\""\n"" ) , progname , dbname ) ;
 fflush ( stdout ) ;
 }
 reindex_one_database ( dbname , dbname , ""DATABASE"" , host , port , username , prompt_password , progname , echo , verbose ) ;
 }
 PQclear ( result ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( NativeBackendLibsecretTest , SomeKeyringAttributesAreMissing ) {
 NativeBackendLibsecret backend ( 42 ) ;
 VerifiedAdd ( & backend , form_google_ ) ;
 EXPECT_EQ ( 1u , global_mock_libsecret_items -> size ( ) ) ;
 ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( ""avatar_url"" ) ;
 ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( ""ssl_valid"" ) ;
 ScopedVector < autofill : : PasswordForm > form_list ;
 EXPECT_TRUE ( backend . GetAutofillableLogins ( & form_list ) ) ;
 EXPECT_EQ ( 1u , form_list . size ( ) ) ;
 EXPECT_EQ ( GURL ( """" ) , form_list [ 0 ] -> icon_url ) ;
 EXPECT_FALSE ( form_list [ 0 ] -> ssl_valid ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , setInfoClass ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 zend_class_entry * ce = spl_ce_SplFileInfo ;
 zend_error_handling error_handling ;
 zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|C"" , & ce ) == SUCCESS ) {
 intern -> info_class = ce ;
 }
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void update_reference_segmentation_map ( VP9_COMP * cpi ) {
 VP9_COMMON * const cm = & cpi -> common ;
 MODE_INFO * * mi_8x8_ptr = cm -> mi_grid_visible ;
 uint8_t * cache_ptr = cm -> last_frame_seg_map ;
 int row , col ;
 for ( row = 0 ;
 row < cm -> mi_rows ;
 row ++ ) {
 MODE_INFO * * mi_8x8 = mi_8x8_ptr ;
 uint8_t * cache = cache_ptr ;
 for ( col = 0 ;
 col < cm -> mi_cols ;
 col ++ , mi_8x8 ++ , cache ++ ) cache [ 0 ] = mi_8x8 [ 0 ] -> mbmi . segment_id ;
 mi_8x8_ptr += cm -> mi_stride ;
 cache_ptr += cm -> mi_cols ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 using std : : string ;
 if ( argc != 2 ) {
 fprintf ( stderr , ""One argument, the input filename, must be provided.\n"" ) ;
 return 1 ;
 }
 string filename ( argv [ 1 ] ) ;
 string outfilename = filename . substr ( 0 , filename . find_last_of ( ""."" ) ) + "".ttf"" ;
 fprintf ( stdout , ""Processing %s => %s\n"" , filename . c_str ( ) , outfilename . c_str ( ) ) ;
 string input = woff2 : : GetFileContent ( filename ) ;
 size_t decompressed_size = woff2 : : ComputeWOFF2FinalSize ( reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;
 string output ( decompressed_size , 0 ) ;
 const bool ok = woff2 : : ConvertWOFF2ToTTF ( reinterpret_cast < uint8_t * > ( & output [ 0 ] ) , decompressed_size , reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;
 if ( ! ok ) {
 fprintf ( stderr , ""Decompression failed\n"" ) ;
 return 1 ;
 }
 woff2 : : SetFileContents ( outfilename , output ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void spl_filesystem_dir_it_current_data ( zend_object_iterator * iter , zval * * * data TSRMLS_DC ) {
 spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;
 * data = & iterator -> current ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Asn1Generic * DecodeAsn1DerIA5String ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {
 const unsigned char * d_ptr = buffer ;
 uint32_t length , numbytes ;
 Asn1Generic * a ;
 unsigned char c ;
 d_ptr ++ ;
 c = d_ptr [ 0 ] ;
 if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {
 length = c ;
 d_ptr ++ ;
 }
 else {
 numbytes = c & 0x7f ;
 d_ptr ++ ;
 if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {
 return NULL ;
 }
 }
 if ( length > max_size ) return NULL ;
 a = Asn1GenericNew ( ) ;
 if ( a == NULL ) return NULL ;
 a -> type = ASN1_IA5STRING ;
 a -> strlen = length ;
 a -> str = SCMalloc ( length + 1 ) ;
 if ( a -> str == NULL ) {
 SCFree ( a ) ;
 return NULL ;
 }
 strlcpy ( a -> str , ( const char * ) d_ptr , length + 1 ) ;
 d_ptr += length ;
 a -> length = ( d_ptr - buffer ) ;
 return a ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void Type_ColorantTable_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {
 cmsFreeNamedColorList ( ( cmsNAMEDCOLORLIST * ) Ptr ) ;
 return ;
 cmsUNUSED_PARAMETER ( self ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_rfc822_parse_content_param ( void ) {
 const char * input = "";
 key1=value1#$!%&'*+-.^_`{
|}
~"" "";
 key2=\"" \\\""(),/:;
<=>?@[\\\\]\"""" ;
 const struct {
 const char * key , * value ;
 }
 output [ ] = {
 {
 ""key1"" , ""value1#$!%&'*+-.^_`{
|}
~"" }
 , {
 ""key2"" , "" \""(),/:;
<=>?@[\\]"" }
 }
 ;
 struct rfc822_parser_context parser ;
 const char * key , * value ;
 unsigned int i = 0 ;
 int ret ;
 test_begin ( ""rfc822 parse content param"" ) ;
 rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;
 while ( ( ret = rfc822_parse_content_param ( & parser , & key , & value ) ) > 0 && i < N_ELEMENTS ( output ) ) {
 test_assert_idx ( strcmp ( output [ i ] . key , key ) == 0 , i ) ;
 test_assert_idx ( strcmp ( output [ i ] . value , value ) == 0 , i ) ;
 i ++ ;
 }
 test_assert ( ret == 0 ) ;
 test_assert ( i == N_ELEMENTS ( output ) ) ;
 test_end ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void parseExtensionObject ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {
 static const int * extobj_mask [ ] = {
 & hf_opcua_extobj_mask_binbodyflag , & hf_opcua_extobj_mask_xmlbodyflag , NULL }
 ;
 gint iOffset = * pOffset ;
 guint8 EncodingMask ;
 guint32 TypeId ;
 proto_tree * extobj_tree ;
 proto_item * ti ;
 extobj_tree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_extensionobject , & ti , ""%s: ExtensionObject"" , szFieldName ) ;
 TypeId = getExtensionObjectType ( tvb , & iOffset ) ;
 parseExpandedNodeId ( extobj_tree , tvb , pinfo , & iOffset , ""TypeId"" ) ;
 EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;
 proto_tree_add_bitmask ( extobj_tree , tvb , iOffset , hf_opcua_extobj_mask , ett_opcua_extensionobject_encodingmask , extobj_mask , ENC_LITTLE_ENDIAN ) ;
 iOffset ++ ;
 if ( EncodingMask & EXTOBJ_ENCODINGMASK_BINBODY_FLAG ) {
 dispatchExtensionObjectType ( extobj_tree , tvb , pinfo , & iOffset , TypeId ) ;
 }
 proto_item_set_end ( ti , tvb , iOffset ) ;
 * pOffset = iOffset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 XanContext * s = avctx -> priv_data ;
 int ftype ;
 int ret ;
 s -> pic . reference = 1 ;
 s -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( ( ret = avctx -> reget_buffer ( avctx , & s -> pic ) ) ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""reget_buffer() failed\n"" ) ;
 return ret ;
 }
 bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ;
 ftype = bytestream2_get_le32 ( & s -> gb ) ;
 switch ( ftype ) {
 case 0 : ret = xan_decode_frame_type0 ( avctx ) ;
 break ;
 case 1 : ret = xan_decode_frame_type1 ( avctx ) ;
 break ;
 default : av_log ( avctx , AV_LOG_ERROR , ""Unknown frame type %d\n"" , ftype ) ;
 return AVERROR_INVALIDDATA ;
 }
 if ( ret ) return ret ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> pic ;
 return avpkt -> size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void loop_filter_rows_mt ( const YV12_BUFFER_CONFIG * const frame_buffer , VP9_COMMON * const cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only , VP9LfSync * const lf_sync , int num_lf_workers ) {
 const int num_planes = y_only ? 1 : MAX_MB_PLANE ;
 int r , c ;
 const int sb_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;
 for ( r = start ;
 r < stop ;
 r += num_lf_workers ) {
 const int mi_row = r << MI_BLOCK_SIZE_LOG2 ;
 MODE_INFO * * const mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;
 for ( c = 0 ;
 c < sb_cols ;
 ++ c ) {
 const int mi_col = c << MI_BLOCK_SIZE_LOG2 ;
 LOOP_FILTER_MASK lfm ;
 int plane ;
 sync_read ( lf_sync , r , c ) ;
 vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;
 vp9_setup_mask ( cm , mi_row , mi_col , mi + mi_col , cm -> mi_stride , & lfm ) ;
 for ( plane = 0 ;
 plane < num_planes ;
 ++ plane ) {
 vp9_filter_block_plane ( cm , & planes [ plane ] , mi_row , & lfm ) ;
 }
 sync_write ( lf_sync , r , c , sb_cols ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static unsigned char conv_ascii2bin ( unsigned char a ) {
 if ( a & 0x80 ) return B64_ERROR ;
 return data_ascii2bin [ a ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , NoFileAccess ) {
 ASSERT_TRUE ( RunExtensionTestNoFileAccess ( ""cross_origin_xhro_file_access"" ) ) << message_ ;
 }",1
Detect whether the following code contains vulnerabilities.,"static guint32 dissect_netb_data_ack ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {
 nb_xmit_corrl ( tvb , offset , tree ) ;
 nb_remote_session ( tvb , offset , tree ) ;
 nb_local_session ( tvb , offset , tree ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , valid ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_BOOL ( intern -> u . dir . entry . d_name [ 0 ] != '\0' ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInMainAndChildFrame ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 GURL a_url ( embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/main_frame_with_iframe.html"" ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;
 waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_PAINT ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;
 waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;
 waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;
 waiter -> Wait ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_set_arnr_type ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 ( void ) ctx ;
 ( void ) args ;
 return VPX_CODEC_OK ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void selinux_sb_free_security ( struct super_block * sb ) {
 superblock_free_security ( sb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) {
 const VP9_COMMON * cm = & cpi -> common ;
 int64_t unused ;
 x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode = DC_PRED ;
 super_block_uvrd ( cpi , x , rate_tokenonly , distortion , skippable , & unused , bsize , INT64_MAX ) ;
 * rate = * rate_tokenonly + cpi -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ;
 return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * passphrase_callback ( struct archive * a , void * _client_data ) {
 struct cpio * cpio = ( struct cpio * ) _client_data ;
 ( void ) a ;
 if ( cpio -> ppbuff == NULL ) {
 cpio -> ppbuff = malloc ( PPBUFF_SIZE ) ;
 if ( cpio -> ppbuff == NULL ) lafe_errc ( 1 , errno , ""Out of memory"" ) ;
 }
 return lafe_readpassphrase ( ""Enter passphrase:"" , cpio -> ppbuff , PPBUFF_SIZE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"gboolean lbmpdm_verify_payload ( tvbuff_t * tvb , int offset , int * encoding , int * length ) {
 guint8 next_header ;
 guint32 len = 0 ;
 if ( ! tvb_bytes_exist ( tvb , offset , L_LBMPDM_MSG_HDR_T ) ) {
 return ( FALSE ) ;
 }
 if ( ! check_lbmpdm_encoding ( tvb , offset , encoding ) ) {
 return ( FALSE ) ;
 }
 next_header = tvb_get_guint8 ( tvb , offset + O_LBMPDM_MSG_HDR_T_NEXT_HDR ) ;
 switch ( next_header ) {
 case PDM_HDR_TYPE_DATA : case PDM_HDR_TYPE_OFSTTBLE : case PDM_HDR_TYPE_DEFN : case PDM_HDR_TYPE_EOM : break ;
 default : return ( FALSE ) ;
 break ;
 }
 len = lbmpdm_fetch_uint32_encoded ( tvb , offset + O_LBMPDM_MSG_HDR_T_LEN , * encoding ) ;
 if ( len > G_MAXINT ) {
 return ( FALSE ) ;
 }
 * length = ( int ) len ;
 return ( TRUE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int parse_audio_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {
 MvContext * mv = avctx -> priv_data ;
 AVIOContext * pb = avctx -> pb ;
 if ( ! strcmp ( name , ""__DIR_COUNT"" ) ) {
 st -> nb_frames = var_read_int ( pb , size ) ;
 }
 else if ( ! strcmp ( name , ""AUDIO_FORMAT"" ) ) {
 mv -> aformat = var_read_int ( pb , size ) ;
 }
 else if ( ! strcmp ( name , ""COMPRESSION"" ) ) {
 mv -> acompression = var_read_int ( pb , size ) ;
 }
 else if ( ! strcmp ( name , ""DEFAULT_VOL"" ) ) {
 var_read_metadata ( avctx , name , size ) ;
 }
 else if ( ! strcmp ( name , ""NUM_CHANNELS"" ) ) {
 return set_channels ( avctx , st , var_read_int ( pb , size ) ) ;
 }
 else if ( ! strcmp ( name , ""SAMPLE_RATE"" ) ) {
 st -> codecpar -> sample_rate = var_read_int ( pb , size ) ;
 avpriv_set_pts_info ( st , 33 , 1 , st -> codecpar -> sample_rate ) ;
 }
 else if ( ! strcmp ( name , ""SAMPLE_WIDTH"" ) ) {
 st -> codecpar -> bits_per_coded_sample = var_read_int ( pb , size ) * 8 ;
 }
 else return AVERROR_INVALIDDATA ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) {
 av_log ( log_ctx , log_level , ""id:%d"" , interval -> id ) ;
 if ( interval -> has_start ) {
 av_log ( log_ctx , log_level , "" start:%s%s"" , interval -> start_is_offset ? ""+"" : """" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ;
 }
 else {
 av_log ( log_ctx , log_level , "" start:N/A"" ) ;
 }
 if ( interval -> has_end ) {
 av_log ( log_ctx , log_level , "" end:%s"" , interval -> end_is_offset ? ""+"" : """" ) ;
 if ( interval -> duration_frames ) av_log ( log_ctx , log_level , ""#%"" PRId64 , interval -> end ) ;
 else av_log ( log_ctx , log_level , ""%s"" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ;
 }
 else {
 av_log ( log_ctx , log_level , "" end:N/A"" ) ;
 }
 av_log ( log_ctx , log_level , ""\n"" ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void get_sb_partition_size_range ( MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) {
 int sb_width_in_blocks = MI_BLOCK_SIZE ;
 int sb_height_in_blocks = MI_BLOCK_SIZE ;
 int i , j ;
 int index = 0 ;
 for ( i = 0 ;
 i < sb_height_in_blocks ;
 ++ i ) {
 for ( j = 0 ;
 j < sb_width_in_blocks ;
 ++ j ) {
 MODE_INFO * mi = mi_8x8 [ index + j ] ;
 BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ;
 bs_hist [ sb_type ] ++ ;
 * min_block_size = MIN ( * min_block_size , sb_type ) ;
 * max_block_size = MAX ( * max_block_size , sb_type ) ;
 }
 index += xd -> mi_stride ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void destroy_address_node ( address_node * my_node ) {
 if ( NULL == my_node ) return ;
 NTP_REQUIRE ( NULL != my_node -> address ) ;
 free ( my_node -> address ) ;
 free ( my_node ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dumpDatabases ( PGconn * conn ) {
 PGresult * res ;
 int i ;
 if ( server_version >= 70100 ) res = executeQuery ( conn , ""SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1"" ) ;
 else res = executeQuery ( conn , ""SELECT datname FROM pg_database ORDER BY 1"" ) ;
 for ( i = 0 ;
 i < PQntuples ( res ) ;
 i ++ ) {
 int ret ;
 char * dbname = PQgetvalue ( res , i , 0 ) ;
 if ( verbose ) fprintf ( stderr , _ ( ""%s: dumping database \""%s\""...\n"" ) , progname , dbname ) ;
 fprintf ( OPF , ""\\connect %s\n\n"" , fmtId ( dbname ) ) ;
 fprintf ( OPF , ""SET default_transaction_read_only = off;
\n\n"" ) ;
 if ( filename ) fclose ( OPF ) ;
 ret = runPgDump ( dbname ) ;
 if ( ret != 0 ) {
 fprintf ( stderr , _ ( ""%s: pg_dump failed on database \""%s\"", exiting\n"" ) , progname , dbname ) ;
 exit_nicely ( 1 ) ;
 }
 if ( filename ) {
 OPF = fopen ( filename , PG_BINARY_A ) ;
 if ( ! OPF ) {
 fprintf ( stderr , _ ( ""%s: could not re-open the output file \""%s\"": %s\n"" ) , progname , filename , strerror ( errno ) ) ;
 exit_nicely ( 1 ) ;
 }
 }
 }
 PQclear ( res ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {
 PGconn * conn ;
 PGresult * result ;
 int i ;
 conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;
 result = executeQuery ( conn , ""SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;
"" , progname , echo ) ;
 PQfinish ( conn ) ;
 for ( i = 0 ;
 i < PQntuples ( result ) ;
 i ++ ) {
 char * dbname = PQgetvalue ( result , i , 0 ) ;
 if ( ! quiet ) {
 printf ( _ ( ""%s: clustering database \""%s\""\n"" ) , progname , dbname ) ;
 fflush ( stdout ) ;
 }
 cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;
 }
 PQclear ( result ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , RandomTest_RangeSupported ) {
 size_t file_size = 1000000 ;
 multibuffer_ . SetFileSize ( file_size ) ;
 multibuffer_ . SetMaxBlocksAfterDefer ( 10 ) ;
 std : : vector < ReadHelper * > read_helpers ;
 multibuffer_ . SetRangeSupported ( true ) ;
 for ( size_t i = 0 ;
 i < 20 ;
 i ++ ) {
 read_helpers . push_back ( new ReadHelper ( file_size , 1000 , & multibuffer_ , & rnd_ ) ) ;
 }
 for ( int i = 0 ;
 i < 100 ;
 i ++ ) {
 for ( int j = 0 ;
 j < 100 ;
 j ++ ) {
 if ( rnd_ . Rand ( ) & 1 ) {
 if ( ! media : : writers . empty ( ) ) Advance ( ) ;
 }
 else {
 size_t j = rnd_ . Rand ( ) % read_helpers . size ( ) ;
 if ( rnd_ . Rand ( ) % 100 < 3 ) read_helpers [ j ] -> Seek ( ) ;
 read_helpers [ j ] -> StartRead ( ) ;
 }
 }
 multibuffer_ . CheckLRUState ( ) ;
 }
 multibuffer_ . CheckPresentState ( ) ;
 while ( ! read_helpers . empty ( ) ) {
 delete read_helpers . back ( ) ;
 read_helpers . pop_back ( ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"mbfl_string * mbfl_buffer_converter_feed_result ( mbfl_buffer_converter * convd , mbfl_string * string , mbfl_string * result ) {
 if ( convd == NULL || string == NULL || result == NULL ) {
 return NULL ;
 }
 mbfl_buffer_converter_feed ( convd , string ) ;
 if ( convd -> filter1 != NULL ) {
 mbfl_convert_filter_flush ( convd -> filter1 ) ;
 }
 if ( convd -> filter2 != NULL ) {
 mbfl_convert_filter_flush ( convd -> filter2 ) ;
 }
 result -> no_encoding = convd -> to -> no_encoding ;
 return mbfl_memory_device_result ( & convd -> device , result ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool parse_authorityInfoAccess ( chunk_t blob , int level0 , private_x509_cert_t * this ) {
 asn1_parser_t * parser ;
 chunk_t object ;
 int objectID ;
 int accessMethod = OID_UNKNOWN ;
 bool success = FALSE ;
 parser = asn1_parser_create ( authInfoAccessObjects , blob ) ;
 parser -> set_top_level ( parser , level0 ) ;
 while ( parser -> iterate ( parser , & objectID , & object ) ) {
 switch ( objectID ) {
 case AUTH_INFO_ACCESS_METHOD : accessMethod = asn1_known_oid ( object ) ;
 break ;
 case AUTH_INFO_ACCESS_LOCATION : {
 switch ( accessMethod ) {
 case OID_OCSP : case OID_CA_ISSUERS : {
 identification_t * id ;
 char * uri ;
 id = parse_generalName ( object , parser -> get_level ( parser ) + 1 ) ;
 if ( id == NULL ) {
 goto end ;
 }
 DBG2 ( DBG_ASN , "" '%Y'"" , id ) ;
 if ( accessMethod == OID_OCSP && gn_to_string ( id , & uri ) ) {
 this -> ocsp_uris -> insert_last ( this -> ocsp_uris , uri ) ;
 }
 id -> destroy ( id ) ;
 }
 break ;
 default : break ;
 }
 break ;
 }
 default : break ;
 }
 }
 success = parser -> success ( parser ) ;
 end : parser -> destroy ( parser ) ;
 return success ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST ( BuildTime , DoesntCrash ) {
 base : : GetBuildTime ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const DataHeader * U_CALLCONV pointerTOCLookupFn ( const UDataMemory * pData , const char * name , int32_t * pLength , UErrorCode * pErrorCode ) {
 ( void ) pErrorCode ;
 if ( pData -> toc != NULL ) {
 const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;
 int32_t number , count = ( int32_t ) toc -> count ;
 # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;
 number < count ;
 ++ number ) {
 fprintf ( stderr , ""\tx%d: %s\n"" , number , toc -> entry [ number ] . entryName ) ;
 }
 # endif number = pointerTOCPrefixBinarySearch ( name , toc -> entry , count ) ;
 if ( number >= 0 ) {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Found.\n"" , toc -> entry [ number ] . entryName ) ;
 # endif * pLength = - 1 ;
 return UDataMemory_normalizeDataPointer ( toc -> entry [ number ] . pHeader ) ;
 }
 else {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Not found.\n"" , name ) ;
 # endif return NULL ;
 }
 }
 else {
 return pData -> pHeader ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int fill_vaapi_ReferenceFrames ( VAPictureParameterBufferH264 * pic_param , H264Context * h ) {
 DPB dpb ;
 int i ;
 dpb . size = 0 ;
 dpb . max_size = FF_ARRAY_ELEMS ( pic_param -> ReferenceFrames ) ;
 dpb . va_pics = pic_param -> ReferenceFrames ;
 for ( i = 0 ;
 i < dpb . max_size ;
 i ++ ) init_vaapi_pic ( & dpb . va_pics [ i ] ) ;
 for ( i = 0 ;
 i < h -> short_ref_count ;
 i ++ ) {
 Picture * const pic = h -> short_ref [ i ] ;
 if ( pic && pic -> f . reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;
 }
 for ( i = 0 ;
 i < 16 ;
 i ++ ) {
 Picture * const pic = h -> long_ref [ i ] ;
 if ( pic && pic -> f . reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , func_name ) \ {
 \ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 \ zend_error_handling error_handling ;
 \ if ( zend_parse_parameters_none ( ) == FAILURE ) {
 \ return ;
 \ }
 \ \ zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;
 \ spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;
 \ php_stat ( intern -> file_name , intern -> file_name_len , func_num , return_value TSRMLS_CC ) ;
 \ zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 \ }
 FileInfoFunction ( getPerms , FS_PERMS ) FileInfoFunction ( getInode , FS_INODE ) FileInfoFunction ( getSize , FS_SIZE ) FileInfoFunction ( getOwner , FS_OWNER ) FileInfoFunction ( getGroup , FS_GROUP ) FileInfoFunction ( getATime , FS_ATIME ) FileInfoFunction ( getMTime , FS_MTIME )",0
Detect whether the following code contains vulnerabilities.,"void xmlHashScan ( xmlHashTablePtr table , xmlHashScanner f , void * data ) {
 stubData stubdata ;
 stubdata . data = data ;
 stubdata . hashscanner = f ;
 xmlHashScanFull ( table , stubHashScannerFull , & stubdata ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , hasChildren ) {
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_FALSE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const DataHeader * pointerTOCLookupFn ( const UDataMemory * pData , const char * name , int32_t * pLength , UErrorCode * pErrorCode ) {
 if ( pData -> toc != NULL ) {
 const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;
 int32_t number , count = ( int32_t ) toc -> count ;
 # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;
 number < count ;
 ++ number ) {
 fprintf ( stderr , ""\tx%d: %s\n"" , number , toc -> entry [ number ] . entryName ) ;
 }
 # endif number = pointerTOCPrefixBinarySearch ( name , toc -> entry , count ) ;
 if ( number >= 0 ) {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Found.\n"" , toc -> entry [ number ] . entryName ) ;
 # endif * pLength = - 1 ;
 return UDataMemory_normalizeDataPointer ( toc -> entry [ number ] . pHeader ) ;
 }
 else {
 # ifdef UDATA_DEBUG fprintf ( stderr , ""%s: Not found.\n"" , name ) ;
 # endif return NULL ;
 }
 }
 else {
 return pData -> pHeader ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int key_notify_sa_expire ( struct xfrm_state * x , const struct km_event * c ) {
 struct sk_buff * out_skb ;
 struct sadb_msg * out_hdr ;
 int hard ;
 int hsc ;
 hard = c -> data . hard ;
 if ( hard ) hsc = 2 ;
 else hsc = 1 ;
 out_skb = pfkey_xfrm_state2msg_expire ( x , hsc ) ;
 if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;
 out_hdr = ( struct sadb_msg * ) out_skb -> data ;
 out_hdr -> sadb_msg_version = PF_KEY_V2 ;
 out_hdr -> sadb_msg_type = SADB_EXPIRE ;
 out_hdr -> sadb_msg_satype = pfkey_proto2satype ( x -> id . proto ) ;
 out_hdr -> sadb_msg_errno = 0 ;
 out_hdr -> sadb_msg_reserved = 0 ;
 out_hdr -> sadb_msg_seq = 0 ;
 out_hdr -> sadb_msg_pid = 0 ;
 pfkey_broadcast ( out_skb , GFP_ATOMIC , BROADCAST_REGISTERED , NULL , xs_net ( x ) ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"X509_REQ * X509_to_X509_REQ ( X509 * x , EVP_PKEY * pkey , const EVP_MD * md ) {
 X509_REQ * ret ;
 X509_REQ_INFO * ri ;
 int i ;
 EVP_PKEY * pktmp ;
 ret = X509_REQ_new ( ) ;
 if ( ret == NULL ) {
 X509err ( X509_F_X509_TO_X509_REQ , ERR_R_MALLOC_FAILURE ) ;
 goto err ;
 }
 ri = ret -> req_info ;
 ri -> version -> length = 1 ;
 ri -> version -> data = ( unsigned char * ) OPENSSL_malloc ( 1 ) ;
 if ( ri -> version -> data == NULL ) goto err ;
 ri -> version -> data [ 0 ] = 0 ;
 if ( ! X509_REQ_set_subject_name ( ret , X509_get_subject_name ( x ) ) ) goto err ;
 pktmp = X509_get_pubkey ( x ) ;
 i = X509_REQ_set_pubkey ( ret , pktmp ) ;
 EVP_PKEY_free ( pktmp ) ;
 if ( ! i ) goto err ;
 if ( pkey != NULL ) {
 if ( ! X509_REQ_sign ( ret , pkey , md ) ) goto err ;
 }
 return ( ret ) ;
 err : X509_REQ_free ( ret ) ;
 return ( NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dtap_tp_reset_ms_positioning_stored_information ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {
 guint32 curr_offset ;
 guint32 consumed ;
 guint curr_len ;
 curr_len = len ;
 curr_offset = offset ;
 ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_MS_POSITIONING_TECHNOLOGY , NULL ) ;
 EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , AbortNewNavigation ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 GURL url ( embedded_test_server ( ) -> GetURL ( ""/title1.html"" ) ) ;
 NavigateParams params ( browser ( ) , url , ui : : PAGE_TRANSITION_LINK ) ;
 content : : TestNavigationManager manager ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , url ) ;
 Navigate ( & params ) ;
 EXPECT_TRUE ( manager . WaitForRequestStart ( ) ) ;
 GURL url2 ( embedded_test_server ( ) -> GetURL ( ""/title2.html"" ) ) ;
 NavigateParams params2 ( browser ( ) , url2 , ui : : PAGE_TRANSITION_FROM_ADDRESS_BAR ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;
 Navigate ( & params2 ) ;
 waiter -> Wait ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramAbortNewNavigationBeforeCommit , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void feature_destroy ( hb_feature_t * g ) {
 free ( g ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) {
 DSA_SIG * s ;
 int ret = - 1 ;
 s = DSA_SIG_new ( ) ;
 if ( s == NULL ) return ( ret ) ;
 if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;
 ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;
 err : DSA_SIG_free ( s ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static UConverter * _ISCII_SafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {
 struct cloneISCIIStruct * localClone ;
 int32_t bufferSizeNeeded = sizeof ( struct cloneISCIIStruct ) ;
 if ( U_FAILURE ( * status ) ) {
 return 0 ;
 }
 if ( * pBufferSize == 0 ) {
 * pBufferSize = bufferSizeNeeded ;
 return 0 ;
 }
 localClone = ( struct cloneISCIIStruct * ) stackBuffer ;
 uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( UConverterDataISCII ) ) ;
 localClone -> cnv . extraInfo = & localClone -> mydata ;
 localClone -> cnv . isExtraLocal = TRUE ;
 return & localClone -> cnv ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int ipv6_addr_type ( const struct in6_addr * addr ) {
 return __ipv6_addr_type ( addr ) & 0xffff ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void exsltNodeSetFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {
 if ( nargs != 1 ) {
 xmlXPathSetArityError ( ctxt ) ;
 return ;
 }
 if ( xmlXPathStackIsNodeSet ( ctxt ) ) {
 xsltFunctionNodeSet ( ctxt , nargs ) ;
 return ;
 }
 else {
 xmlDocPtr fragment ;
 xsltTransformContextPtr tctxt = xsltXPathGetTransformContext ( ctxt ) ;
 xmlNodePtr txt ;
 xmlChar * strval ;
 xmlXPathObjectPtr obj ;
 fragment = xsltCreateRVT ( tctxt ) ;
 if ( fragment == NULL ) {
 xsltTransformError ( tctxt , NULL , tctxt -> inst , ""exsltNodeSetFunction: Failed to create a tree fragment.\n"" ) ;
 tctxt -> state = XSLT_STATE_STOPPED ;
 return ;
 }
 xsltRegisterLocalRVT ( tctxt , fragment ) ;
 strval = xmlXPathPopString ( ctxt ) ;
 txt = xmlNewDocText ( fragment , strval ) ;
 xmlAddChild ( ( xmlNodePtr ) fragment , txt ) ;
 obj = xmlXPathNewNodeSet ( txt ) ;
 if ( obj == NULL ) {
 xsltTransformError ( tctxt , NULL , tctxt -> inst , ""exsltNodeSetFunction: Failed to create a node set object.\n"" ) ;
 tctxt -> state = XSLT_STATE_STOPPED ;
 }
 else {
 xsltExtensionInstructionResultRegister ( tctxt , obj ) ;
 }
 if ( strval != NULL ) xmlFree ( strval ) ;
 valuePush ( ctxt , obj ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer , VP9_COMMON * cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only ) {
 const int num_planes = y_only ? 1 : MAX_MB_PLANE ;
 const int use_420 = y_only || ( planes [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) ;
 LOOP_FILTER_MASK lfm ;
 int mi_row , mi_col ;
 for ( mi_row = start ;
 mi_row < stop ;
 mi_row += MI_BLOCK_SIZE ) {
 MODE_INFO * * mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;
 for ( mi_col = 0 ;
 mi_col < cm -> mi_cols ;
 mi_col += MI_BLOCK_SIZE ) {
 int plane ;
 vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;
 if ( use_420 ) vp9_setup_mask ( cm , mi_row , mi_col , mi + mi_col , cm -> mi_stride , & lfm ) ;
 for ( plane = 0 ;
 plane < num_planes ;
 ++ plane ) {
 if ( use_420 ) vp9_filter_block_plane ( cm , & planes [ plane ] , mi_row , & lfm ) ;
 else filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , mi_row , mi_col ) ;
 }
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int decode_argb_frame ( CLLCContext * ctx , GetBitContext * gb , AVFrame * pic ) {
 AVCodecContext * avctx = ctx -> avctx ;
 uint8_t * dst ;
 int pred [ 4 ] ;
 int ret ;
 int i , j ;
 VLC vlc [ 4 ] ;
 pred [ 0 ] = 0 ;
 pred [ 1 ] = 0x80 ;
 pred [ 2 ] = 0x80 ;
 pred [ 3 ] = 0x80 ;
 dst = pic -> data [ 0 ] ;
 skip_bits ( gb , 16 ) ;
 for ( i = 0 ;
 i < 4 ;
 i ++ ) {
 ret = read_code_table ( ctx , gb , & vlc [ i ] ) ;
 if ( ret < 0 ) {
 for ( j = 0 ;
 j <= i ;
 j ++ ) ff_free_vlc ( & vlc [ j ] ) ;
 av_log ( ctx -> avctx , AV_LOG_ERROR , ""Could not read code table %d.\n"" , i ) ;
 return ret ;
 }
 }
 for ( i = 0 ;
 i < avctx -> height ;
 i ++ ) {
 read_argb_line ( ctx , gb , pred , vlc , dst ) ;
 dst += pic -> linesize [ 0 ] ;
 }
 for ( i = 0 ;
 i < 4 ;
 i ++ ) ff_free_vlc ( & vlc [ i ] ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"char * gcry_sexp_nth_string ( const gcry_sexp_t list , int number ) {
 const char * s ;
 size_t n ;
 char * buf ;
 s = sexp_nth_data ( list , number , & n ) ;
 if ( ! s || n < 1 || ( n + 1 ) < 1 ) return NULL ;
 buf = gcry_malloc ( n + 1 ) ;
 if ( ! buf ) return NULL ;
 memcpy ( buf , s , n ) ;
 buf [ n ] = 0 ;
 return buf ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int check_n_master ( AVCodecContext * avctx , int n_master , int bs_xover_band ) {
 if ( n_master <= 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""Invalid n_master: %d\n"" , n_master ) ;
 return - 1 ;
 }
 if ( bs_xover_band >= n_master ) {
 av_log ( avctx , AV_LOG_ERROR , ""Invalid bitstream, crossover band index beyond array bounds: %d\n"" , bs_xover_band ) ;
 return - 1 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void gs_memory_set_vm_threshold ( gs_ref_memory_t * mem , long val ) {
 gs_memory_gc_status_t stat ;
 gs_ref_memory_t * stable = ( gs_ref_memory_t * ) mem -> stable_memory ;
 gs_memory_gc_status ( mem , & stat ) ;
 stat . vm_threshold = val ;
 gs_memory_set_gc_status ( mem , & stat ) ;
 gs_memory_gc_status ( stable , & stat ) ;
 stat . vm_threshold = val ;
 gs_memory_set_gc_status ( stable , & stat ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"struct condition * compiler_create_condition ( struct filter_op * fop ) {
 struct condition * cnd ;
 SAFE_CALLOC ( cnd , 1 , sizeof ( struct condition ) ) ;
 memcpy ( & cnd -> fop , fop , sizeof ( struct filter_op ) ) ;
 return cnd ;
 }",0
Detect whether the following code contains vulnerabilities.,"void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) {
 struct rds_info_message minfo ;
 minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ;
 minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ;
 if ( flip ) {
 minfo . laddr = daddr ;
 minfo . faddr = saddr ;
 minfo . lport = inc -> i_hdr . h_dport ;
 minfo . fport = inc -> i_hdr . h_sport ;
 }
 else {
 minfo . laddr = saddr ;
 minfo . faddr = daddr ;
 minfo . lport = inc -> i_hdr . h_sport ;
 minfo . fport = inc -> i_hdr . h_dport ;
 }
 rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_KeyProtectionMethod ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_KeyProtectionMethod , KeyProtectionMethod_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_get_parent ( proto_tree * tree ) {
 if ( ! tree ) return NULL ;
 return ( proto_item * ) tree ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void purple_logout ( struct im_connection * ic ) {
 struct purple_data * pd = ic -> proto_data ;
 if ( ! pd ) {
 return ;
 }
 while ( ic -> groupchats ) {
 imcb_chat_free ( ic -> groupchats -> data ) ;
 }
 purple_account_set_enabled ( pd -> account , ""BitlBee"" , FALSE ) ;
 purple_connections = g_slist_remove ( purple_connections , ic ) ;
 purple_accounts_remove ( pd -> account ) ;
 imcb_chat_list_free ( ic ) ;
 g_free ( pd -> chat_list_server ) ;
 g_hash_table_destroy ( pd -> input_requests ) ;
 g_free ( pd ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"size_t vpx_svc_get_rc_stats_buffer_size ( const SvcContext * svc_ctx ) {
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL ) return 0 ;
 return si -> rc_stats_buf_used ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void flush ( AVCodecContext * avctx ) {
 WmallDecodeCtx * s = avctx -> priv_data ;
 s -> packet_loss = 1 ;
 s -> packet_done = 0 ;
 s -> num_saved_bits = 0 ;
 s -> frame_offset = 0 ;
 s -> next_packet_start = 0 ;
 s -> cdlms [ 0 ] [ 0 ] . order = 0 ;
 s -> frame . nb_samples = 0 ;
 init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _UTF7Reset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> toUnicodeStatus = 0x1000000 ;
 cnv -> toULength = 0 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUnicodeStatus = ( cnv -> fromUnicodeStatus & 0xf0000000 ) | 0x1000000 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static PyObject * string_index ( PyStringObject * self , PyObject * args ) {
 Py_ssize_t result = string_find_internal ( self , args , + 1 ) ;
 if ( result == - 2 ) return NULL ;
 if ( result == - 1 ) {
 PyErr_SetString ( PyExc_ValueError , ""substring not found"" ) ;
 return NULL ;
 }
 return PyInt_FromSsize_t ( result ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evhttp_connection_free ( struct evhttp_connection * evcon ) {
 struct evhttp_request * req ;
 if ( evcon -> fd != - 1 ) {
 if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;
 }
 while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {
 TAILQ_REMOVE ( & evcon -> requests , req , next ) ;
 evhttp_request_free ( req ) ;
 }
 if ( evcon -> http_server != NULL ) {
 struct evhttp * http = evcon -> http_server ;
 TAILQ_REMOVE ( & http -> connections , evcon , next ) ;
 }
 if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;
 if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;
 if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;
 if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;
 if ( evcon -> address != NULL ) free ( evcon -> address ) ;
 if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;
 if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;
 free ( evcon ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_simple_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 * argConverted = 0 ;
 if ( u_fgetc ( input ) != 0x0025 ) {
 * argConverted = - 1 ;
 }
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void window_reparent ( WINDOW_REC * win , MAIN_WINDOW_REC * mainwin ) {
 MAIN_WINDOW_REC * old_mainwin ;
 old_mainwin = WINDOW_MAIN ( win ) ;
 if ( old_mainwin != mainwin ) {
 gui_window_set_unsticky ( win ) ;
 if ( old_mainwin -> active == win ) {
 mainwindow_change_active ( old_mainwin , win ) ;
 if ( active_mainwin == NULL ) {
 active_mainwin = mainwin ;
 window_set_active ( mainwin -> active ) ;
 }
 }
 gui_window_reparent ( win , mainwin ) ;
 window_set_active ( win ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static UConverter * _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {
 LMBCSClone * newLMBCS ;
 UConverterDataLMBCS * extraInfo ;
 int32_t i ;
 if ( * pBufferSize <= 0 ) {
 * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;
 return NULL ;
 }
 extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;
 newLMBCS = ( LMBCSClone * ) stackBuffer ;
 uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;
 for ( i = 0 ;
 i <= ULMBCS_GRP_LAST ;
 ++ i ) {
 if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {
 ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;
 }
 }
 newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;
 newLMBCS -> cnv . isExtraLocal = TRUE ;
 return & newLMBCS -> cnv ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void security_init ( void ) {
 uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard ( _dl_random ) ;
 # ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD ( stack_chk_guard ) ;
 # else __stack_chk_guard = stack_chk_guard ;
 # endif if ( GLRO ( dl_pointer_guard ) ) {
 uintptr_t pointer_chk_guard = _dl_setup_pointer_guard ( _dl_random , stack_chk_guard ) ;
 # ifdef THREAD_SET_POINTER_GUARD THREAD_SET_POINTER_GUARD ( pointer_chk_guard ) ;
 # endif __pointer_chk_guard_local = pointer_chk_guard ;
 }
 _dl_random = NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * pathToFullPath ( const char * path , const char * source ) {
 int32_t length ;
 int32_t newLength ;
 char * fullPath ;
 int32_t n ;
 length = ( uint32_t ) ( uprv_strlen ( path ) + 1 ) ;
 newLength = ( length + 1 + ( int32_t ) uprv_strlen ( source ) ) ;
 fullPath = uprv_malloc ( newLength ) ;
 if ( source != NULL ) {
 uprv_strcpy ( fullPath , source ) ;
 uprv_strcat ( fullPath , U_FILE_SEP_STRING ) ;
 }
 else {
 fullPath [ 0 ] = 0 ;
 }
 n = ( int32_t ) uprv_strlen ( fullPath ) ;
 fullPath [ n ] = 0 ;
 uprv_strcat ( fullPath , path ) ;
 # if ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) for ( ;
 fullPath [ n ] ;
 n ++ ) {
 if ( fullPath [ n ] == U_FILE_ALT_SEP_CHAR ) {
 fullPath [ n ] = U_FILE_SEP_CHAR ;
 }
 }
 # endif # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( ;
 fullPath [ n ] ;
 n ++ ) {
 if ( fullPath [ n ] == U_TREE_ENTRY_SEP_CHAR ) {
 fullPath [ n ] = U_FILE_SEP_CHAR ;
 }
 }
 # endif return fullPath ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestDownloadDirPref ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 base : : ScopedAllowBlockingForTesting allow_blocking ;
 base : : ScopedTempDir new_download_dir ;
 ASSERT_TRUE ( new_download_dir . CreateUniqueTempDir ( ) ) ;
 base : : FilePath downloaded_pkg = new_download_dir . GetPath ( ) . AppendASCII ( ""a_zip_file.zip"" ) ;
 browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , new_download_dir . GetPath ( ) ) ;
 std : : unique_ptr < content : : DownloadTestObserver > downloads_observer ( CreateWaiter ( browser ( ) , 1 ) ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/downloads/a_zip_file.zip"" ) ) ;
 downloads_observer -> WaitForFinished ( ) ;
 EXPECT_TRUE ( base : : PathExists ( downloaded_pkg ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int yop_copy_previous_block ( YopDecContext * s , int copy_tag ) {
 uint8_t * bufptr ;
 bufptr = s -> dstptr + motion_vector [ copy_tag ] [ 0 ] + s -> frame . linesize [ 0 ] * motion_vector [ copy_tag ] [ 1 ] ;
 if ( bufptr < s -> dstbuf ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""YOP: cannot decode, file probably corrupt\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 s -> dstptr [ 0 ] = bufptr [ 0 ] ;
 s -> dstptr [ 1 ] = bufptr [ 1 ] ;
 s -> dstptr [ s -> frame . linesize [ 0 ] ] = bufptr [ s -> frame . linesize [ 0 ] ] ;
 s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = bufptr [ s -> frame . linesize [ 0 ] + 1 ] ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int kvm_arch_remove_sw_breakpoint ( CPUState * cs , struct kvm_sw_breakpoint * bp ) {
 uint8_t int3 ;
 if ( cpu_memory_rw_debug ( cs , bp -> pc , & int3 , 1 , 0 ) || int3 != 0xcc || cpu_memory_rw_debug ( cs , bp -> pc , ( uint8_t * ) & bp -> saved_insn , 1 , 1 ) ) {
 return - EINVAL ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int proc_alloc_streams ( struct usb_dev_state * ps , void __user * arg ) {
 unsigned num_streams , num_eps ;
 struct usb_host_endpoint * * eps ;
 struct usb_interface * intf ;
 int r ;
 r = parse_usbdevfs_streams ( ps , arg , & num_streams , & num_eps , & eps , & intf ) ;
 if ( r ) return r ;
 destroy_async_on_interface ( ps , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ) ;
 r = usb_alloc_streams ( intf , eps , num_eps , num_streams , GFP_KERNEL ) ;
 kfree ( eps ) ;
 return r ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * ptvcursor_add ( ptvcursor_t * ptvc , int hfindex , gint length , const guint encoding ) {
 field_info * new_fi ;
 header_field_info * hfinfo ;
 gint item_length ;
 int offset ;
 offset = ptvc -> offset ;
 PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;
 get_hfi_length ( hfinfo , ptvc -> tvb , offset , & length , & item_length ) ;
 test_length ( hfinfo , ptvc -> tvb , offset , item_length ) ;
 ptvc -> offset += get_full_length ( hfinfo , ptvc -> tvb , offset , length , item_length , encoding ) ;
 CHECK_FOR_NULL_TREE ( ptvc -> tree ) ;
 TRY_TO_FAKE_THIS_ITEM ( ptvc -> tree , hfindex , hfinfo ) ;
 new_fi = new_field_info ( ptvc -> tree , hfinfo , ptvc -> tvb , offset , item_length ) ;
 return proto_tree_new_item ( new_fi , ptvc -> tree , ptvc -> tvb , offset , length , encoding ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_uint_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , guint32 value , const char * format , ... ) {
 proto_item * pi ;
 va_list ap ;
 pi = proto_tree_add_uint ( tree , hfindex , tvb , start , length , value ) ;
 if ( pi != tree ) {
 va_start ( ap , format ) ;
 proto_tree_set_representation_value ( pi , format , ap ) ;
 va_end ( ap ) ;
 }
 return pi ;
 }",0
Detect whether the following code contains vulnerabilities.,"xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {
 xsltDocumentPtr cur ;
 cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;
 if ( cur == NULL ) {
 xsltTransformError ( NULL , style , ( xmlNodePtr ) doc , ""xsltNewStyleDocument : malloc failed\n"" ) ;
 return ( NULL ) ;
 }
 memset ( cur , 0 , sizeof ( xsltDocument ) ) ;
 cur -> doc = doc ;
 if ( style != NULL ) {
 cur -> next = style -> docList ;
 style -> docList = cur ;
 }
 return ( cur ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l )",1
Detect whether the following code contains vulnerabilities.,"void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {
 int i , j ;
 unsigned int total = 0 ;
 * outl = 0 ;
 if ( inl <= 0 ) return ;
 OPENSSL_assert ( ctx -> length <= ( int ) sizeof ( ctx -> enc_data ) ) ;
 if ( ( ctx -> num + inl ) < ctx -> length ) {
 memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;
 ctx -> num += inl ;
 return ;
 }
 if ( ctx -> num != 0 ) {
 i = ctx -> length - ctx -> num ;
 memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;
 in += i ;
 inl -= i ;
 j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;
 ctx -> num = 0 ;
 out += j ;
 * ( out ++ ) = '\n' ;
 * out = '\0' ;
 total = j + 1 ;
 }
 while ( inl >= ctx -> length ) {
 j = EVP_EncodeBlock ( out , in , ctx -> length ) ;
 in += ctx -> length ;
 inl -= ctx -> length ;
 out += j ;
 * ( out ++ ) = '\n' ;
 * out = '\0' ;
 total += j + 1 ;
 }
 if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;
 ctx -> num = inl ;
 * outl = total ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {
 uint8_t * apphead ;
 usize_t appheadsz ;
 int ret ;
 if ( ! option_use_appheader ) {
 return ;
 }
 ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;
 if ( ret != 0 ) {
 return ;
 }
 if ( appheadsz > 0 ) {
 char * start = ( char * ) apphead ;
 char * slash ;
 int place = 0 ;
 char * parsed [ 4 ] ;
 memset ( parsed , 0 , sizeof ( parsed ) ) ;
 while ( ( slash = strchr ( start , '/' ) ) != NULL ) {
 * slash = 0 ;
 parsed [ place ++ ] = start ;
 start = slash + 1 ;
 }
 parsed [ place ++ ] = start ;
 if ( place == 2 || place == 4 ) {
 main_get_appheader_params ( output , parsed , 1 , ""output"" , ifile ) ;
 }
 if ( place == 4 ) {
 main_get_appheader_params ( sfile , parsed + 2 , 0 , ""source"" , ifile ) ;
 }
 }
 option_use_appheader = 0 ;
 return ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int tm2_read_deltas ( TM2Context * ctx , int stream_id ) {
 int d , mb ;
 int i , v ;
 d = get_bits ( & ctx -> gb , 9 ) ;
 mb = get_bits ( & ctx -> gb , 5 ) ;
 if ( ( d < 1 ) || ( d > TM2_DELTAS ) || ( mb < 1 ) || ( mb > 32 ) ) {
 av_log ( ctx -> avctx , AV_LOG_ERROR , ""Incorrect delta table: %i deltas x %i bits\n"" , d , mb ) ;
 return AVERROR_INVALIDDATA ;
 }
 for ( i = 0 ;
 i < d ;
 i ++ ) {
 v = get_bits_long ( & ctx -> gb , mb ) ;
 if ( v & ( 1 << ( mb - 1 ) ) ) ctx -> deltas [ stream_id ] [ i ] = v - ( 1 << mb ) ;
 else ctx -> deltas [ stream_id ] [ i ] = v ;
 }
 for ( ;
 i < TM2_DELTAS ;
 i ++ ) ctx -> deltas [ stream_id ] [ i ] = 0 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_get_mvpred_av_var ( const MACROBLOCK * x , const MV * best_mv , const MV * center_mv , const uint8_t * second_pred , const vp9_variance_fn_ptr_t * vfp , int use_mvcost ) {
 const MACROBLOCKD * const xd = & x -> e_mbd ;
 const struct buf_2d * const what = & x -> plane [ 0 ] . src ;
 const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ;
 const MV mv = {
 best_mv -> row * 8 , best_mv -> col * 8 }
 ;
 unsigned int unused ;
 return vfp -> svaf ( get_buf_from_mv ( in_what , best_mv ) , in_what -> stride , 0 , 0 , what -> buf , what -> stride , & unused , second_pred ) + ( use_mvcost ? mv_err_cost ( & mv , center_mv , x -> nmvjointcost , x -> mvcost , x -> errorperbit ) : 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void tb_jmp_remove ( TranslationBlock * tb , int n ) {
 TranslationBlock * tb1 , * * ptb ;
 unsigned int n1 ;
 ptb = & tb -> jmp_next [ n ] ;
 tb1 = * ptb ;
 if ( tb1 ) {
 for ( ;
 ;
 ) {
 tb1 = * ptb ;
 n1 = ( uintptr_t ) tb1 & 3 ;
 tb1 = ( TranslationBlock * ) ( ( uintptr_t ) tb1 & ~ 3 ) ;
 if ( n1 == n && tb1 == tb ) {
 break ;
 }
 if ( n1 == 2 ) {
 ptb = & tb1 -> jmp_first ;
 }
 else {
 ptb = & tb1 -> jmp_next [ n1 ] ;
 }
 }
 * ptb = tb -> jmp_next [ n ] ;
 tb -> jmp_next [ n ] = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * lookup_gname ( struct cpio * cpio , gid_t gid ) {
 return ( lookup_name ( cpio , & cpio -> gname_cache , & lookup_gname_helper , ( id_t ) gid ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void e1000e_core_pci_uninit ( E1000ECore * core ) {
 int i ;
 timer_del ( core -> autoneg_timer ) ;
 timer_free ( core -> autoneg_timer ) ;
 e1000e_intrmgr_pci_unint ( core ) ;
 qemu_del_vm_change_state_handler ( core -> vmstate ) ;
 for ( i = 0 ;
 i < E1000E_NUM_QUEUES ;
 i ++ ) {
 net_tx_pkt_reset ( core -> tx [ i ] . tx_pkt ) ;
 net_tx_pkt_uninit ( core -> tx [ i ] . tx_pkt ) ;
 }
 net_rx_pkt_uninit ( core -> rx_pkt ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {
 const unsigned char * d_ptr = buffer ;
 uint32_t length , numbytes ;
 Asn1Generic * a ;
 unsigned char c ;
 d_ptr ++ ;
 c = d_ptr [ 0 ] ;
 if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {
 length = c ;
 d_ptr ++ ;
 }
 else {
 numbytes = c & 0x7f ;
 d_ptr ++ ;
 if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {
 return NULL ;
 }
 }
 if ( length > max_size ) return NULL ;
 a = Asn1GenericNew ( ) ;
 if ( a == NULL ) return NULL ;
 a -> type = ASN1_OCTETSTRING ;
 a -> strlen = length ;
 a -> str = SCMalloc ( length + 1 ) ;
 if ( a -> str == NULL ) {
 SCFree ( a ) ;
 return NULL ;
 }
 memcpy ( a -> str , ( const char * ) d_ptr , length ) ;
 a -> str [ length ] = 0 ;
 d_ptr += length ;
 a -> length = ( d_ptr - buffer ) ;
 return a ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DisengageRequest ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageRequest , DisengageRequest_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_non_indic_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {
 }",1
Detect whether the following code contains vulnerabilities.,"static void setup_plane_dequants ( VP9_COMMON * cm , MACROBLOCKD * xd , int q_index ) {
 int i ;
 xd -> plane [ 0 ] . dequant = cm -> y_dequant [ q_index ] ;
 for ( i = 1 ;
 i < MAX_MB_PLANE ;
 i ++ ) xd -> plane [ i ] . dequant = cm -> uv_dequant [ q_index ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_QseriesOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_QseriesOptions , QseriesOptions_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelChannels ( Image * image , const size_t number_channels ) {
 image -> number_channels = number_channels ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _SCSUOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 const char * locale = pArgs -> locale ;
 if ( pArgs -> onlyTestIsLoadable ) {
 return ;
 }
 cnv -> extraInfo = uprv_malloc ( sizeof ( SCSUData ) ) ;
 if ( cnv -> extraInfo != NULL ) {
 if ( locale != NULL && locale [ 0 ] == 'j' && locale [ 1 ] == 'a' && ( locale [ 2 ] == 0 || locale [ 2 ] == '_' ) ) {
 ( ( SCSUData * ) cnv -> extraInfo ) -> locale = l_ja ;
 }
 else {
 ( ( SCSUData * ) cnv -> extraInfo ) -> locale = lGeneric ;
 }
 _SCSUReset ( cnv , UCNV_RESET_BOTH ) ;
 }
 else {
 * pErrorCode = U_MEMORY_ALLOCATION_ERROR ;
 }
 cnv -> subUChars [ 0 ] = 0xfffd ;
 cnv -> subCharLen = - 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"my_bool include_table ( const uchar * hash_key , size_t len ) {
 return ! my_hash_search ( & ignore_table , hash_key , len ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cpu_halt_signal ( void * opaque , int irq , int level ) {
 if ( level && cpu_single_env ) {
 cpu_interrupt ( CPU ( sparc_env_get_cpu ( cpu_single_env ) ) , CPU_INTERRUPT_HALT ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_tile_limits ( VP9_COMP * cpi ) {
 VP9_COMMON * const cm = & cpi -> common ;
 int min_log2_tile_cols , max_log2_tile_cols ;
 vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ;
 cm -> log2_tile_cols = clamp ( cpi -> oxcf . tile_columns , min_log2_tile_cols , max_log2_tile_cols ) ;
 cm -> log2_tile_rows = cpi -> oxcf . tile_rows ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void check_reset_2nd_coeffs ( MACROBLOCKD * x , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {
 int sum = 0 ;
 int i ;
 BLOCKD * bd = & x -> block [ 24 ] ;
 if ( bd -> dequant [ 0 ] >= 35 && bd -> dequant [ 1 ] >= 35 ) return ;
 for ( i = 0 ;
 i < ( * bd -> eob ) ;
 i ++ ) {
 int coef = bd -> dqcoeff [ vp8_default_zig_zag1d [ i ] ] ;
 sum += ( coef >= 0 ) ? coef : - coef ;
 if ( sum >= 35 ) return ;
 }
 if ( sum < 35 ) {
 for ( i = 0 ;
 i < ( * bd -> eob ) ;
 i ++ ) {
 int rc = vp8_default_zig_zag1d [ i ] ;
 bd -> qcoeff [ rc ] = 0 ;
 bd -> dqcoeff [ rc ] = 0 ;
 }
 * bd -> eob = 0 ;
 * a = * l = ( * bd -> eob != ! type ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"int proto_registrar_get_parent ( const int n ) {
 header_field_info * hfinfo ;
 PROTO_REGISTRAR_GET_NTH ( n , hfinfo ) ;
 return hfinfo -> parent ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _UTF16LEReset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 if ( UCNV_GET_VERSION ( cnv ) == 0 ) {
 cnv -> mode = 8 ;
 }
 else {
 cnv -> mode = 0 ;
 }
 }
 if ( choice != UCNV_RESET_TO_UNICODE && UCNV_GET_VERSION ( cnv ) == 1 ) {
 cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void qemu_mutex_unlock_iothread ( void ) {
 qemu_mutex_unlock ( & qemu_global_mutex ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {
 StartHttpServer ( ) ;
 base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 FakeUserMetricsUpload ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;
 int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;
 EXPECT_EQ ( 0 , ratio_bucket ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 8 * 8 ] ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 8 ] , temp_out [ 8 ] ;
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 idct8 ( input , outptr ) ;
 input += 8 ;
 outptr += 8 ;
 }
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;
 idct8 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void log_invalid_scale_factor ( SvcContext * svc_ctx , const char * value ) {
 svc_log ( svc_ctx , SVC_LOG_ERROR , ""svc scale-factors: invalid value %s\n"" , value ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * _get_user_from_associd ( mysql_conn_t * mysql_conn , char * cluster , uint32_t associd ) {
 char * user = NULL ;
 char * query = NULL ;
 MYSQL_RES * result = NULL ;
 MYSQL_ROW row ;
 query = xstrdup_printf ( ""select user from \""%s_%s\"" where id_assoc=%u"" , cluster , assoc_table , associd ) ;
 debug4 ( ""%d(%s:%d) query\n%s"" , mysql_conn -> conn , THIS_FILE , __LINE__ , query ) ;
 if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) {
 xfree ( query ) ;
 return NULL ;
 }
 xfree ( query ) ;
 if ( ( row = mysql_fetch_row ( result ) ) && row [ 0 ] [ 0 ] ) user = xstrdup ( row [ 0 ] ) ;
 mysql_free_result ( result ) ;
 return user ;
 }",0
Detect whether the following code contains vulnerabilities.,"file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) {
 bee_t * bee = ic -> bee ;
 bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ;
 if ( bee -> ui -> ft_in_start ) {
 return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;
 }
 else {
 return NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * notify_plural ( int count ) {
 if ( count == 1 ) return ""notification"" ;
 return ""notifies"" ;
 }",0
Detect whether the following code contains vulnerabilities.,"CharDriverState * qdev_init_chardev ( DeviceState * dev ) {
 static int next_serial ;
 static int next_virtconsole ;
 if ( strncmp ( dev -> info -> name , ""virtio"" , 6 ) == 0 ) {
 return virtcon_hds [ next_virtconsole ++ ] ;
 }
 else {
 return serial_hds [ next_serial ++ ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerWithDownloadsBrowserTest , DISABLED_TestBeforeUnloadAndDownloads ) {
 SetDownloadPathForProfile ( browser ( ) -> profile ( ) ) ;
 ASSERT_NO_FATAL_FAILURE ( CreateStalledDownload ( browser ( ) ) ) ;
 ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/beforeunload.html"" ) ) ) ;
 PrepareForDialog ( browser ( ) ) ;
 content : : WindowedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , content : : NotificationService : : AllSources ( ) ) ;
 TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_CANCELS_CLOSE ) ;
 ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;
 cancel_observer . Wait ( ) ;
 EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;
 RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;
 TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_ALLOWS_CLOSE ) ;
 ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;
 close_observer . Wait ( ) ;
 EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;
 EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int libopus_decode ( AVCodecContext * avc , void * data , int * got_frame_ptr , AVPacket * pkt ) {
 struct libopus_context * opus = avc -> priv_data ;
 AVFrame * frame = data ;
 int ret , nb_samples ;
 frame -> nb_samples = MAX_FRAME_SIZE ;
 ret = ff_get_buffer ( avc , frame ) ;
 if ( ret < 0 ) {
 av_log ( avc , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 if ( avc -> sample_fmt == AV_SAMPLE_FMT_S16 ) nb_samples = opus_multistream_decode ( opus -> dec , pkt -> data , pkt -> size , ( opus_int16 * ) frame -> data [ 0 ] , frame -> nb_samples , 0 ) ;
 else nb_samples = opus_multistream_decode_float ( opus -> dec , pkt -> data , pkt -> size , ( float * ) frame -> data [ 0 ] , frame -> nb_samples , 0 ) ;
 if ( nb_samples < 0 ) {
 av_log ( avc , AV_LOG_ERROR , ""Decoding error: %s\n"" , opus_strerror ( nb_samples ) ) ;
 return ff_opus_error_to_averror ( nb_samples ) ;
 }
 frame -> nb_samples = nb_samples ;
 * got_frame_ptr = 1 ;
 return pkt -> size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void report_type_length_mismatch ( proto_tree * tree , const gchar * descr , int length , gboolean is_error ) {
 if ( is_error ) {
 expert_add_info_format ( NULL , tree , & ei_type_length_mismatch_error , ""Trying to fetch %s with length %d"" , descr , length ) ;
 }
 else {
 expert_add_info_format ( NULL , tree , & ei_type_length_mismatch_warn , ""Trying to fetch %s with length %d"" , descr , length ) ;
 }
 if ( is_error ) {
 THROW ( ReportedBoundsError ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void decompose_current_character ( const hb_ot_shape_normalize_context_t * c , bool shortest ) {
 hb_buffer_t * const buffer = c -> buffer ;
 hb_codepoint_t glyph ;
 if ( shortest && c -> font -> get_glyph ( buffer -> cur ( ) . codepoint , 0 , & glyph ) ) next_char ( buffer , glyph ) ;
 else if ( decompose ( c , shortest , buffer -> cur ( ) . codepoint ) ) skip_char ( buffer ) ;
 else if ( ! shortest && c -> font -> get_glyph ( buffer -> cur ( ) . codepoint , 0 , & glyph ) ) next_char ( buffer , glyph ) ;
 else if ( decompose_compatibility ( c , buffer -> cur ( ) . codepoint ) ) skip_char ( buffer ) ;
 else next_char ( buffer , glyph ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONGetStatus ( qemuMonitorPtr mon , bool * running , virDomainPausedReason * reason ) {
 int ret ;
 const char * status ;
 virJSONValuePtr cmd ;
 virJSONValuePtr reply = NULL ;
 virJSONValuePtr data ;
 if ( reason ) * reason = VIR_DOMAIN_PAUSED_UNKNOWN ;
 if ( ! ( cmd = qemuMonitorJSONMakeCommand ( ""query-status"" , NULL ) ) ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 if ( ret < 0 ) goto cleanup ;
 ret = - 1 ;
 if ( ! ( data = virJSONValueObjectGet ( reply , ""return"" ) ) ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""query-status reply was missing return data"" ) ) ;
 goto cleanup ;
 }
 if ( virJSONValueObjectGetBoolean ( data , ""running"" , running ) < 0 ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""query-status reply was missing running state"" ) ) ;
 goto cleanup ;
 }
 if ( ( status = virJSONValueObjectGetString ( data , ""status"" ) ) ) {
 if ( ! * running && reason ) * reason = qemuMonitorVMStatusToPausedReason ( status ) ;
 }
 else if ( ! * running ) {
 VIR_DEBUG ( ""query-status reply was missing status details"" ) ;
 }
 ret = 0 ;
 cleanup : virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gint nlm_msg_res_unmatched_equal ( gconstpointer k1 , gconstpointer k2 ) {
 const nlm_msg_res_unmatched_data * umd1 = ( const nlm_msg_res_unmatched_data * ) k1 ;
 const nlm_msg_res_unmatched_data * umd2 = ( const nlm_msg_res_unmatched_data * ) k2 ;
 if ( umd1 -> cookie_len != umd2 -> cookie_len ) {
 return 0 ;
 }
 return ( memcmp ( umd1 -> cookie , umd2 -> cookie , umd1 -> cookie_len ) == 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_H222LogicalChannelParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H222LogicalChannelParameters , H222LogicalChannelParameters_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pdf_run_gs_OPM ( fz_context * ctx , pdf_processor * proc , int i ) {
 pdf_run_processor * pr = ( pdf_run_processor * ) proc ;
 pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;
 gstate -> stroke . color_params . opm = i ;
 gstate -> fill . color_params . opm = i ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_vertical_16_dual_sse2 ( unsigned char * s , int p , const uint8_t * blimit , const uint8_t * limit , const uint8_t * thresh ) {
 DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 256 ) ;
 transpose8x16 ( s - 8 , s - 8 + 8 * p , p , t_dst , 16 ) ;
 transpose8x16 ( s , s + 8 * p , p , t_dst + 8 * 16 , 16 ) ;
 mb_lpf_horizontal_edge_w_sse2_16 ( t_dst + 8 * 16 , 16 , blimit , limit , thresh ) ;
 transpose8x16 ( t_dst , t_dst + 8 * 16 , 16 , s - 8 , p ) ;
 transpose8x16 ( t_dst + 8 , t_dst + 8 + 8 * 16 , 16 , s - 8 + 8 * p , p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_BandRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 625 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_BandRejectReason , BandRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void record_recent_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {
 sha1_array_append ( & recent_objects , obj -> oid . hash ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( BluetoothChooserBrowserTest , InvokeDialog_ConnectedBubble ) {
 set_status ( FakeBluetoothChooserController : : BluetoothStatus : : IDLE ) ;
 AddConnectedDevice ( ) ;
 RunDialog ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int x ( struct vcache * avc , int afun , struct vrequest * areq , \ struct afs_pdata * ain , struct afs_pdata * aout , \ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;
 DECL_PIOCTL ( PSetAcl ) ;
 DECL_PIOCTL ( PStoreBehind ) ;
 DECL_PIOCTL ( PGCPAGs ) ;
 DECL_PIOCTL ( PGetAcl ) ;
 DECL_PIOCTL ( PNoop ) ;
 DECL_PIOCTL ( PBogus ) ;
 DECL_PIOCTL ( PGetFileCell ) ;
 DECL_PIOCTL ( PGetWSCell ) ;
 DECL_PIOCTL ( PGetUserCell ) ;
 DECL_PIOCTL ( PSetTokens ) ;
 DECL_PIOCTL ( PGetVolumeStatus ) ;
 DECL_PIOCTL ( PSetVolumeStatus ) ;
 DECL_PIOCTL ( PFlush ) ;
 DECL_PIOCTL ( PNewStatMount ) ;
 DECL_PIOCTL ( PGetTokens ) ;
 DECL_PIOCTL ( PUnlog ) ;
 DECL_PIOCTL ( PMariner ) ;
 DECL_PIOCTL ( PCheckServers ) ;
 DECL_PIOCTL ( PCheckVolNames ) ;
 DECL_PIOCTL ( PCheckAuth ) ;
 DECL_PIOCTL ( PFindVolume ) ;
 DECL_PIOCTL ( PViceAccess )",0
Detect whether the following code contains vulnerabilities.,"static void glyph_position_destroy ( hb_glyph_position_t * g ) {
 free ( g ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"cmsBool _cmsRegisterMultiProcessElementPlugin ( cmsContext id , cmsPluginBase * Data ) {
 return RegisterTypesPlugin ( id , Data , MPEPlugin ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int ff_wmv2_decode_picture_header ( MpegEncContext * s ) {
 Wmv2Context * const w = ( Wmv2Context * ) s ;
 int code ;
 if ( s -> picture_number == 0 ) decode_ext_header ( w ) ;
 s -> pict_type = get_bits1 ( & s -> gb ) + 1 ;
 if ( s -> pict_type == AV_PICTURE_TYPE_I ) {
 code = get_bits ( & s -> gb , 7 ) ;
 av_log ( s -> avctx , AV_LOG_DEBUG , ""I7:%X/\n"" , code ) ;
 }
 s -> chroma_qscale = s -> qscale = get_bits ( & s -> gb , 5 ) ;
 if ( s -> qscale <= 0 ) return - 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cirrus_mem_writeb_mode4and5_16bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {
 int x ;
 unsigned val = mem_value ;
 uint8_t * dst ;
 dst = s -> vga . vram_ptr + ( offset &= s -> cirrus_addr_mask ) ;
 for ( x = 0 ;
 x < 8 ;
 x ++ ) {
 if ( val & 0x80 ) {
 * dst = s -> cirrus_shadow_gr1 ;
 * ( dst + 1 ) = s -> vga . gr [ 0x11 ] ;
 }
 else if ( mode == 5 ) {
 * dst = s -> cirrus_shadow_gr0 ;
 * ( dst + 1 ) = s -> vga . gr [ 0x10 ] ;
 }
 val <<= 1 ;
 dst += 2 ;
 }
 memory_region_set_dirty ( & s -> vga . vram , offset , 16 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void dissect_q931_cause_ie ( tvbuff_t * tvb , int offset , int len , proto_tree * tree , int hf_cause_value , guint8 * cause_value , const value_string * ie_vals ) {
 gboolean have_valid_q931_pi_save = have_valid_q931_pi ;
 have_valid_q931_pi = FALSE ;
 dissect_q931_cause_ie_unsafe ( tvb , offset , len , tree , hf_cause_value , cause_value , ie_vals ) ;
 have_valid_q931_pi = have_valid_q931_pi_save ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool check_grant_db_routine ( THD * thd , const char * db , HASH * hash ) {
 Security_context * sctx = thd -> security_ctx ;
 for ( uint idx = 0 ;
 idx < hash -> records ;
 ++ idx ) {
 GRANT_NAME * item = ( GRANT_NAME * ) hash_element ( hash , idx ) ;
 if ( strcmp ( item -> user , sctx -> priv_user ) == 0 && strcmp ( item -> db , db ) == 0 && compare_hostname ( & item -> host , sctx -> host , sctx -> ip ) ) {
 return FALSE ;
 }
 }
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"void ff_mpeg_flush ( AVCodecContext * avctx ) {
 int i ;
 MpegEncContext * s = avctx -> priv_data ;
 if ( s == NULL || s -> picture == NULL ) return ;
 for ( i = 0 ;
 i < s -> picture_count ;
 i ++ ) {
 if ( s -> picture [ i ] . f . data [ 0 ] && ( s -> picture [ i ] . f . type == FF_BUFFER_TYPE_INTERNAL || s -> picture [ i ] . f . type == FF_BUFFER_TYPE_USER ) ) free_frame_buffer ( s , & s -> picture [ i ] ) ;
 }
 s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ;
 s -> mb_x = s -> mb_y = 0 ;
 s -> parse_context . state = - 1 ;
 s -> parse_context . frame_start_found = 0 ;
 s -> parse_context . overread = 0 ;
 s -> parse_context . overread_index = 0 ;
 s -> parse_context . index = 0 ;
 s -> parse_context . last_index = 0 ;
 s -> bitstream_buffer_size = 0 ;
 s -> pp_time = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONGetMigrationStatus ( qemuMonitorPtr mon , int * status , unsigned long long * transferred , unsigned long long * remaining , unsigned long long * total ) {
 int ret ;
 virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( ""query-migrate"" , NULL ) ;
 virJSONValuePtr reply = NULL ;
 * status = 0 ;
 * transferred = * remaining = * total = 0 ;
 if ( ! cmd ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 if ( ret == 0 && qemuMonitorJSONGetMigrationStatusReply ( reply , status , transferred , remaining , total ) < 0 ) ret = - 1 ;
 virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int execstack2_continue ( i_ctx_t * i_ctx_p ) {
 os_ptr op = osp ;
 return do_execstack ( i_ctx_p , op -> value . boolval , op - 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {
 VP9_COMMON * const cm = & cpi -> common ;
 MACROBLOCK * const x = & cpi -> mb ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 MB_MODE_INFO * mbmi ;
 set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;
 mbmi = & xd -> mi [ 0 ] -> mbmi ;
 mbmi -> sb_type = bsize ;
 if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( mbmi -> segment_id && x -> in_static_area ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;
 if ( vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rate , dist , bsize ) ;
 else vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize , ctx ) ;
 duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t offsetTOCPrefixBinarySearch ( const char * s , const char * names , const UDataOffsetTOCEntry * toc , int32_t count ) {
 int32_t start = 0 ;
 int32_t limit = count ;
 int32_t startPrefixLength = 0 ;
 int32_t limitPrefixLength = 0 ;
 if ( count == 0 ) {
 return - 1 ;
 }
 if ( 0 == strcmpAfterPrefix ( s , names + toc [ 0 ] . nameOffset , & startPrefixLength ) ) {
 return 0 ;
 }
 ++ start ;
 -- limit ;
 if ( 0 == strcmpAfterPrefix ( s , names + toc [ limit ] . nameOffset , & limitPrefixLength ) ) {
 return limit ;
 }
 while ( start < limit ) {
 int32_t i = ( start + limit ) / 2 ;
 int32_t prefixLength = MIN ( startPrefixLength , limitPrefixLength ) ;
 int32_t cmp = strcmpAfterPrefix ( s , names + toc [ i ] . nameOffset , & prefixLength ) ;
 if ( cmp < 0 ) {
 limit = i ;
 limitPrefixLength = prefixLength ;
 }
 else if ( cmp == 0 ) {
 return i ;
 }
 else {
 start = i + 1 ;
 startPrefixLength = prefixLength ;
 }
 }
 return - 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void openpic_init ( Object * obj ) {
 OpenPICState * opp = OPENPIC ( obj ) ;
 memory_region_init ( & opp -> mem , obj , ""openpic"" , 0x40000 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {
 int length ;
 length = strlen ( filename ) ;
 if ( length > 0 ) {
 if ( ( filename [ 0 ] == '\""' ) && ( filename [ length - 1 ] == '\""' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;
 }
 return strdup ( filename ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int x_catch_free_colors ( Display * dpy , XErrorEvent * err ) {
 if ( err -> request_code == X_FreeColors ) return 0 ;
 return x_error_handler . orighandler ( dpy , err ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void kvm_arch_on_sigbus_vcpu ( CPUState * c , int code , void * addr ) {
 X86CPU * cpu = X86_CPU ( c ) ;
 CPUX86State * env = & cpu -> env ;
 ram_addr_t ram_addr ;
 hwaddr paddr ;
 assert ( code == BUS_MCEERR_AR || code == BUS_MCEERR_AO ) ;
 if ( ( env -> mcg_cap & MCG_SER_P ) && addr ) {
 ram_addr = qemu_ram_addr_from_host ( addr ) ;
 if ( ram_addr != RAM_ADDR_INVALID && kvm_physical_memory_addr_from_host ( c -> kvm_state , addr , & paddr ) ) {
 kvm_hwpoison_page_add ( ram_addr ) ;
 kvm_mce_inject ( cpu , paddr , code ) ;
 return ;
 }
 fprintf ( stderr , ""Hardware memory error for memory used by "" ""QEMU itself instead of guest system!\n"" ) ;
 }
 if ( code == BUS_MCEERR_AR ) {
 hardware_memory_error ( ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static time_t xstrpisotime ( const char * s , char * * endptr ) {
 struct tm tm ;
 time_t res = ( time_t ) - 1 ;
 memset ( & tm , 0 , sizeof ( tm ) ) ;
 while ( * s == ' ' || * s == '\t' ) ++ s ;
 if ( ( tm . tm_year = strtoi_lim ( s , & s , 1583 , 4095 ) ) < 0 || * s ++ != '-' ) {
 goto out ;
 }
 if ( ( tm . tm_mon = strtoi_lim ( s , & s , 1 , 12 ) ) < 0 || * s ++ != '-' ) {
 goto out ;
 }
 if ( ( tm . tm_mday = strtoi_lim ( s , & s , 1 , 31 ) ) < 0 || * s ++ != 'T' ) {
 goto out ;
 }
 if ( ( tm . tm_hour = strtoi_lim ( s , & s , 0 , 23 ) ) < 0 || * s ++ != ':' ) {
 goto out ;
 }
 if ( ( tm . tm_min = strtoi_lim ( s , & s , 0 , 59 ) ) < 0 || * s ++ != ':' ) {
 goto out ;
 }
 if ( ( tm . tm_sec = strtoi_lim ( s , & s , 0 , 60 ) ) < 0 || * s ++ != 'Z' ) {
 goto out ;
 }
 tm . tm_year -= 1900 ;
 tm . tm_mon -- ;
 res = time_from_tm ( & tm ) ;
 out : if ( endptr != NULL ) {
 * endptr = deconst ( s ) ;
 }
 return res ;
 }",0
Detect whether the following code contains vulnerabilities.,"int linux_udev_scan_devices ( struct libusb_context * ctx ) {
 struct udev_enumerate * enumerator ;
 struct udev_list_entry * devices , * entry ;
 struct udev_device * udev_dev ;
 const char * sys_name ;
 int r ;
 assert ( udev_ctx != NULL ) ;
 enumerator = udev_enumerate_new ( udev_ctx ) ;
 if ( NULL == enumerator ) {
 usbi_err ( ctx , ""error creating udev enumerator"" ) ;
 return LIBUSB_ERROR_OTHER ;
 }
 udev_enumerate_add_match_subsystem ( enumerator , ""usb"" ) ;
 udev_enumerate_scan_devices ( enumerator ) ;
 devices = udev_enumerate_get_list_entry ( enumerator ) ;
 udev_list_entry_foreach ( entry , devices ) {
 const char * path = udev_list_entry_get_name ( entry ) ;
 uint8_t busnum = 0 , devaddr = 0 ;
 udev_dev = udev_device_new_from_syspath ( udev_ctx , path ) ;
 r = udev_device_info ( ctx , 0 , udev_dev , & busnum , & devaddr , & sys_name ) ;
 if ( r ) {
 udev_device_unref ( udev_dev ) ;
 continue ;
 }
 linux_enumerate_device ( ctx , busnum , devaddr , sys_name ) ;
 udev_device_unref ( udev_dev ) ;
 }
 udev_enumerate_unref ( enumerator ) ;
 return LIBUSB_SUCCESS ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {
 update_consonant_positions ( plan , font , buffer ) ;
 insert_dotted_circles ( plan , font , buffer ) ;
 foreach_syllable ( buffer , start , end ) initial_reordering_syllable ( plan , font -> face , buffer , start , end ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClickedReusesBlank ) {
 int starting_tab_count = browser ( ) -> tab_strip_model ( ) -> count ( ) ;
 scoped_ptr < BookmarkBubbleDelegate > delegate ;
 delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;
 delegate -> OnSignInLinkClicked ( ) ;
 EXPECT_EQ ( starting_tab_count , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_opcua ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {
 tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , FRAME_HEADER_LEN , get_opcua_message_len , dissect_opcua_message , data ) ;
 return tvb_reported_length ( tvb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void safeputs ( netdissect_options * ndo , const u_char * s , const u_int maxlen ) {
 u_int idx = 0 ;
 while ( * s && idx < maxlen ) {
 safeputchar ( ndo , * s ) ;
 idx ++ ;
 s ++ ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) {
 if ( pic -> f . data [ 0 ] == NULL ) return 1 ;
 if ( pic -> needs_realloc && ! ( pic -> f . reference & DELAYED_PIC_REF ) ) if ( ! pic -> owner2 || pic -> owner2 == s ) return 1 ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"X509_NAME * GetX509NamePtr ( VALUE obj ) {
 X509_NAME * name ;
 SafeGetX509Name ( obj , name ) ;
 return name ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vble_restore_plane ( VBLEContext * ctx , int plane , int offset , int width , int height ) {
 AVFrame * pic = ctx -> avctx -> coded_frame ;
 uint8_t * dst = pic -> data [ plane ] ;
 uint8_t * val = ctx -> val + offset ;
 int stride = pic -> linesize [ plane ] ;
 int i , j , left , left_top ;
 for ( i = 0 ;
 i < height ;
 i ++ ) {
 for ( j = 0 ;
 j < width ;
 j ++ ) val [ j ] = ( val [ j ] >> 1 ) ^ - ( val [ j ] & 1 ) ;
 if ( i ) {
 left = 0 ;
 left_top = dst [ - stride ] ;
 ctx -> dsp . add_hfyu_median_prediction ( dst , dst - stride , val , width , & left , & left_top ) ;
 }
 else {
 dst [ 0 ] = val [ 0 ] ;
 for ( j = 1 ;
 j < width ;
 j ++ ) dst [ j ] = val [ j ] + dst [ j - 1 ] ;
 }
 dst += stride ;
 val += width ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static long usbdev_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) {
 int ret ;
 ret = usbdev_do_ioctl ( file , cmd , ( void __user * ) arg ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"Archive * CreateArchive ( const char * FileSpec , const ArchiveFormat fmt , const int compression , ArchiveMode mode , SetupWorkerPtr setupDumpWorker ) {
 ArchiveHandle * AH = _allocAH ( FileSpec , fmt , compression , mode , setupDumpWorker ) ;
 return ( Archive * ) AH ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _slurm_rpc_sib_job_lock ( uint32_t uid , slurm_msg_t * msg ) {
 int rc ;
 sib_msg_t * sib_msg = msg -> data ;
 if ( ! msg -> conn ) {
 error ( ""Security violation, SIB_JOB_LOCK RPC from uid=%d"" , uid ) ;
 slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;
 return ;
 }
 rc = fed_mgr_job_lock_set ( sib_msg -> job_id , sib_msg -> cluster_id ) ;
 slurm_send_rc_msg ( msg , rc ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int mime_hdr_length_get ( MIMEHdrImpl * mh ) {
 unsigned int length , index ;
 MIMEFieldBlockImpl * fblock ;
 MIMEField * field ;
 length = 2 ;
 for ( fblock = & ( mh -> m_first_fblock ) ;
 fblock != nullptr ;
 fblock = fblock -> m_next ) {
 for ( index = 0 ;
 index < fblock -> m_freetop ;
 index ++ ) {
 field = & ( fblock -> m_field_slots [ index ] ) ;
 if ( field -> is_live ( ) ) {
 length += mime_field_length_get ( field ) ;
 }
 }
 }
 return length ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fdct8x8_1_c ( const int16_t * input , int16_t * output , int stride ) {
 int r , c ;
 int16_t sum = 0 ;
 for ( r = 0 ;
 r < 8 ;
 ++ r ) for ( c = 0 ;
 c < 8 ;
 ++ c ) sum += input [ r * stride + c ] ;
 output [ 0 ] = sum ;
 output [ 1 ] = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_fdct32x32_c ( const int16_t * input , int16_t * out , int stride ) {
 int i , j ;
 int output [ 32 * 32 ] ;
 for ( i = 0 ;
 i < 32 ;
 ++ i ) {
 int temp_in [ 32 ] , temp_out [ 32 ] ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;
 fdct32 ( temp_in , temp_out , 0 ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) output [ j * 32 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] > 0 ) ) >> 2 ;
 }
 for ( i = 0 ;
 i < 32 ;
 ++ i ) {
 int temp_in [ 32 ] , temp_out [ 32 ] ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) temp_in [ j ] = output [ j + i * 32 ] ;
 fdct32 ( temp_in , temp_out , 0 ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) out [ j + i * 32 ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , setCsvControl ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 char delimiter = ',' , enclosure = '""' , escape = '\\' ;
 char * delim = NULL , * enclo = NULL , * esc = NULL ;
 int d_len = 0 , e_len = 0 , esc_len = 0 ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|sss"" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) {
 switch ( ZEND_NUM_ARGS ( ) ) {
 case 3 : if ( esc_len != 1 ) {
 php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""escape must be a character"" ) ;
 RETURN_FALSE ;
 }
 escape = esc [ 0 ] ;
 case 2 : if ( e_len != 1 ) {
 php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""enclosure must be a character"" ) ;
 RETURN_FALSE ;
 }
 enclosure = enclo [ 0 ] ;
 case 1 : if ( d_len != 1 ) {
 php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""delimiter must be a character"" ) ;
 RETURN_FALSE ;
 }
 delimiter = delim [ 0 ] ;
 case 0 : break ;
 }
 intern -> u . file . delimiter = delimiter ;
 intern -> u . file . enclosure = enclosure ;
 intern -> u . file . escape = escape ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void vp3_draw_horiz_band ( Vp3DecodeContext * s , int y ) {
 int h , cy , i ;
 int offset [ AV_NUM_DATA_POINTERS ] ;
 if ( HAVE_THREADS && s -> avctx -> active_thread_type & FF_THREAD_FRAME ) {
 int y_flipped = s -> flipped_image ? s -> avctx -> height - y : y ;
 ff_thread_report_progress ( & s -> current_frame , y_flipped == s -> avctx -> height ? INT_MAX : y_flipped - 1 , 0 ) ;
 }
 if ( s -> avctx -> draw_horiz_band == NULL ) return ;
 h = y - s -> last_slice_end ;
 s -> last_slice_end = y ;
 y -= h ;
 if ( ! s -> flipped_image ) {
 y = s -> avctx -> height - y - h ;
 }
 cy = y >> s -> chroma_y_shift ;
 offset [ 0 ] = s -> current_frame . linesize [ 0 ] * y ;
 offset [ 1 ] = s -> current_frame . linesize [ 1 ] * cy ;
 offset [ 2 ] = s -> current_frame . linesize [ 2 ] * cy ;
 for ( i = 3 ;
 i < AV_NUM_DATA_POINTERS ;
 i ++ ) offset [ i ] = 0 ;
 emms_c ( ) ;
 s -> avctx -> draw_horiz_band ( s -> avctx , & s -> current_frame , offset , y , 3 , h ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void do_system ( struct st_command * command ) {
 DYNAMIC_STRING ds_cmd ;
 DBUG_ENTER ( ""do_system"" ) ;
 if ( strlen ( command -> first_argument ) == 0 ) {
 report_or_die ( ""Missing arguments to system, nothing to do!"" ) ;
 return ;
 }
 init_dynamic_string ( & ds_cmd , 0 , command -> query_len + 64 , 256 ) ;
 do_eval ( & ds_cmd , command -> first_argument , command -> end , ! is_windows ) ;
 # ifdef __WIN__ # ifndef USE_CYGWIN while ( replace ( & ds_cmd , ""/devull"" , 9 , ""NUL"" , 3 ) == 0 ) ;
 # endif # endif DBUG_PRINT ( ""info"" , ( ""running system command '%s' as '%s'"" , command -> first_argument , ds_cmd . str ) ) ;
 if ( my_system ( & ds_cmd ) ) {
 if ( command -> abort_on_error ) report_or_die ( ""system command '%s' failed"" , command -> first_argument ) ;
 else {
 dynstr_append ( & ds_res , ""system command '"" ) ;
 replace_dynstr_append ( & ds_res , command -> first_argument ) ;
 dynstr_append ( & ds_res , ""' failed\n"" ) ;
 }
 }
 command -> last_argument = command -> end ;
 dynstr_free ( & ds_cmd ) ;
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_spellout_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 int32_t len ;
 double num ;
 UNumberFormat * format ;
 int32_t parsePos = 0 ;
 int32_t skipped ;
 UErrorCode status = U_ZERO_ERROR ;
 skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 ufile_fill_uchar_buffer ( input ) ;
 len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;
 if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;
 format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_SPELLOUT ) ;
 if ( format == 0 ) return 0 ;
 num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;
 if ( ! info -> fSkipArg ) {
 * ( double * ) ( args [ 0 ] . ptrValue ) = num ;
 }
 input -> str . fPos += parsePos ;
 * argConverted = ! info -> fSkipArg ;
 return parsePos + skipped ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void mktree ( struct tree_content * t , int v , struct strbuf * b ) {
 size_t maxlen = 0 ;
 unsigned int i ;
 if ( ! v ) qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp0 ) ;
 else qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp1 ) ;
 for ( i = 0 ;
 i < t -> entry_count ;
 i ++ ) {
 if ( t -> entries [ i ] -> versions [ v ] . mode ) maxlen += t -> entries [ i ] -> name -> str_len + 34 ;
 }
 strbuf_reset ( b ) ;
 strbuf_grow ( b , maxlen ) ;
 for ( i = 0 ;
 i < t -> entry_count ;
 i ++ ) {
 struct tree_entry * e = t -> entries [ i ] ;
 if ( ! e -> versions [ v ] . mode ) continue ;
 strbuf_addf ( b , ""%o %s%c"" , ( unsigned int ) ( e -> versions [ v ] . mode & ~ NO_DELTA ) , e -> name -> str_dat , '\0' ) ;
 strbuf_add ( b , e -> versions [ v ] . sha1 , 20 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t compareFallbacks ( const void * context , const void * fb1 , const void * fb2 ) {
 return ( ( const _MBCSToUFallback * ) fb1 ) -> offset - ( ( const _MBCSToUFallback * ) fb2 ) -> offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {
 int i ;
 struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ;
 if ( ext_fb_list == NULL ) return - 1 ;
 for ( i = 0 ;
 i < ext_fb_list -> num_external_frame_buffers ;
 ++ i ) {
 if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ;
 }
 if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ;
 if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {
 free ( ext_fb_list -> ext_fb [ i ] . data ) ;
 ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;
 if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;
 ext_fb_list -> ext_fb [ i ] . size = min_size ;
 }
 fb -> data = ext_fb_list -> ext_fb [ i ] . data ;
 fb -> size = ext_fb_list -> ext_fb [ i ] . size ;
 ext_fb_list -> ext_fb [ i ] . in_use = 1 ;
 fb -> priv = & ext_fb_list -> ext_fb [ i ] ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void arm_gic_realize ( DeviceState * dev , Error * * errp ) {
 int i ;
 GICState * s = ARM_GIC ( dev ) ;
 SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ;
 ARMGICClass * agc = ARM_GIC_GET_CLASS ( s ) ;
 agc -> parent_realize ( dev , errp ) ;
 if ( error_is_set ( errp ) ) {
 return ;
 }
 gic_init_irqs_and_distributor ( s , s -> num_irq ) ;
 memory_region_init_io ( & s -> cpuiomem [ 0 ] , OBJECT ( s ) , & gic_thiscpu_ops , s , ""gic_cpu"" , 0x100 ) ;
 for ( i = 0 ;
 i < NUM_CPU ( s ) ;
 i ++ ) {
 s -> backref [ i ] = s ;
 memory_region_init_io ( & s -> cpuiomem [ i + 1 ] , OBJECT ( s ) , & gic_cpu_ops , & s -> backref [ i ] , ""gic_cpu"" , 0x100 ) ;
 }
 sysbus_init_mmio ( sbd , & s -> iomem ) ;
 for ( i = 0 ;
 i <= NUM_CPU ( s ) ;
 i ++ ) {
 sysbus_init_mmio ( sbd , & s -> cpuiomem [ i ] ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void user_data_key_destroy ( hb_user_data_key_t l ) {
 }",1
Detect whether the following code contains vulnerabilities.,"bool virLogProbablyLogMessage ( const char * str ) {
 bool ret = false ;
 if ( ! virLogRegex ) return false ;
 if ( regexec ( virLogRegex , str , 0 , NULL , 0 ) == 0 ) ret = true ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void fts_build_parse_content_type ( struct fts_mail_build_context * ctx , const struct message_header_line * hdr ) {
 struct rfc822_parser_context parser ;
 string_t * content_type ;
 if ( ctx -> content_type != NULL ) return ;
 rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 T_BEGIN {
 content_type = t_str_new ( 64 ) ;
 ( void ) rfc822_parse_content_type ( & parser , content_type ) ;
 ctx -> content_type = str_lcase ( i_strdup ( str_c ( content_type ) ) ) ;
 }
 T_END ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool _is_valid_will_run_user ( job_desc_msg_t * job_desc_msg , uid_t uid ) {
 char * account = NULL ;
 if ( ( uid == job_desc_msg -> user_id ) || validate_operator ( uid ) ) return true ;
 if ( job_desc_msg -> job_id != NO_VAL ) {
 struct job_record * job_ptr ;
 job_ptr = find_job_record ( job_desc_msg -> job_id ) ;
 if ( job_ptr ) account = job_ptr -> account ;
 }
 else if ( job_desc_msg -> account ) account = job_desc_msg -> account ;
 if ( account && assoc_mgr_is_user_acct_coord ( acct_db_conn , uid , account ) ) return true ;
 return false ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , func_name ) \ {
 \ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 \ zend_error_handling error_handling ;
 \ if ( zend_parse_parameters_none ( ) == FAILURE ) {
 \ return ;
 \ }
 \ \ zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;
 \ spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;
 \ php_stat ( intern -> file_name , intern -> file_name_len , func_num , return_value TSRMLS_CC ) ;
 \ zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 \ }
 FileInfoFunction ( getPerms , FS_PERMS ) FileInfoFunction ( getInode , FS_INODE ) FileInfoFunction ( getSize , FS_SIZE ) FileInfoFunction ( getOwner , FS_OWNER ) FileInfoFunction ( getGroup , FS_GROUP ) FileInfoFunction ( getATime , FS_ATIME ) FileInfoFunction ( getMTime , FS_MTIME ) FileInfoFunction ( getCTime , FS_CTIME ) FileInfoFunction ( getType , FS_TYPE ) FileInfoFunction ( isWritable , FS_IS_W ) FileInfoFunction ( isReadable , FS_IS_R ) FileInfoFunction ( isExecutable , FS_IS_X ) FileInfoFunction ( isFile , FS_IS_FILE )",0
Detect whether the following code contains vulnerabilities.,"static int purge_bin_logs_to ( MYSQL * mysql_con , char * log_name ) {
 DYNAMIC_STRING str ;
 int err ;
 init_dynamic_string_checked ( & str , ""PURGE BINARY LOGS TO '"" , 1024 , 1024 ) ;
 dynstr_append_checked ( & str , log_name ) ;
 dynstr_append_checked ( & str , ""'"" ) ;
 err = mysql_query_with_error_report ( mysql_con , 0 , str . str ) ;
 dynstr_free ( & str ) ;
 return err ;
 }",0
Detect whether the following code contains vulnerabilities.,"gboolean pk_transaction_set_tid ( PkTransaction * transaction , const gchar * tid ) {
 static const GDBusInterfaceVTable interface_vtable = {
 pk_transaction_method_call , pk_transaction_get_property , NULL }
 ;
 g_return_val_if_fail ( PK_IS_TRANSACTION ( transaction ) , FALSE ) ;
 g_return_val_if_fail ( tid != NULL , FALSE ) ;
 g_return_val_if_fail ( transaction -> priv -> tid == NULL , FALSE ) ;
 transaction -> priv -> tid = g_strdup ( tid ) ;
 transaction -> priv -> connection = g_bus_get_sync ( G_BUS_TYPE_SYSTEM , NULL , NULL ) ;
 g_assert ( transaction -> priv -> connection != NULL ) ;
 transaction -> priv -> registration_id = g_dbus_connection_register_object ( transaction -> priv -> connection , tid , transaction -> priv -> introspection -> interfaces [ 0 ] , & interface_vtable , transaction , NULL , NULL ) ;
 g_assert ( transaction -> priv -> registration_id > 0 ) ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"void qemu_cpu_kick_self ( void ) {
 # ifndef _WIN32 assert ( current_cpu ) ;
 if ( ! current_cpu -> thread_kicked ) {
 qemu_cpu_kick_thread ( current_cpu ) ;
 current_cpu -> thread_kicked = true ;
 }
 # else abort ( ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void inter_predictor ( const uint8_t * src , int src_stride , uint8_t * dst , int dst_stride , const int subpel_x , const int subpel_y , const struct scale_factors * sf , int w , int h , int ref , const InterpKernel * kernel , int xs , int ys ) {
 sf -> predict [ subpel_x != 0 ] [ subpel_y != 0 ] [ ref ] ( src , src_stride , dst , dst_stride , kernel [ subpel_x ] , xs , kernel [ subpel_y ] , ys , w , h ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void mpi_set_ui ( MPI w , unsigned long u ) {
 RESIZE_IF_NEEDED ( w , 1 ) ;
 w -> d [ 0 ] = u ;
 w -> nlimbs = u ? 1 : 0 ;
 w -> sign = 0 ;
 w -> nbits = 0 ;
 w -> flags = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void rtp_free_hash_dyn_payload ( GHashTable * rtp_dyn_payload ) {
 if ( rtp_dyn_payload == NULL ) return ;
 g_hash_table_destroy ( rtp_dyn_payload ) ;
 rtp_dyn_payload = NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"METHOD ( certificate_t , destroy , void , private_x509_cert_t * this ) {
 if ( ref_put ( & this -> ref ) ) {
 this -> subjectAltNames -> destroy_offset ( this -> subjectAltNames , offsetof ( identification_t , destroy ) ) ;
 this -> crl_uris -> destroy_function ( this -> crl_uris , ( void * ) crl_uri_destroy ) ;
 this -> ocsp_uris -> destroy_function ( this -> ocsp_uris , free ) ;
 this -> ipAddrBlocks -> destroy_offset ( this -> ipAddrBlocks , offsetof ( traffic_selector_t , destroy ) ) ;
 this -> permitted_names -> destroy_offset ( this -> permitted_names , offsetof ( identification_t , destroy ) ) ;
 this -> excluded_names -> destroy_offset ( this -> excluded_names , offsetof ( identification_t , destroy ) ) ;
 this -> cert_policies -> destroy_function ( this -> cert_policies , ( void * ) cert_policy_destroy ) ;
 this -> policy_mappings -> destroy_function ( this -> policy_mappings , ( void * ) policy_mapping_destroy ) ;
 DESTROY_IF ( this -> issuer ) ;
 DESTROY_IF ( this -> subject ) ;
 DESTROY_IF ( this -> public_key ) ;
 chunk_free ( & this -> authKeyIdentifier ) ;
 chunk_free ( & this -> encoding ) ;
 chunk_free ( & this -> encoding_hash ) ;
 if ( ! this -> parsed ) {
 chunk_free ( & this -> signature ) ;
 chunk_free ( & this -> serialNumber ) ;
 chunk_free ( & this -> tbsCertificate ) ;
 }
 free ( this ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static COMMANDS * find_command ( char cmd_char ) {
 DBUG_ENTER ( ""find_command"" ) ;
 DBUG_PRINT ( ""enter"" , ( ""cmd_char: %d"" , cmd_char ) ) ;
 int index = - 1 ;
 if ( real_binary_mode ) {
 if ( cmd_char == 'C' ) index = charset_index ;
 }
 else index = get_command_index ( cmd_char ) ;
 if ( index >= 0 ) {
 DBUG_PRINT ( ""exit"" , ( ""found command: %s"" , commands [ index ] . name ) ) ;
 DBUG_RETURN ( & commands [ index ] ) ;
 }
 else DBUG_RETURN ( ( COMMANDS * ) 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void TSTextLogObjectRollingIntervalSecSet ( TSTextLogObject the_object , int rolling_interval_sec ) {
 sdk_assert ( sdk_sanity_check_iocore_structure ( the_object ) == TS_SUCCESS ) ;
 ( ( TextLogObject * ) the_object ) -> set_rolling_interval_sec ( rolling_interval_sec ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , TX_SIZE tx_size , PREDICTION_MODE mode , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {
 const int bwl = bwl_in - tx_size ;
 const int wmask = ( 1 << bwl ) - 1 ;
 const int have_top = ( block_idx >> bwl ) || xd -> up_available ;
 const int have_left = ( block_idx & wmask ) || xd -> left_available ;
 const int have_right = ( ( block_idx & wmask ) != wmask ) ;
 const int x = aoff * 4 ;
 const int y = loff * 4 ;
 assert ( bwl >= 0 ) ;
 build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"char * vpx_svc_get_rc_stats_buffer ( const SvcContext * svc_ctx ) {
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL ) return NULL ;
 return si -> rc_stats_buf ;
 }",1
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 const int ref_frame_flags = va_arg ( args , int ) ;
 vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ;
 return VPX_CODEC_OK ;
 }",0
Detect whether the following code contains vulnerabilities.,"static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {
 struct object * obj = & tree -> object ;
 struct tree_desc desc ;
 struct name_entry entry ;
 struct name_path me ;
 obj -> flags |= LOCAL ;
 if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;
 if ( parse_tree ( tree ) < 0 ) die ( ""bad tree object %s"" , oid_to_hex ( & obj -> oid ) ) ;
 obj -> flags |= SEEN ;
 name = xstrdup ( name ) ;
 p = add_one_object ( obj , p ) ;
 me . up = path ;
 me . elem = name ;
 me . elem_len = strlen ( name ) ;
 init_tree_desc ( & desc , tree -> buffer , tree -> size ) ;
 while ( tree_entry ( & desc , & entry ) ) switch ( object_type ( entry . mode ) ) {
 case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;
 break ;
 case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;
 break ;
 default : break ;
 }
 free_tree_buffer ( tree ) ;
 return p ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x6 ( IpvideoContext * s ) {
 av_log ( s -> avctx , AV_LOG_ERROR , "" Interplay video: Help! Mystery opcode 0x6 seen\n"" ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cmd_window_move_up ( void ) {
 MAIN_WINDOW_REC * rec ;
 rec = mainwindows_find_upper_left ( active_mainwin ) ;
 if ( rec != NULL ) window_reparent ( active_win , rec ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) {
 EVP_CIPHER_CTX * ctx ;
 int key_len ;
 StringValue ( key ) ;
 GetCipher ( self , ctx ) ;
 key_len = EVP_CIPHER_CTX_key_length ( ctx ) ;
 if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key must be %d bytes"" , key_len ) ;
 if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;
 return key ;
 }",1
Detect whether the following code contains vulnerabilities.,"static UChar32 T_UConverter_getNextUChar_UTF32_LE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {
 const uint8_t * mySource ;
 UChar32 myUChar ;
 int32_t length ;
 mySource = ( const uint8_t * ) args -> source ;
 if ( mySource >= ( const uint8_t * ) args -> sourceLimit ) {
 * err = U_INDEX_OUTOFBOUNDS_ERROR ;
 return 0xffff ;
 }
 length = ( int32_t ) ( ( const uint8_t * ) args -> sourceLimit - mySource ) ;
 if ( length < 4 ) {
 uprv_memcpy ( args -> converter -> toUBytes , mySource , length ) ;
 args -> converter -> toULength = ( int8_t ) length ;
 args -> source = ( const char * ) ( mySource + length ) ;
 * err = U_TRUNCATED_CHAR_FOUND ;
 return 0xffff ;
 }
 myUChar = ( ( UChar32 ) mySource [ 3 ] << 24 ) | ( ( UChar32 ) mySource [ 2 ] << 16 ) | ( ( UChar32 ) mySource [ 1 ] << 8 ) | ( ( UChar32 ) mySource [ 0 ] ) ;
 args -> source = ( const char * ) ( mySource + 4 ) ;
 if ( ( uint32_t ) myUChar <= MAXIMUM_UTF && ! U_IS_SURROGATE ( myUChar ) ) {
 return myUChar ;
 }
 uprv_memcpy ( args -> converter -> toUBytes , mySource , 4 ) ;
 args -> converter -> toULength = 4 ;
 * err = U_ILLEGAL_CHAR_FOUND ;
 return 0xffff ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int nsv_probe ( AVProbeData * p ) {
 int i , score = 0 ;
 if ( p -> buf [ 0 ] == 'N' && p -> buf [ 1 ] == 'S' && p -> buf [ 2 ] == 'V' && ( p -> buf [ 3 ] == 'f' || p -> buf [ 3 ] == 's' ) ) return AVPROBE_SCORE_MAX ;
 for ( i = 1 ;
 i < p -> buf_size - 3 ;
 i ++ ) {
 if ( AV_RL32 ( p -> buf + i ) == AV_RL32 ( ""NSVs"" ) ) {
 int vsize = AV_RL24 ( p -> buf + i + 19 ) >> 4 ;
 int asize = AV_RL16 ( p -> buf + i + 22 ) ;
 int offset = i + 23 + asize + vsize + 1 ;
 if ( offset <= p -> buf_size - 2 && AV_RL16 ( p -> buf + offset ) == 0xBEEF ) return 4 * AVPROBE_SCORE_MAX / 5 ;
 score = AVPROBE_SCORE_MAX / 5 ;
 }
 }
 if ( av_match_ext ( p -> filename , ""nsv"" ) ) return AVPROBE_SCORE_EXTENSION ;
 return score ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE mFloat_to_json ( int argc , VALUE * argv , VALUE self ) {
 GENERATE_JSON ( float ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UBool action_setInverse ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {
 ubidi_setInverse ( pTransform -> pBidi , TRUE ) ;
 ubidi_setReorderingMode ( pTransform -> pBidi , UBIDI_REORDER_INVERSE_LIKE_DIRECT ) ;
 return FALSE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * html_replace ( char ch , char * buf ) {
 switch ( ch ) {
 case '<' : return ""&lt;
"" ;
 case '>' : return ""&gt;
"" ;
 case '""' : return ""&quot;
"" ;
 case '\'' : return ""&#039;
"" ;
 case '&' : return ""&amp;
"" ;
 default : break ;
 }
 buf [ 0 ] = ch ;
 buf [ 1 ] = '\0' ;
 return buf ;
 }",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION ( locale_accept_from_http ) {
 UEnumeration * available ;
 char * http_accept = NULL ;
 int http_accept_len ;
 UErrorCode status = 0 ;
 int len ;
 char resultLocale [ INTL_MAX_LOCALE_LEN + 1 ] ;
 UAcceptResult outResult ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s"" , & http_accept , & http_accept_len ) == FAILURE ) {
 intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , ""locale_accept_from_http: unable to parse input parameters"" , 0 TSRMLS_CC ) ;
 RETURN_FALSE ;
 }
 available = ures_openAvailableLocales ( NULL , & status ) ;
 INTL_CHECK_STATUS ( status , ""locale_accept_from_http: failed to retrieve locale list"" ) ;
 len = uloc_acceptLanguageFromHTTP ( resultLocale , INTL_MAX_LOCALE_LEN , & outResult , http_accept , available , & status ) ;
 uenum_close ( available ) ;
 INTL_CHECK_STATUS ( status , ""locale_accept_from_http: failed to find acceptable locale"" ) ;
 if ( len < 0 || outResult == ULOC_ACCEPT_FAILED ) {
 RETURN_FALSE ;
 }
 RETURN_STRINGL ( resultLocale , len , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 883 ""./asn1/h225/h225.cnf"" const gchar * oid_str = NULL ;
 gef_ctx_t * gefx ;
 offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) gefx -> id = oid_str ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Both_NonHtmlMainResource ) {
 StartHttpServer ( ) ;
 StartHttpsServer ( false ) ;
 NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( ""/circle.svg"" ) , https_test_server_ -> GetURL ( ""/circle.svg"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_block_size ( VP9_COMP * const cpi , int mi_row , int mi_col , BLOCK_SIZE bsize ) {
 if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {
 MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;
 set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;
 xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;
 duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int * __xmlParserDebugEntities ( void ) {
 if ( IS_MAIN_THREAD ) return ( & xmlParserDebugEntities ) ;
 else return ( & xmlGetGlobalState ( ) -> xmlParserDebugEntities ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int execstack_continue ( i_ctx_t * i_ctx_p ) {
 os_ptr op = osp ;
 return do_execstack ( i_ctx_p , false , op ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int main_open_output ( xd3_stream * stream , main_file * ofile ) {
 int ret ;
 if ( option_no_output ) {
 return 0 ;
 }
 if ( ofile -> filename == NULL ) {
 XSTDOUT_XF ( ofile ) ;
 if ( option_verbose > 1 ) {
 XPR ( NT ""using standard output: %s\n"" , ofile -> filename ) ;
 }
 }
 else {
 if ( option_force == 0 && main_file_exists ( ofile ) ) {
 if ( ! option_quiet ) {
 XPR ( NT ""to overwrite output file specify -f: %s\n"" , ofile -> filename ) ;
 }
 return EEXIST ;
 }
 if ( ( ret = main_file_open ( ofile , ofile -> filename , XO_WRITE ) ) ) {
 return ret ;
 }
 if ( option_verbose > 1 ) {
 XPR ( NT ""output %s\n"" , ofile -> filename ) ;
 }
 }
 # if EXTERNAL_COMPRESSION if ( ofile -> compressor != NULL && option_recompress_outputs == 1 ) {
 if ( ! option_quiet ) {
 XPR ( NT ""externally compressed output: %s %s%s > %s\n"" , ofile -> compressor -> recomp_cmdname , ofile -> compressor -> recomp_options , ( option_force2 ? "" -f"" : """" ) , ofile -> filename ) ;
 }
 if ( ( ret = main_recompress_output ( ofile ) ) ) {
 return ret ;
 }
 }
 # endif return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int handle_cpu_signal ( uintptr_t pc , unsigned long address , int is_write , sigset_t * old_set , void * puc ) {
 int ret ;
 # if defined ( DEBUG_SIGNAL ) qemu_printf ( ""qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\n"" , pc , address , is_write , * ( unsigned long * ) old_set ) ;
 # endif if ( is_write && h2g_valid ( address ) && page_unprotect ( h2g ( address ) , pc , puc ) ) {
 return 1 ;
 }
 ret = cpu_handle_mmu_fault ( cpu_single_env , address , is_write , MMU_USER_IDX ) ;
 if ( ret < 0 ) {
 return 0 ;
 }
 if ( ret == 0 ) {
 return 1 ;
 }
 cpu_restore_state ( cpu_single_env , pc ) ;
 sigprocmask ( SIG_SETMASK , old_set , NULL ) ;
 exception_action ( cpu_single_env ) ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static usize_t main_get_winsize ( main_file * ifile ) {
 xoff_t file_size = 0 ;
 usize_t size = option_winsize ;
 static shortbuf iszbuf ;
 if ( main_file_stat ( ifile , & file_size ) == 0 ) {
 size = ( usize_t ) min ( file_size , ( xoff_t ) size ) ;
 }
 size = max ( size , XD3_ALLOCSIZE ) ;
 if ( option_verbose > 1 ) {
 XPR ( NT ""input %s window size %s\n"" , ifile -> filename , main_format_bcnt ( size , & iszbuf ) ) ;
 }
 return size ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void eval_lpcenv ( TwinContext * tctx , const float * cos_vals , float * lpc ) {
 int i ;
 const ModeTab * mtab = tctx -> mtab ;
 int size_s = mtab -> size / mtab -> fmode [ FT_SHORT ] . sub ;
 for ( i = 0 ;
 i < size_s / 2 ;
 i ++ ) {
 float cos_i = tctx -> cos_tabs [ 0 ] [ i ] ;
 lpc [ i ] = eval_lpc_spectrum ( cos_vals , cos_i , mtab -> n_lsp ) ;
 lpc [ size_s - i - 1 ] = eval_lpc_spectrum ( cos_vals , - cos_i , mtab -> n_lsp ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , IgnoreDownloads ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 base : : ScopedAllowBlockingForTesting allow_blocking ;
 base : : ScopedTempDir downloads_directory ;
 ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;
 browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;
 content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/download-test3.gif"" ) ) ;
 downloads_observer . WaitForFinished ( ) ;
 NavigateToUntrackedUrl ( ) ;
 EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << ""Recorded metrics: "" << GetRecordedPageLoadMetricNames ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void my_coll_agg_error ( Item * * args , uint count , const char * fname , int item_sep ) {
 if ( count == 2 ) my_coll_agg_error ( args [ 0 ] -> collation , args [ item_sep ] -> collation , fname ) ;
 else if ( count == 3 ) my_coll_agg_error ( args [ 0 ] -> collation , args [ item_sep ] -> collation , args [ 2 * item_sep ] -> collation , fname ) ;
 else my_error ( ER_CANT_AGGREGATE_NCOLLATIONS , MYF ( 0 ) , fname ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int event_base_priority_init ( struct event_base * base , int npriorities ) {
 int i ;
 if ( base -> event_count_active ) return ( - 1 ) ;
 if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {
 for ( i = 0 ;
 i < base -> nactivequeues ;
 ++ i ) {
 free ( base -> activequeues [ i ] ) ;
 }
 free ( base -> activequeues ) ;
 }
 base -> nactivequeues = npriorities ;
 base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;
 if ( base -> activequeues == NULL ) event_err ( 1 , ""%s: calloc"" , __func__ ) ;
 for ( i = 0 ;
 i < base -> nactivequeues ;
 ++ i ) {
 base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;
 if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , ""%s: malloc"" , __func__ ) ;
 TAILQ_INIT ( base -> activequeues [ i ] ) ;
 }
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void SRP_user_pwd_free ( SRP_user_pwd * user_pwd ) {
 if ( user_pwd == NULL ) return ;
 BN_free ( user_pwd -> s ) ;
 BN_clear_free ( user_pwd -> v ) ;
 OPENSSL_free ( user_pwd -> id ) ;
 OPENSSL_free ( user_pwd -> info ) ;
 OPENSSL_free ( user_pwd ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DialedDigits ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 319 ""./asn1/h225/h225.cnf"" tvbuff_t * value_tvb = NULL ;
 guint len = 0 ;
 h225_packet_info * h225_pi ;
 offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , ""0123456789#*,"" , 13 , & value_tvb ) ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi && h225_pi -> is_destinationInfo == TRUE ) {
 if ( value_tvb ) {
 len = tvb_reported_length ( value_tvb ) ;
 if ( len > sizeof h225_pi -> dialedDigits - 1 ) len = sizeof h225_pi -> dialedDigits - 1 ;
 tvb_memcpy ( value_tvb , ( guint8 * ) h225_pi -> dialedDigits , 0 , len ) ;
 }
 h225_pi -> dialedDigits [ len ] = '\0' ;
 h225_pi -> is_destinationInfo = FALSE ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultDontBlock ) {
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""mailto"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_TRUE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int find_real_tpr_addr ( VAPICROMState * s , CPUX86State * env ) {
 hwaddr paddr ;
 target_ulong addr ;
 if ( s -> state == VAPIC_ACTIVE ) {
 return 0 ;
 }
 for ( addr = 0xfffff000 ;
 addr >= 0x80000000 ;
 addr -= TARGET_PAGE_SIZE ) {
 paddr = cpu_get_phys_page_debug ( env , addr ) ;
 if ( paddr != APIC_DEFAULT_ADDRESS ) {
 continue ;
 }
 s -> real_tpr_addr = addr + 0x80 ;
 update_guest_rom_state ( s ) ;
 return 0 ;
 }
 return - 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void lag_pred_line ( LagarithContext * l , uint8_t * buf , int width , int stride , int line ) {
 int L , TL ;
 if ( ! line ) {
 L = l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , width - 1 , buf [ 0 ] ) ;
 }
 else {
 L = buf [ width - stride - 1 ] ;
 if ( line == 1 ) {
 TL = l -> avctx -> pix_fmt == AV_PIX_FMT_YUV420P ? buf [ - stride ] : L ;
 }
 else {
 TL = buf [ width - ( 2 * stride ) - 1 ] ;
 }
 add_lag_median_prediction ( buf , buf - stride , buf , width , & L , & TL ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void extra_close_record ( struct ctl_extr_rec * ctl , int ce_size ) {
 int padding = 0 ;
 if ( ce_size > 0 ) extra_tell_used_size ( ctl , ce_size ) ;
 if ( ctl -> cur_len & 0x01 ) {
 ctl -> cur_len ++ ;
 if ( ctl -> bp != NULL ) ctl -> bp [ ctl -> cur_len ] = 0 ;
 padding = 1 ;
 }
 if ( ctl -> use_extr ) {
 if ( ctl -> ce_ptr != NULL ) set_SUSP_CE ( ctl -> ce_ptr , ctl -> extr_loc , ctl -> extr_off , ctl -> cur_len - padding ) ;
 }
 else ctl -> dr_len = ctl -> cur_len ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_regular_quantize_b_4x4 ( MACROBLOCK * x , int plane , int block , const int16_t * scan , const int16_t * iscan ) {
 MACROBLOCKD * const xd = & x -> e_mbd ;
 struct macroblock_plane * p = & x -> plane [ plane ] ;
 struct macroblockd_plane * pd = & xd -> plane [ plane ] ;
 vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"BerElement * der_alloc ( void ) {
 return ber_alloc_t ( LBER_USE_DER ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int find_best_16x16_intra ( VP9_COMP * cpi , PREDICTION_MODE * pbest_mode ) {
 MACROBLOCK * const x = & cpi -> mb ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 PREDICTION_MODE best_mode = - 1 , mode ;
 unsigned int best_err = INT_MAX ;
 for ( mode = DC_PRED ;
 mode <= TM_PRED ;
 mode ++ ) {
 unsigned int err ;
 xd -> mi [ 0 ] -> mbmi . mode = mode ;
 vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ;
 err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ) ;
 if ( err < best_err ) {
 best_err = err ;
 best_mode = mode ;
 }
 }
 if ( pbest_mode ) * pbest_mode = best_mode ;
 return best_err ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_UnregRequestReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 603 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_UnregRequestReason , UnregRequestReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void rgb_to_gray ( fz_context * ctx , const fz_colorspace * cs , const float * rgb , float * gray ) {
 float r = rgb [ 0 ] ;
 float g = rgb [ 1 ] ;
 float b = rgb [ 2 ] ;
 gray [ 0 ] = r * 0.3f + g * 0.59f + b * 0.11f ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x7_16 ( IpvideoContext * s ) {
 int x , y ;
 uint16_t P [ 2 ] ;
 unsigned int flags ;
 uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;
 P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 if ( ! ( P [ 0 ] & 0x8000 ) ) {
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;
 for ( ;
 flags != 1 ;
 flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;
 pixel_ptr += s -> line_inc ;
 }
 }
 else {
 flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y += 2 ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 , flags >>= 1 ) {
 pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;
 }
 pixel_ptr += s -> stride * 2 ;
 }
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static field_info * new_field_info ( proto_tree * tree , header_field_info * hfinfo , tvbuff_t * tvb , const gint start , const gint item_length ) {
 field_info * fi ;
 FIELD_INFO_NEW ( PNODE_POOL ( tree ) , fi ) ;
 fi -> hfinfo = hfinfo ;
 fi -> start = start ;
 fi -> start += ( tvb ) ? tvb_raw_offset ( tvb ) : 0 ;
 fi -> length = item_length ;
 fi -> tree_type = - 1 ;
 fi -> flags = 0 ;
 if ( ! PTREE_DATA ( tree ) -> visible ) FI_SET_FLAG ( fi , FI_HIDDEN ) ;
 fvalue_init ( & fi -> value , fi -> hfinfo -> type ) ;
 fi -> rep = NULL ;
 fi -> ds_tvb = tvb ? tvb_get_ds_tvb ( tvb ) : NULL ;
 fi -> appendix_start = 0 ;
 fi -> appendix_length = 0 ;
 return fi ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_denoiser_alloc ( VP9_DENOISER * denoiser , int width , int height , int ssx , int ssy , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif int border ) {
 int i , fail ;
 assert ( denoiser != NULL ) ;
 for ( i = 0 ;
 i < MAX_REF_FRAMES ;
 ++ i ) {
 fail = vp9_alloc_frame_buffer ( & denoiser -> running_avg_y [ i ] , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;
 if ( fail ) {
 vp9_denoiser_free ( denoiser ) ;
 return 1 ;
 }
 # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;
 # endif }
 fail = vp9_alloc_frame_buffer ( & denoiser -> mc_running_avg_y , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;
 if ( fail ) {
 vp9_denoiser_free ( denoiser ) ;
 return 1 ;
 }
 # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;
 # endif denoiser -> increase_denoising = 0 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static bluetooth_uuid_t get_service_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {
 wmem_tree_key_t key [ 4 ] ;
 guint32 frame_number ;
 handle_data_t * handle_data ;
 wmem_tree_t * sub_wmemtree ;
 bluetooth_uuid_t uuid ;
 memset ( & uuid , 0 , sizeof uuid ) ;
 frame_number = pinfo -> num ;
 key [ 0 ] . length = 1 ;
 key [ 0 ] . key = & bluetooth_data -> interface_id ;
 key [ 1 ] . length = 1 ;
 key [ 1 ] . key = & bluetooth_data -> adapter_id ;
 key [ 2 ] . length = 1 ;
 key [ 2 ] . key = & handle ;
 key [ 3 ] . length = 0 ;
 key [ 3 ] . key = NULL ;
 while ( handle > 0 ) {
 sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( handle_to_uuid , key ) ;
 handle_data = ( sub_wmemtree ) ? ( handle_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;
 if ( handle_data && handle_data -> type == ATTRIBUTE_TYPE_SERVICE ) {
 uuid = handle_data -> uuid ;
 return uuid ;
 }
 handle -= 1 ;
 }
 return uuid ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int yop_paint_block ( YopDecContext * s , int tag ) {
 if ( s -> src_end - s -> srcptr < paint_lut [ tag ] [ 3 ] ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""Packet too small.\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 s -> dstptr [ 0 ] = s -> srcptr [ 0 ] ;
 s -> dstptr [ 1 ] = s -> srcptr [ paint_lut [ tag ] [ 0 ] ] ;
 s -> dstptr [ s -> frame . linesize [ 0 ] ] = s -> srcptr [ paint_lut [ tag ] [ 1 ] ] ;
 s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = s -> srcptr [ paint_lut [ tag ] [ 2 ] ] ;
 s -> srcptr += paint_lut [ tag ] [ 3 ] ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int ber_len ( BerElement * ber ) {
 return ( ber -> ber_end - ber -> ber_buf ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * evhttp_method ( enum evhttp_cmd_type type ) {
 const char * method ;
 switch ( type ) {
 case EVHTTP_REQ_GET : method = ""GET"" ;
 break ;
 case EVHTTP_REQ_POST : method = ""POST"" ;
 break ;
 case EVHTTP_REQ_HEAD : method = ""HEAD"" ;
 break ;
 default : method = NULL ;
 break ;
 }
 return ( method ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int selinux_inet_conn_request ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) {
 struct sk_security_struct * sksec = sk -> sk_security ;
 int err ;
 u16 family = req -> rsk_ops -> family ;
 u32 connsid ;
 u32 peersid ;
 err = selinux_skb_peerlbl_sid ( skb , family , & peersid ) ;
 if ( err ) return err ;
 err = selinux_conn_sid ( sksec -> sid , peersid , & connsid ) ;
 if ( err ) return err ;
 req -> secid = connsid ;
 req -> peer_secid = peersid ;
 return selinux_netlbl_inet_conn_request ( req , family ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void idct4 ( const int16_t * input , int16_t * output ) {
 int16_t step [ 4 ] ;
 int temp1 , temp2 ;
 temp1 = ( input [ 0 ] + input [ 2 ] ) * cospi_16_64 ;
 temp2 = ( input [ 0 ] - input [ 2 ] ) * cospi_16_64 ;
 step [ 0 ] = dct_const_round_shift ( temp1 ) ;
 step [ 1 ] = dct_const_round_shift ( temp2 ) ;
 temp1 = input [ 1 ] * cospi_24_64 - input [ 3 ] * cospi_8_64 ;
 temp2 = input [ 1 ] * cospi_8_64 + input [ 3 ] * cospi_24_64 ;
 step [ 2 ] = dct_const_round_shift ( temp1 ) ;
 step [ 3 ] = dct_const_round_shift ( temp2 ) ;
 output [ 0 ] = step [ 0 ] + step [ 3 ] ;
 output [ 1 ] = step [ 1 ] + step [ 2 ] ;
 output [ 2 ] = step [ 1 ] - step [ 2 ] ;
 output [ 3 ] = step [ 0 ] - step [ 3 ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"op_array_table * get_op_array ( const gs_memory_t * mem , int size ) {
 gs_main_instance * minst = get_minst_from_memory ( mem ) ;
 return op_index_op_array_table ( minst -> i_ctx_p , size ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int split_field_copy ( Picture * dest , Picture * src , int parity , int id_add ) {
 int match = ! ! ( src -> reference & parity ) ;
 if ( match ) {
 COPY_PICTURE ( dest , src ) ;
 if ( parity != PICT_FRAME ) {
 pic_as_field ( dest , parity ) ;
 dest -> pic_id *= 2 ;
 dest -> pic_id += id_add ;
 }
 }
 return match ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int lang_compare_first_component ( const char * a , const char * b ) {
 unsigned int da , db ;
 const char * p ;
 p = strchr ( a , '-' ) ;
 da = p ? ( unsigned int ) ( p - a ) : strlen ( a ) ;
 p = strchr ( b , '-' ) ;
 db = p ? ( unsigned int ) ( p - b ) : strlen ( b ) ;
 return strncmp ( a , b , MAX ( da , db ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int libgsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 int i , ret ;
 LibGSMDecodeContext * s = avctx -> priv_data ;
 AVFrame * frame = data ;
 uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 int16_t * samples ;
 if ( buf_size < avctx -> block_align ) {
 av_log ( avctx , AV_LOG_ERROR , ""Packet is too small\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 frame -> nb_samples = avctx -> frame_size ;
 if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 samples = ( int16_t * ) frame -> data [ 0 ] ;
 for ( i = 0 ;
 i < avctx -> frame_size / GSM_FRAME_SIZE ;
 i ++ ) {
 if ( ( ret = gsm_decode ( s -> state , buf , samples ) ) < 0 ) return - 1 ;
 buf += GSM_BLOCK_SIZE ;
 samples += GSM_FRAME_SIZE ;
 }
 * got_frame_ptr = 1 ;
 return avctx -> block_align ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void short_usage ( FILE * f ) {
 short_usage_sub ( f ) ;
 fprintf ( f , ""For more options, use %s --help\n"" , my_progname_short ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool spec_ctrl_needed ( void * opaque ) {
 X86CPU * cpu = opaque ;
 CPUX86State * env = & cpu -> env ;
 return env -> spec_ctrl != 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _CompoundText_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 UConverterDataCompoundText * myConverterData = ( UConverterDataCompoundText * ) cnv -> extraInfo ;
 int32_t i ;
 for ( i = 1 ;
 i < NUM_OF_CONVERTERS ;
 i ++ ) {
 ucnv_MBCSGetUnicodeSetForUnicode ( myConverterData -> myConverterArray [ i ] , sa , which , pErrorCode ) ;
 }
 sa -> add ( sa -> set , 0x0000 ) ;
 sa -> add ( sa -> set , 0x0009 ) ;
 sa -> add ( sa -> set , 0x000A ) ;
 sa -> addRange ( sa -> set , 0x0020 , 0x007F ) ;
 sa -> addRange ( sa -> set , 0x00A0 , 0x00FF ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {
 struct segmentation * const seg = & cm -> seg ;
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 const BLOCK_SIZE bsize = mbmi -> sb_type ;
 int predicted_segment_id , segment_id ;
 if ( ! seg -> enabled ) return 0 ;
 predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;
 if ( ! seg -> update_map ) return predicted_segment_id ;
 if ( seg -> temporal_update ) {
 const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;
 mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ;
 segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;
 }
 else {
 segment_id = read_segment_id ( r , seg ) ;
 }
 set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;
 return segment_id ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {
 AVCodecParameters * par = stream -> codecpar ;
 if ( ! strcmp ( attr , ""packetization-mode"" ) ) {
 av_log ( s , AV_LOG_DEBUG , ""RTP Packetization Mode: %d\n"" , atoi ( value ) ) ;
 h264_data -> packetization_mode = atoi ( value ) ;
 if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""Interleaved RTP mode is not supported yet.\n"" ) ;
 }
 else if ( ! strcmp ( attr , ""profile-level-id"" ) ) {
 if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;
 }
 else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) {
 int ret ;
 if ( value [ strlen ( value ) - 1 ] == ',' ) {
 av_log ( s , AV_LOG_WARNING , ""Missing PPS in sprop-parameter-sets, ignoring\n"" ) ;
 return 0 ;
 }
 par -> extradata_size = 0 ;
 av_freep ( & par -> extradata ) ;
 ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;
 av_log ( s , AV_LOG_DEBUG , ""Extradata set to %p (size: %d)\n"" , par -> extradata , par -> extradata_size ) ;
 return ret ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Simple_Http ) {
 StartHttpServer ( ) ;
 base : : TimeDelta upper_bound = NavigateInForegroundAndCloseWithTiming ( http_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void fixDirToTreePath ( char * s ) {
 # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) || ( ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) && ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) ) char * t ;
 # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( t = s ;
 t = uprv_strchr ( t , U_FILE_SEP_CHAR ) ;
 ) {
 * t = U_TREE_ENTRY_SEP_CHAR ;
 }
 # endif # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) && ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( t = s ;
 t = uprv_strchr ( t , U_FILE_ALT_SEP_CHAR ) ;
 ) {
 * t = U_TREE_ENTRY_SEP_CHAR ;
 }
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 Msvideo1Context * s = avctx -> priv_data ;
 s -> buf = buf ;
 s -> size = buf_size ;
 s -> frame . reference = 1 ;
 s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( avctx -> reget_buffer ( avctx , & s -> frame ) ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""reget_buffer() failed\n"" ) ;
 return - 1 ;
 }
 if ( s -> mode_8bit ) {
 const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;
 if ( pal ) {
 memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;
 s -> frame . palette_has_changed = 1 ;
 }
 }
 if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;
 else msvideo1_decode_16bit ( s ) ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_rc_set_gf_max_interval ( const VP9_COMP * const cpi , RATE_CONTROL * const rc ) {
 const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;
 rc -> max_gf_interval = 16 ;
 rc -> static_scene_max_gf_interval = oxcf -> key_freq >> 1 ;
 if ( rc -> static_scene_max_gf_interval > ( MAX_LAG_BUFFERS * 2 ) ) rc -> static_scene_max_gf_interval = MAX_LAG_BUFFERS * 2 ;
 if ( is_altref_enabled ( cpi ) ) {
 if ( rc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) rc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ;
 }
 if ( rc -> max_gf_interval > rc -> static_scene_max_gf_interval ) rc -> max_gf_interval = rc -> static_scene_max_gf_interval ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {
 return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;
 }
 # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;
 typedef const char * OPENSSL_CSTRING ;
 DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )",1
Detect whether the following code contains vulnerabilities.,"static UBool _isVariantSubtag ( const char * s , int32_t len ) {
 if ( len < 0 ) {
 len = ( int32_t ) uprv_strlen ( s ) ;
 }
 if ( len >= 5 && len <= 8 && _isAlphaNumericString ( s , len ) ) {
 return TRUE ;
 }
 if ( len == 4 && ISNUMERIC ( * s ) && _isAlphaNumericString ( s + 1 , 3 ) ) {
 return TRUE ;
 }
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestIsSameOrigin ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/updated-url/%s"" ) , ""test2"" ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://other.com/%s"" ) , ""test"" ) ;
 ASSERT_EQ ( ph1 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph1 . IsSameOrigin ( ph2 ) ) ;
 ASSERT_EQ ( ph1 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph2 . IsSameOrigin ( ph1 ) ) ;
 ASSERT_EQ ( ph2 . url ( ) . GetOrigin ( ) == ph3 . url ( ) . GetOrigin ( ) , ph2 . IsSameOrigin ( ph3 ) ) ;
 ASSERT_EQ ( ph3 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph3 . IsSameOrigin ( ph2 ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void lag_pred_line_yuy2 ( LagarithContext * l , uint8_t * buf , int width , int stride , int line , int is_luma ) {
 int L , TL ;
 if ( ! line ) {
 if ( is_luma ) {
 buf ++ ;
 width -- ;
 }
 l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , width - 1 , buf [ 0 ] ) ;
 return ;
 }
 if ( line == 1 ) {
 const int HEAD = is_luma ? 4 : 2 ;
 int i ;
 L = buf [ width - stride - 1 ] ;
 TL = buf [ HEAD - stride - 1 ] ;
 for ( i = 0 ;
 i < HEAD ;
 i ++ ) {
 L += buf [ i ] ;
 buf [ i ] = L ;
 }
 buf += HEAD ;
 width -= HEAD ;
 }
 else {
 TL = buf [ width - ( 2 * stride ) - 1 ] ;
 L = buf [ width - stride - 1 ] ;
 }
 l -> dsp . add_hfyu_median_prediction ( buf , buf - stride , buf , width , & L , & TL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void get_hfi_length ( header_field_info * hfinfo , tvbuff_t * tvb , const gint start , gint * length , gint * item_length ) {
 gint length_remaining ;
 DISSECTOR_ASSERT ( tvb != NULL || * length == 0 ) ;
 if ( * length == - 1 ) {
 switch ( hfinfo -> type ) {
 case FT_PROTOCOL : case FT_NONE : case FT_BYTES : case FT_STRING : case FT_STRINGZPAD : * length = tvb_captured_length ( tvb ) ? tvb_ensure_captured_length_remaining ( tvb , start ) : 0 ;
 DISSECTOR_ASSERT ( * length >= 0 ) ;
 break ;
 case FT_STRINGZ : break ;
 default : THROW ( ReportedBoundsError ) ;
 DISSECTOR_ASSERT_NOT_REACHED ( ) ;
 }
 * item_length = * length ;
 }
 else {
 * item_length = * length ;
 if ( hfinfo -> type == FT_PROTOCOL || hfinfo -> type == FT_NONE ) {
 if ( tvb ) {
 length_remaining = tvb_captured_length_remaining ( tvb , start ) ;
 if ( * item_length < 0 || ( * item_length > 0 && ( length_remaining < * item_length ) ) ) * item_length = length_remaining ;
 }
 }
 if ( * item_length < 0 ) {
 THROW ( ReportedBoundsError ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int SRP_user_pwd_set_sv_BN ( SRP_user_pwd * vinfo , BIGNUM * s , BIGNUM * v ) {
 vinfo -> v = v ;
 vinfo -> s = s ;
 return ( vinfo -> s != NULL && vinfo -> v != NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int xmlListPushBack ( xmlListPtr l , void * data ) {
 xmlLinkPtr lkPlace , lkNew ;
 if ( l == NULL ) return ( 0 ) ;
 lkPlace = l -> sentinel -> prev ;
 if ( NULL == ( lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for new link"" ) ;
 return ( 0 ) ;
 }
 lkNew -> data = data ;
 lkNew -> next = lkPlace -> next ;
 ( lkPlace -> next ) -> prev = lkNew ;
 lkPlace -> next = lkNew ;
 lkNew -> prev = lkPlace ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static double calc_frame_boost ( const TWO_PASS * twopass , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out ) {
 double frame_boost ;
 if ( this_frame -> intra_error > twopass -> gf_intra_err_min ) frame_boost = ( IIFACTOR * this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;
 else frame_boost = ( IIFACTOR * twopass -> gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;
 if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ;
 else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ;
 return MIN ( frame_boost , GF_RMAX ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DisengageRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 646 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageRejectReason , DisengageRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void DangerousDownloadValidated ( JNIEnv * env , const JavaParamRef < jclass > & clazz , const JavaParamRef < jobject > & tab , jint download_id , jboolean accept ) {
 TabAndroid * tab_android = TabAndroid : : GetNativeTab ( env , tab ) ;
 content : : DownloadControllerAndroid : : Get ( ) -> DangerousDownloadValidated ( tab_android -> web_contents ( ) , download_id , accept ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void unixErrorHandler ( const char * module , const char * fmt , va_list ap ) {
 if ( module != NULL ) fprintf ( stderr , ""%s: "" , module ) ;
 vfprintf ( stderr , fmt , ap ) ;
 fprintf ( stderr , "".\n"" ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int selinux_inode_setsecctx ( struct dentry * dentry , void * ctx , u32 ctxlen ) {
 return __vfs_setxattr_noperm ( dentry , XATTR_NAME_SELINUX , ctx , ctxlen , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void * jas_malloc ( size_t size ) {
 void * result ;
 JAS_DBGLOG ( 101 , ( ""jas_malloc called with %zu\n"" , size ) ) ;
 result = malloc ( size ) ;
 JAS_DBGLOG ( 100 , ( ""jas_malloc(%zu) -> %p\n"" , size , result ) ) ;
 return result ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_ExtendedVideoCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ExtendedVideoCapability , ExtendedVideoCapability_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) {
 GdkScreen * screen ;
 char * uri ;
 GFile * file ;
 switch ( response_id ) {
 case RESPONSE_RUN : {
 screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ;
 uri = nautilus_file_get_uri ( parameters -> file ) ;
 DEBUG ( ""Launching untrusted launcher %s"" , uri ) ;
 nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;
 g_free ( uri ) ;
 }
 break ;
 case RESPONSE_MARK_TRUSTED : {
 file = nautilus_file_get_location ( parameters -> file ) ;
 nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;
 g_object_unref ( file ) ;
 }
 break ;
 default : {
 }
 break ;
 }
 gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;
 activate_parameters_desktop_free ( parameters ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void * vpx_svc_get_buffer ( SvcContext * svc_ctx ) {
 SvcInternal * const si = get_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return NULL ;
 if ( si -> frame_temp ) fd_free ( si -> frame_temp ) ;
 si -> frame_temp = si -> frame_list ;
 si -> frame_list = si -> frame_list -> next ;
 return si -> frame_temp -> buf ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct32x32_34_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 32 * 32 ] = {
 0 }
 ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 32 ] , temp_out [ 32 ] ;
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 idct32 ( input , outptr ) ;
 input += 32 ;
 outptr += 32 ;
 }
 for ( i = 0 ;
 i < 32 ;
 ++ i ) {
 for ( j = 0 ;
 j < 32 ;
 ++ j ) temp_in [ j ] = out [ j * 32 + i ] ;
 idct32 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int cinaudio_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 AVFrame * frame = data ;
 const uint8_t * buf = avpkt -> data ;
 CinAudioContext * cin = avctx -> priv_data ;
 const uint8_t * buf_end = buf + avpkt -> size ;
 int16_t * samples ;
 int delta , ret ;
 frame -> nb_samples = avpkt -> size - cin -> initial_decode_frame ;
 if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 samples = ( int16_t * ) frame -> data [ 0 ] ;
 delta = cin -> delta ;
 if ( cin -> initial_decode_frame ) {
 cin -> initial_decode_frame = 0 ;
 delta = sign_extend ( AV_RL16 ( buf ) , 16 ) ;
 buf += 2 ;
 * samples ++ = delta ;
 }
 while ( buf < buf_end ) {
 delta += cinaudio_delta16_table [ * buf ++ ] ;
 delta = av_clip_int16 ( delta ) ;
 * samples ++ = delta ;
 }
 cin -> delta = delta ;
 * got_frame_ptr = 1 ;
 return avpkt -> size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void add_dct ( MpegEncContext * s , int16_t * block , int i , uint8_t * dest , int line_size ) {
 if ( s -> block_last_index [ i ] >= 0 ) {
 s -> dsp . idct_add ( dest , line_size , block ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {
 char myhash [ 16 ] ;
 if ( len < 16 ) return ;
 if ( userid < 0 || userid >= created_users ) return ;
 if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;
 if ( ! users [ userid ] . authenticated ) return ;
 if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;
 if ( debug >= 1 ) {
 fprintf ( stderr , ""IN login raw, len %d, from user %d\n"" , len , userid ) ;
 }
 login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;
 if ( memcmp ( packet , myhash , 16 ) == 0 ) {
 struct sockaddr_in * tempin ;
 users [ userid ] . last_pkt = time ( NULL ) ;
 memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;
 tempin = ( struct sockaddr_in * ) & ( q -> from ) ;
 memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;
 user_set_conn_type ( userid , CONN_RAW_UDP ) ;
 login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;
 send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;
 users [ userid ] . authenticated_raw = 1 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_pointer_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 int32_t len ;
 int32_t skipped ;
 void * result ;
 void * * p = ( void * * ) ( args [ 0 ] . ptrValue ) ;
 skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 ufile_fill_uchar_buffer ( input ) ;
 len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;
 if ( info -> fWidth != - 1 ) {
 len = ufmt_min ( len , info -> fWidth ) ;
 }
 if ( len > ( int32_t ) ( sizeof ( void * ) * 2 ) ) {
 len = ( int32_t ) ( sizeof ( void * ) * 2 ) ;
 }
 result = ufmt_utop ( input -> str . fPos , & len ) ;
 if ( ! info -> fSkipArg ) {
 * p = result ;
 }
 input -> str . fPos += len ;
 * argConverted = ! info -> fSkipArg ;
 return len + skipped ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {
 arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;
 if ( unlikely ( ! arabic_plan ) ) return NULL ;
 arabic_plan -> do_fallback = plan -> props . script == HB_SCRIPT_ARABIC ;
 for ( unsigned int i = 0 ;
 i < ARABIC_NUM_FEATURES ;
 i ++ ) {
 arabic_plan -> mask_array [ i ] = plan -> map . get_1_mask ( arabic_features [ i ] ) ;
 arabic_plan -> do_fallback = arabic_plan -> do_fallback && ( FEATURE_IS_SYRIAC ( arabic_features [ i ] ) || plan -> map . needs_fallback ( arabic_features [ i ] ) ) ;
 }
 return arabic_plan ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int get_kf_active_quality ( const RATE_CONTROL * const rc , int q ) {
 return get_active_quality ( q , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int sethalftone_cleanup ( i_ctx_t * i_ctx_p ) {
 gx_device_halftone * pdht = r_ptr ( & esp [ 4 ] , gx_device_halftone ) ;
 gs_halftone * pht = r_ptr ( & esp [ 3 ] , gs_halftone ) ;
 gs_free_object ( pdht -> rc . memory , pdht , ""sethalftone_cleanup(device halftone)"" ) ;
 gs_free_object ( pht -> rc . memory , pht , ""sethalftone_cleanup(halftone)"" ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {
 struct segmentation * const seg = & cm -> seg ;
 const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;
 int segment_id ;
 if ( ! seg -> enabled ) return 0 ;
 if ( ! seg -> update_map ) return 0 ;
 segment_id = read_segment_id ( r , seg ) ;
 set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;
 return segment_id ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void ctr64_inc ( unsigned char * counter ) {
 int n = 8 ;
 unsigned char c ;
 do {
 -- n ;
 c = counter [ n ] ;
 ++ c ;
 counter [ n ] = c ;
 if ( c ) return ;
 }
 while ( n ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToAppMenu ) {
 TestBubbleAnchoredToAppMenu ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"EXCLUSIVE_REGRESSION_TEST ( SDK_API_HttpParentProxySet_Success ) ( RegressionTest * test , int level , int * pstatus ) {
 * pstatus = REGRESSION_TEST_INPROGRESS ;
 if ( level < REGRESSION_TEST_EXTENDED ) {
 * pstatus = REGRESSION_TEST_NOT_RUN ;
 return ;
 }
 TSCont cont = TSContCreate ( parent_proxy_handler , TSMutexCreate ( ) ) ;
 if ( cont == nullptr ) {
 SDK_RPRINT ( test , ""TSHttpTxnParentProxySet"" , ""SuccessCase"" , TC_FAIL , ""Unable to create continuation"" ) ;
 * pstatus = REGRESSION_TEST_FAILED ;
 return ;
 }
 ParentTest * ptest = new ParentTest ( test , pstatus ) ;
 ptest -> testcase = ""SuccessCase"" ;
 ptest -> handler = parent_proxy_success ;
 TSContDataSet ( cont , ptest ) ;
 TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont ) ;
 ptest -> os = synserver_create ( SYNSERVER_LISTEN_PORT , TSContCreate ( synserver_vc_accept , TSMutexCreate ( ) ) ) ;
 synserver_start ( ptest -> os ) ;
 TSContSchedule ( cont , 25 , TS_THREAD_POOL_DEFAULT ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"struct event_base * event_base_new ( void ) {
 int i ;
 struct event_base * base ;
 if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , ""%s: calloc"" , __func__ ) ;
 gettime ( base , & base -> event_tv ) ;
 min_heap_ctor ( & base -> timeheap ) ;
 TAILQ_INIT ( & base -> eventqueue ) ;
 base -> sig . ev_signal_pair [ 0 ] = - 1 ;
 base -> sig . ev_signal_pair [ 1 ] = - 1 ;
 base -> evbase = NULL ;
 for ( i = 0 ;
 eventops [ i ] && ! base -> evbase ;
 i ++ ) {
 base -> evsel = eventops [ i ] ;
 base -> evbase = base -> evsel -> init ( base ) ;
 }
 if ( base -> evbase == NULL ) event_errx ( 1 , ""%s: no event mechanism available"" , __func__ ) ;
 if ( evutil_getenv ( ""EVENT_SHOW_METHOD"" ) ) event_msgx ( ""libevent using: %s\n"" , base -> evsel -> name ) ;
 event_base_priority_init ( base , 1 ) ;
 return ( base ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void bprint_bytes ( AVBPrint * bp , const uint8_t * ubuf , size_t ubuf_size ) {
 int i ;
 av_bprintf ( bp , ""0X"" ) ;
 for ( i = 0 ;
 i < ubuf_size ;
 i ++ ) av_bprintf ( bp , ""%02X"" , ubuf [ i ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MaintenanceLoopRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_MaintenanceLoopRejectCause , MaintenanceLoopRejectCause_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {
 if ( _hb_glyph_info_ligated ( & info ) ) return false ;
 return ! ! ( FLAG ( info . myanmar_category ( ) ) & flags ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"ATF_TP_ADD_TCS ( tp ) {
 ATF_TP_ADD_TC ( tp , option_refcnt ) ;
 return ( atf_no_error ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int xmlIsBlank ( unsigned int ch ) {
 return ( xmlIsBlankQ ( ch ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void parse_ls ( const char * p , struct branch * b ) {
 struct tree_entry * root = NULL ;
 struct tree_entry leaf = {
 NULL }
 ;
 if ( * p == '""' ) {
 if ( ! b ) die ( ""Not in a commit: %s"" , command_buf . buf ) ;
 root = & b -> branch_tree ;
 }
 else {
 struct object_entry * e = parse_treeish_dataref ( & p ) ;
 root = new_tree_entry ( ) ;
 hashcpy ( root -> versions [ 1 ] . sha1 , e -> idx . sha1 ) ;
 if ( ! is_null_sha1 ( root -> versions [ 1 ] . sha1 ) ) root -> versions [ 1 ] . mode = S_IFDIR ;
 load_tree ( root ) ;
 }
 if ( * p == '""' ) {
 static struct strbuf uq = STRBUF_INIT ;
 const char * endp ;
 strbuf_reset ( & uq ) ;
 if ( unquote_c_style ( & uq , p , & endp ) ) die ( ""Invalid path: %s"" , command_buf . buf ) ;
 if ( * endp ) die ( ""Garbage after path in: %s"" , command_buf . buf ) ;
 p = uq . buf ;
 }
 tree_content_get ( root , p , & leaf , 1 ) ;
 if ( S_ISDIR ( leaf . versions [ 1 ] . mode ) ) store_tree ( & leaf ) ;
 print_ls ( leaf . versions [ 1 ] . mode , leaf . versions [ 1 ] . sha1 , p ) ;
 if ( leaf . tree ) release_tree_content_recursive ( leaf . tree ) ;
 if ( ! b || root != & b -> branch_tree ) release_tree_entry ( root ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t compareMappingsUnicodeFirst ( const void * context , const void * left , const void * right ) {
 return compareMappings ( ( UCMTable * ) context , ( const UCMapping * ) left , ( UCMTable * ) context , ( const UCMapping * ) right , TRUE ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline bool e1000e_rx_csum_enabled ( E1000ECore * core ) {
 return ( core -> mac [ RXCSUM ] & E1000_RXCSUM_PCSD ) ? false : true ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void memshl ( register int32_t * a , register int32_t * b ) {
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a ++ = * b ++ ;
 * a = * b ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_P ( GLES2DecoderTestWithCHROMIUMPathRendering , MatrixLoadfCHROMIUMImmediateValidArgs ) {
 cmds : : MatrixLoadfCHROMIUMImmediate & cmd = * GetImmediateAs < cmds : : MatrixLoadfCHROMIUMImmediate > ( ) ;
 SpecializedSetup < cmds : : MatrixLoadfCHROMIUMImmediate , 0 > ( true ) ;
 GLfloat temp [ 16 ] = {
 0 , }
 ;
 cmd . Init ( GL_PATH_PROJECTION_CHROMIUM , & temp [ 0 ] ) ;
 EXPECT_CALL ( * gl_ , MatrixLoadfEXT ( GL_PATH_PROJECTION_CHROMIUM , reinterpret_cast < GLfloat * > ( ImmediateDataAddress ( & cmd ) ) ) ) ;
 EXPECT_EQ ( error : : kNoError , ExecuteImmediateCmd ( cmd , sizeof ( temp ) ) ) ;
 EXPECT_EQ ( GL_NO_ERROR , GetGLError ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void spl_filesystem_info_set_filename ( spl_filesystem_object * intern , char * path , int len , int use_copy TSRMLS_DC ) {
 char * p1 , * p2 ;
 if ( intern -> file_name ) {
 efree ( intern -> file_name ) ;
 }
 intern -> file_name = use_copy ? estrndup ( path , len ) : path ;
 intern -> file_name_len = len ;
 while ( IS_SLASH_AT ( intern -> file_name , intern -> file_name_len - 1 ) && intern -> file_name_len > 1 ) {
 intern -> file_name [ intern -> file_name_len - 1 ] = 0 ;
 intern -> file_name_len -- ;
 }
 p1 = strrchr ( intern -> file_name , '/' ) ;
 # if defined ( PHP_WIN32 ) || defined ( NETWARE ) p2 = strrchr ( intern -> file_name , '\\' ) ;
 # else p2 = 0 ;
 # endif if ( p1 || p2 ) {
 intern -> _path_len = ( p1 > p2 ? p1 : p2 ) - intern -> file_name ;
 }
 else {
 intern -> _path_len = 0 ;
 }
 if ( intern -> _path ) {
 efree ( intern -> _path ) ;
 }
 intern -> _path = estrndup ( path , intern -> _path_len ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void e1000e_set_rx_control ( E1000ECore * core , int index , uint32_t val ) {
 core -> mac [ RCTL ] = val ;
 trace_e1000e_rx_set_rctl ( core -> mac [ RCTL ] ) ;
 if ( val & E1000_RCTL_EN ) {
 e1000e_parse_rxbufsize ( core ) ;
 e1000e_calc_rxdesclen ( core ) ;
 core -> rxbuf_min_shift = ( ( val / E1000_RCTL_RDMTS_QUAT ) & 3 ) + 1 + E1000_RING_DESC_LEN_SHIFT ;
 e1000e_start_recv ( core ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {
 size_t width = ( 79 - strlen ( prefix ) ) ;
 if ( ! config -> mute ) {
 size_t len ;
 char * ptr ;
 char * print_buffer ;
 print_buffer = curlx_mvaprintf ( fmt , ap ) ;
 if ( ! print_buffer ) return ;
 len = strlen ( print_buffer ) ;
 ptr = print_buffer ;
 while ( len > 0 ) {
 fputs ( prefix , config -> errors ) ;
 if ( len > width ) {
 size_t cut = width - 1 ;
 while ( ! ISSPACE ( ptr [ cut ] ) && cut ) {
 cut -- ;
 }
 if ( 0 == cut ) cut = width - 1 ;
 ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ;
 fputs ( ""\n"" , config -> errors ) ;
 ptr += cut + 1 ;
 len -= cut ;
 }
 else {
 fputs ( ptr , config -> errors ) ;
 len = 0 ;
 }
 }
 curl_free ( print_buffer ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"xmlHashTablePtr xmlHashCopy ( xmlHashTablePtr table , xmlHashCopier f ) {
 int i ;
 xmlHashEntryPtr iter ;
 xmlHashEntryPtr next ;
 xmlHashTablePtr ret ;
 if ( table == NULL ) return ( NULL ) ;
 if ( f == NULL ) return ( NULL ) ;
 ret = xmlHashCreate ( table -> size ) ;
 if ( table -> table ) {
 for ( i = 0 ;
 i < table -> size ;
 i ++ ) {
 if ( table -> table [ i ] . valid == 0 ) continue ;
 iter = & ( table -> table [ i ] ) ;
 while ( iter ) {
 next = iter -> next ;
 xmlHashAddEntry3 ( ret , iter -> name , iter -> name2 , iter -> name3 , f ( iter -> payload , iter -> name ) ) ;
 iter = next ;
 }
 }
 }
 ret -> nbElems = table -> nbElems ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) {
 return ( PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void ber_decode_as_dt ( const gchar * table_name _U_ , ftenum_t selector_type _U_ , gpointer key , gpointer value , gpointer user_data ) {
 da_data * decode_as_data ;
 decode_as_data = ( da_data * ) user_data ;
 decode_as_data -> func ( key , value , decode_as_data -> user_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_rsl_ie_smscb_mess ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {
 proto_item * ti ;
 proto_tree * ie_tree ;
 tvbuff_t * next_tvb ;
 guint length ;
 guint8 ie_id ;
 int ie_offset ;
 if ( is_mandatory == FALSE ) {
 ie_id = tvb_get_guint8 ( tvb , offset ) ;
 if ( ie_id != RSL_IE_SMSCB_MESS ) return offset ;
 }
 ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_smscb_mess , & ti , ""SMSCB Message IE"" ) ;
 proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;
 offset ++ ;
 length = tvb_get_guint8 ( tvb , offset ) ;
 proto_item_set_len ( ti , length + 2 ) ;
 proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;
 offset ++ ;
 ie_offset = offset ;
 next_tvb = tvb_new_subset_length ( tvb , offset , length ) ;
 call_dissector ( gsm_cbs_handle , next_tvb , pinfo , top_tree ) ;
 offset = ie_offset + length ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMediaContextDuringShutdown ) {
 StartActiveFetcherDuringProfileShutdownTest ( content : : BrowserContext : : GetDefaultStoragePartition ( browser ( ) -> profile ( ) ) -> GetMediaURLRequestContext ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void nlm_msg_res_unmatched_value_destroy ( gpointer value ) {
 nlm_msg_res_unmatched_data * umd = ( nlm_msg_res_unmatched_data * ) value ;
 g_free ( ( gpointer ) umd -> cookie ) ;
 g_free ( umd ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void tgq_idct_put_mb ( TgqContext * s , int16_t ( * block ) [ 64 ] , int mb_x , int mb_y ) {
 int linesize = s -> frame . linesize [ 0 ] ;
 uint8_t * dest_y = s -> frame . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = s -> frame . data [ 1 ] + ( mb_y * 8 * s -> frame . linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = s -> frame . data [ 2 ] + ( mb_y * 8 * s -> frame . linesize [ 2 ] ) + mb_x * 8 ;
 ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;
 if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 ff_ea_idct_put_c ( dest_cb , s -> frame . linesize [ 1 ] , block [ 4 ] ) ;
 ff_ea_idct_put_c ( dest_cr , s -> frame . linesize [ 2 ] , block [ 5 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONSavePhysicalMemory ( qemuMonitorPtr mon , unsigned long long offset , size_t length , const char * path ) {
 return qemuMonitorJSONSaveMemory ( mon , ""pmemsave"" , offset , length , path ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int vvalue_tvb_vector_internal ( tvbuff_t * tvb , int offset , struct vt_vector * val , struct vtype_data * type , guint num ) {
 const int offset_in = offset ;
 const gboolean varsize = ( type -> size == - 1 ) ;
 const guint elsize = varsize ? ( guint ) sizeof ( struct data_blob ) : ( guint ) type -> size ;
 guint8 * data ;
 int len ;
 guint i ;
 if ( ( guint64 ) elsize * ( guint64 ) num > G_MAXUINT ) {
 THROW ( ReportedBoundsError ) ;
 }
 tvb_ensure_bytes_exist ( tvb , offset , elsize * num ) ;
 data = ( guint8 * ) wmem_alloc ( wmem_packet_scope ( ) , elsize * num ) ;
 val -> len = num ;
 val -> u . vt_ui1 = data ;
 DISSECTOR_ASSERT ( ( void * ) & val -> u == ( ( void * ) & val -> u . vt_ui1 ) ) ;
 for ( i = 0 ;
 i < num ;
 i ++ ) {
 DISSECTOR_ASSERT_HINT ( type -> tvb_get != 0 , ""type that we don't know yet how to handle, please submit a bug with trace"" ) ;
 len = type -> tvb_get ( tvb , offset , data ) ;
 data += elsize ;
 offset += len ;
 if ( varsize && ( offset % 4 ) ) {
 int padding = 4 - ( offset % 4 ) ;
 offset += padding ;
 }
 }
 return offset - offset_in ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void move_file_to_low_priority_queue ( NautilusDirectory * directory , NautilusFile * file ) {
 nautilus_file_queue_enqueue ( directory -> details -> low_priority_queue , file ) ;
 nautilus_file_queue_remove ( directory -> details -> high_priority_queue , file ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void pxa2xx_rtc_swal1_tick ( void * opaque ) {
 PXA2xxRTCState * s = ( PXA2xxRTCState * ) opaque ;
 s -> rtsr |= ( 1 << 8 ) ;
 pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;
 pxa2xx_rtc_int_update ( s ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int BIO_vprintf ( BIO * bio , const char * format , va_list args ) {
 int ret ;
 size_t retlen ;
 char hugebuf [ 1024 * 2 ] ;
 char * hugebufp = hugebuf ;
 size_t hugebufsize = sizeof ( hugebuf ) ;
 char * dynbuf = NULL ;
 int ignored ;
 dynbuf = NULL ;
 CRYPTO_push_info ( ""doapr()"" ) ;
 _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , args ) ;
 if ( dynbuf ) {
 ret = BIO_write ( bio , dynbuf , ( int ) retlen ) ;
 OPENSSL_free ( dynbuf ) ;
 }
 else {
 ret = BIO_write ( bio , hugebuf , ( int ) retlen ) ;
 }
 CRYPTO_pop_info ( ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"proto_item * parseByte ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {
 proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 1 , ENC_LITTLE_ENDIAN ) ;
 * pOffset += 1 ;
 return item ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_nonCollapsingRaw ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 689 ""../../asn1/h245/h245.cnf"" tvbuff_t * value_tvb ;
 gef_ctx_t * parent_gefx ;
 gef_ctx_t * gefx ;
 parent_gefx = gef_ctx_get ( actx -> private_data ) ;
 actx -> private_data = gef_ctx_alloc ( parent_gefx , ""nonCollapsingRaw"" ) ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) {
 dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;
 }
 actx -> private_data = parent_gefx ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"const char * proto_get_protocol_long_name ( const protocol_t * protocol ) {
 if ( protocol == NULL ) return ""(none)"" ;
 return protocol -> name ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {
 if ( check_user_and_ip ( userid , q ) != 0 ) {
 return ;
 }
 users [ userid ] . last_pkt = time ( NULL ) ;
 memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;
 users [ userid ] . inpacket . offset = 0 ;
 memcpy ( users [ userid ] . inpacket . data , packet , len ) ;
 users [ userid ] . inpacket . len = len ;
 if ( debug >= 1 ) {
 fprintf ( stderr , ""IN pkt raw, total %d, from user %d\n"" , users [ userid ] . inpacket . len , userid ) ;
 }
 handle_full_packet ( tun_fd , dns_fd , userid ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {
 int i , j ;
 int16_t out [ 16 * 16 ] ;
 int16_t * outptr = out ;
 int16_t temp_in [ 16 ] , temp_out [ 16 ] ;
 const transform_2d ht = IHT_16 [ tx_type ] ;
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 ht . rows ( input , outptr ) ;
 input += 16 ;
 outptr += 16 ;
 }
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x0 ( IpvideoContext * s ) {
 return copy_from ( s , & s -> last_frame , 0 , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , isDot ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_BOOL ( spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void array_cleanup ( char * arr [ ] , int arr_size ) {
 int i = 0 ;
 for ( i = 0 ;
 i < arr_size ;
 i ++ ) {
 if ( arr [ i * 2 ] ) {
 efree ( arr [ i * 2 ] ) ;
 }
 }
 efree ( arr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * ContentTypeForFilename ( const char * filename , const char * prevtype ) {
 const char * contenttype = NULL ;
 unsigned int i ;
 struct ContentType {
 const char * extension ;
 const char * type ;
 }
 ;
 static const struct ContentType ctts [ ] = {
 {
 "".gif"" , ""image/gif"" }
 , {
 "".jpg"" , ""image/jpeg"" }
 , {
 "".jpeg"" , ""image/jpeg"" }
 , {
 "".txt"" , ""text/plain"" }
 , {
 "".html"" , ""text/html"" }
 , {
 "".xml"" , ""application/xml"" }
 }
 ;
 if ( prevtype ) contenttype = prevtype ;
 else contenttype = HTTPPOST_CONTENTTYPE_DEFAULT ;
 if ( filename ) {
 for ( i = 0 ;
 i < sizeof ( ctts ) / sizeof ( ctts [ 0 ] ) ;
 i ++ ) {
 if ( strlen ( filename ) >= strlen ( ctts [ i ] . extension ) ) {
 if ( strequal ( filename + strlen ( filename ) - strlen ( ctts [ i ] . extension ) , ctts [ i ] . extension ) ) {
 contenttype = ctts [ i ] . type ;
 break ;
 }
 }
 }
 }
 return contenttype ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean confirm_empty_trash ( CommonJob * job ) {
 char * prompt ;
 int response ;
 if ( ! should_confirm_trash ( ) ) {
 return TRUE ;
 }
 prompt = f ( _ ( ""Empty all items from Trash?"" ) ) ;
 response = run_warning ( job , prompt , f ( _ ( ""All items in the Trash will be permanently deleted."" ) ) , NULL , FALSE , CANCEL , _ ( ""Empty _Trash"" ) , NULL ) ;
 return ( response == 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void ber_check_value64 ( gint64 value , gint64 min_len , gint64 max_len , asn1_ctx_t * actx , proto_item * item ) {
 if ( ( min_len != - 1 ) && ( value < min_len ) ) {
 expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_value , ""Size constraint: value too small: %"" G_GINT64_MODIFIER ""d (%"" G_GINT64_MODIFIER ""d .. %"" G_GINT64_MODIFIER ""d)"" , value , min_len , max_len ) ;
 }
 else if ( ( max_len != - 1 ) && ( value > max_len ) ) {
 expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_value , ""Size constraint: value too big: %"" G_GINT64_MODIFIER ""d (%"" G_GINT64_MODIFIER ""d .. %"" G_GINT64_MODIFIER ""d)"" , value , min_len , max_len ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int all_vcpus_paused ( void ) {
 CPUArchState * penv = first_cpu ;
 while ( penv ) {
 CPUState * pcpu = ENV_GET_CPU ( penv ) ;
 if ( ! pcpu -> stopped ) {
 return 0 ;
 }
 penv = penv -> next_cpu ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;
 # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MINOR ( __SYSMACROS_DECL_TEMPL )",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_AdmissionRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 657 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_AdmissionRejectReason , AdmissionRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gint round_to_4byte ( gint current_offset , gint starting_offset ) {
 gint length = current_offset - starting_offset ;
 return starting_offset + ROUND_TO_4BYTE ( length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SingleClientSessionsSyncTest , TimestampMatchesHistory ) {
 ASSERT_TRUE ( SetupSync ( ) ) << ""SetupSync() failed."" ;
 ASSERT_TRUE ( CheckInitialState ( 0 ) ) ;
 const GURL url ( ""about:version"" ) ;
 ScopedWindowMap windows ;
 ASSERT_TRUE ( OpenTabAndGetLocalWindows ( 0 , url , windows . GetMutable ( ) ) ) ;
 int found_navigations = 0 ;
 for ( SessionWindowMap : : const_iterator it = windows . Get ( ) -> begin ( ) ;
 it != windows . Get ( ) -> end ( ) ;
 ++ it ) {
 for ( std : : vector < sessions : : SessionTab * > : : const_iterator it2 = it -> second -> tabs . begin ( ) ;
 it2 != it -> second -> tabs . end ( ) ;
 ++ it2 ) {
 for ( std : : vector < sessions : : SerializedNavigationEntry > : : const_iterator it3 = ( * it2 ) -> navigations . begin ( ) ;
 it3 != ( * it2 ) -> navigations . end ( ) ;
 ++ it3 ) {
 const base : : Time timestamp = it3 -> timestamp ( ) ;
 history : : URLRow virtual_row ;
 ASSERT_TRUE ( GetUrlFromClient ( 0 , it3 -> virtual_url ( ) , & virtual_row ) ) ;
 const base : : Time history_timestamp = virtual_row . last_visit ( ) ;
 ASSERT_EQ ( timestamp , history_timestamp ) ;
 ++ found_navigations ;
 }
 }
 }
 ASSERT_EQ ( 1 , found_navigations ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlChar * xsltEvalAttrValueTemplate ( xsltTransformContextPtr ctxt , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns ) {
 xmlChar * ret ;
 xmlChar * expr ;
 if ( ( ctxt == NULL ) || ( inst == NULL ) || ( name == NULL ) ) return ( NULL ) ;
 expr = xsltGetNsProp ( inst , name , ns ) ;
 if ( expr == NULL ) return ( NULL ) ;
 ret = xsltAttrTemplateValueProcessNode ( ctxt , expr , inst ) ;
 # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , ""xsltEvalAttrValueTemplate: %s returns %s\n"" , expr , ret ) ) ;
 # endif if ( expr != NULL ) xmlFree ( expr ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void interpolate_isp ( double isp_q [ 4 ] [ LP_ORDER ] , const double * isp4_past ) {
 int i , k ;
 for ( k = 0 ;
 k < 3 ;
 k ++ ) {
 float c = isfp_inter [ k ] ;
 for ( i = 0 ;
 i < LP_ORDER ;
 i ++ ) isp_q [ k ] [ i ] = ( 1.0 - c ) * isp4_past [ i ] + c * isp_q [ 3 ] [ i ] ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int com_charset ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {
 char buff [ 256 ] , * param ;
 CHARSET_INFO * new_cs ;
 strmake_buf ( buff , line ) ;
 param = get_arg ( buff , 0 ) ;
 if ( ! param || ! * param ) {
 return put_info ( ""Usage: \\C charset_name | charset charset_name"" , INFO_ERROR , 0 ) ;
 }
 new_cs = get_charset_by_csname ( param , MY_CS_PRIMARY , MYF ( MY_WME ) ) ;
 if ( new_cs ) {
 charset_info = new_cs ;
 mysql_set_character_set ( & mysql , charset_info -> csname ) ;
 default_charset = ( char * ) charset_info -> csname ;
 put_info ( ""Charset changed"" , INFO_INFO ) ;
 }
 else put_info ( ""Charset is not found"" , INFO_INFO ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelYellowTraits ( Image * image , const PixelTrait traits ) {
 image -> channel_map [ YellowPixelChannel ] . traits = traits ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int kvm_put_xcrs ( X86CPU * cpu ) {
 CPUX86State * env = & cpu -> env ;
 struct kvm_xcrs xcrs = {
 }
 ;
 if ( ! has_xcrs ) {
 return 0 ;
 }
 xcrs . nr_xcrs = 1 ;
 xcrs . flags = 0 ;
 xcrs . xcrs [ 0 ] . xcr = 0 ;
 xcrs . xcrs [ 0 ] . value = env -> xcr0 ;
 return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_XCRS , & xcrs ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x1 ( IpvideoContext * s ) {
 return copy_from ( s , & s -> second_last_frame , 0 , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void * xmlHashLookup3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {
 unsigned long key ;
 xmlHashEntryPtr entry ;
 if ( table == NULL ) return ( NULL ) ;
 if ( name == NULL ) return ( NULL ) ;
 key = xmlHashComputeKey ( table , name , name2 , name3 ) ;
 if ( table -> table [ key ] . valid == 0 ) return ( NULL ) ;
 if ( table -> dict ) {
 for ( entry = & ( table -> table [ key ] ) ;
 entry != NULL ;
 entry = entry -> next ) {
 if ( ( entry -> name == name ) && ( entry -> name2 == name2 ) && ( entry -> name3 == name3 ) ) return ( entry -> payload ) ;
 }
 }
 for ( entry = & ( table -> table [ key ] ) ;
 entry != NULL ;
 entry = entry -> next ) {
 if ( ( xmlStrEqual ( entry -> name , name ) ) && ( xmlStrEqual ( entry -> name2 , name2 ) ) && ( xmlStrEqual ( entry -> name3 , name3 ) ) ) return ( entry -> payload ) ;
 }
 return ( NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( VirtualKeyboardBrowserTest , AttributesTest ) {
 RunTest ( base : : FilePath ( FILE_PATH_LITERAL ( ""attributes_test.js"" ) ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static xmlLinkPtr xmlListLinkSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 lk = xmlListLowerSearch ( l , data ) ;
 if ( lk == l -> sentinel ) return NULL ;
 else {
 if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;
 return NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , const int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {
 MACROBLOCKD * const xd = & x -> e_mbd ;
 ctx -> skip = x -> skip ;
 ctx -> skippable = skippable ;
 ctx -> best_mode_index = mode_index ;
 ctx -> mic = * xd -> mi [ 0 ] ;
 ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ;
 ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ;
 ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ;
 vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;
 vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set )",1
Detect whether the following code contains vulnerabilities.,"static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {
 insert_dotted_circles ( plan , font , buffer ) ;
 hb_glyph_info_t * info = buffer -> info ;
 unsigned int count = buffer -> len ;
 if ( unlikely ( ! count ) ) return ;
 unsigned int last = 0 ;
 unsigned int last_syllable = info [ 0 ] . syllable ( ) ;
 for ( unsigned int i = 1 ;
 i < count ;
 i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {
 initial_reordering_syllable ( plan , font -> face , buffer , last , i ) ;
 last = i ;
 last_syllable = info [ last ] . syllable ( ) ;
 }
 initial_reordering_syllable ( plan , font -> face , buffer , last , count ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gboolean delete_file_recursively ( GFile * file , GCancellable * cancellable , DeleteCallback callback , gpointer callback_data ) {
 gboolean success ;
 g_autoptr ( GError ) error = NULL ;
 do {
 g_autoptr ( GFileEnumerator ) enumerator = NULL ;
 success = g_file_delete ( file , cancellable , & error ) ;
 if ( success || ! g_error_matches ( error , G_IO_ERROR , G_IO_ERROR_NOT_EMPTY ) ) {
 break ;
 }
 g_clear_error ( & error ) ;
 enumerator = g_file_enumerate_children ( file , G_FILE_ATTRIBUTE_STANDARD_NAME , G_FILE_QUERY_INFO_NONE , cancellable , & error ) ;
 if ( enumerator ) {
 GFileInfo * info ;
 success = TRUE ;
 info = g_file_enumerator_next_file ( enumerator , cancellable , & error ) ;
 while ( info != NULL ) {
 g_autoptr ( GFile ) child = NULL ;
 child = g_file_enumerator_get_child ( enumerator , info ) ;
 success = success && delete_file_recursively ( child , cancellable , callback , callback_data ) ;
 g_object_unref ( info ) ;
 info = g_file_enumerator_next_file ( enumerator , cancellable , & error ) ;
 }
 }
 if ( error != NULL ) {
 success = FALSE ;
 }
 }
 while ( success ) ;
 if ( callback ) {
 callback ( file , error , callback_data ) ;
 }
 return success ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * remove_leading_slash ( const char * p ) {
 const char * rp ;
 if ( ( p [ 0 ] == '/' || p [ 0 ] == '\\' ) && ( p [ 1 ] == '/' || p [ 1 ] == '\\' ) && ( p [ 2 ] == '.' || p [ 2 ] == '?' ) && ( p [ 3 ] == '/' || p [ 3 ] == '\\' ) ) {
 if ( p [ 2 ] == '?' && ( p [ 4 ] == 'U' || p [ 4 ] == 'u' ) && ( p [ 5 ] == 'N' || p [ 5 ] == 'n' ) && ( p [ 6 ] == 'C' || p [ 6 ] == 'c' ) && ( p [ 7 ] == '/' || p [ 7 ] == '\\' ) ) p += 8 ;
 else p += 4 ;
 }
 do {
 rp = p ;
 if ( ( ( p [ 0 ] >= 'a' && p [ 0 ] <= 'z' ) || ( p [ 0 ] >= 'A' && p [ 0 ] <= 'Z' ) ) && p [ 1 ] == ':' ) {
 p += 2 ;
 }
 while ( p [ 0 ] == '/' || p [ 0 ] == '\\' ) {
 if ( p [ 1 ] == '.' && p [ 2 ] == '.' && ( p [ 3 ] == '/' || p [ 3 ] == '\\' ) ) {
 p += 3 ;
 }
 else p += 1 ;
 }
 }
 while ( rp != p ) ;
 return ( p ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l ) ;
 __exctype_l ( ispunct_l ) ;
 __exctype_l ( isspace_l ) ;
 __exctype_l ( isupper_l ) ;
 __exctype_l ( isxdigit_l )",1
Detect whether the following code contains vulnerabilities.,"struct mszipd_stream * mszipd_init ( struct mspack_system * system , struct mspack_file * input , struct mspack_file * output , int input_buffer_size , int repair_mode ) {
 struct mszipd_stream * zip ;
 if ( ! system ) return NULL ;
 input_buffer_size = ( input_buffer_size + 1 ) & - 2 ;
 if ( ! input_buffer_size ) return NULL ;
 if ( ! ( zip = ( struct mszipd_stream * ) system -> alloc ( system , sizeof ( struct mszipd_stream ) ) ) ) {
 return NULL ;
 }
 zip -> inbuf = ( unsigned char * ) system -> alloc ( system , ( size_t ) input_buffer_size ) ;
 if ( ! zip -> inbuf ) {
 system -> free ( zip ) ;
 return NULL ;
 }
 zip -> sys = system ;
 zip -> input = input ;
 zip -> output = output ;
 zip -> inbuf_size = input_buffer_size ;
 zip -> input_end = 0 ;
 zip -> error = MSPACK_ERR_OK ;
 zip -> repair_mode = repair_mode ;
 zip -> flush_window = & mszipd_flush_window ;
 zip -> i_ptr = zip -> i_end = & zip -> inbuf [ 0 ] ;
 zip -> o_ptr = zip -> o_end = NULL ;
 zip -> bit_buffer = 0 ;
 zip -> bits_left = 0 ;
 return zip ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , BLOCK_SIZE bsize ) {
 VP9_COMMON * const cm = & cpi -> common ;
 MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 TOKENEXTRA * t_backup = * t ;
 const int ctx = vp9_get_skip_context ( xd ) ;
 const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;
 struct tokenize_b_args arg = {
 cpi , xd , t }
 ;
 if ( mbmi -> skip ) {
 if ( ! dry_run ) cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ;
 reset_skip_context ( xd , bsize ) ;
 if ( dry_run ) * t = t_backup ;
 return ;
 }
 if ( ! dry_run ) {
 cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ;
 vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ;
 }
 else {
 vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ;
 * t = t_backup ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static hb_unicode_combining_class_t hb_ucdn_combining_class ( hb_unicode_funcs_t * ufuncs , hb_codepoint_t unicode , void * user_data HB_UNUSED ) {
 return ( hb_unicode_combining_class_t ) ucdn_get_combining_class ( unicode ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void build_inter_predictors_for_planes ( MACROBLOCKD * xd , BLOCK_SIZE bsize , int mi_row , int mi_col , int plane_from , int plane_to ) {
 int plane ;
 const int mi_x = mi_col * MI_SIZE ;
 const int mi_y = mi_row * MI_SIZE ;
 for ( plane = plane_from ;
 plane <= plane_to ;
 ++ plane ) {
 const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , & xd -> plane [ plane ] ) ;
 const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ;
 const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ;
 const int bw = 4 * num_4x4_w ;
 const int bh = 4 * num_4x4_h ;
 if ( xd -> mi [ 0 ] -> mbmi . sb_type < BLOCK_8X8 ) {
 int i = 0 , x , y ;
 assert ( bsize == BLOCK_8X8 ) ;
 for ( y = 0 ;
 y < num_4x4_h ;
 ++ y ) for ( x = 0 ;
 x < num_4x4_w ;
 ++ x ) build_inter_predictors ( xd , plane , i ++ , bw , bh , * x , 4 * y , 4 , 4 , mi_x , mi_y ) ;
 }
 else {
 build_inter_predictors ( xd , plane , 0 , bw , bh , 0 , 0 , bw , bh , mi_x , mi_y ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line15_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t v , r , g , b ;
 w = width ;
 do {
 v = lduw_le_p ( ( void * ) s ) ;
 r = ( v >> 7 ) & 0xf8 ;
 g = ( v >> 2 ) & 0xf8 ;
 b = ( v << 3 ) & 0xf8 ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 2 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void keydb_release ( KEYDB_HANDLE hd ) {
 int i ;
 if ( ! hd ) return ;
 assert ( active_handles > 0 ) ;
 active_handles -- ;
 unlock_all ( hd ) ;
 for ( i = 0 ;
 i < hd -> used ;
 i ++ ) {
 switch ( hd -> active [ i ] . type ) {
 case KEYDB_RESOURCE_TYPE_NONE : break ;
 case KEYDB_RESOURCE_TYPE_KEYRING : keyring_release ( hd -> active [ i ] . u . kr ) ;
 break ;
 case KEYDB_RESOURCE_TYPE_KEYBOX : keybox_release ( hd -> active [ i ] . u . kb ) ;
 break ;
 }
 }
 xfree ( hd ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int dissect_h225_GenericIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 848 ""./asn1/h225/h225.cnf"" gef_ctx_t * gefx ;
 proto_item * ti ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_GenericIdentifier , GenericIdentifier_choice , NULL ) ;
 # line 851 ""./asn1/h225/h225.cnf"" gef_ctx_update_key ( gef_ctx_get ( actx -> private_data ) ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) {
 ti = proto_tree_add_string ( tree , hf_h225_debug_dissector_try_string , tvb , offset >> 3 , 0 , gefx -> key ) ;
 PROTO_ITEM_SET_HIDDEN ( ti ) ;
 dissector_try_string ( gef_name_dissector_table , gefx -> key , tvb_new_subset ( tvb , offset >> 3 , 0 , 0 ) , actx -> pinfo , tree , actx ) ;
 }
 actx -> private_data = gefx ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Https ) {
 StartHttpsServer ( false ) ;
 NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( ""/simple.html"" ) , https_test_server_ -> GetURL ( ""/empty.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 2 ) ;
 FakeUserMetricsUpload ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;
 int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;
 EXPECT_EQ ( 100 , ratio_bucket ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) {
 vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , MODEL_NODES * sizeof ( vp9_prob ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {
 remote_error rerr ;
 int ret ;
 VIR_DEBUG ( ""stream=%p proc=%d serial=%d len=%d offset=%d"" , stream , msg -> hdr . proc , msg -> hdr . serial , msg -> bufferLength , msg -> bufferOffset ) ;
 memset ( & rerr , 0 , sizeof rerr ) ;
 ret = virStreamSend ( stream -> st , msg -> buffer + msg -> bufferOffset , msg -> bufferLength - msg -> bufferOffset ) ;
 if ( ret > 0 ) {
 msg -> bufferOffset += ret ;
 if ( msg -> bufferOffset < msg -> bufferLength ) return 1 ;
 }
 else if ( ret == - 2 ) {
 return 1 ;
 }
 else {
 VIR_INFO0 ( ""Stream send failed"" ) ;
 stream -> closed = 1 ;
 remoteDispatchConnError ( & rerr , client -> conn ) ;
 return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( FullscreenControllerStateUnitTest , ExitTabFullscreenViaReplacingTab ) {
 AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;
 ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;
 ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;
 ASSERT_TRUE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;
 content : : WebContents * new_web_contents = content : : WebContents : : Create ( content : : WebContents : : CreateParams ( profile ( ) ) ) ;
 scoped_ptr < content : : WebContents > old_web_contents ( browser ( ) -> tab_strip_model ( ) -> ReplaceWebContentsAt ( 0 , new_web_contents ) ) ;
 ChangeWindowFullscreenState ( ) ;
 EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vmmouse_set_data ( const uint32_t * data ) {
 CPUX86State * env = cpu_single_env ;
 env -> regs [ R_EAX ] = data [ 0 ] ;
 env -> regs [ R_EBX ] = data [ 1 ] ;
 env -> regs [ R_ECX ] = data [ 2 ] ;
 env -> regs [ R_EDX ] = data [ 3 ] ;
 env -> regs [ R_ESI ] = data [ 4 ] ;
 env -> regs [ R_EDI ] = data [ 5 ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DisengageReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 636 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageReason , DisengageReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 ( void ) handler ;
 ( void ) context ;
 ( void ) formatBundle ;
 int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;
 * count = info -> fWidth ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_vowel_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {
 initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gboolean isSignal ( const gchar * signal_str_p , const gchar * signalStr ) {
 gint i ;
 gchar * * resultArray ;
 if ( signalStr == NULL ) return FALSE ;
 if ( ( * signal_str_p == '\0' ) && ( * signalStr == '\0' ) ) return TRUE ;
 resultArray = g_strsplit ( signalStr , "","" , 10 ) ;
 for ( i = 0 ;
 resultArray [ i ] ;
 i ++ ) {
 g_strstrip ( resultArray [ i ] ) ;
 if ( strcmp ( resultArray [ i ] , signal_str_p ) == 0 ) return TRUE ;
 }
 g_strfreev ( resultArray ) ;
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {
 int y ;
 unsigned char P [ 2 ] ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 if ( ! ( y & 3 ) ) {
 P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 }
 memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;
 memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;
 s -> pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int do_flush_tables_read_lock ( MYSQL * mysql_con ) {
 return ( mysql_query_with_error_report ( mysql_con , 0 , ( ( opt_master_data != 0 ) ? ""FLUSH /*!40101 LOCAL */ TABLES"" : ""FLUSH TABLES"" ) ) || mysql_query_with_error_report ( mysql_con , 0 , ""FLUSH TABLES WITH READ LOCK"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evdns_search_add ( const char * domain ) {
 search_postfix_add ( domain ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ShortcutsProviderTest , DaysAgoMatches ) {
 base : : string16 text ( ASCIIToUTF16 ( ""ago"" ) ) ;
 ExpectedURLs expected_urls ;
 expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( ""http://www.daysagotest.com/a.html"" , false ) ) ;
 expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( ""http://www.daysagotest.com/b.html"" , false ) ) ;
 expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( ""http://www.daysagotest.com/c.html"" , false ) ) ;
 RunShortcutsProviderTest ( provider_ , text , false , expected_urls , ""http://www.daysagotest.com/a.html"" , base : : string16 ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vmport_ioport_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) {
 CPUX86State * env = cpu_single_env ;
 env -> regs [ R_EAX ] = vmport_ioport_read ( opaque , addr , 4 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void test_errors ( ) {
 int rc ;
 MYSQL_RES * result ;
 myheader ( ""test_errors"" ) ;
 mysql_query ( mysql , ""DROP TABLE if exists test_non_exists"" ) ;
 rc = mysql_query ( mysql , ""DROP TABLE test_non_exists"" ) ;
 myquery_r ( rc ) ;
 rc = mysql_query ( mysql , ""SHOW ERRORS"" ) ;
 myquery ( rc ) ;
 result = mysql_store_result ( mysql ) ;
 mytest ( result ) ;
 ( void ) my_process_result_set ( result ) ;
 mysql_free_result ( result ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static hb_language_t * language_reference ( hb_language_t * l ) {
 hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * l ;
 return c ;
 }",1
Detect whether the following code contains vulnerabilities.,"size_t vpx_svc_get_frame_size ( const SvcContext * svc_ctx ) {
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return 0 ;
 return si -> frame_list -> size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_Avb_type ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Avb_type , Avb_type_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_nlm4_shareres ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {
 return dissect_nlm_shareres ( tvb , 0 , pinfo , tree , 4 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void isofile_free ( struct isofile * file ) {
 struct content * con , * tmp ;
 con = file -> content . next ;
 while ( con != NULL ) {
 tmp = con ;
 con = con -> next ;
 free ( tmp ) ;
 }
 archive_entry_free ( file -> entry ) ;
 archive_string_free ( & ( file -> parentdir ) ) ;
 archive_string_free ( & ( file -> basename ) ) ;
 archive_string_free ( & ( file -> basename_utf16 ) ) ;
 archive_string_free ( & ( file -> symlink ) ) ;
 free ( file ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {
 if ( page -> image == NULL ) {
 jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , ""page info possibly missing, no image defined"" ) ;
 return 0 ;
 }
 if ( page -> striped ) {
 uint32_t new_height = y + image -> height + page -> end_row ;
 if ( page -> image -> height < new_height ) {
 jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""growing page buffer to %d rows "" ""to accomodate new stripe"" , new_height ) ;
 jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;
 }
 }
 jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateUnknown ) {
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""tel"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : UNKNOWN , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSMimeHdrFieldValueInt64Set ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , int64_t value ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;
 sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;
 if ( ! isWriteable ( bufp ) ) {
 return TS_ERROR ;
 }
 char tmp [ 20 ] ;
 int len = mime_format_int64 ( tmp , value , sizeof ( tmp ) ) ;
 TSMimeFieldValueSet ( bufp , field , idx , tmp , len ) ;
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct32x32_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int i , j ;
 int a1 ;
 int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;
 out = dct_const_round_shift ( out * cospi_16_64 ) ;
 a1 = ROUND_POWER_OF_TWO ( out , 6 ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) {
 for ( i = 0 ;
 i < 32 ;
 ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;
 dest += stride ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_subElementList ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 100 ""../../asn1/h245/h245.cnf"" h223_mux_element dummy_me , * parent_me = h223_me ;
 memset ( & dummy_me , 0 , sizeof ( h223_mux_element ) ) ;
 h223_me = & dummy_me ;
 offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_T_subElementList , T_subElementList_sequence_of , 2 , 255 , FALSE ) ;
 parent_me -> sublist = dummy_me . next ;
 h223_me = parent_me ;
 h223_me -> vc = 0 ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_consumed_bytes ( MpegEncContext * s , int buf_size ) {
 int pos = get_bits_count ( & s -> gb ) >> 3 ;
 if ( pos == 0 ) pos = 1 ;
 if ( pos + 10 > buf_size ) pos = buf_size ;
 return pos ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void finish_object ( struct object * obj , const char * name , void * cb_data ) {
 struct rev_list_info * info = cb_data ;
 if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( ""missing blob object '%s'"" , oid_to_hex ( & obj -> oid ) ) ;
 if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs )",1
Detect whether the following code contains vulnerabilities.,"int TS_X509_ALGOR_print_bio ( BIO * bio , const X509_ALGOR * alg ) {
 int i = OBJ_obj2nid ( alg -> algorithm ) ;
 return BIO_printf ( bio , ""Hash Algorithm: %s\n"" , ( i == NID_undef ) ? ""UNKNOWN"" : OBJ_nid2ln ( i ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean is_mpa_fpdu ( packet_info * pinfo ) {
 conversation_t * conversation = NULL ;
 mpa_state_t * state = NULL ;
 conversation = find_conversation ( pinfo -> num , & pinfo -> src , & pinfo -> dst , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , 0 ) ;
 if ( ! conversation ) {
 return FALSE ;
 }
 state = get_mpa_state ( conversation ) ;
 if ( ! state ) {
 return FALSE ;
 }
 if ( ! state -> full_operation ) {
 return FALSE ;
 }
 if ( pinfo -> num == state -> req_frame_num || pinfo -> num == state -> rep_frame_num ) {
 return FALSE ;
 }
 else {
 return TRUE ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalRelabelType ( GenericExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 return ExecEvalExpr ( exprstate -> arg , econtext , isNull , isDone ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _cmd_window_show_opt ( const char * data , int right ) {
 MAIN_WINDOW_REC * parent ;
 WINDOW_REC * window ;
 if ( * data == '\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;
 if ( is_numeric ( data , '\0' ) ) {
 window = window_find_refnum ( atoi ( data ) ) ;
 if ( window == NULL ) {
 printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_REFNUM_NOT_FOUND , data ) ;
 }
 }
 else {
 window = window_find_item ( active_win -> active_server , data ) ;
 }
 if ( window == NULL || is_window_visible ( window ) ) return ;
 if ( WINDOW_GUI ( window ) -> sticky ) {
 if ( ! settings_get_bool ( ""autounstick_windows"" ) ) {
 printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_CANT_SHOW_STICKY_WINDOWS ) ;
 return ;
 }
 }
 parent = mainwindow_create ( right ) ;
 if ( parent == NULL ) {
 printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_WINDOW_TOO_SMALL ) ;
 return ;
 }
 parent -> active = window ;
 gui_window_reparent ( window , parent ) ;
 if ( settings_get_bool ( ""autostick_split_windows"" ) ) gui_window_set_sticky ( window ) ;
 active_mainwin = NULL ;
 window_set_active ( window ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( WebRtcApprtcBrowserTest , MAYBE_MANUAL_FirefoxApprtcInteropTest ) {
 DetectErrorsInJavaScript ( ) ;
 ASSERT_TRUE ( LaunchApprtcInstanceOnLocalhost ( ""9999"" ) ) ;
 ASSERT_TRUE ( LaunchColliderOnLocalHost ( ""http://localhost:9999"" , ""8089"" ) ) ;
 while ( ! LocalApprtcInstanceIsUp ( ) ) DVLOG ( 1 ) << ""Waiting for AppRTC to come up..."" ;
 GURL room_url = GURL ( ""http://localhost:9999/r/some_room"" ""?wshpp=localhost:8089&wstls=false"" ""&firefox_fake_device=1"" ) ;
 chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;
 content : : WebContents * chrome_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;
 PermissionBubbleManager : : FromWebContents ( chrome_tab ) -> set_auto_response_for_test ( PermissionBubbleManager : : ACCEPT_ALL ) ;
 InfoBarResponder infobar_responder ( InfoBarService : : FromWebContents ( chrome_tab ) , InfoBarResponder : : ACCEPT ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;
 ASSERT_TRUE ( LaunchFirefoxWithUrl ( room_url ) ) ;
 ASSERT_TRUE ( WaitForCallToComeUp ( chrome_tab ) ) ;
 ASSERT_TRUE ( DetectRemoteVideoPlaying ( chrome_tab ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void spl_filesystem_dir_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {
 spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;
 object -> u . dir . index = 0 ;
 if ( object -> u . dir . dirp ) {
 php_stream_rewinddir ( object -> u . dir . dirp ) ;
 }
 spl_filesystem_dir_read ( object TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void forward_query ( int bind_fd , struct query * q ) {
 char buf [ 64 * 1024 ] ;
 int len ;
 struct fw_query fwq ;
 struct sockaddr_in * myaddr ;
 in_addr_t newaddr ;
 len = dns_encode ( buf , sizeof ( buf ) , q , QR_QUERY , q -> name , strlen ( q -> name ) ) ;
 if ( len < 1 ) {
 warnx ( ""dns_encode doesn't fit"" ) ;
 return ;
 }
 memcpy ( & ( fwq . addr ) , & ( q -> from ) , q -> fromlen ) ;
 fwq . addrlen = q -> fromlen ;
 fwq . id = q -> id ;
 fw_query_put ( & fwq ) ;
 newaddr = inet_addr ( ""127.0.0.1"" ) ;
 myaddr = ( struct sockaddr_in * ) & ( q -> from ) ;
 memcpy ( & ( myaddr -> sin_addr ) , & newaddr , sizeof ( in_addr_t ) ) ;
 myaddr -> sin_port = htons ( bind_port ) ;
 if ( debug >= 2 ) {
 fprintf ( stderr , ""TX: NS reply \n"" ) ;
 }
 if ( sendto ( bind_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {
 warn ( ""forward query error"" ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void f_parser ( lua_State * L , void * ud ) {
 int i ;
 Proto * tf ;
 Closure * cl ;
 struct SParser * p = cast ( struct SParser * , ud ) ;
 int c = luaZ_lookahead ( p -> z ) ;
 luaC_checkGC ( L ) ;
 tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;
 cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ;
 cl -> l . p = tf ;
 for ( i = 0 ;
 i < tf -> nups ;
 i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ;
 setclvalue ( L , L -> top , cl ) ;
 incr_top ( L ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan )",1
Detect whether the following code contains vulnerabilities.,"static void sbr_qmf_deint_bfly_c ( float * v , const float * src0 , const float * src1 ) {
 int i ;
 for ( i = 0 ;
 i < 64 ;
 i ++ ) {
 v [ i ] = src0 [ i ] - src1 [ 63 - i ] ;
 v [ 127 - i ] = src0 [ i ] + src1 [ 63 - i ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void useSndTimeout ( socket_handle_t sock ) {
 # ifdef _WIN32 const DWORD socket_timeout = SOCKET_RW_TIMEOUT_MS ;
 setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , ( const char * ) & socket_timeout , sizeof ( socket_timeout ) ) ;
 # else const struct timeval socket_timeout = {
 . tv_sec = SOCKET_RW_TIMEOUT_MS / 1000 , . tv_usec = ( SOCKET_RW_TIMEOUT_MS % 1000 ) * 1000 }
 ;
 setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , & socket_timeout , sizeof ( socket_timeout ) ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void update_remote_info_refs ( struct remote_lock * lock ) {
 struct buffer buffer = {
 STRBUF_INIT , 0 }
 ;
 struct active_request_slot * slot ;
 struct slot_results results ;
 struct curl_slist * dav_headers ;
 remote_ls ( ""refs/"" , ( PROCESS_FILES | RECURSIVE ) , add_remote_info_ref , & buffer . buf ) ;
 if ( ! aborted ) {
 dav_headers = get_dav_token_headers ( lock , DAV_HEADER_IF ) ;
 slot = get_active_slot ( ) ;
 slot -> results = & results ;
 curl_setup_http ( slot -> curl , lock -> url , DAV_PUT , & buffer , fwrite_null ) ;
 curl_easy_setopt ( slot -> curl , CURLOPT_HTTPHEADER , dav_headers ) ;
 if ( start_active_slot ( slot ) ) {
 run_active_slot ( slot ) ;
 if ( results . curl_result != CURLE_OK ) {
 fprintf ( stderr , ""PUT error: curl result=%d, HTTP code=%ld\n"" , results . curl_result , results . http_code ) ;
 }
 }
 }
 strbuf_release ( & buffer . buf ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * _UTF7GetName ( const UConverter * cnv ) {
 switch ( cnv -> fromUnicodeStatus >> 28 ) {
 case 1 : return ""UTF-7,version=1"" ;
 default : return ""UTF-7"" ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ScoredHistoryMatchTest , ScoringTLD ) {
 base : : Time now = base : : Time : : NowFromSystemTime ( ) ;
 std : : string url_string ( ""http://fedcba.com/"" ) ;
 const GURL url ( url_string ) ;
 history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , """" , 8 , 3 , 1 ) ) ;
 RowWordStarts word_starts ;
 PopulateWordStarts ( row , & word_starts ) ;
 WordStarts two_words_no_offsets ( 2 , 0u ) ;
 VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;
 ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""fed com"" ) , Make2Terms ( ""fed"" , ""com"" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;
 EXPECT_EQ ( 0 , scored . raw_score ) ;
 base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_tld_matches_ , true ) ;
 ScoredHistoryMatch scored_with_tld ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""fed com"" ) , Make2Terms ( ""fed"" , ""com"" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;
 EXPECT_GT ( scored_with_tld . raw_score , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pdf_set_color ( fz_context * ctx , pdf_run_processor * pr , int what , float * v ) {
 pdf_gstate * gstate = pr -> gstate + pr -> gtop ;
 pdf_material * mat ;
 gstate = pdf_flush_text ( ctx , pr ) ;
 mat = what == PDF_FILL ? & gstate -> fill : & gstate -> stroke ;
 switch ( mat -> kind ) {
 case PDF_MAT_PATTERN : case PDF_MAT_COLOR : fz_clamp_color ( ctx , mat -> colorspace , v , mat -> v ) ;
 break ;
 default : fz_warn ( ctx , ""color incompatible with material"" ) ;
 }
 mat -> gstate_num = pr -> gparent ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Https ) {
 StartHttpsServer ( false ) ;
 NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( ""/simple.html"" ) , GURL ( chrome : : kChromeUIVersionURL ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF16Reset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> mode = 0 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void makeAlterConfigCommand ( PGconn * conn , const char * arrayitem , const char * type , const char * name , const char * type2 , const char * name2 ) {
 char * pos ;
 char * mine ;
 PQExpBuffer buf ;
 mine = pg_strdup ( arrayitem ) ;
 pos = strchr ( mine , '=' ) ;
 if ( pos == NULL ) {
 free ( mine ) ;
 return ;
 }
 buf = createPQExpBuffer ( ) ;
 * pos = 0 ;
 appendPQExpBuffer ( buf , ""ALTER %s %s "" , type , fmtId ( name ) ) ;
 if ( type2 != NULL && name2 != NULL ) appendPQExpBuffer ( buf , ""IN %s %s "" , type2 , fmtId ( name2 ) ) ;
 appendPQExpBuffer ( buf , ""SET %s TO "" , fmtId ( mine ) ) ;
 if ( pg_strcasecmp ( mine , ""DateStyle"" ) == 0 || pg_strcasecmp ( mine , ""search_path"" ) == 0 ) appendPQExpBufferStr ( buf , pos + 1 ) ;
 else appendStringLiteralConn ( buf , pos + 1 , conn ) ;
 appendPQExpBufferStr ( buf , "";
\n"" ) ;
 fprintf ( OPF , ""%s"" , buf -> data ) ;
 destroyPQExpBuffer ( buf ) ;
 free ( mine ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"bool send_id ( connection_t * c ) {
 if ( proxytype && c -> outgoing && ! c -> status . proxy_passed ) {
 return send_proxyrequest ( c ) ;
 }
 return send_request ( c , ""%d %s %d"" , ID , myself -> connection -> name , myself -> connection -> protocol_version ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , VpxVideoWriter * writer ) {
 int got_pkts = 0 ;
 vpx_codec_iter_t iter = NULL ;
 const vpx_codec_cx_pkt_t * pkt = NULL ;
 const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ;
 if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed to encode frame."" ) ;
 while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {
 got_pkts = 1 ;
 if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {
 const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ;
 if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , ""Failed to write compressed frame."" ) ;
 printf ( keyframe ? ""K"" : ""."" ) ;
 fflush ( stdout ) ;
 }
 }
 return got_pkts ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct name_path * path , const char * name , void * cb_data ) {
 struct object * obj = & blob -> object ;
 if ( ! revs -> blob_objects ) return ;
 if ( ! obj ) die ( ""bad blob object"" ) ;
 if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ;
 obj -> flags |= SEEN ;
 show ( obj , path , name , cb_data ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) {
 VP9_COMMON * const cm = & cpi -> common ;
 struct loopfilter * const lf = & cm -> lf ;
 lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ;
 if ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) {
 lf -> filter_level = 0 ;
 }
 else if ( method >= LPF_PICK_FROM_Q ) {
 const int min_filter_level = 0 ;
 const int max_filter_level = get_max_filter_level ( cpi ) ;
 const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;
 int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;
 if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;
 lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ;
 }
 else {
 lf -> filter_level = search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void evhttp_set_timeout ( struct evhttp * http , int timeout_in_secs ) {
 http -> timeout = timeout_in_secs ;
 }",0
Detect whether the following code contains vulnerabilities.,"void fz_init_cached_color_converter ( fz_context * ctx , fz_color_converter * cc , fz_colorspace * is , fz_colorspace * ds , fz_colorspace * ss , const fz_color_params * params ) {
 int n = ss -> n ;
 fz_cached_color_converter * cached = fz_malloc_struct ( ctx , fz_cached_color_converter ) ;
 cc -> opaque = cached ;
 cc -> convert = fz_cached_color_convert ;
 cc -> ds = ds ? ds : fz_device_gray ( ctx ) ;
 cc -> ss = ss ;
 cc -> is = is ;
 fz_try ( ctx ) {
 fz_find_color_converter ( ctx , & cached -> base , is , cc -> ds , ss , params ) ;
 cached -> hash = fz_new_hash_table ( ctx , 256 , n * sizeof ( float ) , - 1 , fz_free ) ;
 }
 fz_catch ( ctx ) {
 fz_drop_color_converter ( ctx , & cached -> base ) ;
 fz_drop_hash_table ( ctx , cached -> hash ) ;
 fz_free ( ctx , cached ) ;
 fz_rethrow ( ctx ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t idCmp ( const char * id1 , const char * id2 ) {
 int32_t diffIdx = 0 ;
 while ( * id1 == * id2 && * id1 != 0 ) {
 diffIdx ++ ;
 id1 ++ ;
 id2 ++ ;
 }
 return diffIdx ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void print_blob_as_hex ( FILE * output_file , const char * str , ulong len ) {
 const char * ptr = str , * end = ptr + len ;
 for ( ;
 ptr < end ;
 ptr ++ ) fprintf ( output_file , ""%02X"" , * ( ( uchar * ) ptr ) ) ;
 check_io ( output_file ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _ISCIIClose ( UConverter * cnv ) {
 if ( cnv -> extraInfo != NULL ) {
 if ( ! cnv -> isExtraLocal ) {
 uprv_free ( cnv -> extraInfo ) ;
 }
 cnv -> extraInfo = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {
 char buff [ 256 ] , * tmp ;
 strmake_buf ( buff , line ) ;
 tmp = get_arg ( buff , 0 ) ;
 if ( ! tmp || ! * tmp ) {
 put_info ( ""DELIMITER must be followed by a 'delimiter' character or string"" , INFO_ERROR ) ;
 return 0 ;
 }
 else {
 if ( strstr ( tmp , ""\\"" ) ) {
 put_info ( ""DELIMITER cannot contain a backslash character"" , INFO_ERROR ) ;
 return 0 ;
 }
 }
 strmake_buf ( delimiter , tmp ) ;
 delimiter_length = ( int ) strlen ( delimiter ) ;
 delimiter_str = delimiter ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , key ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_LONG ( intern -> u . file . current_line_num ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_EnumeratedParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 830 ""./asn1/h225/h225.cnf"" gef_ctx_t * parent_gefx ;
 parent_gefx = gef_ctx_get ( actx -> private_data ) ;
 actx -> private_data = gef_ctx_alloc ( parent_gefx , NULL ) ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_EnumeratedParameter , EnumeratedParameter_sequence ) ;
 # line 835 ""./asn1/h225/h225.cnf"" actx -> private_data = parent_gefx ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decode_gains ( AMRContext * p , const AMRNBSubframe * amr_subframe , const enum Mode mode , const int subframe , float * fixed_gain_factor ) {
 if ( mode == MODE_12k2 || mode == MODE_7k95 ) {
 p -> pitch_gain [ 4 ] = qua_gain_pit [ amr_subframe -> p_gain ] * ( 1.0 / 16384.0 ) ;
 * fixed_gain_factor = qua_gain_code [ amr_subframe -> fixed_gain ] * ( 1.0 / 2048.0 ) ;
 }
 else {
 const uint16_t * gains ;
 if ( mode >= MODE_6k7 ) {
 gains = gains_high [ amr_subframe -> p_gain ] ;
 }
 else if ( mode >= MODE_5k15 ) {
 gains = gains_low [ amr_subframe -> p_gain ] ;
 }
 else {
 gains = gains_MODE_4k75 [ ( p -> frame . subframe [ subframe & 2 ] . p_gain << 1 ) + ( subframe & 1 ) ] ;
 }
 p -> pitch_gain [ 4 ] = gains [ 0 ] * ( 1.0 / 16384.0 ) ;
 * fixed_gain_factor = gains [ 1 ] * ( 1.0 / 4096.0 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {
 UConverterDataLMBCS * extraInfo = _this -> extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;
 if ( extraInfo != NULL ) {
 UConverterNamePieces stackPieces ;
 UConverterLoadArgs stackArgs = {
 ( int32_t ) sizeof ( UConverterLoadArgs ) }
 ;
 ulmbcs_byte_t i ;
 uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;
 stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;
 for ( i = 0 ;
 i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;
 i ++ ) {
 if ( OptGroupByteToCPName [ i ] != NULL ) {
 extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;
 }
 }
 if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {
 _LMBCSClose ( _this ) ;
 return ;
 }
 extraInfo -> OptGroup = OptGroup ;
 extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;
 }
 else {
 * err = U_MEMORY_ALLOCATION_ERROR ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_CInGroupSortAggregSets ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 guint32 cCount , i ;
 proto_item * item ;
 proto_tree * tree ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSets , & item , txt ) ;
 cCount = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_cingroupsortaggregsets_count , tvb , offset , 4 , cCount ) ;
 offset += 4 ;
 for ( i = 0 ;
 i < cCount ;
 i ++ ) {
 offset = parse_CInGroupSortAggregSet ( tvb , offset , tree , pad_tree , ""SortSets[%u]"" , i ) ;
 }
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void http_writecb ( struct bufferevent * bev , void * arg ) {
 if ( EVBUFFER_LENGTH ( bev -> output ) == 0 ) {
 bufferevent_enable ( bev , EV_READ ) ;
 test_ok ++ ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalCurrentOfExpr ( ExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 ereport ( ERROR , ( errcode ( ERRCODE_FEATURE_NOT_SUPPORTED ) , errmsg ( ""WHERE CURRENT OF is not supported for this table type"" ) ) ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evhttp_send_reply_chunk ( struct evhttp_request * req , struct evbuffer * databuf ) {
 if ( req -> chunked ) {
 evbuffer_add_printf ( req -> evcon -> output_buffer , ""%x\r\n"" , ( unsigned ) EVBUFFER_LENGTH ( databuf ) ) ;
 }
 evbuffer_add_buffer ( req -> evcon -> output_buffer , databuf ) ;
 if ( req -> chunked ) {
 evbuffer_add ( req -> evcon -> output_buffer , ""\r\n"" , 2 ) ;
 }
 evhttp_write_buffer ( req -> evcon , NULL , NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl )",1
Detect whether the following code contains vulnerabilities.,"static void php_zip_free_entry ( zend_rsrc_list_entry * rsrc TSRMLS_DC ) {
 zip_read_rsrc * zr_rsrc = ( zip_read_rsrc * ) rsrc -> ptr ;
 if ( zr_rsrc ) {
 if ( zr_rsrc -> zf ) {
 if ( zr_rsrc -> zf -> za ) {
 zip_fclose ( zr_rsrc -> zf ) ;
 }
 else {
 if ( zr_rsrc -> zf -> src ) zip_source_free ( zr_rsrc -> zf -> src ) ;
 free ( zr_rsrc -> zf ) ;
 }
 zr_rsrc -> zf = NULL ;
 }
 efree ( zr_rsrc ) ;
 rsrc -> ptr = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void flush_unauthorized_files ( const struct cred * cred , struct files_struct * files ) {
 struct file * file , * devnull = NULL ;
 struct tty_struct * tty ;
 int drop_tty = 0 ;
 unsigned n ;
 tty = get_current_tty ( ) ;
 if ( tty ) {
 spin_lock ( & tty -> files_lock ) ;
 if ( ! list_empty ( & tty -> tty_files ) ) {
 struct tty_file_private * file_priv ;
 file_priv = list_first_entry ( & tty -> tty_files , struct tty_file_private , list ) ;
 file = file_priv -> file ;
 if ( file_path_has_perm ( cred , file , FILE__READ | FILE__WRITE ) ) drop_tty = 1 ;
 }
 spin_unlock ( & tty -> files_lock ) ;
 tty_kref_put ( tty ) ;
 }
 if ( drop_tty ) no_tty ( ) ;
 n = iterate_fd ( files , 0 , match_file , cred ) ;
 if ( ! n ) return ;
 devnull = dentry_open ( & selinux_null , O_RDWR , cred ) ;
 if ( IS_ERR ( devnull ) ) devnull = NULL ;
 do {
 replace_fd ( n - 1 , devnull , 0 ) ;
 }
 while ( ( n = iterate_fd ( files , n , match_file , cred ) ) != 0 ) ;
 if ( devnull ) fput ( devnull ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_CapabilityIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 714 ""../../asn1/h245/h245.cnf"" gef_ctx_t * gefx ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_CapabilityIdentifier , CapabilityIdentifier_choice , NULL ) ;
 # line 716 ""../../asn1/h245/h245.cnf"" gef_ctx_update_key ( gef_ctx_get ( actx -> private_data ) ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) {
 dissector_try_string ( gef_name_dissector_table , gefx -> key , tvb_new_subset ( tvb , offset >> 3 , 0 , 0 ) , actx -> pinfo , tree , actx ) ;
 }
 actx -> private_data = gefx ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"void msyslog ( int level , const char * fmt , ... ) {
 char buf [ 1024 ] ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 mvsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;
 va_end ( ap ) ;
 addto_syslog ( level , buf ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint32_t PREP_io_800_readb ( void * opaque , uint32_t addr ) {
 uint32_t retval = 0xFF ;
 switch ( addr ) {
 case 0x0092 : retval = 0x40 ;
 break ;
 case 0x080C : retval = 0xFC ;
 break ;
 case 0x0818 : retval = 0x00 ;
 break ;
 case 0x081C : retval = syscontrol ;
 break ;
 case 0x0823 : retval = 0x03 ;
 break ;
 case 0x0850 : retval = 0x00 ;
 break ;
 default : break ;
 }
 PPC_IO_DPRINTF ( ""0x%08x <= 0x%08x\n"" , addr - PPC_IO_BASE , retval ) ;
 return retval ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void copy_picture_attributes ( MpegEncContext * s , AVFrame * dst , const AVFrame * src ) {
 dst -> pict_type = src -> pict_type ;
 dst -> quality = src -> quality ;
 dst -> coded_picture_number = src -> coded_picture_number ;
 dst -> display_picture_number = src -> display_picture_number ;
 dst -> pts = src -> pts ;
 dst -> interlaced_frame = src -> interlaced_frame ;
 dst -> top_field_first = src -> top_field_first ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void comp_ppf_gains ( int lag , PPFParam * ppf , enum Rate cur_rate , int tgt_eng , int ccr , int res_eng ) {
 int pf_residual ;
 int temp1 , temp2 ;
 ppf -> index = lag ;
 temp1 = tgt_eng * res_eng >> 1 ;
 temp2 = ccr * ccr << 1 ;
 if ( temp2 > temp1 ) {
 if ( ccr >= res_eng ) {
 ppf -> opt_gain = ppf_gain_weight [ cur_rate ] ;
 }
 else {
 ppf -> opt_gain = ( ccr << 15 ) / res_eng * ppf_gain_weight [ cur_rate ] >> 15 ;
 }
 temp1 = ( tgt_eng << 15 ) + ( ccr * ppf -> opt_gain << 1 ) ;
 temp2 = ( ppf -> opt_gain * ppf -> opt_gain >> 15 ) * res_eng ;
 pf_residual = av_sat_add32 ( temp1 , temp2 + ( 1 << 15 ) ) >> 16 ;
 if ( tgt_eng >= pf_residual << 1 ) {
 temp1 = 0x7fff ;
 }
 else {
 temp1 = ( tgt_eng << 14 ) / pf_residual ;
 }
 ppf -> sc_gain = square_root ( temp1 << 16 ) ;
 }
 else {
 ppf -> opt_gain = 0 ;
 ppf -> sc_gain = 0x7fff ;
 }
 ppf -> opt_gain = av_clip_int16 ( ppf -> opt_gain * ppf -> sc_gain >> 15 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( FullscreenControllerTest , PendingMouseLockExitsOnTabClose ) {
 AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;
 AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;
 RequestToLockMouse ( true , false ) ;
 ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;
 {
 MouseLockNotificationObserver mouse_lock_observer ;
 chrome : : CloseTab ( browser ( ) ) ;
 mouse_lock_observer . Wait ( ) ;
 }
 ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE cState_partial_generate ( VALUE self , VALUE obj ) {
 FBuffer * buffer = cState_prepare_buffer ( self ) ;
 GET_STATE ( self ) ;
 generate_json ( buffer , self , state , obj ) ;
 return fbuffer_to_s ( buffer ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int is_mv_diff_gt_3 ( int16_t ( * motion_val ) [ 2 ] , int step ) {
 int d ;
 d = motion_val [ 0 ] [ 0 ] - motion_val [ - step ] [ 0 ] ;
 if ( d < - 3 || d > 3 ) return 1 ;
 d = motion_val [ 0 ] [ 1 ] - motion_val [ - step ] [ 1 ] ;
 if ( d < - 3 || d > 3 ) return 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xD_16 ( IpvideoContext * s ) {
 int x , y ;
 uint16_t P [ 2 ] ;
 uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 if ( ! ( y & 3 ) ) {
 P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 }
 for ( x = 0 ;
 x < 8 ;
 x ++ ) pixel_ptr [ x ] = P [ x >> 2 ] ;
 pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int checkcmap ( int n , uint16 * r , uint16 * g , uint16 * b ) {
 while ( n -- > 0 ) if ( * r ++ >= 256 || * g ++ >= 256 || * b ++ >= 256 ) return ( 16 ) ;
 fprintf ( stderr , ""Warning, assuming 8-bit colormap.\n"" ) ;
 return ( 8 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean istr_equal ( gconstpointer v , gconstpointer v2 ) {
 return g_ascii_strcasecmp ( v , v2 ) == 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"const char * mgs_hook_http_scheme ( const request_rec * r ) {
 mgs_srvconf_rec * sc ;
 if ( r == NULL ) return NULL ;
 sc = ( mgs_srvconf_rec * ) ap_get_module_config ( r -> server -> module_config , & gnutls_module ) ;
 _gnutls_log ( debug_log_fp , ""%s: %d\n"" , __func__ , __LINE__ ) ;
 if ( sc -> enabled == GNUTLS_ENABLED_FALSE ) {
 return NULL ;
 }
 return ""https"" ;
 }",0
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalOper ( FuncExprState * fcache , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 OpExpr * op = ( OpExpr * ) fcache -> xprstate . expr ;
 init_fcache ( op -> opfuncid , op -> inputcollid , fcache , econtext -> ecxt_per_query_memory , true ) ;
 if ( fcache -> func . fn_retset || expression_returns_set ( ( Node * ) op -> args ) ) {
 fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResult ;
 return ExecMakeFunctionResult ( fcache , econtext , isNull , isDone ) ;
 }
 else {
 fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResultNoSets ;
 return ExecMakeFunctionResultNoSets ( fcache , econtext , isNull , isDone ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void _SCSUReset ( UConverter * cnv , UConverterResetChoice choice ) {
 SCSUData * scsu = ( SCSUData * ) cnv -> extraInfo ;
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 uprv_memcpy ( scsu -> toUDynamicOffsets , initialDynamicOffsets , 32 ) ;
 scsu -> toUIsSingleByteMode = TRUE ;
 scsu -> toUState = readCommand ;
 scsu -> toUQuoteWindow = scsu -> toUDynamicWindow = 0 ;
 scsu -> toUByteOne = 0 ;
 cnv -> toULength = 0 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 uprv_memcpy ( scsu -> fromUDynamicOffsets , initialDynamicOffsets , 32 ) ;
 scsu -> fromUIsSingleByteMode = TRUE ;
 scsu -> fromUDynamicWindow = 0 ;
 scsu -> nextWindowUseIndex = 0 ;
 switch ( scsu -> locale ) {
 case l_ja : uprv_memcpy ( scsu -> windowUse , initialWindowUse_ja , 8 ) ;
 break ;
 default : uprv_memcpy ( scsu -> windowUse , initialWindowUse , 8 ) ;
 break ;
 }
 cnv -> fromUChar32 = 0 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void await_reference_row ( Vp3DecodeContext * s , Vp3Fragment * fragment , int motion_y , int y ) {
 AVFrame * ref_frame ;
 int ref_row ;
 int border = motion_y & 1 ;
 if ( fragment -> coding_method == MODE_USING_GOLDEN || fragment -> coding_method == MODE_GOLDEN_MV ) ref_frame = & s -> golden_frame ;
 else ref_frame = & s -> last_frame ;
 ref_row = y + ( motion_y >> 1 ) ;
 ref_row = FFMAX ( FFABS ( ref_row ) , ref_row + 8 + border ) ;
 ff_thread_await_progress ( ref_frame , ref_row , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int copy_from ( IpvideoContext * s , AVFrame * src , int delta_x , int delta_y ) {
 int current_offset = s -> pixel_ptr - s -> current_frame . data [ 0 ] ;
 int motion_offset = current_offset + delta_y * s -> current_frame . linesize [ 0 ] + delta_x * ( 1 + s -> is_16bpp ) ;
 if ( motion_offset < 0 ) {
 av_log ( s -> avctx , AV_LOG_ERROR , "" Interplay video: motion offset < 0 (%d)\n"" , motion_offset ) ;
 return AVERROR_INVALIDDATA ;
 }
 else if ( motion_offset > s -> upper_motion_limit_offset ) {
 av_log ( s -> avctx , AV_LOG_ERROR , "" Interplay video: motion offset above limit (%d >= %d)\n"" , motion_offset , s -> upper_motion_limit_offset ) ;
 return AVERROR_INVALIDDATA ;
 }
 if ( src -> data [ 0 ] == NULL ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid decode type, corrupted header?\n"" ) ;
 return AVERROR ( EINVAL ) ;
 }
 s -> dsp . put_pixels_tab [ ! s -> is_16bpp ] [ 0 ] ( s -> pixel_ptr , src -> data [ 0 ] + motion_offset , s -> current_frame . linesize [ 0 ] , 8 ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ int TLV_GET_LEN ( struct tlv_desc * tlv ) {
 return ntohs ( tlv -> tlv_len ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int x ( struct vcache * avc , int afun , struct vrequest * areq , \ struct afs_pdata * ain , struct afs_pdata * aout , \ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;
 DECL_PIOCTL ( PSetAcl ) ;
 DECL_PIOCTL ( PStoreBehind ) ;
 DECL_PIOCTL ( PGCPAGs ) ;
 DECL_PIOCTL ( PGetAcl ) ;
 DECL_PIOCTL ( PNoop ) ;
 DECL_PIOCTL ( PBogus ) ;
 DECL_PIOCTL ( PGetFileCell ) ;
 DECL_PIOCTL ( PGetWSCell ) ;
 DECL_PIOCTL ( PGetUserCell ) ;
 DECL_PIOCTL ( PSetTokens ) ;
 DECL_PIOCTL ( PGetVolumeStatus ) ;
 DECL_PIOCTL ( PSetVolumeStatus ) ;
 DECL_PIOCTL ( PFlush )",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_symbol_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {
 }",1
Detect whether the following code contains vulnerabilities.,"static void fd_free_list ( struct FrameData * list ) {
 struct FrameData * p = list ;
 while ( p ) {
 list = list -> next ;
 fd_free ( p ) ;
 p = list ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {
 return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;
 }
 static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {
 return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;
 }
 # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;
 typedef const char * OPENSSL_CSTRING ;
 DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )",1
Detect whether the following code contains vulnerabilities.,"static void dumpcfffdselect ( SplineFont * sf , struct alltabs * at ) {
 int cid , k , lastfd , cnt ;
 int gid ;
 putc ( 3 , at -> fdselect ) ;
 putshort ( at -> fdselect , 0 ) ;
 for ( k = 0 ;
 k < sf -> subfontcnt ;
 ++ k ) if ( SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ 0 ] ) ) break ;
 if ( k == sf -> subfontcnt ) -- k ;
 putshort ( at -> fdselect , 0 ) ;
 putc ( k , at -> fdselect ) ;
 lastfd = k ;
 cnt = 1 ;
 for ( gid = 1 ;
 gid < at -> gi . gcnt ;
 ++ gid ) {
 cid = at -> gi . bygid [ gid ] ;
 for ( k = 0 ;
 k < sf -> subfontcnt ;
 ++ k ) {
 if ( cid < sf -> subfonts [ k ] -> glyphcnt && SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ cid ] ) ) break ;
 }
 if ( k == sf -> subfontcnt ) ;
 else {
 if ( k != lastfd ) {
 putshort ( at -> fdselect , gid ) ;
 putc ( k , at -> fdselect ) ;
 lastfd = k ;
 ++ cnt ;
 }
 }
 }
 putshort ( at -> fdselect , gid ) ;
 fseek ( at -> fdselect , 1 , SEEK_SET ) ;
 putshort ( at -> fdselect , cnt ) ;
 fseek ( at -> fdselect , 0 , SEEK_END ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , LoadingMetricsFailed ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : LOAD_TIMING_INFO ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/404.html"" ) ) ;
 waiter -> Wait ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static __always_inline __le32 __cpu_to_le32p ( const __u32 * p ) {
 return ( __le32 ) * p ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {
 int layer , layer_index ;
 vpx_svc_parameters_t svc_params ;
 SvcInternal * const si = get_svc_internal ( svc_ctx ) ;
 memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;
 svc_params . temporal_layer = 0 ;
 svc_params . spatial_layer = si -> layer ;
 layer = si -> layer ;
 if ( VPX_CODEC_OK != vpx_svc_get_layer_resolution ( svc_ctx , layer , & svc_params . width , & svc_params . height ) ) {
 svc_log ( svc_ctx , SVC_LOG_ERROR , ""vpx_svc_get_layer_resolution failed\n"" ) ;
 }
 layer_index = layer + VPX_SS_MAX_LAYERS - si -> layers ;
 if ( codec_ctx -> config . enc -> g_pass == VPX_RC_ONE_PASS ) {
 svc_params . min_quantizer = si -> quantizer [ layer_index ] ;
 svc_params . max_quantizer = si -> quantizer [ layer_index ] ;
 }
 else {
 svc_params . min_quantizer = codec_ctx -> config . enc -> rc_min_quantizer ;
 svc_params . max_quantizer = codec_ctx -> config . enc -> rc_max_quantizer ;
 }
 svc_params . distance_from_i_frame = si -> frame_within_gop ;
 vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pdf_run_c ( fz_context * ctx , pdf_processor * proc , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) {
 pdf_run_processor * pr = ( pdf_run_processor * ) proc ;
 fz_curveto ( ctx , pr -> path , x1 , y1 , x2 , y2 , x3 , y3 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"gcry_mpi_t gcry_sexp_nth_mpi ( gcry_sexp_t list , int number , int mpifmt ) {
 const char * s ;
 size_t n ;
 gcry_mpi_t a ;
 if ( ! mpifmt ) mpifmt = GCRYMPI_FMT_STD ;
 s = sexp_nth_data ( list , number , & n ) ;
 if ( ! s ) return NULL ;
 if ( gcry_mpi_scan ( & a , mpifmt , s , n , NULL ) ) return NULL ;
 return a ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pdf_run_TD ( fz_context * ctx , pdf_processor * proc , float tx , float ty ) {
 pdf_run_processor * pr = ( pdf_run_processor * ) proc ;
 pdf_gstate * gstate = pr -> gstate + pr -> gtop ;
 gstate -> text . leading = - ty ;
 pdf_tos_translate ( & pr -> tos , tx , ty ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int _find_update_object_in_list ( void * x , void * key ) {
 slurmdb_update_object_t * object = ( slurmdb_update_object_t * ) x ;
 slurmdb_update_type_t type = * ( slurmdb_update_type_t * ) key ;
 if ( object -> type == type ) return 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int wpa_decrypt ( u_char * mac , u_char * data , size_t len , struct wpa_sa sa ) {
 if ( sa . algo == WPA_KEY_CCMP ) {
 return wpa_ccmp_decrypt ( mac , data , len , sa ) ;
 }
 else if ( sa . algo == WPA_KEY_TKIP ) {
 return wpa_tkip_decrypt ( mac , data , len , sa ) ;
 }
 return - E_NOTHANDLED ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestAccept ) {
 ShowDialog ( ) ;
 EXPECT_TRUE ( dialog_ -> Accept ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_TRUE ( accept_ ) ;
 EXPECT_FALSE ( cancel_ ) ;
 EXPECT_FALSE ( dont_block_ ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 , 1 ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : LAUNCH , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t U_CALLCONV compareMappingsUnicodeFirst ( const void * context , const void * left , const void * right ) {
 return compareMappings ( ( UCMTable * ) context , ( const UCMapping * ) left , ( UCMTable * ) context , ( const UCMapping * ) right , TRUE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pic_as_field ( Picture * pic , const int parity ) {
 int i ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 if ( parity == PICT_BOTTOM_FIELD ) pic -> f . data [ i ] += pic -> f . linesize [ i ] ;
 pic -> f . reference = parity ;
 pic -> f . linesize [ i ] *= 2 ;
 }
 pic -> poc = pic -> field_poc [ parity == PICT_BOTTOM_FIELD ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"void main_buffree ( void * ptr ) {
 # if XD3_WIN32 VirtualFree ( ptr , 0 , MEM_RELEASE ) ;
 # else main_free1 ( NULL , ptr ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Simple_Https ) {
 StartHttpsServer ( false ) ;
 base : : TimeDelta upper_bound = NavigateInForegroundAndCloseWithTiming ( https_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_FeatureDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 840 ""./asn1/h225/h225.cnf"" void * priv_data = actx -> private_data ;
 actx -> private_data = gef_ctx_alloc ( NULL , ""FeatureDescriptor"" ) ;
 offset = dissect_h225_GenericData ( tvb , offset , actx , tree , hf_index ) ;
 # line 843 ""./asn1/h225/h225.cnf"" actx -> private_data = priv_data ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 int32_t len ;
 double num ;
 UNumberFormat * format ;
 int32_t parsePos = 0 ;
 UErrorCode status = U_ZERO_ERROR ;
 u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;
 ufile_fill_uchar_buffer ( input ) ;
 len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;
 if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;
 format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_PERCENT ) ;
 if ( format == 0 ) return 0 ;
 u_scanf_skip_leading_positive_sign ( input , format , & status ) ;
 num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;
 if ( ! info -> fSkipArg ) {
 * ( double * ) ( args [ 0 ] . ptrValue ) = num ;
 }
 input -> str . fPos += parsePos ;
 * argConverted = ! info -> fSkipArg ;
 return parsePos ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace ) ;
 __exctype ( isupper ) ;
 __exctype ( isxdigit ) ;
 extern int tolower ( int __c ) __THROW ;
 extern int toupper ( int __c ) __THROW ;
 # ifdef __USE_ISOC99 __exctype ( isblank ) ;
 # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;
 # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;
 extern int toascii ( int __c ) __THROW ;
 __exctype ( _toupper ) ;
 __exctype ( _tolower )",1
Detect whether the following code contains vulnerabilities.,"int xml_init ( modsec_rec * msr , char * * error_msg ) {
 if ( error_msg == NULL ) return - 1 ;
 * error_msg = NULL ;
 msr -> xml = apr_pcalloc ( msr -> mp , sizeof ( xml_data ) ) ;
 if ( msr -> xml == NULL ) return - 1 ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace ) ;
 __exctype ( isupper ) ;
 __exctype ( isxdigit )",1
Detect whether the following code contains vulnerabilities.,"void mi_check_print_error ( MI_CHECK * param , const char * fmt , ... ) {
 va_list args ;
 DBUG_ENTER ( ""mi_check_print_error"" ) ;
 DBUG_PRINT ( ""enter"" , ( ""format: %s"" , fmt ) ) ;
 fflush ( stdout ) ;
 if ( ! param -> warning_printed && ! param -> error_printed ) {
 if ( param -> testflag & T_SILENT ) fprintf ( stderr , ""%s: MyISAM file %s\n"" , my_progname_short , param -> isam_file_name ) ;
 param -> out_flag |= O_DATA_LOST ;
 }
 param -> error_printed |= 1 ;
 va_start ( args , fmt ) ;
 fprintf ( stderr , ""%s: error: "" , my_progname_short ) ;
 ( void ) vfprintf ( stderr , fmt , args ) ;
 ( void ) fputc ( '\n' , stderr ) ;
 fflush ( stderr ) ;
 va_end ( args ) ;
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"void pcnet_ioport_writew ( void * opaque , uint32_t addr , uint32_t val ) {
 PCNetState * s = opaque ;
 pcnet_poll_timer ( s ) ;
 # ifdef PCNET_DEBUG_IO printf ( ""pcnet_ioport_writew addr=0x%08x val=0x%04x\n"" , addr , val ) ;
 # endif if ( ! BCR_DWIO ( s ) ) {
 switch ( addr & 0x0f ) {
 case 0x00 : pcnet_csr_writew ( s , s -> rap , val ) ;
 break ;
 case 0x02 : s -> rap = val & 0x7f ;
 break ;
 case 0x06 : pcnet_bcr_writew ( s , s -> rap , val ) ;
 break ;
 }
 }
 pcnet_update_irq ( s ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xB ( IpvideoContext * s ) {
 int y ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 bytestream2_get_buffer ( & s -> stream_ptr , s -> pixel_ptr , 8 ) ;
 s -> pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static kadm5_ret_t copy_tl_data ( krb5_int16 n_tl_data , krb5_tl_data * tl_data , krb5_tl_data * * out ) {
 kadm5_ret_t ret ;
 krb5_tl_data * tl , * tl_new ;
 if ( ( ret = alloc_tl_data ( n_tl_data , out ) ) ) return ret ;
 tl = tl_data ;
 tl_new = * out ;
 for ( ;
 tl ;
 tl = tl -> tl_data_next , tl_new = tl_new -> tl_data_next ) {
 tl_new -> tl_data_contents = malloc ( tl -> tl_data_length ) ;
 if ( tl_new -> tl_data_contents == NULL ) return ENOMEM ;
 memcpy ( tl_new -> tl_data_contents , tl -> tl_data_contents , tl -> tl_data_length ) ;
 tl_new -> tl_data_type = tl -> tl_data_type ;
 tl_new -> tl_data_length = tl -> tl_data_length ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 947 ""../../asn1/h245/h245.cnf"" gint32 value ;
 nsiOID = """" ;
 h221NonStandard = 0 ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;
 switch ( value ) {
 case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;
 break ;
 case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;
 break ;
 default : nsp_handle = NULL ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * pool_alloc ( size_t len ) {
 struct mem_pool * p ;
 void * r ;
 if ( len & ( sizeof ( uintmax_t ) - 1 ) ) len += sizeof ( uintmax_t ) - ( len & ( sizeof ( uintmax_t ) - 1 ) ) ;
 for ( p = mem_pool ;
 p ;
 p = p -> next_pool ) if ( ( p -> end - p -> next_free >= len ) ) break ;
 if ( ! p ) {
 if ( len >= ( mem_pool_alloc / 2 ) ) {
 total_allocd += len ;
 return xmalloc ( len ) ;
 }
 total_allocd += sizeof ( struct mem_pool ) + mem_pool_alloc ;
 p = xmalloc ( sizeof ( struct mem_pool ) + mem_pool_alloc ) ;
 p -> next_pool = mem_pool ;
 p -> next_free = ( char * ) p -> space ;
 p -> end = p -> next_free + mem_pool_alloc ;
 mem_pool = p ;
 }
 r = p -> next_free ;
 p -> next_free += len ;
 return r ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void reindex_system_catalogs ( const char * dbname , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool verbose ) {
 PGconn * conn ;
 PQExpBufferData sql ;
 conn = connectDatabase ( dbname , host , port , username , prompt_password , progname , false , false ) ;
 initPQExpBuffer ( & sql ) ;
 appendPQExpBuffer ( & sql , ""REINDEX"" ) ;
 if ( verbose ) appendPQExpBuffer ( & sql , "" (VERBOSE)"" ) ;
 appendPQExpBuffer ( & sql , "" SYSTEM %s;
"" , PQdb ( conn ) ) ;
 if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) {
 fprintf ( stderr , _ ( ""%s: reindexing of system catalogs failed: %s"" ) , progname , PQerrorMessage ( conn ) ) ;
 PQfinish ( conn ) ;
 exit ( 1 ) ;
 }
 PQfinish ( conn ) ;
 termPQExpBuffer ( & sql ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_mediaMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_mediaMode , T_mediaMode_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint32_t getHostID ( const ILcidPosixMap * this_0 , const char * posixID , UErrorCode * status ) {
 int32_t bestIdx = 0 ;
 int32_t bestIdxDiff = 0 ;
 int32_t posixIDlen = ( int32_t ) uprv_strlen ( posixID ) ;
 uint32_t idx ;
 for ( idx = 0 ;
 idx < this_0 -> numRegions ;
 idx ++ ) {
 int32_t sameChars = idCmp ( posixID , this_0 -> regionMaps [ idx ] . posixID ) ;
 if ( sameChars > bestIdxDiff && this_0 -> regionMaps [ idx ] . posixID [ sameChars ] == 0 ) {
 if ( posixIDlen == sameChars ) {
 return this_0 -> regionMaps [ idx ] . hostID ;
 }
 bestIdxDiff = sameChars ;
 bestIdx = idx ;
 }
 }
 if ( ( posixID [ bestIdxDiff ] == '_' || posixID [ bestIdxDiff ] == '@' ) && this_0 -> regionMaps [ bestIdx ] . posixID [ bestIdxDiff ] == 0 ) {
 * status = U_USING_FALLBACK_WARNING ;
 return this_0 -> regionMaps [ bestIdx ] . hostID ;
 }
 * status = U_ILLEGAL_ARGUMENT_ERROR ;
 return this_0 -> regionMaps -> hostID ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void flac_set_bps ( FLACContext * s ) {
 enum AVSampleFormat req = s -> avctx -> request_sample_fmt ;
 int need32 = s -> bps > 16 ;
 int want32 = av_get_bytes_per_sample ( req ) > 2 ;
 int planar = av_sample_fmt_is_planar ( req ) ;
 if ( need32 || want32 ) {
 if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32P ;
 else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32 ;
 s -> sample_shift = 32 - s -> bps ;
 }
 else {
 if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16P ;
 else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ;
 s -> sample_shift = 16 - s -> bps ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) {
 const VP9_COMMON * const cm = & cpi -> common ;
 int q = active_worst_quality ;
 int last_error = INT_MAX ;
 int i , target_bits_per_mb ;
 const double correction_factor = get_rate_correction_factor ( cpi ) ;
 target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ;
 i = active_best_quality ;
 do {
 const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , correction_factor ) ;
 if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {
 if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ;
 else q = i - 1 ;
 break ;
 }
 else {
 last_error = bits_per_mb_at_this_q - target_bits_per_mb ;
 }
 }
 while ( ++ i <= active_worst_quality ) ;
 return q ;
 }",1
Detect whether the following code contains vulnerabilities.,"static VALUE cState_initialize ( int argc , VALUE * argv , VALUE self ) {
 VALUE opts ;
 GET_STATE ( self ) ;
 state -> max_nesting = 100 ;
 state -> buffer_initial_length = FBUFFER_INITIAL_LENGTH_DEFAULT ;
 rb_scan_args ( argc , argv , ""01"" , & opts ) ;
 if ( ! NIL_P ( opts ) ) cState_configure ( self , opts ) ;
 return self ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( eob == 1 ) vp9_idct32x32_1_add ( input , dest , stride ) ;
 else if ( eob <= 34 ) vp9_idct32x32_34_add ( input , dest , stride ) ;
 else vp9_idct32x32_1024_add ( input , dest , stride ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int spl_filesystem_file_read_line ( zval * this_ptr , spl_filesystem_object * intern , int silent TSRMLS_DC ) {
 int ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;
 while ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_SKIP_EMPTY ) && ret == SUCCESS && spl_filesystem_file_is_empty_line ( intern TSRMLS_CC ) ) {
 spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;
 ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;
 }
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static _Bool have_gcrypt ( void ) {
 static _Bool result = 0 ;
 static _Bool need_init = 1 ;
 if ( ! need_init ) return ( result ) ;
 need_init = 0 ;
 # if HAVE_LIBGCRYPT # if GCRYPT_VERSION_NUMBER < 0x010600 gcry_control ( GCRYCTL_SET_THREAD_CBS , & gcry_threads_pthread ) ;
 # endif if ( ! gcry_check_version ( GCRYPT_VERSION ) ) return ( 0 ) ;
 gcry_control ( GCRYCTL_INIT_SECMEM , 32768 , 0 ) ;
 gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;
 result = 1 ;
 return ( 1 ) ;
 # else return ( 0 ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static int should_include ( struct commit * commit , void * _data ) {
 struct bitmap * base = _data ;
 if ( ! add_to_include_set ( base , commit ) ) {
 struct commit_list * parent = commit -> parents ;
 mark_as_seen ( ( struct object * ) commit ) ;
 while ( parent ) {
 parent -> item -> object . flags |= SEEN ;
 mark_as_seen ( ( struct object * ) parent -> item ) ;
 parent = parent -> next ;
 }
 return 0 ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int gs_heap_register_root ( gs_memory_t * mem , gs_gc_root_t * rp , gs_ptr_type_t ptype , void * * up , client_name_t cname ) {
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void choose_largest_tx_size ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * sse , int64_t ref_best_rd , BLOCK_SIZE bs ) {
 const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] ;
 VP9_COMMON * const cm = & cpi -> common ;
 const TX_SIZE largest_tx_size = tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 mbmi -> tx_size = MIN ( max_tx_size , largest_tx_size ) ;
 txfm_rd_in_plane ( x , rate , distortion , skip , sse , ref_best_rd , 0 , bs , mbmi -> tx_size , cpi -> sf . use_fast_coef_costing ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_ustring_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 ( void ) formatBundle ;
 int32_t len , written ;
 const UChar * arg = ( const UChar * ) ( args [ 0 ] . ptrValue ) ;
 if ( arg == NULL ) {
 arg = gNullStr ;
 }
 len = u_strlen ( arg ) ;
 if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {
 len = info -> fPrecision ;
 }
 written = handler -> pad_and_justify ( context , info , arg , len ) ;
 return written ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xB_16 ( IpvideoContext * s ) {
 int x , y ;
 uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 for ( x = 0 ;
 x < 8 ;
 x ++ ) pixel_ptr [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int yop_copy_previous_block ( YopDecContext * s , int linesize , int copy_tag ) {
 uint8_t * bufptr ;
 bufptr = s -> dstptr + motion_vector [ copy_tag ] [ 0 ] + linesize * motion_vector [ copy_tag ] [ 1 ] ;
 if ( bufptr < s -> dstbuf ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""YOP: cannot decode, file probably corrupt\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 s -> dstptr [ 0 ] = bufptr [ 0 ] ;
 s -> dstptr [ 1 ] = bufptr [ 1 ] ;
 s -> dstptr [ linesize ] = bufptr [ linesize ] ;
 s -> dstptr [ linesize + 1 ] = bufptr [ linesize + 1 ] ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_decision ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_decision , T_decision_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , getCsvControl ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 char delimiter [ 2 ] , enclosure [ 2 ] ;
 array_init ( return_value ) ;
 delimiter [ 0 ] = intern -> u . file . delimiter ;
 delimiter [ 1 ] = '\0' ;
 enclosure [ 0 ] = intern -> u . file . enclosure ;
 enclosure [ 1 ] = '\0' ;
 add_next_index_string ( return_value , delimiter , 1 ) ;
 add_next_index_string ( return_value , enclosure , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void get_current_db ( ) {
 MYSQL_RES * res ;
 if ( one_database ) return ;
 my_free ( current_db ) ;
 current_db = NULL ;
 if ( ! mysql_query ( & mysql , ""SELECT DATABASE()"" ) && ( res = mysql_use_result ( & mysql ) ) ) {
 MYSQL_ROW row = mysql_fetch_row ( res ) ;
 if ( row && row [ 0 ] ) current_db = my_strdup ( row [ 0 ] , MYF ( MY_WME ) ) ;
 mysql_free_result ( res ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_fetch_float ( ) {
 int rc ;
 myheader ( ""test_fetch_float"" ) ;
 rc = mysql_query ( mysql , ""DROP TABLE IF EXISTS test_bind_fetch"" ) ;
 myquery ( rc ) ;
 rc = mysql_query ( mysql , ""CREATE TABLE test_bind_fetch(c1 float(3), \ c2 float, \ c3 float unsigned, \ c4 float, \ c5 float, \ c6 float, \ c7 float(10) unsigned)"" ) ;
 myquery ( rc ) ;
 bind_fetch ( 2 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int file_compare_by_parent_uri ( NautilusFile * file_a , NautilusFile * file_b ) {
 char * parent_uri_a , * parent_uri_b ;
 int ret ;
 parent_uri_a = nautilus_file_get_parent_uri ( file_a ) ;
 parent_uri_b = nautilus_file_get_parent_uri ( file_b ) ;
 ret = strcmp ( parent_uri_a , parent_uri_b ) ;
 g_free ( parent_uri_a ) ;
 g_free ( parent_uri_b ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 IdcinContext * s = avctx -> priv_data ;
 const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;
 s -> buf = buf ;
 s -> size = buf_size ;
 if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;
 if ( ff_get_buffer ( avctx , & s -> frame ) ) {
 av_log ( avctx , AV_LOG_ERROR , "" id CIN Video: get_buffer() failed\n"" ) ;
 return - 1 ;
 }
 idcin_decode_vlcs ( s ) ;
 if ( pal ) {
 s -> frame . palette_has_changed = 1 ;
 memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;
 }
 memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"void proto_report_dissector_bug ( const char * message ) {
 if ( getenv ( ""WIRESHARK_ABORT_ON_DISSECTOR_BUG"" ) != NULL ) abort ( ) ;
 else THROW_MESSAGE ( DissectorError , message ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , setFileClass ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 zend_class_entry * ce = spl_ce_SplFileObject ;
 zend_error_handling error_handling ;
 zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|C"" , & ce ) == SUCCESS ) {
 intern -> file_class = ce ;
 }
 zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int auth_server_input_cont ( struct auth_server_connection * conn , const char * const * args ) {
 struct auth_client_request * request ;
 if ( str_array_length ( args ) < 2 ) {
 i_error ( ""BUG: Authentication server sent broken CONT line"" ) ;
 return - 1 ;
 }
 if ( auth_server_lookup_request ( conn , args [ 0 ] , FALSE , & request ) < 0 ) return - 1 ;
 auth_client_request_server_input ( request , AUTH_REQUEST_STATUS_CONTINUE , args + 1 ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * i_alloc_struct_array ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {
 gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;
 obj_header_t * obj ;
 # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;
 # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;
 # ifdef DEBUG if ( pstype -> enum_ptrs == basic_enum_ptrs ) {
 dmprintf2 ( mem , "" i_alloc_struct_array: called with incorrect structure type (not element), struct='%s', client='%s'\n"" , pstype -> sname , cname ) ;
 return NULL ;
 }
 # endif obj = alloc_obj ( imem , ( ulong ) num_elements * pstype -> ssize , pstype , ALLOC_DIRECT , cname ) ;
 if_debug7m ( 'A' , mem , ""[a%d:+<.]%s %s*(%lu=%u*%u) = 0x%lx\n"" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;
 return ( char * ) obj ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , getBasename ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 char * suffix = 0 , * fname ;
 int slen = 0 ;
 size_t flen ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""|s"" , & suffix , & slen ) == FAILURE ) {
 return ;
 }
 php_basename ( intern -> u . dir . entry . d_name , strlen ( intern -> u . dir . entry . d_name ) , suffix , slen , & fname , & flen TSRMLS_CC ) ;
 RETURN_STRINGL ( fname , flen , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"const char * tok2str ( register const struct tok * lp , register const char * fmt , register u_int v ) {
 static char buf [ 4 ] [ TOKBUFSIZE ] ;
 static int idx = 0 ;
 char * ret ;
 ret = buf [ idx ] ;
 idx = ( idx + 1 ) & 3 ;
 return tok2strbuf ( lp , fmt , v , ret , sizeof ( buf [ 0 ] ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"WRITE_CLASS_ENCODER ( CephXServiceTicket ) struct CephXServiceTicketInfo {
 AuthTicket ticket ;
 CryptoKey session_key ;
 void encode ( bufferlist & bl ) const {
 __u8 struct_v = 1 ;
 : : encode ( struct_v , bl ) ;
 : : encode ( ticket , bl ) ;
 : : encode ( session_key , bl ) ;
 }
 void decode ( bufferlist : : iterator & bl ) {
 __u8 struct_v ;
 : : decode ( struct_v , bl ) ;
 : : decode ( ticket , bl ) ;
 : : decode ( session_key , bl ) ;
 }
 }
 ;
 WRITE_CLASS_ENCODER ( CephXServiceTicketInfo ) struct CephXAuthorize {
 uint64_t nonce ;
 void encode ( bufferlist & bl ) const {
 __u8 struct_v = 1 ;
 : : encode ( struct_v , bl ) ;
 : : encode ( nonce , bl ) ;
 }
 void decode ( bufferlist : : iterator & bl ) {
 __u8 struct_v ;
 : : decode ( struct_v , bl ) ;
 : : decode ( nonce , bl ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void server_port_read ( struct evdns_server_port * s ) {
 u8 packet [ 1500 ] ;
 struct sockaddr_storage addr ;
 socklen_t addrlen ;
 int r ;
 for ( ;
 ;
 ) {
 addrlen = sizeof ( struct sockaddr_storage ) ;
 r = recvfrom ( s -> socket , packet , sizeof ( packet ) , 0 , ( struct sockaddr * ) & addr , & addrlen ) ;
 if ( r < 0 ) {
 int err = last_error ( s -> socket ) ;
 if ( error_is_eagain ( err ) ) return ;
 log ( EVDNS_LOG_WARN , ""Error %s (%d) while reading request."" , strerror ( err ) , err ) ;
 return ;
 }
 request_parse ( packet , r , s , ( struct sockaddr * ) & addr , addrlen ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static struct tree_content * new_tree_content ( unsigned int cnt ) {
 struct avail_tree_content * f , * l = NULL ;
 struct tree_content * t ;
 unsigned int hc = hc_entries ( cnt ) ;
 for ( f = avail_tree_table [ hc ] ;
 f ;
 l = f , f = f -> next_avail ) if ( f -> entry_capacity >= cnt ) break ;
 if ( f ) {
 if ( l ) l -> next_avail = f -> next_avail ;
 else avail_tree_table [ hc ] = f -> next_avail ;
 }
 else {
 cnt = cnt & 7 ? ( ( cnt / 8 ) + 1 ) * 8 : cnt ;
 f = pool_alloc ( sizeof ( * t ) + sizeof ( t -> entries [ 0 ] ) * cnt ) ;
 f -> entry_capacity = cnt ;
 }
 t = ( struct tree_content * ) f ;
 t -> entry_count = 0 ;
 t -> delta_depth = 0 ;
 return t ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void sbr_chirp ( SpectralBandReplication * sbr , SBRData * ch_data ) {
 int i ;
 float new_bw ;
 static const float bw_tab [ ] = {
 0.0f , 0.75f , 0.9f , 0.98f }
 ;
 for ( i = 0 ;
 i < sbr -> n_q ;
 i ++ ) {
 if ( ch_data -> bs_invf_mode [ 0 ] [ i ] + ch_data -> bs_invf_mode [ 1 ] [ i ] == 1 ) {
 new_bw = 0.6f ;
 }
 else new_bw = bw_tab [ ch_data -> bs_invf_mode [ 0 ] [ i ] ] ;
 if ( new_bw < ch_data -> bw_array [ i ] ) {
 new_bw = 0.75f * new_bw + 0.25f * ch_data -> bw_array [ i ] ;
 }
 else new_bw = 0.90625f * new_bw + 0.09375f * ch_data -> bw_array [ i ] ;
 ch_data -> bw_array [ i ] = new_bw < 0.015625f ? 0.0f : new_bw ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Content ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_Content , Content_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_uinteger_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int64_t num = args [ 0 ] . int64Value ;
 UNumberFormat * format ;
 UChar result [ UPRINTF_BUFFER_SIZE ] ;
 int32_t minDigits = - 1 ;
 int32_t resultLen ;
 UErrorCode status = U_ZERO_ERROR ;
 if ( info -> fIsShort ) num &= UINT16_MAX ;
 else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;
 format = u_locbund_getNumberFormat ( formatBundle , UNUM_DECIMAL ) ;
 if ( format == 0 ) return 0 ;
 if ( info -> fPrecision != - 1 ) {
 minDigits = unum_getAttribute ( format , UNUM_MIN_INTEGER_DIGITS ) ;
 unum_setAttribute ( format , UNUM_MIN_INTEGER_DIGITS , info -> fPrecision ) ;
 }
 resultLen = unum_formatInt64 ( format , num , result , UPRINTF_BUFFER_SIZE , 0 , & status ) ;
 if ( U_FAILURE ( status ) ) {
 resultLen = 0 ;
 }
 if ( minDigits != - 1 ) {
 unum_setAttribute ( format , UNUM_MIN_INTEGER_DIGITS , minDigits ) ;
 }
 return handler -> pad_and_justify ( context , info , result , resultLen ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static GList * get_trash_dirs_for_mount ( GMount * mount ) {
 GFile * root ;
 GFile * trash ;
 char * relpath ;
 GList * list ;
 root = g_mount_get_root ( mount ) ;
 if ( root == NULL ) {
 return NULL ;
 }
 list = NULL ;
 if ( g_file_is_native ( root ) ) {
 relpath = g_strdup_printf ( "".Trash/%d"" , getuid ( ) ) ;
 trash = g_file_resolve_relative_path ( root , relpath ) ;
 g_free ( relpath ) ;
 list = g_list_prepend ( list , g_file_get_child ( trash , ""files"" ) ) ;
 list = g_list_prepend ( list , g_file_get_child ( trash , ""info"" ) ) ;
 g_object_unref ( trash ) ;
 relpath = g_strdup_printf ( "".Trash-%d"" , getuid ( ) ) ;
 trash = g_file_get_child ( root , relpath ) ;
 g_free ( relpath ) ;
 list = g_list_prepend ( list , g_file_get_child ( trash , ""files"" ) ) ;
 list = g_list_prepend ( list , g_file_get_child ( trash , ""info"" ) ) ;
 g_object_unref ( trash ) ;
 }
 g_object_unref ( root ) ;
 return list ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * _ISCIIgetName ( const UConverter * cnv ) {
 if ( cnv -> extraInfo ) {
 UConverterDataISCII * myData = ( UConverterDataISCII * ) cnv -> extraInfo ;
 return myData -> name ;
 }
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void fill_vaapi_pic ( VAPictureH264 * va_pic , Picture * pic , int pic_structure ) {
 if ( pic_structure == 0 ) pic_structure = pic -> f . reference ;
 pic_structure &= PICT_FRAME ;
 va_pic -> picture_id = ff_vaapi_get_surface_id ( pic ) ;
 va_pic -> frame_idx = pic -> long_ref ? pic -> pic_id : pic -> frame_num ;
 va_pic -> flags = 0 ;
 if ( pic_structure != PICT_FRAME ) va_pic -> flags |= ( pic_structure & PICT_TOP_FIELD ) ? VA_PICTURE_H264_TOP_FIELD : VA_PICTURE_H264_BOTTOM_FIELD ;
 if ( pic -> f . reference ) va_pic -> flags |= pic -> long_ref ? VA_PICTURE_H264_LONG_TERM_REFERENCE : VA_PICTURE_H264_SHORT_TERM_REFERENCE ;
 va_pic -> TopFieldOrderCnt = 0 ;
 if ( pic -> field_poc [ 0 ] != INT_MAX ) va_pic -> TopFieldOrderCnt = pic -> field_poc [ 0 ] ;
 va_pic -> BottomFieldOrderCnt = 0 ;
 if ( pic -> field_poc [ 1 ] != INT_MAX ) va_pic -> BottomFieldOrderCnt = pic -> field_poc [ 1 ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) {
 Mpeg1Context * s1 = avctx -> priv_data ;
 MpegEncContext * s = & s1 -> mpeg_enc_ctx ;
 if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) return 0 ;
 if ( s -> avctx -> hwaccel ) {
 if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) av_log ( avctx , AV_LOG_ERROR , ""hardware accelerator failed to decode picture\n"" ) ;
 }
 if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) ff_xvmc_field_end ( s ) ;
 if ( ! s -> first_field ) {
 s -> current_picture_ptr -> f . qscale_type = FF_QSCALE_TYPE_MPEG2 ;
 ff_er_frame_end ( & s -> er ) ;
 ff_MPV_frame_end ( s ) ;
 if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {
 * pict = s -> current_picture_ptr -> f ;
 ff_print_debug_info ( s , pict ) ;
 }
 else {
 if ( avctx -> active_thread_type & FF_THREAD_FRAME ) s -> picture_number ++ ;
 if ( s -> last_picture_ptr != NULL ) {
 * pict = s -> last_picture_ptr -> f ;
 ff_print_debug_info ( s , pict ) ;
 }
 }
 return 1 ;
 }
 else {
 return 0 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int qemudParseDriveAddReply ( const char * reply , virDomainDeviceDriveAddressPtr addr ) {
 char * s , * e ;
 if ( ! ( s = strstr ( reply , ""OK "" ) ) ) return - 1 ;
 s += 3 ;
 if ( STRPREFIX ( s , ""bus "" ) ) {
 s += strlen ( ""bus "" ) ;
 if ( virStrToLong_ui ( s , & e , 10 , & addr -> bus ) == - 1 ) {
 VIR_WARN ( ""Unable to parse bus '%s'"" , s ) ;
 return - 1 ;
 }
 if ( ! STRPREFIX ( e , "", "" ) ) {
 VIR_WARN ( ""Expected ', ' parsing drive_add reply '%s'"" , s ) ;
 return - 1 ;
 }
 s = e + 2 ;
 }
 if ( ! STRPREFIX ( s , ""unit "" ) ) {
 VIR_WARN ( ""Expected 'unit ' parsing drive_add reply '%s'"" , s ) ;
 return - 1 ;
 }
 s += strlen ( ""bus "" ) ;
 if ( virStrToLong_ui ( s , & e , 10 , & addr -> unit ) == - 1 ) {
 VIR_WARN ( ""Unable to parse unit number '%s'"" , s ) ;
 return - 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int btatt_call_dissector_by_dissector_name_with_data ( const char * dissector_name , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {
 dissector_handle_t handle ;
 handle = find_dissector ( dissector_name ) ;
 if ( handle != NULL ) return call_dissector_with_data ( handle , tvb , pinfo , tree , data ) ;
 else return call_data_dissector ( tvb , pinfo , tree ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultDontBlock ) {
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""mailto"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingExtensionContextDuringIncognitoTeardown ) {
 Browser * incognito_browser = OpenURLOffTheRecord ( browser ( ) -> profile ( ) , GURL ( ""about:blank"" ) ) ;
 RunURLFetcherActiveDuringIncognitoTeardownTest ( incognito_browser , incognito_browser -> profile ( ) -> GetRequestContextForExtensions ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static guint16 de_tp_ack ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {
 guint32 curr_offset ;
 guchar oct ;
 curr_offset = offset ;
 oct = tvb_get_guint8 ( tvb , curr_offset ) ;
 if ( ( oct & 0xF0 ) == 0x80 ) proto_tree_add_uint ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , oct & 0x01 ) ;
 else proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , 0xFF , ""No acknowledgment element present"" ) ;
 curr_offset += 1 ;
 return ( curr_offset - offset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int evhttp_add_header_internal ( struct evkeyvalq * headers , const char * key , const char * value ) {
 struct evkeyval * header = calloc ( 1 , sizeof ( struct evkeyval ) ) ;
 if ( header == NULL ) {
 event_warn ( ""%s: calloc"" , __func__ ) ;
 return ( - 1 ) ;
 }
 if ( ( header -> key = strdup ( key ) ) == NULL ) {
 free ( header ) ;
 event_warn ( ""%s: strdup"" , __func__ ) ;
 return ( - 1 ) ;
 }
 if ( ( header -> value = strdup ( value ) ) == NULL ) {
 free ( header -> key ) ;
 free ( header ) ;
 event_warn ( ""%s: strdup"" , __func__ ) ;
 return ( - 1 ) ;
 }
 TAILQ_INSERT_TAIL ( headers , header , next ) ;
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( FastUnloadTest , BrowserListForceCloseAfterNormalCloseWithFastUnload ) {
 NavigateToDataURL ( BEFORE_UNLOAD_HTML , ""beforeunload"" ) ;
 content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;
 UnloadResults unload_results ;
 BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , false ) ;
 BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , true ) ;
 window_observer . Wait ( ) ;
 EXPECT_EQ ( 1 , unload_results . get_successes ( ) ) ;
 EXPECT_EQ ( 0 , unload_results . get_aborts ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_notify_info_data_buffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {
 guint32 len ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_buffer_len , & len ) ;
 offset = dissect_ndr_uint16s ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_buffer_data , len ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorTextDiskSnapshot ( qemuMonitorPtr mon , const char * device , const char * file ) {
 char * cmd = NULL ;
 char * reply = NULL ;
 int ret = - 1 ;
 char * safename ;
 if ( ! ( safename = qemuMonitorEscapeArg ( file ) ) || virAsprintf ( & cmd , ""snapshot_blkdev %s \""%s\"""" , device , safename ) < 0 ) {
 virReportOOMError ( ) ;
 goto cleanup ;
 }
 if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {
 qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( ""failed to take snapshot using command '%s'"" ) , cmd ) ;
 goto cleanup ;
 }
 if ( strstr ( reply , ""error while creating qcow2"" ) != NULL || strstr ( reply , ""unknown command:"" ) != NULL ) {
 qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( ""Failed to take snapshot: %s"" ) , reply ) ;
 goto cleanup ;
 }
 ret = 0 ;
 cleanup : VIR_FREE ( safename ) ;
 VIR_FREE ( cmd ) ;
 VIR_FREE ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_bug5315 ( ) {
 MYSQL_STMT * stmt ;
 const char * stmt_text ;
 int rc ;
 myheader ( ""test_bug5315"" ) ;
 stmt_text = ""SELECT 1"" ;
 stmt = mysql_stmt_init ( mysql ) ;
 rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;
 DIE_UNLESS ( rc == 0 ) ;
 if ( ! opt_silent ) printf ( ""Excuting mysql_change_user\n"" ) ;
 mysql_change_user ( mysql , opt_user , opt_password , current_db ) ;
 if ( ! opt_silent ) printf ( ""Excuting mysql_stmt_execute\n"" ) ;
 rc = mysql_stmt_execute ( stmt ) ;
 DIE_UNLESS ( rc != 0 ) ;
 if ( rc ) {
 if ( ! opt_silent ) printf ( ""Got error (as expected): '%s'\n"" , mysql_stmt_error ( stmt ) ) ;
 }
 if ( ! opt_silent ) printf ( ""Excuting mysql_stmt_close\n"" ) ;
 mysql_stmt_close ( stmt ) ;
 if ( ! opt_silent ) printf ( ""Excuting mysql_stmt_init\n"" ) ;
 stmt = mysql_stmt_init ( mysql ) ;
 rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;
 DIE_UNLESS ( rc == 0 ) ;
 rc = mysql_stmt_execute ( stmt ) ;
 DIE_UNLESS ( rc == 0 ) ;
 mysql_stmt_close ( stmt ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void free_days ( UChar * days [ ] ) {
 free_symbols ( days , DAY_COUNT ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ha_checksum mi_byte_checksum ( const uchar * buf , uint length ) {
 ha_checksum crc ;
 const uchar * end = buf + length ;
 for ( crc = 0 ;
 buf != end ;
 buf ++ ) crc = ( ( crc << 1 ) + * ( ( uchar * ) buf ) ) + test ( crc & ( ( ( ha_checksum ) 1 ) << ( 8 * sizeof ( ha_checksum ) - 1 ) ) ) ;
 return crc ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline __s32 ceph_seq_cmp ( __u32 a , __u32 b ) {
 return ( __s32 ) a - ( __s32 ) b ;
 }",0
Detect whether the following code contains vulnerabilities.,"struct ifblock * compiler_create_ifblock ( struct condition * conds , struct block * blk ) {
 struct ifblock * ifblk ;
 SAFE_CALLOC ( ifblk , 1 , sizeof ( struct ifblock ) ) ;
 ifblk -> conds = conds ;
 ifblk -> blk = blk ;
 return ifblk ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void exsltDynEvaluateFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {
 xmlChar * str = NULL ;
 xmlXPathObjectPtr ret = NULL ;
 if ( ctxt == NULL ) return ;
 if ( nargs != 1 ) {
 xsltPrintErrorContext ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL ) ;
 xsltGenericError ( xsltGenericErrorContext , ""dyn:evalute() : invalid number of args %d\n"" , nargs ) ;
 ctxt -> error = XPATH_INVALID_ARITY ;
 return ;
 }
 str = xmlXPathPopString ( ctxt ) ;
 if ( ! str || ! xmlStrlen ( str ) ) {
 if ( str ) xmlFree ( str ) ;
 valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;
 return ;
 }
 ret = xmlXPathEval ( str , ctxt -> context ) ;
 if ( ret ) valuePush ( ctxt , ret ) ;
 else {
 xsltGenericError ( xsltGenericErrorContext , ""dyn:evaluate() : unable to evaluate expression '%s'\n"" , str ) ;
 valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;
 }
 xmlFree ( str ) ;
 return ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuAgentSuspend ( qemuAgentPtr mon , unsigned int target ) {
 int ret = - 1 ;
 virJSONValuePtr cmd ;
 virJSONValuePtr reply = NULL ;
 cmd = qemuAgentMakeCommand ( qemuAgentSuspendModeTypeToString ( target ) , NULL ) ;
 if ( ! cmd ) return - 1 ;
 mon -> await_event = QEMU_AGENT_EVENT_SUSPEND ;
 ret = qemuAgentCommand ( mon , cmd , & reply , false , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) ;
 virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"int remoteSerializeStreamError ( struct qemud_client * client , remote_error * rerr , int proc , int serial ) {
 return remoteSerializeError ( client , rerr , REMOTE_PROGRAM , REMOTE_PROTOCOL_VERSION , proc , REMOTE_STREAM , serial ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_INTEGER_1_256 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 256U , NULL , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * authGSSClientUnwrap ( PyObject * self , PyObject * args ) {
 gss_client_state * state ;
 PyObject * pystate ;
 char * challenge = NULL ;
 int result = 0 ;
 if ( ! PyArg_ParseTuple ( args , ""Os"" , & pystate , & challenge ) ) return NULL ;
 # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {
 # else if ( ! PyCObject_Check ( pystate ) ) {
 # endif PyErr_SetString ( PyExc_TypeError , ""Expected a context object"" ) ;
 return NULL ;
 }
 # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;
 # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;
 # endif if ( state == NULL ) return NULL ;
 result = authenticate_gss_client_unwrap ( state , challenge ) ;
 if ( result == AUTH_GSS_ERROR ) return NULL ;
 return Py_BuildValue ( ""i"" , result ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , IgnoreEquivalentProtocolHandler ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/%s"" ) , ""test2"" ) ;
 registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph1 ) ;
 ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph1 ) ) ;
 ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;
 registry ( ) -> RemoveIgnoredHandler ( ph1 ) ;
 ASSERT_FALSE ( registry ( ) -> IsIgnored ( ph1 ) ) ;
 ASSERT_FALSE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l )",1
Detect whether the following code contains vulnerabilities.,"int dissect_h245_Capability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Capability , Capability_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_bug57058 ( ) {
 MYSQL_RES * res ;
 int rc ;
 DBUG_ENTER ( ""test_bug57058"" ) ;
 myheader ( ""test_bug57058"" ) ;
 rc = mysql_query ( mysql , ""set @@session.long_query_time=0.1"" ) ;
 myquery ( rc ) ;
 DIE_UNLESS ( ! ( mysql -> server_status & SERVER_QUERY_WAS_SLOW ) ) ;
 rc = mysql_query ( mysql , ""select sleep(1)"" ) ;
 myquery ( rc ) ;
 res = mysql_store_result ( mysql ) ;
 DIE_UNLESS ( mysql -> server_status & SERVER_QUERY_WAS_SLOW ) ;
 mysql_free_result ( res ) ;
 rc = mysql_query ( mysql , ""set @@session.long_query_time=default"" ) ;
 myquery ( rc ) ;
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"xmlHashTablePtr xmlHashCreate ( int size ) {
 xmlHashTablePtr table ;
 if ( size <= 0 ) size = 256 ;
 table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;
 if ( table ) {
 table -> dict = NULL ;
 table -> size = size ;
 table -> nbElems = 0 ;
 table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;
 if ( table -> table ) {
 memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;
 return ( table ) ;
 }
 xmlFree ( table ) ;
 }
 return ( NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int make_cdt24_entry ( int p1 , int p2 , int16_t * cdt ) {
 int r , b ;
 b = cdt [ p2 ] ;
 r = cdt [ p1 ] << 16 ;
 return ( b + r ) << 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ulmbcs_byte_t FindLMBCSUniRange ( UChar uniChar ) {
 const struct _UniLMBCSGrpMap * pTable = UniLMBCSGrpMap ;
 while ( uniChar > pTable -> uniEndRange ) {
 pTable ++ ;
 }
 if ( uniChar >= pTable -> uniStartRange ) {
 return pTable -> GrpType ;
 }
 return ULMBCS_GRP_UNICODE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UBool U_CALLCONV _enumPropertyStartsRange ( const void * context , UChar32 start , UChar32 end , uint32_t value ) {
 const USetAdder * sa = ( const USetAdder * ) context ;
 sa -> add ( sa -> set , start ) ;
 ( void ) end ;
 ( void ) value ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_scanf_simple_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {
 ( void ) info ;
 ( void ) args ;
 ( void ) fmt ;
 ( void ) fmtConsumed ;
 * argConverted = 0 ;
 if ( u_fgetc ( input ) != 0x0025 ) {
 * argConverted = - 1 ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean k12_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {
 k12_t * k12 = ( k12_t * ) wth -> priv ;
 guint8 * buffer ;
 gint len ;
 K12_DBG ( 5 , ( ""k12_seek_read: ENTER"" ) ) ;
 if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) {
 K12_DBG ( 5 , ( ""k12_seek_read: SEEK ERROR"" ) ) ;
 return FALSE ;
 }
 len = get_record ( k12 , wth -> random_fh , seek_off , TRUE , err , err_info ) ;
 if ( len < 0 ) {
 K12_DBG ( 5 , ( ""k12_seek_read: READ ERROR"" ) ) ;
 return FALSE ;
 }
 else if ( len < K12_RECORD_SRC_ID + 4 ) {
 K12_DBG ( 5 , ( ""k12_seek_read: SHORT READ"" ) ) ;
 * err = WTAP_ERR_SHORT_READ ;
 return FALSE ;
 }
 buffer = k12 -> rand_read_buff ;
 process_packet_data ( phdr , buf , buffer , len , k12 ) ;
 K12_DBG ( 5 , ( ""k12_seek_read: DONE OK"" ) ) ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void jbig2_decode_mmr_init ( Jbig2MmrCtx * mmr , int width , int height , const byte * data , size_t size ) {
 int i ;
 uint32_t word = 0 ;
 mmr -> width = width ;
 mmr -> height = height ;
 mmr -> data = data ;
 mmr -> size = size ;
 mmr -> data_index = 0 ;
 mmr -> bit_index = 0 ;
 for ( i = 0 ;
 i < size && i < 4 ;
 i ++ ) word |= ( data [ i ] << ( ( 3 - i ) << 3 ) ) ;
 mmr -> word = word ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * _UTF16LEGetName ( const UConverter * cnv ) {
 if ( UCNV_GET_VERSION ( cnv ) == 0 ) {
 return ""UTF-16LE"" ;
 }
 else {
 return ""UTF-16LE,version=1"" ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {
 int i ;
 InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ;
 if ( int_fb_list == NULL ) return - 1 ;
 for ( i = 0 ;
 i < int_fb_list -> num_internal_frame_buffers ;
 ++ i ) {
 if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ;
 }
 if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ;
 if ( int_fb_list -> int_fb [ i ] . size < min_size ) {
 int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ;
 if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;
 int_fb_list -> int_fb [ i ] . size = min_size ;
 }
 fb -> data = int_fb_list -> int_fb [ i ] . data ;
 fb -> size = int_fb_list -> int_fb [ i ] . size ;
 int_fb_list -> int_fb [ i ] . in_use = 1 ;
 fb -> priv = & int_fb_list -> int_fb [ i ] ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void sigint ( int sig ) {
 running = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void exsltSaxonRegister ( void ) {
 xsltRegisterExtModule ( SAXON_NAMESPACE , ( xsltExtInitFunction ) exsltSaxonInit , ( xsltExtShutdownFunction ) exsltSaxonShutdown ) ;
 xsltRegisterExtModuleFunction ( ( const xmlChar * ) ""expression"" , SAXON_NAMESPACE , exsltSaxonExpressionFunction ) ;
 xsltRegisterExtModuleFunction ( ( const xmlChar * ) ""eval"" , SAXON_NAMESPACE , exsltSaxonEvalFunction ) ;
 xsltRegisterExtModuleFunction ( ( const xmlChar * ) ""evaluate"" , SAXON_NAMESPACE , exsltSaxonEvaluateFunction ) ;
 xsltRegisterExtModuleFunction ( ( const xmlChar * ) ""line-number"" , SAXON_NAMESPACE , exsltSaxonLineNumberFunction ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) {
 LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;
 ( void ) arg2 ;
 vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_get_tx_size_context ( const MACROBLOCKD * xd ) {
 const int max_tx_size = max_txsize_lookup [ xd -> mi [ 0 ] -> mbmi . sb_type ] ;
 const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ;
 const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ;
 const int has_above = above_mbmi != NULL ;
 const int has_left = left_mbmi != NULL ;
 int above_ctx = ( has_above && ! above_mbmi -> skip ) ? ( int ) above_mbmi -> tx_size : max_tx_size ;
 int left_ctx = ( has_left && ! left_mbmi -> skip ) ? ( int ) left_mbmi -> tx_size : max_tx_size ;
 if ( ! has_left ) left_ctx = above_ctx ;
 if ( ! has_above ) above_ctx = left_ctx ;
 return ( above_ctx + left_ctx ) > max_tx_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MultiplexEntrySendRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySendRelease , MultiplexEntrySendRelease_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void hostnames ( struct parse * pcmd , FILE * fp ) {
 if ( pcmd -> nargs == 0 ) {
 if ( showhostnames ) ( void ) fprintf ( fp , ""hostnames being shown\n"" ) ;
 else ( void ) fprintf ( fp , ""hostnames not being shown\n"" ) ;
 }
 else {
 if ( STREQ ( pcmd -> argval [ 0 ] . string , ""yes"" ) ) showhostnames = 1 ;
 else if ( STREQ ( pcmd -> argval [ 0 ] . string , ""no"" ) ) showhostnames = 0 ;
 else ( void ) fprintf ( stderr , ""What?\n"" ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void sbr_hf_apply_noise_3 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {
 float phi_sign = 1 - 2 * ( kx & 1 ) ;
 sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 0.0 , - phi_sign , m_max ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCancel ) {
 ShowDialog ( ) ;
 EXPECT_TRUE ( dialog_ -> Cancel ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_FALSE ( accept_ ) ;
 EXPECT_TRUE ( cancel_ ) ;
 EXPECT_FALSE ( dont_block_ ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 , 1 ) ;
 histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : DONT_LAUNCH , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void erase_screen ( AVCodecContext * avctx ) {
 AnsiContext * s = avctx -> priv_data ;
 int i ;
 for ( i = 0 ;
 i < avctx -> height ;
 i ++ ) memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
 s -> x = s -> y = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int estimate_bits_at_q ( FRAME_TYPE frame_type , int q , int mbs , double correction_factor ) {
 const int bpm = ( int ) ( vp9_rc_bits_per_mb ( frame_type , q , correction_factor ) ) ;
 return ( ( uint64_t ) bpm * mbs ) >> BPER_MB_NORMBITS ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ScoredHistoryMatchTest , ScoringScheme ) {
 base : : Time now = base : : Time : : NowFromSystemTime ( ) ;
 std : : string url_string ( ""http://fedcba/"" ) ;
 const GURL url ( url_string ) ;
 history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , """" , 8 , 3 , 1 ) ) ;
 RowWordStarts word_starts ;
 PopulateWordStarts ( row , & word_starts ) ;
 WordStarts two_words_no_offsets ( 2 , 0u ) ;
 VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;
 ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""fed http"" ) , Make2Terms ( ""fed"" , ""http"" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;
 EXPECT_EQ ( 0 , scored . raw_score ) ;
 base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_scheme_matches_ , true ) ;
 ScoredHistoryMatch scored_with_scheme ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""fed http"" ) , Make2Terms ( ""fed"" , ""http"" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;
 EXPECT_GT ( scored_with_scheme . raw_score , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , MAYBE_TestRemoveHandlerRemovesDefault ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""test"" , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""test"" , ""test2"" ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""test"" , ""test3"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 registry ( ) -> RemoveHandler ( ph1 ) ;
 ASSERT_FALSE ( registry ( ) -> IsDefault ( ph1 ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void * xmalloc ( size_t size ) {
 void * ptr = malloc ( size ) ;
 if ( ! ptr && ( size != 0 ) ) {
 perror ( ""xmalloc: Memory allocation failure"" ) ;
 abort ( ) ;
 }
 return ptr ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void test_rfc2231_parser ( void ) {
 const char * input = "";
 key4*=us-ascii''foo"" "";
 key*2=ba%"" "";
 key2*0=a"" "";
 key3*0*=us-ascii'en'xyz"" "";
 key*0=\""foo\"""" "";
 key2*1*=b%25"" "";
 key3*1=plop%"" "";
 key*1=baz"" ;
 const char * output [ ] = {
 ""key"" , ""foobazba%"" , ""key2*"" , ""''ab%25"" , ""key3*"" , ""us-ascii'en'xyzplop%25"" , ""key4*"" , ""us-ascii''foo"" , NULL }
 ;
 struct rfc822_parser_context parser ;
 const char * const * result ;
 unsigned int i ;
 test_begin ( ""rfc2231 parser"" ) ;
 rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;
 test_assert ( rfc2231_parse ( & parser , & result ) == 0 ) ;
 for ( i = 0 ;
 output [ i ] != NULL && result [ i ] != NULL ;
 i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;
 test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;
 test_end ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_SPOOL_PRINTER_INFO ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {
 proto_tree * subtree ;
 guint32 level ;
 proto_tree * item ;
 subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_SPOOL_PRINTER_INFO_LEVEL , & item , ""Spool printer info level"" ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_level , & level ) ;
 switch ( level ) {
 case 3 : {
 guint32 devmode_ptr , secdesc_ptr ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_devmode_ptr , & devmode_ptr ) ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_secdesc_ptr , & secdesc_ptr ) ;
 if ( devmode_ptr ) offset = dissect_DEVMODE_CTR ( tvb , offset , pinfo , subtree , di , drep ) ;
 if ( secdesc_ptr ) offset = dissect_SEC_DESC_BUF ( tvb , offset , pinfo , subtree , di , drep ) ;
 break ;
 }
 case 2 : default : expert_add_info_format ( pinfo , item , & ei_spool_printer_info_level , ""Unknown spool printer info level %d"" , level ) ;
 break ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dtls1_clear_queues ( SSL * s ) {
 pitem * item = NULL ;
 hm_fragment * frag = NULL ;
 while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) {
 frag = ( hm_fragment * ) item -> data ;
 dtls1_hm_fragment_free ( frag ) ;
 pitem_free ( item ) ;
 }
 while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) {
 frag = ( hm_fragment * ) item -> data ;
 dtls1_hm_fragment_free ( frag ) ;
 pitem_free ( item ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void update_consonant_positions ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {
 const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;
 if ( indic_plan -> config -> base_pos != BASE_POS_LAST ) return ;
 hb_codepoint_t virama ;
 if ( indic_plan -> get_virama_glyph ( font , & virama ) ) {
 hb_face_t * face = font -> face ;
 unsigned int count = buffer -> len ;
 hb_glyph_info_t * info = buffer -> info ;
 for ( unsigned int i = 0 ;
 i < count ;
 i ++ ) if ( info [ i ] . indic_position ( ) == POS_BASE_C ) {
 hb_codepoint_t consonant = info [ i ] . codepoint ;
 info [ i ] . indic_position ( ) = consonant_position_from_face ( indic_plan , consonant , virama , face ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int SpoolssGeneric_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {
 int len = tvb_reported_length ( tvb ) ;
 proto_tree_add_expert ( tree , pinfo , & ei_unimplemented_dissector , tvb , offset , 0 ) ;
 offset = dissect_doserror ( tvb , len - 4 , pinfo , tree , di , drep , hf_rc , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace )",1
Detect whether the following code contains vulnerabilities.,"static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {
 int i ;
 memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;
 for ( i = 0 ;
 i < sbr -> n_q ;
 i ++ ) ch_data -> bs_invf_mode [ 0 ] [ i ] = get_bits ( gb , 2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_FacilityReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 581 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_FacilityReason , FacilityReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int64_t num = args [ 0 ] . int64Value ;
 UChar result [ UPRINTF_BUFFER_SIZE ] ;
 int32_t len = UPRINTF_BUFFER_SIZE ;
 if ( info -> fIsShort ) num &= UINT16_MAX ;
 else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;
 ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;
 if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {
 memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;
 result [ 0 ] = 0x0030 ;
 result [ 1 ] = info -> fSpec ;
 len += 2 ;
 }
 return handler -> pad_and_justify ( context , info , result , len ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint64_t openpic_src_read ( void * opaque , uint64_t addr , unsigned len ) {
 OpenPICState * opp = opaque ;
 uint32_t retval ;
 int idx ;
 DPRINTF ( ""%s: addr %#"" HWADDR_PRIx ""\n"" , __func__ , addr ) ;
 retval = 0xFFFFFFFF ;
 addr = addr & 0xffff ;
 idx = addr >> 5 ;
 switch ( addr & 0x1f ) {
 case 0x00 : retval = read_IRQreg_ivpr ( opp , idx ) ;
 break ;
 case 0x10 : retval = read_IRQreg_idr ( opp , idx ) ;
 break ;
 case 0x18 : retval = read_IRQreg_ilr ( opp , idx ) ;
 break ;
 }
 DPRINTF ( ""%s: => 0x%08x\n"" , __func__ , retval ) ;
 return retval ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void xhci_stop ( XHCIState * xhci ) {
 trace_usb_xhci_stop ( ) ;
 xhci -> usbsts |= USBSTS_HCH ;
 xhci -> crcr_low &= ~ CRCR_CRR ;
 }",0
Detect whether the following code contains vulnerabilities.,"int event_reinit ( struct event_base * base ) {
 const struct eventop * evsel = base -> evsel ;
 void * evbase = base -> evbase ;
 int res = 0 ;
 struct event * ev ;
 if ( ! evsel -> need_reinit ) return ( 0 ) ;
 if ( base -> sig . ev_signal_added ) {
 event_queue_remove ( base , & base -> sig . ev_signal , EVLIST_INSERTED ) ;
 if ( base -> sig . ev_signal . ev_flags & EVLIST_ACTIVE ) event_queue_remove ( base , & base -> sig . ev_signal , EVLIST_ACTIVE ) ;
 base -> sig . ev_signal_added = 0 ;
 }
 if ( base -> evsel -> dealloc != NULL ) base -> evsel -> dealloc ( base , base -> evbase ) ;
 evbase = base -> evbase = evsel -> init ( base ) ;
 if ( base -> evbase == NULL ) event_errx ( 1 , ""%s: could not reinitialize event mechanism"" , __func__ ) ;
 TAILQ_FOREACH ( ev , & base -> eventqueue , ev_next ) {
 if ( evsel -> add ( evbase , ev ) == - 1 ) res = - 1 ;
 }
 return ( res ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void pk_transaction_get_categories ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {
 g_autoptr ( GError ) error = NULL ;
 g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;
 g_return_if_fail ( transaction -> priv -> tid != NULL ) ;
 g_debug ( ""GetCategories method called"" ) ;
 if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_GET_CATEGORIES ) ) {
 g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , ""GetCategories not supported by backend"" ) ;
 pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;
 goto out ;
 }
 pk_transaction_set_role ( transaction , PK_ROLE_ENUM_GET_CATEGORIES ) ;
 pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;
 out : pk_transaction_dbus_return ( context , error ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void check_cluster_versions ( void ) {
 prep_status ( ""Checking cluster versions"" ) ;
 old_cluster . major_version = get_major_server_version ( & old_cluster ) ;
 new_cluster . major_version = get_major_server_version ( & new_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) pg_fatal ( ""This utility can only upgrade from PostgreSQL version 8.4 and later.\n"" ) ;
 if ( GET_MAJOR_VERSION ( new_cluster . major_version ) != GET_MAJOR_VERSION ( PG_VERSION_NUM ) ) pg_fatal ( ""This utility can only upgrade to PostgreSQL version %s.\n"" , PG_MAJORVERSION ) ;
 if ( old_cluster . major_version > new_cluster . major_version ) pg_fatal ( ""This utility cannot be used to downgrade to older major PostgreSQL versions.\n"" ) ;
 get_bin_version ( & old_cluster ) ;
 get_bin_version ( & new_cluster ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) != GET_MAJOR_VERSION ( old_cluster . bin_version ) ) pg_fatal ( ""Old cluster data and binary directories are from different major versions.\n"" ) ;
 if ( GET_MAJOR_VERSION ( new_cluster . major_version ) != GET_MAJOR_VERSION ( new_cluster . bin_version ) ) pg_fatal ( ""New cluster data and binary directories are from different major versions.\n"" ) ;
 check_ok ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void spl_filesystem_dir_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) {
 spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;
 object -> u . dir . index ++ ;
 spl_filesystem_dir_read ( object TSRMLS_CC ) ;
 if ( object -> file_name ) {
 efree ( object -> file_name ) ;
 object -> file_name = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void Type_Measurement_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {
 _cmsFree ( self -> ContextID , Ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vpx_svc_get_encode_frame_count ( const SvcContext * svc_ctx ) {
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL ) return 0 ;
 return si -> encode_frame_count ;
 }",1
Detect whether the following code contains vulnerabilities.,"OM_uint32 kg_set_ccache_name ( OM_uint32 * minor_status , const char * name ) {
 char * new_name = NULL ;
 char * swap = NULL ;
 char * kg_ccache_name ;
 krb5_error_code kerr ;
 if ( name ) {
 new_name = strdup ( name ) ;
 if ( new_name == NULL ) {
 * minor_status = ENOMEM ;
 return GSS_S_FAILURE ;
 }
 }
 kg_ccache_name = k5_getspecific ( K5_KEY_GSS_KRB5_CCACHE_NAME ) ;
 swap = kg_ccache_name ;
 kg_ccache_name = new_name ;
 new_name = swap ;
 kerr = k5_setspecific ( K5_KEY_GSS_KRB5_CCACHE_NAME , kg_ccache_name ) ;
 if ( kerr != 0 ) {
 free ( kg_ccache_name ) ;
 * minor_status = kerr ;
 return GSS_S_FAILURE ;
 }
 free ( new_name ) ;
 * minor_status = 0 ;
 return GSS_S_COMPLETE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline RV34VLC * choose_vlc_set ( int quant , int mod , int type ) {
 if ( mod == 2 && quant < 19 ) quant += 10 ;
 else if ( mod && quant < 26 ) quant += 5 ;
 return type ? & inter_vlcs [ rv34_quant_to_vlc_set [ 1 ] [ av_clip ( quant , 0 , 30 ) ] ] : & intra_vlcs [ rv34_quant_to_vlc_set [ 0 ] [ av_clip ( quant , 0 , 30 ) ] ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"int xsltSetCtxtSecurityPrefs ( xsltSecurityPrefsPtr sec , xsltTransformContextPtr ctxt ) {
 if ( ctxt == NULL ) return ( - 1 ) ;
 ctxt -> sec = ( void * ) sec ;
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void or_bits ( REP_SET * to , REP_SET * from ) {
 reg1 uint i ;
 for ( i = 0 ;
 i < to -> size_of_bits ;
 i ++ ) to -> bits [ i ] |= from -> bits [ i ] ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSMimeHdrFieldValueStringInsert ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , const char * value , int length ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;
 sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) value ) == TS_SUCCESS ) ;
 if ( ! isWriteable ( bufp ) ) {
 return TS_ERROR ;
 }
 if ( length == - 1 ) {
 length = strlen ( value ) ;
 }
 TSMimeFieldValueInsert ( bufp , field , value , length , idx ) ;
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void kq_dealloc ( struct event_base * base , void * arg ) {
 struct kqop * kqop = arg ;
 if ( kqop -> changes ) free ( kqop -> changes ) ;
 if ( kqop -> events ) free ( kqop -> events ) ;
 if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;
 memset ( kqop , 0 , sizeof ( struct kqop ) ) ;
 free ( kqop ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * Type_Data_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {
 cmsICCData * BinData ;
 cmsUInt32Number LenOfData ;
 * nItems = 0 ;
 if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) return NULL ;
 LenOfData = SizeOfTag - sizeof ( cmsUInt32Number ) ;
 if ( LenOfData > INT_MAX ) return NULL ;
 BinData = ( cmsICCData * ) _cmsMalloc ( self -> ContextID , sizeof ( cmsICCData ) + LenOfData - 1 ) ;
 if ( BinData == NULL ) return NULL ;
 BinData -> len = LenOfData ;
 if ( ! _cmsReadUInt32Number ( io , & BinData -> flag ) ) {
 _cmsFree ( self -> ContextID , BinData ) ;
 return NULL ;
 }
 if ( io -> Read ( io , BinData -> data , sizeof ( cmsUInt8Number ) , LenOfData ) != LenOfData ) {
 _cmsFree ( self -> ContextID , BinData ) ;
 return NULL ;
 }
 * nItems = 1 ;
 return ( void * ) BinData ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_vertical_16_sse2 ( unsigned char * s , int p , const unsigned char * blimit , const unsigned char * limit , const unsigned char * thresh ) {
 DECLARE_ALIGNED_ARRAY ( 8 , unsigned char , t_dst , 8 * 16 ) ;
 unsigned char * src [ 2 ] ;
 unsigned char * dst [ 2 ] ;
 src [ 0 ] = s - 8 ;
 src [ 1 ] = s ;
 dst [ 0 ] = t_dst ;
 dst [ 1 ] = t_dst + 8 * 8 ;
 transpose ( src , p , dst , 8 , 2 ) ;
 mb_lpf_horizontal_edge_w_sse2_8 ( t_dst + 8 * 8 , 8 , blimit , limit , thresh ) ;
 src [ 0 ] = t_dst ;
 src [ 1 ] = t_dst + 8 * 8 ;
 dst [ 0 ] = s - 8 ;
 dst [ 1 ] = s ;
 transpose ( src , 8 , dst , p , 2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"fz_colorspace * fz_default_output_intent ( fz_context * ctx , const fz_default_colorspaces * default_cs ) {
 if ( default_cs ) return default_cs -> oi ;
 else return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void pfkey_exit_proc ( struct net * net ) {
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x5 ( IpvideoContext * s ) {
 signed char x , y ;
 x = bytestream2_get_byte ( & s -> stream_ptr ) ;
 y = bytestream2_get_byte ( & s -> stream_ptr ) ;
 av_dlog ( NULL , "" motion bytes = %d, %d\n"" , x , y ) ;
 return copy_from ( s , & s -> last_frame , x , y ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void read_embedded_server_arguments ( const char * name ) {
 char argument [ 1024 ] , buff [ FN_REFLEN ] , * str = 0 ;
 FILE * file ;
 if ( ! test_if_hard_path ( name ) ) {
 strxmov ( buff , opt_basedir , name , NullS ) ;
 name = buff ;
 }
 fn_format ( buff , name , """" , """" , MY_UNPACK_FILENAME ) ;
 if ( ! embedded_server_arg_count ) {
 embedded_server_arg_count = 1 ;
 embedded_server_args [ 0 ] = ( char * ) """" ;
 }
 if ( ! ( file = my_fopen ( buff , O_RDONLY | FILE_BINARY , MYF ( MY_WME ) ) ) ) die ( ""Failed to open file '%s'"" , buff ) ;
 while ( embedded_server_arg_count < MAX_EMBEDDED_SERVER_ARGS && ( str = fgets ( argument , sizeof ( argument ) , file ) ) ) {
 * ( strend ( str ) - 1 ) = 0 ;
 if ( ! ( embedded_server_args [ embedded_server_arg_count ] = ( char * ) my_strdup ( str , MYF ( MY_WME ) ) ) ) {
 my_fclose ( file , MYF ( 0 ) ) ;
 die ( ""Out of memory"" ) ;
 }
 embedded_server_arg_count ++ ;
 }
 my_fclose ( file , MYF ( 0 ) ) ;
 if ( str ) die ( ""Too many arguments in option file: %s"" , name ) ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct8x8_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int i , j ;
 int a1 ;
 int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;
 out = dct_const_round_shift ( out * cospi_16_64 ) ;
 a1 = ROUND_POWER_OF_TWO ( out , 5 ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) {
 for ( i = 0 ;
 i < 8 ;
 ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;
 dest += stride ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_get_switchable_rate ( const VP9_COMP * cpi ) {
 const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;
 const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ;
 return SWITCHABLE_INTERP_RATE_FACTOR * cpi -> switchable_interp_costs [ ctx ] [ mbmi -> interp_filter ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( SyncBookmarkDataTypeControllerTest , StartBookmarkModelNotReady ) {
 CreateBookmarkModel ( DONT_LOAD_MODEL ) ;
 SetStartExpectations ( ) ;
 SetAssociateExpectations ( ) ;
 EXPECT_CALL ( start_callback_ , Run ( DataTypeController : : OK , _ , _ ) ) ;
 bookmark_dtc_ -> LoadModels ( base : : Bind ( & ModelLoadCallbackMock : : Run , base : : Unretained ( & model_load_callback_ ) ) ) ;
 EXPECT_EQ ( DataTypeController : : MODEL_STARTING , bookmark_dtc_ -> state ( ) ) ;
 TestingPrefServiceSimple prefs ;
 bookmark_model_ -> Load ( & prefs , std : : string ( ) , base : : FilePath ( ) , base : : ThreadTaskRunnerHandle : : Get ( ) , base : : ThreadTaskRunnerHandle : : Get ( ) ) ;
 bookmarks : : test : : WaitForBookmarkModelToLoad ( bookmark_model_ . get ( ) ) ;
 EXPECT_EQ ( DataTypeController : : MODEL_LOADED , bookmark_dtc_ -> state ( ) ) ;
 bookmark_dtc_ -> StartAssociating ( base : : Bind ( & StartCallbackMock : : Run , base : : Unretained ( & start_callback_ ) ) ) ;
 base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;
 EXPECT_EQ ( DataTypeController : : RUNNING , bookmark_dtc_ -> state ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int evhttp_is_connection_keepalive ( struct evkeyvalq * headers ) {
 const char * connection = evhttp_find_header ( headers , ""Connection"" ) ;
 return ( connection != NULL && strncasecmp ( connection , ""keep-alive"" , 10 ) == 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void PyString_Concat ( register PyObject * * pv , register PyObject * w ) {
 register PyObject * v ;
 if ( * pv == NULL ) return ;
 if ( w == NULL || ! PyString_Check ( * pv ) ) {
 Py_CLEAR ( * pv ) ;
 return ;
 }
 v = string_concat ( ( PyStringObject * ) * pv , w ) ;
 Py_SETREF ( * pv , v ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t TSRMLS_DC ) {
 # ifdef PHP_WIN32 unsigned long key = realpath_cache_key ( path , path_len TSRMLS_CC ) ;
 # else unsigned long key = realpath_cache_key ( path , path_len ) ;
 # endif unsigned long n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;
 realpath_cache_bucket * * bucket = & CWDG ( realpath_cache ) [ n ] ;
 while ( * bucket != NULL ) {
 if ( CWDG ( realpath_cache_ttl ) && ( * bucket ) -> expires < t ) {
 realpath_cache_bucket * r = * bucket ;
 * bucket = ( * bucket ) -> next ;
 if ( r -> path == r -> realpath ) {
 CWDG ( realpath_cache_size ) -= sizeof ( realpath_cache_bucket ) + r -> path_len + 1 ;
 }
 else {
 CWDG ( realpath_cache_size ) -= sizeof ( realpath_cache_bucket ) + r -> path_len + 1 + r -> realpath_len + 1 ;
 }
 free ( r ) ;
 }
 else if ( key == ( * bucket ) -> key && path_len == ( * bucket ) -> path_len && memcmp ( path , ( * bucket ) -> path , path_len ) == 0 ) {
 return * bucket ;
 }
 else {
 bucket = & ( * bucket ) -> next ;
 }
 }
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"void gx_device_set_media_size ( gx_device * dev , double media_width , double media_height ) {
 dev -> MediaSize [ 0 ] = media_width ;
 dev -> MediaSize [ 1 ] = media_height ;
 gx_device_set_hwsize_from_media ( dev ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_double_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , double value , const char * format , ... ) {
 proto_item * pi ;
 va_list ap ;
 pi = proto_tree_add_double ( tree , hfindex , tvb , start , length , value ) ;
 if ( pi != tree ) {
 va_start ( ap , format ) ;
 proto_tree_set_representation_value ( pi , format , ap ) ;
 va_end ( ap ) ;
 }
 return pi ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * timelib_string ( Scanner * s ) {
 char * tmp = calloc ( 1 , s -> cur - s -> tok + 1 ) ;
 memcpy ( tmp , s -> tok , s -> cur - s -> tok ) ;
 return tmp ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int gic_get_current_cpu ( GICState * s ) {
 if ( s -> num_cpu > 1 ) {
 return current_cpu -> cpu_index ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace ) ;
 __exctype ( isupper )",1
Detect whether the following code contains vulnerabilities.,"enum nss_status CONCAT ( _nss_files_set , ENTNAME ) ( int stayopen ) {
 enum nss_status status ;
 __libc_lock_lock ( lock ) ;
 status = internal_setent ( stayopen ) ;
 if ( status == NSS_STATUS_SUCCESS && fgetpos ( stream , & position ) < 0 ) {
 fclose ( stream ) ;
 stream = NULL ;
 status = NSS_STATUS_UNAVAIL ;
 }
 last_use = getent ;
 __libc_lock_unlock ( lock ) ;
 return status ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_InfoRequestNak ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_InfoRequestNak , InfoRequestNak_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline bool e1000e_rx_l3_cso_enabled ( E1000ECore * core ) {
 return ! ! ( core -> mac [ RXCSUM ] & E1000_RXCSUM_IPOFLD ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {
 CURLcode result ;
 char * plainauth ;
 size_t ulen ;
 size_t plen ;
 size_t plainlen ;
 * outlen = 0 ;
 * outptr = NULL ;
 ulen = strlen ( userp ) ;
 plen = strlen ( passwdp ) ;
 if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;
 plainlen = 2 * ulen + plen + 2 ;
 plainauth = malloc ( plainlen ) ;
 if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;
 memcpy ( plainauth , userp , ulen ) ;
 plainauth [ ulen ] = '\0' ;
 memcpy ( plainauth + ulen + 1 , userp , ulen ) ;
 plainauth [ 2 * ulen + 1 ] = '\0' ;
 memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;
 result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;
 free ( plainauth ) ;
 return result ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ __u32 __fswahw32 ( __u32 val ) {
 # ifdef __arch_swahw32 return __arch_swahw32 ( val ) ;
 # else return ___constant_swahw32 ( val ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static int search_request_new ( int type , const char * const name , int flags , evdns_callback_type user_callback , void * user_arg ) {
 assert ( type == TYPE_A || type == TYPE_AAAA ) ;
 if ( ( ( flags & DNS_QUERY_NO_SEARCH ) == 0 ) && global_search_state && global_search_state -> num_domains ) {
 struct request * req ;
 if ( string_num_dots ( name ) >= global_search_state -> ndots ) {
 req = request_new ( type , name , flags , user_callback , user_arg ) ;
 if ( ! req ) return 1 ;
 req -> search_index = - 1 ;
 }
 else {
 char * const new_name = search_make_new ( global_search_state , 0 , name ) ;
 if ( ! new_name ) return 1 ;
 req = request_new ( type , new_name , flags , user_callback , user_arg ) ;
 free ( new_name ) ;
 if ( ! req ) return 1 ;
 req -> search_index = 0 ;
 }
 req -> search_origname = strdup ( name ) ;
 req -> search_state = global_search_state ;
 req -> search_flags = flags ;
 global_search_state -> refcount ++ ;
 request_submit ( req ) ;
 return 0 ;
 }
 else {
 struct request * const req = request_new ( type , name , flags , user_callback , user_arg ) ;
 if ( ! req ) return 1 ;
 request_submit ( req ) ;
 return 0 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int udev_device_info ( struct libusb_context * ctx , int detached , struct udev_device * udev_dev , uint8_t * busnum , uint8_t * devaddr , const char * * sys_name ) {
 const char * dev_node ;
 dev_node = udev_device_get_devnode ( udev_dev ) ;
 if ( ! dev_node ) {
 return LIBUSB_ERROR_OTHER ;
 }
 * sys_name = udev_device_get_sysname ( udev_dev ) ;
 if ( ! * sys_name ) {
 return LIBUSB_ERROR_OTHER ;
 }
 return linux_get_device_address ( ctx , detached , busnum , devaddr , dev_node , * sys_name ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_fht16x16_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {
 if ( tx_type == DCT_DCT ) {
 vp9_fdct16x16_c ( input , output , stride ) ;
 }
 else {
 int16_t out [ 256 ] ;
 int16_t * outptr = & out [ 0 ] ;
 int i , j ;
 int16_t temp_in [ 16 ] , temp_out [ 16 ] ;
 const transform_2d ht = FHT_16 [ tx_type ] ;
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;
 }
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = out [ j + i * 16 ] ;
 ht . rows ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) output [ j + i * 16 ] = temp_out [ j ] ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"REGRESSION_TEST ( SDK_API_TSIOBufferReaderConsume ) ( RegressionTest * test , int , int * pstatus ) {
 bool test_passed = false ;
 * pstatus = REGRESSION_TEST_INPROGRESS ;
 TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;
 TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;
 TSIOBufferProduce ( bufp , 10 ) ;
 TSIOBufferReaderConsume ( readerp , 10 ) ;
 int64_t reader_avail = TSIOBufferReaderAvail ( readerp ) ;
 if ( reader_avail == 0 ) {
 SDK_RPRINT ( test , ""TSIOBufferReaderConsume"" , ""TestCase1"" , TC_PASS , ""ok"" ) ;
 test_passed = true ;
 }
 else {
 SDK_RPRINT ( test , ""TSIOBufferReaderConsume"" , ""TestCase1"" , TC_FAIL , ""failed"" ) ;
 }
 * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {
 return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;
 }
 # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;
 typedef const char * OPENSSL_CSTRING ;
 DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_RequestSeqNum ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 724 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 65535U , & ( h225_pi -> requestSeqNum ) , FALSE ) ;
 # line 732 ""./asn1/h225/h225.cnf"" }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"void dec_connection_count ( THD * thd ) {
 mysql_mutex_lock ( & LOCK_connection_count ) ;
 ( * thd -> scheduler -> connection_count ) -- ;
 mysql_mutex_unlock ( & LOCK_connection_count ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {
 int segment_id ;
 if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;
 xd -> mi = mi ;
 segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;
 set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ;
 no_pred_segcounts [ segment_id ] ++ ;
 if ( cm -> frame_type != KEY_FRAME ) {
 const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;
 const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;
 const int pred_flag = pred_segment_id == segment_id ;
 const int pred_context = vp9_get_pred_context_seg_id ( xd ) ;
 xd -> mi [ 0 ] -> mbmi . seg_id_predicted = pred_flag ;
 temporal_predictor_count [ pred_context ] [ pred_flag ] ++ ;
 if ( ! pred_flag ) t_unpred_seg_counts [ segment_id ] ++ ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , SingleTabSessionRestore ) {
 ui_test_utils : : NavigateToURL ( browser ( ) , GetTestURL ( ) ) ;
 SessionRestorePaintWaiter session_restore_paint_waiter ;
 QuitBrowserAndRestore ( browser ( ) ) ;
 session_restore_paint_waiter . WaitForForegroundTabs ( 1 ) ;
 ExpectFirstPaintMetricsTotalCount ( 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void gx_device_init_on_stack ( gx_device * dev , const gx_device * proto , gs_memory_t * mem ) {
 memcpy ( dev , proto , proto -> params_size ) ;
 dev -> memory = mem ;
 dev -> retained = 0 ;
 dev -> pad = proto -> pad ;
 dev -> log2_align_mod = proto -> log2_align_mod ;
 dev -> is_planar = proto -> is_planar ;
 rc_init ( dev , NULL , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int rtp_packetize_mpa ( sout_stream_id_sys_t * id , block_t * in ) {
 int i_max = rtp_mtu ( id ) - 4 ;
 int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;
 uint8_t * p_data = in -> p_buffer ;
 int i_data = in -> i_buffer ;
 int i ;
 for ( i = 0 ;
 i < i_count ;
 i ++ ) {
 int i_payload = __MIN ( i_max , i_data ) ;
 block_t * out = block_Alloc ( 16 + i_payload ) ;
 rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts ) ;
 SetWBE ( out -> p_buffer + 12 , 0 ) ;
 SetWBE ( out -> p_buffer + 14 , i * i_max ) ;
 memcpy ( & out -> p_buffer [ 16 ] , p_data , i_payload ) ;
 out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;
 out -> i_length = in -> i_length / i_count ;
 rtp_packetize_send ( id , out ) ;
 p_data += i_payload ;
 i_data -= i_payload ;
 }
 block_Release ( in ) ;
 return VLC_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static struct kvm_cpuid2 * get_supported_cpuid ( KVMState * s ) {
 struct kvm_cpuid2 * cpuid ;
 int max = 1 ;
 if ( cpuid_cache != NULL ) {
 return cpuid_cache ;
 }
 while ( ( cpuid = try_get_cpuid ( s , max ) ) == NULL ) {
 max *= 2 ;
 }
 cpuid_cache = cpuid ;
 return cpuid ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {
 update_consonant_positions ( plan , font , buffer ) ;
 insert_dotted_circles ( plan , font , buffer ) ;
 hb_glyph_info_t * info = buffer -> info ;
 unsigned int count = buffer -> len ;
 if ( unlikely ( ! count ) ) return ;
 unsigned int last = 0 ;
 unsigned int last_syllable = info [ 0 ] . syllable ( ) ;
 for ( unsigned int i = 1 ;
 i < count ;
 i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {
 initial_reordering_syllable ( plan , font -> face , buffer , last , i ) ;
 last = i ;
 last_syllable = info [ last ] . syllable ( ) ;
 }
 initial_reordering_syllable ( plan , font -> face , buffer , last , count ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void alloc_limit_failure ( char * fn_name , size_t size ) {
 fprintf ( stderr , ""%s: Maximum allocation size exceeded "" ""(maxsize = %lu;
 size = %lu).\n"" , fn_name , ( unsigned long ) alloc_limit , ( unsigned long ) size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int jbig2_end_of_stripe ( Jbig2Ctx * ctx , Jbig2Segment * segment , const uint8_t * segment_data ) {
 Jbig2Page page = ctx -> pages [ ctx -> current_page ] ;
 int end_row ;
 end_row = jbig2_get_int32 ( segment_data ) ;
 if ( end_row < page . end_row ) {
 jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , ""end of stripe segment with non-positive end row advance"" "" (new end row %d vs current end row %d)"" , end_row , page . end_row ) ;
 }
 else {
 jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , ""end of stripe: advancing end row to %d"" , end_row ) ;
 }
 page . end_row = end_row ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int estimate_array_length ( Node * arrayexpr ) {
 arrayexpr = strip_array_coercion ( arrayexpr ) ;
 if ( arrayexpr && IsA ( arrayexpr , Const ) ) {
 Datum arraydatum = ( ( Const * ) arrayexpr ) -> constvalue ;
 bool arrayisnull = ( ( Const * ) arrayexpr ) -> constisnull ;
 ArrayType * arrayval ;
 if ( arrayisnull ) return 0 ;
 arrayval = DatumGetArrayTypeP ( arraydatum ) ;
 return ArrayGetNItems ( ARR_NDIM ( arrayval ) , ARR_DIMS ( arrayval ) ) ;
 }
 else if ( arrayexpr && IsA ( arrayexpr , ArrayExpr ) && ! ( ( ArrayExpr * ) arrayexpr ) -> multidims ) {
 return list_length ( ( ( ArrayExpr * ) arrayexpr ) -> elements ) ;
 }
 else {
 return 10 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int alac_set_info ( ALACContext * alac ) {
 GetByteContext gb ;
 bytestream2_init ( & gb , alac -> avctx -> extradata , alac -> avctx -> extradata_size ) ;
 bytestream2_skipu ( & gb , 12 ) ;
 alac -> max_samples_per_frame = bytestream2_get_be32u ( & gb ) ;
 if ( ! alac -> max_samples_per_frame || alac -> max_samples_per_frame > INT_MAX ) {
 av_log ( alac -> avctx , AV_LOG_ERROR , ""max samples per frame invalid: %u\n"" , alac -> max_samples_per_frame ) ;
 return AVERROR_INVALIDDATA ;
 }
 bytestream2_skipu ( & gb , 1 ) ;
 alac -> sample_size = bytestream2_get_byteu ( & gb ) ;
 alac -> rice_history_mult = bytestream2_get_byteu ( & gb ) ;
 alac -> rice_initial_history = bytestream2_get_byteu ( & gb ) ;
 alac -> rice_limit = bytestream2_get_byteu ( & gb ) ;
 alac -> channels = bytestream2_get_byteu ( & gb ) ;
 bytestream2_get_be16u ( & gb ) ;
 bytestream2_get_be32u ( & gb ) ;
 bytestream2_get_be32u ( & gb ) ;
 bytestream2_get_be32u ( & gb ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint mac_is_channel_hash ( gconstpointer key ) {
 const mac_is_channel * ch = ( const mac_is_channel * ) key ;
 return ( ch -> ueid << 4 ) | ch -> lchid ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_pred_buffer ( PRED_BUFFER * p , int len ) {
 int i ;
 for ( i = 0 ;
 i < len ;
 i ++ ) {
 if ( ! p [ i ] . in_use ) {
 p [ i ] . in_use = 1 ;
 return i ;
 }
 }
 return - 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , next ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;
 if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {
 spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) ;
 }
 intern -> u . file . current_line_num ++ ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void evhttp_maybe_add_content_length_header ( struct evkeyvalq * headers , long content_length ) {
 if ( evhttp_find_header ( headers , ""Transfer-Encoding"" ) == NULL && evhttp_find_header ( headers , ""Content-Length"" ) == NULL ) {
 char len [ 12 ] ;
 evutil_snprintf ( len , sizeof ( len ) , ""%ld"" , content_length ) ;
 evhttp_add_header ( headers , ""Content-Length"" , len ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ void TLV_LIST_STEP ( struct tlv_list_desc * list ) {
 __u16 tlv_space = TLV_ALIGN ( ntohs ( list -> tlv_ptr -> tlv_len ) ) ;
 list -> tlv_ptr = ( struct tlv_desc * ) ( ( char * ) list -> tlv_ptr + tlv_space ) ;
 list -> tlv_space -= tlv_space ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ulong get_sort ( uint count , ... ) {
 va_list args ;
 va_start ( args , count ) ;
 ulong sort = 0 ;
 DBUG_ASSERT ( count <= 4 ) ;
 while ( count -- ) {
 char * start , * str = va_arg ( args , char * ) ;
 uint chars = 0 ;
 uint wild_pos = 0 ;
 if ( ( start = str ) ) {
 for ( ;
 * str ;
 str ++ ) {
 if ( * str == wild_prefix && str [ 1 ] ) str ++ ;
 else if ( * str == wild_many || * str == wild_one ) {
 wild_pos = ( uint ) ( str - start ) + 1 ;
 break ;
 }
 chars = 128 ;
 }
 }
 sort = ( sort << 8 ) + ( wild_pos ? min ( wild_pos , 127 ) : chars ) ;
 }
 va_end ( args ) ;
 return sort ;
 }",1
Detect whether the following code contains vulnerabilities.,"void run_on_cpu ( CPUState * cpu , void ( * func ) ( void * data ) , void * data ) {
 struct qemu_work_item wi ;
 if ( qemu_cpu_is_self ( cpu ) ) {
 func ( data ) ;
 return ;
 }
 wi . func = func ;
 wi . data = data ;
 if ( cpu -> queued_work_first == NULL ) {
 cpu -> queued_work_first = & wi ;
 }
 else {
 cpu -> queued_work_last -> next = & wi ;
 }
 cpu -> queued_work_last = & wi ;
 wi . next = NULL ;
 wi . done = false ;
 qemu_cpu_kick ( cpu ) ;
 while ( ! wi . done ) {
 CPUArchState * self_env = cpu_single_env ;
 qemu_cond_wait ( & qemu_work_cond , & qemu_global_mutex ) ;
 cpu_single_env = self_env ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Facility_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 441 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Facility_UUIE , Facility_UUIE_sequence ) ;
 # line 445 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_FACILITY ;
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF16BEReset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 if ( UCNV_GET_VERSION ( cnv ) == 0 ) {
 cnv -> mode = 8 ;
 }
 else {
 cnv -> mode = 0 ;
 }
 }
 if ( choice != UCNV_RESET_TO_UNICODE && UCNV_GET_VERSION ( cnv ) == 1 ) {
 cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_FECData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_FECData , FECData_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , rewind ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 intern -> u . dir . index = 0 ;
 if ( intern -> u . dir . dirp ) {
 php_stream_rewinddir ( intern -> u . dir . dirp ) ;
 }
 spl_filesystem_dir_read ( intern TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void evbuffer_align ( struct evbuffer * buf ) {
 memmove ( buf -> orig_buffer , buf -> buffer , buf -> off ) ;
 buf -> buffer = buf -> orig_buffer ;
 buf -> misalign = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static Buf _build_rc_buf ( int rc , uint16_t rpc_version ) {
 Buf buf = NULL ;
 slurm_msg_t msg ;
 return_code_msg_t data ;
 data . return_code = rc ;
 slurm_msg_t_init ( & msg ) ;
 msg . msg_type = RESPONSE_SLURM_RC ;
 msg . data = & data ;
 buf = init_buf ( 128 ) ;
 pack16 ( msg . msg_type , buf ) ;
 if ( pack_msg ( & msg , buf ) != SLURM_SUCCESS ) FREE_NULL_BUFFER ( buf ) ;
 return buf ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( WebUsbDetectorTest , UsbDeviceAddedAndRemoved ) {
 base : : string16 product_name = base : : UTF8ToUTF16 ( kProductName_1 ) ;
 GURL landing_page ( kLandingPage_1 ) ;
 scoped_refptr < device : : MockUsbDevice > device ( new device : : MockUsbDevice ( 0 , 1 , ""Google"" , kProductName_1 , ""002"" , landing_page ) ) ;
 std : : string guid = device -> guid ( ) ;
 Initialize ( ) ;
 device_client_ . usb_service ( ) -> AddDevice ( device ) ;
 message_center : : Notification * notification = message_center_ -> FindVisibleNotificationById ( guid ) ;
 ASSERT_TRUE ( notification != nullptr ) ;
 base : : string16 expected_title = base : : ASCIIToUTF16 ( ""Google Product A detected"" ) ;
 EXPECT_EQ ( expected_title , notification -> title ( ) ) ;
 base : : string16 expected_message = base : : ASCIIToUTF16 ( ""Go to www.google.com/A to connect."" ) ;
 EXPECT_EQ ( expected_message , notification -> message ( ) ) ;
 EXPECT_TRUE ( notification -> delegate ( ) != nullptr ) ;
 device_client_ . usb_service ( ) -> RemoveDevice ( device ) ;
 EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid ) == nullptr ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int in_table_int16 ( const int16_t * table , int last_el , int16_t needle ) {
 int i ;
 for ( i = 0 ;
 i <= last_el ;
 i ++ ) if ( table [ i ] == needle ) return 1 ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( NewAvatarMenuButtonTest , MAYBE_SignOut ) {
 if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;
 CreateTestingProfile ( ) ;
 ASSERT_NO_FATAL_FAILURE ( StartAvatarMenu ( ) ) ;
 BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;
 EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;
 content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;
 AvatarMenu * menu = ProfileChooserView : : profile_bubble_ -> avatar_menu_ . get ( ) ;
 const AvatarMenu : : Item & menu_item_before = menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) ;
 EXPECT_FALSE ( menu_item_before . signin_required ) ;
 ui : : MouseEvent mouse_ev ( ui : : ET_MOUSE_RELEASED , gfx : : Point ( ) , gfx : : Point ( ) , 0 , 0 ) ;
 ProfileChooserView : : profile_bubble_ -> ButtonPressed ( ProfileChooserView : : profile_bubble_ -> lock_button_ , mouse_ev ) ;
 EXPECT_TRUE ( menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) . signin_required ) ;
 window_close_observer . Wait ( ) ;
 EXPECT_TRUE ( browser_list -> empty ( ) ) ;
 if ( ! UserManager : : IsShowing ( ) ) base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;
 UserManager : : Hide ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int make_cdt16_entry ( int p1 , int p2 , int16_t * cdt ) {
 int r , b , lo ;
 b = cdt [ p2 ] ;
 r = cdt [ p1 ] << 11 ;
 lo = b + r ;
 return ( lo + ( lo << 16 ) ) << 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void main_file_cleanup ( main_file * xfile ) {
 XD3_ASSERT ( xfile != NULL ) ;
 if ( main_file_isopen ( xfile ) ) {
 main_file_close ( xfile ) ;
 }
 if ( xfile -> snprintf_buf != NULL ) {
 main_free ( xfile -> snprintf_buf ) ;
 xfile -> snprintf_buf = NULL ;
 }
 if ( xfile -> filename_copy != NULL ) {
 main_free ( xfile -> filename_copy ) ;
 xfile -> filename_copy = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_cryptoEPPwdHash ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_cryptoEPPwdHash , T_cryptoEPPwdHash_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , ftell ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 long ret = php_stream_tell ( intern -> u . file . stream ) ;
 if ( ret == - 1 ) {
 RETURN_FALSE ;
 }
 else {
 RETURN_LONG ( ret ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) {
 sf_count_t total = 0 ;
 ssize_t count ;
 if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;
 items *= bytes ;
 if ( items <= 0 ) return 0 ;
 while ( items > 0 ) {
 count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ;
 count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ;
 if ( count == - 1 ) {
 if ( errno == EINTR ) continue ;
 psf_log_syserr ( psf , errno ) ;
 break ;
 }
 ;
 if ( count == 0 ) break ;
 total += count ;
 items -= count ;
 }
 ;
 if ( psf -> is_pipe ) psf -> pipeoffset += total ;
 return total / bytes ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , next ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 int skip_dots = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_SKIPDOTS ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 intern -> u . dir . index ++ ;
 do {
 spl_filesystem_dir_read ( intern TSRMLS_CC ) ;
 }
 while ( skip_dots && spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;
 if ( intern -> file_name ) {
 efree ( intern -> file_name ) ;
 intern -> file_name = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * * slirp_dnssearch ( const StringList * dnsname ) {
 const StringList * c = dnsname ;
 size_t i = 0 , num_opts = 0 ;
 const char * * ret ;
 while ( c ) {
 num_opts ++ ;
 c = c -> next ;
 }
 if ( num_opts == 0 ) {
 return NULL ;
 }
 ret = g_malloc ( ( num_opts + 1 ) * sizeof ( * ret ) ) ;
 c = dnsname ;
 while ( c ) {
 ret [ i ++ ] = c -> value -> str ;
 c = c -> next ;
 }
 ret [ i ] = NULL ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_InfoRequestNakReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 690 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_InfoRequestNakReason , InfoRequestNakReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void reset_skip_tx_size ( VP9_COMMON * cm , TX_SIZE max_tx_size ) {
 int mi_row , mi_col ;
 const int mis = cm -> mi_stride ;
 MODE_INFO * * mi_ptr = cm -> mi_grid_visible ;
 for ( mi_row = 0 ;
 mi_row < cm -> mi_rows ;
 ++ mi_row , mi_ptr += mis ) {
 for ( mi_col = 0 ;
 mi_col < cm -> mi_cols ;
 ++ mi_col ) {
 if ( mi_ptr [ mi_col ] -> mbmi . tx_size > max_tx_size ) mi_ptr [ mi_col ] -> mbmi . tx_size = max_tx_size ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line8 ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {
 uint32_t * palette ;
 int x ;
 palette = vga -> last_palette ;
 width >>= 3 ;
 for ( x = 0 ;
 x < width ;
 x ++ ) {
 ( ( uint32_t * ) d ) [ 0 ] = palette [ vga_read_byte ( vga , addr + 0 ) ] ;
 ( ( uint32_t * ) d ) [ 1 ] = palette [ vga_read_byte ( vga , addr + 1 ) ] ;
 ( ( uint32_t * ) d ) [ 2 ] = palette [ vga_read_byte ( vga , addr + 2 ) ] ;
 ( ( uint32_t * ) d ) [ 3 ] = palette [ vga_read_byte ( vga , addr + 3 ) ] ;
 ( ( uint32_t * ) d ) [ 4 ] = palette [ vga_read_byte ( vga , addr + 4 ) ] ;
 ( ( uint32_t * ) d ) [ 5 ] = palette [ vga_read_byte ( vga , addr + 5 ) ] ;
 ( ( uint32_t * ) d ) [ 6 ] = palette [ vga_read_byte ( vga , addr + 6 ) ] ;
 ( ( uint32_t * ) d ) [ 7 ] = palette [ vga_read_byte ( vga , addr + 7 ) ] ;
 d += 32 ;
 addr += 8 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int archive_read_format_cpio_bid ( struct archive_read * a , int best_bid ) {
 const unsigned char * p ;
 struct cpio * cpio ;
 int bid ;
 ( void ) best_bid ;
 cpio = ( struct cpio * ) ( a -> format -> data ) ;
 if ( ( p = __archive_read_ahead ( a , 6 , NULL ) ) == NULL ) return ( - 1 ) ;
 bid = 0 ;
 if ( memcmp ( p , ""070707"" , 6 ) == 0 ) {
 cpio -> read_header = header_odc ;
 bid += 48 ;
 }
 else if ( memcmp ( p , ""070727"" , 6 ) == 0 ) {
 cpio -> read_header = header_odc ;
 bid += 48 ;
 }
 else if ( memcmp ( p , ""070701"" , 6 ) == 0 ) {
 cpio -> read_header = header_newc ;
 bid += 48 ;
 }
 else if ( memcmp ( p , ""070702"" , 6 ) == 0 ) {
 cpio -> read_header = header_newc ;
 bid += 48 ;
 }
 else if ( p [ 0 ] * 256 + p [ 1 ] == 070707 ) {
 cpio -> read_header = header_bin_be ;
 bid += 16 ;
 }
 else if ( p [ 0 ] + p [ 1 ] * 256 == 070707 ) {
 cpio -> read_header = header_bin_le ;
 bid += 16 ;
 }
 else return ( ARCHIVE_WARN ) ;
 return ( bid ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;
 * count = info -> fWidth ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , FirstMeaningfulPaintNotRecorded ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/page_load_metrics/page_with_active_connections.html"" ) ) ;
 waiter -> Wait ( ) ;
 NavigateToUntrackedUrl ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstContentfulPaint , 1 ) ;
 histogram_tester_ . ExpectUniqueSample ( internal : : kHistogramFirstMeaningfulPaintStatus , internal : : FIRST_MEANINGFUL_PAINT_DID_NOT_REACH_NETWORK_STABLE , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstMeaningfulPaint , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramParseStartToFirstMeaningfulPaint , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ar_parse_gnu_filename_table ( struct archive_read * a ) {
 struct ar * ar ;
 char * p ;
 size_t size ;
 ar = ( struct ar * ) ( a -> format -> data ) ;
 size = ar -> strtab_size ;
 for ( p = ar -> strtab ;
 p < ar -> strtab + size - 1 ;
 ++ p ) {
 if ( * p == '/' ) {
 * p ++ = '\0' ;
 if ( * p != '\n' ) goto bad_string_table ;
 * p = '\0' ;
 }
 }
 if ( p != ar -> strtab + size && * p != '\n' && * p != '`' ) goto bad_string_table ;
 ar -> strtab [ size - 1 ] = '\0' ;
 return ( ARCHIVE_OK ) ;
 bad_string_table : archive_set_error ( & a -> archive , EINVAL , ""Invalid string table"" ) ;
 free ( ar -> strtab ) ;
 ar -> strtab = NULL ;
 return ( ARCHIVE_WARN ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_spoolss_string_parm ( tvbuff_t * tvb , gint offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep , const char * text ) {
 offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_spoolss_string_parm_data , NDR_POINTER_UNIQUE , text , - 1 ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int uwsgi_php_init ( void ) {
 struct uwsgi_string_list * pset = uphp . set ;
 struct uwsgi_string_list * append_config = uphp . append_config ;
 # ifdef ZTS tsrm_startup ( 1 , 1 , 0 , NULL ) ;
 # endif sapi_startup ( & uwsgi_sapi_module ) ;
 while ( append_config ) {
 uwsgi_php_append_config ( append_config -> value ) ;
 append_config = append_config -> next ;
 }
 while ( pset ) {
 uwsgi_php_set ( pset -> value ) ;
 pset = pset -> next ;
 }
 if ( uphp . dump_config ) {
 uwsgi_log ( ""--- PHP custom config ---\n\n"" ) ;
 uwsgi_log ( ""%s\n"" , uwsgi_sapi_module . ini_entries ) ;
 uwsgi_log ( ""--- end of PHP custom config ---\n"" ) ;
 }
 if ( uphp . docroot ) {
 char * orig_docroot = uphp . docroot ;
 uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;
 if ( ! uphp . docroot ) {
 uwsgi_log ( ""unable to set php docroot to %s\n"" , orig_docroot ) ;
 exit ( 1 ) ;
 }
 }
 if ( uphp . sapi_name ) {
 uwsgi_sapi_module . name = uphp . sapi_name ;
 }
 uwsgi_sapi_module . startup ( & uwsgi_sapi_module ) ;
 uwsgi_log ( ""PHP %s initialized\n"" , PHP_VERSION ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static struct addrinfo * make_addrinfo ( const char * address , u_short port ) {
 struct addrinfo * aitop = NULL ;
 # ifdef HAVE_GETADDRINFO struct addrinfo ai ;
 char strport [ NI_MAXSERV ] ;
 int ai_result ;
 memset ( & ai , 0 , sizeof ( ai ) ) ;
 ai . ai_family = AF_INET ;
 ai . ai_socktype = SOCK_STREAM ;
 ai . ai_flags = AI_PASSIVE ;
 evutil_snprintf ( strport , sizeof ( strport ) , ""%d"" , port ) ;
 if ( ( ai_result = getaddrinfo ( address , strport , & ai , & aitop ) ) != 0 ) {
 if ( ai_result == EAI_SYSTEM ) event_warn ( ""getaddrinfo"" ) ;
 else event_warnx ( ""getaddrinfo: %s"" , gai_strerror ( ai_result ) ) ;
 return ( NULL ) ;
 }
 # else static int cur ;
 static struct addrinfo ai [ 2 ] ;
 if ( ++ cur == 2 ) cur = 0 ;
 if ( fake_getaddrinfo ( address , & ai [ cur ] ) < 0 ) {
 event_warn ( ""fake_getaddrinfo"" ) ;
 return ( NULL ) ;
 }
 aitop = & ai [ cur ] ;
 ( ( struct sockaddr_in * ) aitop -> ai_addr ) -> sin_port = htons ( port ) ;
 # endif return ( aitop ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void fmtstr ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , const char * value , int flags , int min , int max ) {
 int padlen , strln ;
 int cnt = 0 ;
 if ( value == 0 ) value = ""<NULL>"" ;
 for ( strln = 0 ;
 value [ strln ] ;
 ++ strln ) ;
 padlen = min - strln ;
 if ( padlen < 0 ) padlen = 0 ;
 if ( flags & DP_F_MINUS ) padlen = - padlen ;
 while ( ( padlen > 0 ) && ( cnt < max ) ) {
 doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;
 -- padlen ;
 ++ cnt ;
 }
 while ( * value && ( cnt < max ) ) {
 doapr_outch ( sbuffer , buffer , currlen , maxlen , * value ++ ) ;
 ++ cnt ;
 }
 while ( ( padlen < 0 ) && ( cnt < max ) ) {
 doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;
 ++ padlen ;
 ++ cnt ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void config_connection_input ( struct config_connection * conn ) {
 const char * const * args , * line ;
 switch ( i_stream_read ( conn -> input ) ) {
 case - 2 : i_error ( ""BUG: Config client connection sent too much data"" ) ;
 config_connection_destroy ( conn ) ;
 return ;
 case - 1 : config_connection_destroy ( conn ) ;
 return ;
 }
 if ( ! conn -> version_received ) {
 line = i_stream_next_line ( conn -> input ) ;
 if ( line == NULL ) return ;
 if ( ! version_string_verify ( line , ""config"" , CONFIG_CLIENT_PROTOCOL_MAJOR_VERSION ) ) {
 i_error ( ""Config client not compatible with this server "" ""(mixed old and new binaries?)"" ) ;
 config_connection_destroy ( conn ) ;
 return ;
 }
 conn -> version_received = TRUE ;
 }
 while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {
 if ( args [ 0 ] == NULL ) continue ;
 if ( strcmp ( args [ 0 ] , ""REQ"" ) == 0 ) {
 if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_set_lossless ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;
 extra_cfg . lossless = CAST ( VP9E_SET_LOSSLESS , args ) ;
 return update_extra_cfg ( ctx , & extra_cfg ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"tdata_t _TIFFmalloc ( tsize_t s ) {
 if ( s == 0 ) return ( ( void * ) NULL ) ;
 return ( malloc ( ( size_t ) s ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void relpTcpHintBurstEnd ( relpTcp_t * pThis ) {
 setCORKopt ( pThis -> sock , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static kadm5_ret_t make_ks_from_keys ( krb5_context context , int n_keys , krb5_keyblock * keyblocks , krb5_key_salt_tuple * * ks_tuple ) {
 int i ;
 * ks_tuple = calloc ( n_keys , sizeof ( * * ks_tuple ) ) ;
 if ( * ks_tuple == NULL ) return ENOMEM ;
 for ( i = 0 ;
 i < n_keys ;
 i ++ ) {
 ( * ks_tuple ) [ i ] . ks_enctype = keyblocks [ i ] . enctype ;
 ( * ks_tuple ) [ i ] . ks_salttype = KRB5_KDB_SALTTYPE_NORMAL ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONSetMigrationSpeed ( qemuMonitorPtr mon , unsigned long bandwidth ) {
 int ret ;
 virJSONValuePtr cmd ;
 virJSONValuePtr reply = NULL ;
 cmd = qemuMonitorJSONMakeCommand ( ""migrate_set_speed"" , ""U:value"" , bandwidth * 1024ULL * 1024ULL , NULL ) ;
 if ( ! cmd ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"int archive_read_support_format_all ( struct archive * a ) {
 archive_check_magic ( a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , ""archive_read_support_format_all"" ) ;
 archive_read_support_format_ar ( a ) ;
 archive_read_support_format_cpio ( a ) ;
 archive_read_support_format_empty ( a ) ;
 archive_read_support_format_lha ( a ) ;
 archive_read_support_format_mtree ( a ) ;
 archive_read_support_format_tar ( a ) ;
 archive_read_support_format_xar ( a ) ;
 archive_read_support_format_7zip ( a ) ;
 archive_read_support_format_cab ( a ) ;
 archive_read_support_format_rar ( a ) ;
 archive_read_support_format_iso9660 ( a ) ;
 archive_read_support_format_zip ( a ) ;
 archive_clear_error ( a ) ;
 return ( ARCHIVE_OK ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSMimeHdrFieldCreateNamed ( TSMBuffer bufp , TSMLoc mh_mloc , const char * name , int name_len , TSMLoc * locp ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( mh_mloc ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( mh_mloc ) == TS_SUCCESS ) ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) name ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) locp ) == TS_SUCCESS ) ;
 if ( ! isWriteable ( bufp ) ) {
 return TS_ERROR ;
 }
 if ( name_len == - 1 ) {
 name_len = strlen ( name ) ;
 }
 MIMEHdrImpl * mh = _hdr_mloc_to_mime_hdr_impl ( mh_mloc ) ;
 HdrHeap * heap = ( HdrHeap * ) ( ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ) ;
 MIMEFieldSDKHandle * h = sdk_alloc_field_handle ( bufp , mh ) ;
 h -> field_ptr = mime_field_create_named ( heap , mh , name , name_len ) ;
 * locp = reinterpret_cast < TSMLoc > ( h ) ;
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void iadst4 ( const int16_t * input , int16_t * output ) {
 int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;
 int x0 = input [ 0 ] ;
 int x1 = input [ 1 ] ;
 int x2 = input [ 2 ] ;
 int x3 = input [ 3 ] ;
 if ( ! ( x0 | x1 | x2 | x3 ) ) {
 output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ;
 return ;
 }
 s0 = sinpi_1_9 * x0 ;
 s1 = sinpi_2_9 * x0 ;
 s2 = sinpi_3_9 * x1 ;
 s3 = sinpi_4_9 * x2 ;
 s4 = sinpi_1_9 * x2 ;
 s5 = sinpi_2_9 * x3 ;
 s6 = sinpi_4_9 * x3 ;
 s7 = x0 - x2 + x3 ;
 x0 = s0 + s3 + s5 ;
 x1 = s1 - s4 - s6 ;
 x2 = sinpi_3_9 * s7 ;
 x3 = s2 ;
 s0 = x0 + x3 ;
 s1 = x1 + x3 ;
 s2 = x2 ;
 s3 = x0 + x1 - x3 ;
 output [ 0 ] = dct_const_round_shift ( s0 ) ;
 output [ 1 ] = dct_const_round_shift ( s1 ) ;
 output [ 2 ] = dct_const_round_shift ( s2 ) ;
 output [ 3 ] = dct_const_round_shift ( s3 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int PyString_AsStringAndSize ( register PyObject * obj , register char * * s , register Py_ssize_t * len ) {
 if ( s == NULL ) {
 PyErr_BadInternalCall ( ) ;
 return - 1 ;
 }
 if ( ! PyString_Check ( obj ) ) {
 # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( obj ) ) {
 obj = _PyUnicode_AsDefaultEncodedString ( obj , NULL ) ;
 if ( obj == NULL ) return - 1 ;
 }
 else # endif {
 PyErr_Format ( PyExc_TypeError , ""expected string or Unicode object, "" ""%.200s found"" , Py_TYPE ( obj ) -> tp_name ) ;
 return - 1 ;
 }
 }
 * s = PyString_AS_STRING ( obj ) ;
 if ( len != NULL ) * len = PyString_GET_SIZE ( obj ) ;
 else if ( strlen ( * s ) != ( size_t ) PyString_GET_SIZE ( obj ) ) {
 PyErr_SetString ( PyExc_TypeError , ""expected string without null bytes"" ) ;
 return - 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_JitterIndication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_JitterIndication , JitterIndication_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int evsignal_init ( struct event_base * base ) {
 int i ;
 if ( evutil_socketpair ( AF_UNIX , SOCK_STREAM , 0 , base -> sig . ev_signal_pair ) == - 1 ) {
 # ifdef WIN32 event_warn ( ""%s: socketpair"" , __func__ ) ;
 # else event_err ( 1 , ""%s: socketpair"" , __func__ ) ;
 # endif return - 1 ;
 }
 FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 0 ] ) ;
 FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 1 ] ) ;
 base -> sig . sh_old = NULL ;
 base -> sig . sh_old_max = 0 ;
 base -> sig . evsignal_caught = 0 ;
 memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;
 for ( i = 0 ;
 i < NSIG ;
 ++ i ) TAILQ_INIT ( & base -> sig . evsigevents [ i ] ) ;
 evutil_make_socket_nonblocking ( base -> sig . ev_signal_pair [ 0 ] ) ;
 event_set ( & base -> sig . ev_signal , base -> sig . ev_signal_pair [ 1 ] , EV_READ | EV_PERSIST , evsignal_cb , & base -> sig . ev_signal ) ;
 base -> sig . ev_signal . ev_base = base ;
 base -> sig . ev_signal . ev_flags |= EVLIST_INTERNAL ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static apr_status_t modsecurity_process_phase_request_headers ( modsec_rec * msr ) {
 apr_time_t time_before ;
 apr_status_t rc = 0 ;
 if ( msr -> txcfg -> debuglog_level >= 4 ) {
 msr_log ( msr , 4 , ""Starting phase REQUEST_HEADERS."" ) ;
 }
 time_before = apr_time_now ( ) ;
 if ( msr -> txcfg -> ruleset != NULL ) {
 rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;
 }
 msr -> time_phase1 = apr_time_now ( ) - time_before ;
 return rc ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_pwr_prof_pwrprofstatersp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {
 proto_tree * sub_tree = NULL ;
 guint i ;
 guint8 power_profile_count ;
 power_profile_count = tvb_get_guint8 ( tvb , * offset ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_count , tvb , * offset , 1 , ENC_NA ) ;
 * offset += 1 ;
 for ( i = 0 ;
 i < power_profile_count ;
 i ++ ) {
 sub_tree = proto_tree_add_subtree_format ( tree , tvb , * offset , 1 , ett_zbee_zcl_pwr_prof_pwrprofiles [ i ] , NULL , ""Power Profile #%u"" , i ) ;
 dissect_zcl_power_profile ( tvb , sub_tree , offset ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void cblk_destroy ( jpc_enc_cblk_t * cblk ) {
 uint_fast16_t passno ;
 jpc_enc_pass_t * pass ;
 if ( cblk -> passes ) {
 for ( passno = 0 , pass = cblk -> passes ;
 passno < cblk -> numpasses ;
 ++ passno , ++ pass ) {
 pass_destroy ( pass ) ;
 }
 jas_free ( cblk -> passes ) ;
 }
 if ( cblk -> stream ) {
 jas_stream_close ( cblk -> stream ) ;
 }
 if ( cblk -> mqenc ) {
 jpc_mqenc_destroy ( cblk -> mqenc ) ;
 }
 if ( cblk -> data ) {
 jas_seq2d_destroy ( cblk -> data ) ;
 }
 if ( cblk -> flags ) {
 jas_seq2d_destroy ( cblk -> flags ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int get_stream_idx ( const unsigned * d ) {
 if ( d [ 0 ] >= '0' && d [ 0 ] <= '9' && d [ 1 ] >= '0' && d [ 1 ] <= '9' ) {
 return ( d [ 0 ] - '0' ) * 10 + ( d [ 1 ] - '0' ) ;
 }
 else {
 return 100 ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void spl_filesystem_tree_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) {
 spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;
 spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;
 object -> u . dir . index ++ ;
 do {
 spl_filesystem_dir_read ( object TSRMLS_CC ) ;
 }
 while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;
 if ( object -> file_name ) {
 efree ( object -> file_name ) ;
 object -> file_name = NULL ;
 }
 if ( iterator -> current ) {
 zval_ptr_dtor ( & iterator -> current ) ;
 iterator -> current = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {
 EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;
 int num = EVP_CIPHER_CTX_num ( ctx ) ;
 CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;
 EVP_CIPHER_CTX_set_num ( ctx , num ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_i2c_event ( I2CSlave * i2c , enum i2c_event event ) {
 PXA2xxI2CSlaveState * slave = FROM_I2C_SLAVE ( PXA2xxI2CSlaveState , i2c ) ;
 PXA2xxI2CState * s = slave -> host ;
 switch ( event ) {
 case I2C_START_SEND : s -> status |= ( 1 << 9 ) ;
 s -> status &= ~ ( 1 << 0 ) ;
 break ;
 case I2C_START_RECV : s -> status |= ( 1 << 9 ) ;
 s -> status |= 1 << 0 ;
 break ;
 case I2C_FINISH : s -> status |= ( 1 << 4 ) ;
 break ;
 case I2C_NACK : s -> status |= 1 << 1 ;
 break ;
 }
 pxa2xx_i2c_update ( s ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_billingMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_billingMode , T_billingMode_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cond_release_buffer ( AVFrame * pic ) {
 if ( pic -> data [ 0 ] ) {
 av_freep ( & pic -> data [ 0 ] ) ;
 av_free ( pic -> data [ 1 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , valid ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {
 RETURN_BOOL ( intern -> u . file . current_line || intern -> u . file . current_zval ) ;
 }
 else {
 RETVAL_BOOL ( ! php_stream_eof ( intern -> u . file . stream ) ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"mtime_t decoder_GetDisplayDate ( decoder_t * p_dec , mtime_t i_ts ) {
 if ( ! p_dec -> pf_get_display_date ) return VLC_TS_INVALID ;
 return p_dec -> pf_get_display_date ( p_dec , i_ts ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"const char * SSL_rstate_string ( const SSL * s ) {
 const char * str ;
 switch ( s -> rstate ) {
 case SSL_ST_READ_HEADER : str = ""RH"" ;
 break ;
 case SSL_ST_READ_BODY : str = ""RB"" ;
 break ;
 case SSL_ST_READ_DONE : str = ""RD"" ;
 break ;
 default : str = ""unknown"" ;
 break ;
 }
 return ( str ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"xmlListPtr xmlListDup ( const xmlListPtr old ) {
 xmlListPtr cur ;
 if ( old == NULL ) return ( NULL ) ;
 if ( NULL == ( cur = xmlListCreate ( NULL , old -> linkCompare ) ) ) return ( NULL ) ;
 if ( 0 != xmlListCopy ( cur , old ) ) return NULL ;
 return cur ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ __u32 __fswahb32 ( __u32 val ) {
 # ifdef __arch_swahb32 return __arch_swahb32 ( val ) ;
 # else return ___constant_swahb32 ( val ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static int hfinfo_container_bitwidth ( const header_field_info * hfinfo ) {
 if ( ! hfinfo -> bitmask ) {
 return 0 ;
 }
 if ( hfinfo -> type == FT_BOOLEAN ) {
 return hfinfo -> display ;
 }
 return hfinfo_type_bitwidth ( hfinfo -> type ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_Mode_g7231 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Mode_g7231 , Mode_g7231_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void report_preparing_move_progress ( CopyMoveJob * move_job , int total , int left ) {
 CommonJob * job ;
 job = ( CommonJob * ) move_job ;
 nautilus_progress_info_take_status ( job -> progress , f ( _ ( ""Preparing to move to “%B”"" ) , move_job -> destination ) ) ;
 nautilus_progress_info_take_details ( job -> progress , f ( ngettext ( ""Preparing to move %'d file"" , ""Preparing to move %'d files"" , left ) , left ) ) ;
 nautilus_progress_info_pulse_progress ( job -> progress ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l ) ;
 __exctype_l ( ispunct_l ) ;
 __exctype_l ( isspace_l ) ;
 __exctype_l ( isupper_l ) ;
 __exctype_l ( isxdigit_l ) ;
 __exctype_l ( isblank_l )",1
Detect whether the following code contains vulnerabilities.,"int gs_copydevice ( gx_device * * pnew_dev , const gx_device * dev , gs_memory_t * mem ) {
 return gs_copydevice2 ( pnew_dev , dev , false , mem ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vpx_svc_is_keyframe ( const SvcContext * svc_ctx ) {
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return 0 ;
 return ( si -> frame_list -> flags & VPX_FRAME_IS_KEY ) != 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void Type_ColorantOrderType_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {
 _cmsFree ( self -> ContextID , Ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint32 dissect_netb_session_init ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {
 netbios_add_session_init_flags ( tvb , tree , offset + NB_FLAGS ) ;
 nb_data2 ( hf_netb_max_data_recv_size , tvb , offset , tree ) ;
 nb_resp_corrl ( tvb , offset , tree ) ;
 nb_xmit_corrl ( tvb , offset , tree ) ;
 nb_remote_session ( tvb , offset , tree ) ;
 nb_local_session ( tvb , offset , tree ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vvalue_strbuf_append_i8 ( wmem_strbuf_t * strbuf , void * ptr ) {
 gint64 i8 = * ( gint64 * ) ptr ;
 wmem_strbuf_append_printf ( strbuf , ""%"" G_GINT64_MODIFIER ""d"" , i8 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void config_filter_deinit ( struct config_filter_context * * _ctx ) {
 struct config_filter_context * ctx = * _ctx ;
 unsigned int i ;
 * _ctx = NULL ;
 for ( i = 0 ;
 ctx -> parsers [ i ] != NULL ;
 i ++ ) config_filter_parsers_free ( ctx -> parsers [ i ] -> parsers ) ;
 pool_unref ( & ctx -> pool ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"afs_int32 SPR_DumpEntry ( struct rx_call * call , afs_int32 apos , struct prdebugentry * aentry ) {
 afs_int32 code ;
 afs_int32 cid = ANONYMOUSID ;
 code = dumpEntry ( call , apos , aentry , & cid ) ;
 osi_auditU ( call , PTS_DmpEntEvent , code , AUD_LONG , apos , AUD_END ) ;
 ViceLog ( 125 , ( ""PTS_DumpEntry: code %d cid %d apos %d\n"" , code , cid , apos ) ) ;
 return code ;
 }",0
Detect whether the following code contains vulnerabilities.,"void rtp_dyn_payload_insert ( rtp_dyn_payload_t * rtp_dyn_payload , const guint8 pt , const gchar * encoding_name , const int sample_rate ) {
 if ( rtp_dyn_payload && rtp_dyn_payload -> table ) {
 encoding_name_and_rate_t * encoding_name_and_rate_pt = wmem_new ( wmem_file_scope ( ) , encoding_name_and_rate_t ) ;
 encoding_name_and_rate_pt -> encoding_name = wmem_strdup ( wmem_file_scope ( ) , encoding_name ) ;
 encoding_name_and_rate_pt -> sample_rate = sample_rate ;
 g_hash_table_insert ( rtp_dyn_payload -> table , GUINT_TO_POINTER ( pt ) , encoding_name_and_rate_pt ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Alerting_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 499 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Alerting_UUIE , Alerting_UUIE_sequence ) ;
 # line 503 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_ALERTING ;
 if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , ""%s OLC (%s)"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) , h225_pi -> frame_label ) ;
 else g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"void select_connection_name ( const char * name ) {
 DBUG_ENTER ( ""select_connection_name"" ) ;
 DBUG_PRINT ( ""enter"" , ( ""name: '%s'"" , name ) ) ;
 st_connection * con = find_connection_by_name ( name ) ;
 if ( ! con ) die ( ""connection '%s' not found in connection pool"" , name ) ;
 set_current_connection ( con ) ;
 if ( ! disable_connect_log && ! disable_query_log ) {
 DYNAMIC_STRING * ds = & ds_res ;
 dynstr_append_mem ( ds , ""connection "" , 11 ) ;
 replace_dynstr_append ( ds , name ) ;
 dynstr_append_mem ( ds , "";
\n"" , 2 ) ;
 }
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void call_avp_subdissector ( guint32 vendorid , guint32 code , tvbuff_t * subtvb , packet_info * pinfo , proto_tree * avp_tree , diam_sub_dis_t * diam_sub_dis_inf ) {
 TRY {
 switch ( vendorid ) {
 case 0 : dissector_try_uint_new ( diameter_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;
 break ;
 case VENDOR_ERICSSON : dissector_try_uint_new ( diameter_ericsson_avp_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;
 break ;
 case VENDOR_THE3GPP : dissector_try_uint_new ( diameter_3gpp_avp_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;
 break ;
 default : break ;
 }
 }
 CATCH_NONFATAL_ERRORS {
 show_exception ( subtvb , pinfo , avp_tree , EXCEPT_CODE , GET_MESSAGE ) ;
 }
 ENDTRY ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_i2s_data_req ( void * opaque , int tx , int rx ) {
 PXA2xxI2SState * s = ( PXA2xxI2SState * ) opaque ;
 uint32_t * sample ;
 if ( s -> enable && s -> tx_len ) s -> status |= 1 << 5 ;
 if ( s -> enable && s -> rx_len ) s -> status |= 1 << 6 ;
 s -> tx_len = tx - s -> fifo_len ;
 s -> rx_len = rx ;
 if ( s -> enable ) for ( sample = s -> fifo ;
 s -> fifo_len ;
 s -> fifo_len -- , sample ++ ) s -> codec_out ( s -> opaque , * sample ) ;
 pxa2xx_i2s_update ( s ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_punctuation_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {
 }",1
Detect whether the following code contains vulnerabilities.,"TSMatcherLine TSMatcherLineCreate ( void ) {
 return reinterpret_cast < TSMatcherLine > ( ats_malloc ( sizeof ( matcher_line ) ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int ogg_probe ( AVProbeData * p ) {
 if ( ! memcmp ( ""OggS"" , p -> buf , 5 ) && p -> buf [ 5 ] <= 0x7 ) return AVPROBE_SCORE_MAX ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void appendConnStrVal ( PQExpBuffer buf , const char * str ) {
 const char * s ;
 bool needquotes ;
 needquotes = false ;
 for ( s = str ;
 * s ;
 s ++ ) {
 if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) || ( * s >= '0' && * s <= '9' ) || * s == '_' || * s == '.' ) ) {
 needquotes = true ;
 break ;
 }
 }
 if ( needquotes ) {
 appendPQExpBufferChar ( buf , '\'' ) ;
 while ( * str ) {
 if ( * str == '\'' || * str == '\\' ) appendPQExpBufferChar ( buf , '\\' ) ;
 appendPQExpBufferChar ( buf , * str ) ;
 str ++ ;
 }
 appendPQExpBufferChar ( buf , '\'' ) ;
 }
 else appendPQExpBufferStr ( buf , str ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static guint composite_offset ( const tvbuff_t * tvb , const guint counter ) {
 const struct tvb_composite * composite_tvb = ( const struct tvb_composite * ) tvb ;
 const tvbuff_t * member = ( const tvbuff_t * ) composite_tvb -> composite . tvbs -> data ;
 return tvb_offset_from_real_beginning_counter ( member , counter ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , fscanf ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;
 intern -> u . file . current_line_num ++ ;
 FileFunctionCall ( fscanf , ZEND_NUM_ARGS ( ) , NULL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * get_pid_environ_val ( pid_t pid , char * val ) {
 char temp [ 500 ] ;
 int i = 0 ;
 int foundit = 0 ;
 FILE * fp ;
 sprintf ( temp , ""/proc/%d/environ"" , pid ) ;
 fp = fopen ( temp , ""r"" ) ;
 if ( fp == NULL ) return NULL ;
 for ( ;
 ;
 ) {
 temp [ i ] = fgetc ( fp ) ;
 if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\0' || temp [ i ] == EOF ) ) {
 char * ret ;
 temp [ i ] = 0 ;
 ret = malloc ( strlen ( temp ) + 10 ) ;
 sprintf ( ret , ""%s"" , temp ) ;
 fclose ( fp ) ;
 return ret ;
 }
 switch ( temp [ i ] ) {
 case EOF : fclose ( fp ) ;
 return NULL ;
 case '=' : temp [ i ] = 0 ;
 if ( ! strcmp ( temp , val ) ) {
 foundit = 1 ;
 }
 i = 0 ;
 break ;
 case '\0' : i = 0 ;
 break ;
 default : i ++ ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static PGconn * get_db_conn ( ClusterInfo * cluster , const char * db_name ) {
 char conn_opts [ 2 * NAMEDATALEN + MAXPGPATH + 100 ] ;
 if ( cluster -> sockdir ) snprintf ( conn_opts , sizeof ( conn_opts ) , ""dbname = '%s' user = '%s' host = '%s' port = %d"" , db_name , os_info . user , cluster -> sockdir , cluster -> port ) ;
 else snprintf ( conn_opts , sizeof ( conn_opts ) , ""dbname = '%s' user = '%s' port = %d"" , db_name , os_info . user , cluster -> port ) ;
 return PQconnectdb ( conn_opts ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {
 OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;
 }
 LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {
 OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;
 }
 LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;
 # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_mediaControlChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 914 ""../../asn1/h245/h245.cnf"" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_control_addr ;
 offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;
 # line 918 ""../../asn1/h245/h245.cnf"" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_ModeElement ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ModeElement , ModeElement_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void uiserver_io_event ( void * engine , gpgme_event_io_t type , void * type_data ) {
 engine_uiserver_t uiserver = engine ;
 TRACE3 ( DEBUG_ENGINE , ""gpgme:uiserver_io_event"" , uiserver , ""event %p, type %d, type_data %p"" , uiserver -> io_cbs . event , type , type_data ) ;
 if ( uiserver -> io_cbs . event ) ( * uiserver -> io_cbs . event ) ( uiserver -> io_cbs . event_priv , type , type_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_cipher_decrypt ( int argc , VALUE * argv , VALUE self ) {
 return ossl_cipher_init ( argc , argv , self , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gcry_err_code_t pubkey_verify ( int algorithm , gcry_mpi_t hash , gcry_mpi_t * data , gcry_mpi_t * pkey , struct pk_encoding_ctx * ctx ) {
 gcry_pk_spec_t * pubkey ;
 gcry_module_t module ;
 gcry_err_code_t rc ;
 int i ;
 if ( DBG_CIPHER && ! fips_mode ( ) ) {
 log_debug ( ""pubkey_verify: algo=%d\n"" , algorithm ) ;
 for ( i = 0 ;
 i < pubkey_get_npkey ( algorithm ) ;
 i ++ ) log_mpidump ( "" pkey"" , pkey [ i ] ) ;
 for ( i = 0 ;
 i < pubkey_get_nsig ( algorithm ) ;
 i ++ ) log_mpidump ( "" sig"" , data [ i ] ) ;
 log_mpidump ( "" hash"" , hash ) ;
 }
 ath_mutex_lock ( & pubkeys_registered_lock ) ;
 module = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;
 if ( module ) {
 pubkey = ( gcry_pk_spec_t * ) module -> spec ;
 rc = pubkey -> verify ( algorithm , hash , data , pkey , ctx -> verify_cmp , ctx , ctx -> flags , ctx -> hash_algo ) ;
 _gcry_module_release ( module ) ;
 goto ready ;
 }
 rc = GPG_ERR_PUBKEY_ALGO ;
 ready : ath_mutex_unlock ( & pubkeys_registered_lock ) ;
 return rc ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , ReadAllAdvanceFirst_NeverDefer2 ) {
 multibuffer_ . SetMaxWriters ( 1 ) ;
 size_t pos = 0 ;
 size_t end = 10000 ;
 multibuffer_ . SetFileSize ( 10000 ) ;
 multibuffer_ . SetMustReadWholeFile ( true ) ;
 multibuffer_ . SetMaxBlocksAfterDefer ( - 10000 ) ;
 media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;
 reader . SetMaxBuffer ( 2000 , 5000 ) ;
 reader . SetPreload ( 1000 , 1000 ) ;
 while ( pos < end ) {
 unsigned char buffer [ 27 ] ;
 buffer [ 17 ] = 17 ;
 size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;
 while ( AdvanceAll ( ) ) ;
 int64_t bytes = reader . TryRead ( buffer , to_read ) ;
 EXPECT_GT ( bytes , 0 ) ;
 EXPECT_EQ ( buffer [ 17 ] , 17 ) ;
 for ( int64_t i = 0 ;
 i < bytes ;
 i ++ ) {
 uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;
 EXPECT_EQ ( expected , buffer [ i ] ) << "" pos = "" << pos ;
 pos ++ ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline __uint32_t __uint32_identity ( __uint32_t __x ) {
 return __x ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , rewind ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int getulong ( const char * numstr , unsigned long int * result ) {
 long long int val ;
 char * endptr ;
 errno = 0 ;
 val = strtoll ( numstr , & endptr , 0 ) ;
 if ( ( '\0' == * numstr ) || ( '\0' != * endptr ) || ( ERANGE == errno ) || ( val != ( unsigned long int ) val ) ) {
 return 0 ;
 }
 * result = ( unsigned long int ) val ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int16_t vp9_dc_quant ( int qindex , int delta ) {
 return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"int xmlListInsert ( xmlListPtr l , void * data ) {
 xmlLinkPtr lkPlace , lkNew ;
 if ( l == NULL ) return ( 1 ) ;
 lkPlace = xmlListLowerSearch ( l , data ) ;
 lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;
 if ( lkNew == NULL ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for new link"" ) ;
 return ( 1 ) ;
 }
 lkNew -> data = data ;
 lkPlace = lkPlace -> prev ;
 lkNew -> next = lkPlace -> next ;
 ( lkPlace -> next ) -> prev = lkNew ;
 lkPlace -> next = lkNew ;
 lkNew -> prev = lkPlace ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int libopenjpeg_matches_pix_fmt ( const opj_image_t * img , enum AVPixelFormat pix_fmt ) {
 const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ;
 int match = 1 ;
 if ( desc -> nb_components != img -> numcomps ) {
 return 0 ;
 }
 switch ( desc -> nb_components ) {
 case 4 : match = match && desc -> comp [ 3 ] . depth_minus1 + 1 >= img -> comps [ 3 ] . prec && 1 == img -> comps [ 3 ] . dx && 1 == img -> comps [ 3 ] . dy ;
 case 3 : match = match && desc -> comp [ 2 ] . depth_minus1 + 1 >= img -> comps [ 2 ] . prec && 1 << desc -> log2_chroma_w == img -> comps [ 2 ] . dx && 1 << desc -> log2_chroma_h == img -> comps [ 2 ] . dy ;
 case 2 : match = match && desc -> comp [ 1 ] . depth_minus1 + 1 >= img -> comps [ 1 ] . prec && 1 << desc -> log2_chroma_w == img -> comps [ 1 ] . dx && 1 << desc -> log2_chroma_h == img -> comps [ 1 ] . dy ;
 case 1 : match = match && desc -> comp [ 0 ] . depth_minus1 + 1 >= img -> comps [ 0 ] . prec && 1 == img -> comps [ 0 ] . dx && 1 == img -> comps [ 0 ] . dy ;
 default : break ;
 }
 return match ;
 }",0
Detect whether the following code contains vulnerabilities.,"int xmlListAppend ( xmlListPtr l , void * data ) {
 xmlLinkPtr lkPlace , lkNew ;
 if ( l == NULL ) return ( 1 ) ;
 lkPlace = xmlListHigherSearch ( l , data ) ;
 lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;
 if ( lkNew == NULL ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for new link"" ) ;
 return ( 1 ) ;
 }
 lkNew -> data = data ;
 lkNew -> next = lkPlace -> next ;
 ( lkPlace -> next ) -> prev = lkNew ;
 lkPlace -> next = lkNew ;
 lkNew -> prev = lkPlace ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void init_config ( struct VP9_COMP * cpi , VP9EncoderConfig * oxcf ) {
 VP9_COMMON * const cm = & cpi -> common ;
 cpi -> oxcf = * oxcf ;
 cpi -> framerate = oxcf -> init_framerate ;
 cm -> profile = oxcf -> profile ;
 cm -> bit_depth = oxcf -> bit_depth ;
 cm -> color_space = UNKNOWN ;
 cm -> width = oxcf -> width ;
 cm -> height = oxcf -> height ;
 vp9_alloc_compressor_data ( cpi ) ;
 cpi -> svc . number_spatial_layers = oxcf -> ss_number_layers ;
 cpi -> svc . number_temporal_layers = oxcf -> ts_number_layers ;
 if ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( ( cpi -> svc . number_temporal_layers > 1 || cpi -> svc . number_spatial_layers > 1 ) && cpi -> oxcf . pass == 2 ) ) {
 vp9_init_layer_context ( cpi ) ;
 }
 vp9_change_config ( cpi , oxcf ) ;
 cpi -> static_mb_pct = 0 ;
 cpi -> ref_frame_flags = 0 ;
 init_buffer_indices ( cpi ) ;
 set_tile_limits ( cpi ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int archive_read_support_format_cpio ( struct archive * _a ) {
 struct archive_read * a = ( struct archive_read * ) _a ;
 struct cpio * cpio ;
 int r ;
 archive_check_magic ( _a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , ""archive_read_support_format_cpio"" ) ;
 cpio = ( struct cpio * ) calloc ( 1 , sizeof ( * cpio ) ) ;
 if ( cpio == NULL ) {
 archive_set_error ( & a -> archive , ENOMEM , ""Can't allocate cpio data"" ) ;
 return ( ARCHIVE_FATAL ) ;
 }
 cpio -> magic = CPIO_MAGIC ;
 r = __archive_read_register_format ( a , cpio , ""cpio"" , archive_read_format_cpio_bid , archive_read_format_cpio_options , archive_read_format_cpio_read_header , archive_read_format_cpio_read_data , archive_read_format_cpio_skip , NULL , archive_read_format_cpio_cleanup , NULL , NULL ) ;
 if ( r != ARCHIVE_OK ) free ( cpio ) ;
 return ( ARCHIVE_OK ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_TBCD_STRING ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 900 ""./asn1/h225/h225.cnf"" int min_len , max_len ;
 gboolean has_extension ;
 get_size_constraint_from_stack ( actx , ""TBCD_STRING"" , & min_len , & max_len , & has_extension ) ;
 offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , min_len , max_len , has_extension , ""0123456789#*abc"" , 15 , NULL ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_CallTerminationCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_CallTerminationCause , CallTerminationCause_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int multi_reg_replace ( struct st_replace_regex * r , char * val ) {
 uint i ;
 char * in_buf , * out_buf ;
 int * buf_len_p ;
 in_buf = val ;
 out_buf = r -> even_buf ;
 buf_len_p = & r -> even_buf_len ;
 r -> buf = 0 ;
 for ( i = 0 ;
 i < r -> regex_arr . elements ;
 i ++ ) {
 struct st_regex re ;
 char * save_out_buf = out_buf ;
 get_dynamic ( & r -> regex_arr , ( uchar * ) & re , i ) ;
 if ( ! reg_replace ( & out_buf , buf_len_p , re . pattern , re . replace , in_buf , re . icase ) ) {
 if ( save_out_buf != out_buf ) {
 if ( save_out_buf == r -> even_buf ) r -> even_buf = out_buf ;
 else r -> odd_buf = out_buf ;
 }
 r -> buf = out_buf ;
 if ( in_buf == val ) in_buf = r -> odd_buf ;
 swap_variables ( char * , in_buf , out_buf ) ;
 buf_len_p = ( out_buf == r -> even_buf ) ? & r -> even_buf_len : & r -> odd_buf_len ;
 }
 }
 return ( r -> buf == 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void search_state_decref ( struct search_state * const state ) {
 if ( ! state ) return ;
 state -> refcount -- ;
 if ( ! state -> refcount ) {
 struct search_domain * next , * dom ;
 for ( dom = state -> head ;
 dom ;
 dom = next ) {
 next = dom -> next ;
 free ( dom ) ;
 }
 free ( state ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_G723AnnexCAudioMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_G723AnnexCAudioMode , G723AnnexCAudioMode_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static bool is_zero_width_char ( hb_font_t * font , hb_codepoint_t unicode ) {
 hb_codepoint_t glyph ;
 return hb_font_get_glyph ( font , unicode , 0 , & glyph ) && hb_font_get_glyph_h_advance ( font , glyph ) == 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , PrefetchQueryParameters ) {
 TemplateURLData data ;
 search_terms_data_ . set_google_base_url ( ""http://bar/"" ) ;
 data . SetURL ( ""http://bar/search?q={
searchTerms}
&{
google:prefetchQuery}
xssi=t"" ) ;
 TemplateURL url ( data ) ;
 TemplateURLRef : : SearchTermsArgs search_terms_args ( ASCIIToUTF16 ( ""foo"" ) ) ;
 search_terms_args . prefetch_query = ""full query text"" ;
 search_terms_args . prefetch_query_type = ""2338"" ;
 std : : string result = url . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;
 EXPECT_EQ ( ""http://bar/search?q=foo&pfq=full%20query%20text&qha=2338&xssi=t"" , result ) ;
 TemplateURL url2 ( data ) ;
 search_terms_args . prefetch_query . clear ( ) ;
 search_terms_args . prefetch_query_type . clear ( ) ;
 result = url2 . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;
 EXPECT_EQ ( ""http://bar/search?q=foo&xssi=t"" , result ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line8d2 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 uint32_t * palette ;
 int x ;
 palette = s1 -> last_palette ;
 width >>= 3 ;
 for ( x = 0 ;
 x < width ;
 x ++ ) {
 PUT_PIXEL2 ( d , 0 , palette [ s [ 0 ] ] ) ;
 PUT_PIXEL2 ( d , 1 , palette [ s [ 1 ] ] ) ;
 PUT_PIXEL2 ( d , 2 , palette [ s [ 2 ] ] ) ;
 PUT_PIXEL2 ( d , 3 , palette [ s [ 3 ] ] ) ;
 d += 32 ;
 s += 4 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_socket_recvmsg ( struct socket * sock , struct msghdr * msg , int size , int flags ) {
 return sock_has_perm ( current , sock -> sk , SOCKET__READ ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct16x16_10_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 16 * 16 ] = {
 0 }
 ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 16 ] , temp_out [ 16 ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 idct16 ( input , outptr ) ;
 input += 16 ;
 outptr += 16 ;
 }
 for ( i = 0 ;
 i < 16 ;
 ++ i ) {
 for ( j = 0 ;
 j < 16 ;
 ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;
 idct16 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {
 int width , height ;
 vp9_read_frame_size ( rb , & width , & height ) ;
 resize_context_buffers ( cm , width , height ) ;
 setup_display_size ( cm , rb ) ;
 if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {
 vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed to allocate frame buffer"" ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void remoteDispatchConnError ( remote_error * rerr , virConnectPtr conn ATTRIBUTE_UNUSED ) {
 virErrorPtr verr = virGetLastError ( ) ;
 if ( verr ) remoteDispatchCopyError ( rerr , verr ) ;
 else remoteDispatchGenericError ( rerr ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void evhttp_send_reply ( struct evhttp_request * req , int code , const char * reason , struct evbuffer * databuf ) {
 evhttp_response_code ( req , code , reason ) ;
 evhttp_send ( req , databuf ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void xsltFreeAttrVT ( xsltAttrVTPtr avt ) {
 int i ;
 if ( avt == NULL ) return ;
 if ( avt -> strstart == 1 ) {
 for ( i = 0 ;
 i < avt -> nb_seg ;
 i += 2 ) if ( avt -> segments [ i ] != NULL ) xmlFree ( ( xmlChar * ) avt -> segments [ i ] ) ;
 for ( i = 1 ;
 i < avt -> nb_seg ;
 i += 2 ) xmlXPathFreeCompExpr ( ( xmlXPathCompExprPtr ) avt -> segments [ i ] ) ;
 }
 else {
 for ( i = 0 ;
 i < avt -> nb_seg ;
 i += 2 ) xmlXPathFreeCompExpr ( ( xmlXPathCompExprPtr ) avt -> segments [ i ] ) ;
 for ( i = 1 ;
 i < avt -> nb_seg ;
 i += 2 ) if ( avt -> segments [ i ] != NULL ) xmlFree ( ( xmlChar * ) avt -> segments [ i ] ) ;
 }
 if ( avt -> nsList != NULL ) xmlFree ( avt -> nsList ) ;
 xmlFree ( avt ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int test_read_integer_error ( xd3_stream * stream , usize_t trunto , const char * msg ) {
 uint64_t eval = 1ULL << 34 ;
 uint32_t rval ;
 xd3_output * buf = NULL ;
 const uint8_t * max ;
 const uint8_t * inp ;
 int ret ;
 buf = xd3_alloc_output ( stream , buf ) ;
 if ( ( ret = xd3_emit_uint64_t ( stream , & buf , eval ) ) ) {
 goto fail ;
 }
 again : inp = buf -> base ;
 max = buf -> base + buf -> next - trunto ;
 if ( ( ret = xd3_read_uint32_t ( stream , & inp , max , & rval ) ) != XD3_INVALID_INPUT || ! MSG_IS ( msg ) ) {
 ret = XD3_INTERNAL ;
 }
 else if ( trunto && trunto < buf -> next ) {
 trunto += 1 ;
 goto again ;
 }
 else {
 ret = 0 ;
 }
 fail : xd3_free_output ( stream , buf ) ;
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void nlm_msg_res_match_cleanup ( void ) {
 g_hash_table_destroy ( nlm_msg_res_unmatched ) ;
 g_hash_table_destroy ( nlm_msg_res_matched ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_q931_ie_cs7 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {
 dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 7 ) ;
 return tvb_captured_length ( tvb ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void intra_pred_down_right ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {
 int x , y ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) for ( x = 0 ;
 x < 8 ;
 x ++ ) if ( x == y ) d [ y * stride + x ] = ( left [ 1 ] + 2 * top [ 0 ] + top [ 1 ] + 2 ) >> 2 ;
 else if ( x > y ) d [ y * stride + x ] = LOWPASS ( top , x - y ) ;
 else d [ y * stride + x ] = LOWPASS ( left , y - x ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void e1000e_autoneg_resume ( E1000ECore * core ) {
 if ( e1000e_have_autoneg ( core ) && ! ( core -> phy [ 0 ] [ PHY_STATUS ] & MII_SR_AUTONEG_COMPLETE ) ) {
 qemu_get_queue ( core -> owner_nic ) -> link_down = false ;
 timer_mod ( core -> autoneg_timer , qemu_clock_get_ms ( QEMU_CLOCK_VIRTUAL ) + 500 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int at1_parse_bsm ( GetBitContext * gb , int log2_block_cnt [ AT1_QMF_BANDS ] ) {
 int log2_block_count_tmp , i ;
 for ( i = 0 ;
 i < 2 ;
 i ++ ) {
 log2_block_count_tmp = get_bits ( gb , 2 ) ;
 if ( log2_block_count_tmp & 1 ) return AVERROR_INVALIDDATA ;
 log2_block_cnt [ i ] = 2 - log2_block_count_tmp ;
 }
 log2_block_count_tmp = get_bits ( gb , 2 ) ;
 if ( log2_block_count_tmp != 0 && log2_block_count_tmp != 3 ) return AVERROR_INVALIDDATA ;
 log2_block_cnt [ IDX_HIGH_BAND ] = 3 - log2_block_count_tmp ;
 skip_bits ( gb , 2 ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , ParseURLTwoParameters ) {
 TemplateURLData data ;
 data . SetURL ( ""{
}
{
{
%s}
}
"" ) ;
 TemplateURL url ( data ) ;
 TemplateURLRef : : Replacements replacements ;
 bool valid = false ;
 EXPECT_EQ ( ""{
}
{
}
"" , url . url_ref ( ) . ParseURL ( ""{
}
{
{
searchTerms}
}
"" , & replacements , NULL , & valid ) ) ;
 ASSERT_EQ ( 1U , replacements . size ( ) ) ;
 EXPECT_EQ ( 3U , replacements [ 0 ] . index ) ;
 EXPECT_EQ ( TemplateURLRef : : SEARCH_TERMS , replacements [ 0 ] . type ) ;
 EXPECT_TRUE ( valid ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void spl_ptr_llist_push ( spl_ptr_llist * llist , void * data TSRMLS_DC ) {
 spl_ptr_llist_element * elem = emalloc ( sizeof ( spl_ptr_llist_element ) ) ;
 elem -> data = data ;
 elem -> rc = 1 ;
 elem -> prev = llist -> tail ;
 elem -> next = NULL ;
 if ( llist -> tail ) {
 llist -> tail -> next = elem ;
 }
 else {
 llist -> head = elem ;
 }
 llist -> tail = elem ;
 llist -> count ++ ;
 if ( llist -> ctor ) {
 llist -> ctor ( elem TSRMLS_CC ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static UChar32 _UTF32GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {
 switch ( pArgs -> converter -> mode ) {
 case 8 : return T_UConverter_getNextUChar_UTF32_BE ( pArgs , pErrorCode ) ;
 case 9 : return T_UConverter_getNextUChar_UTF32_LE ( pArgs , pErrorCode ) ;
 default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dvvideo_close ( AVCodecContext * c ) {
 DVVideoContext * s = c -> priv_data ;
 if ( s -> picture . data [ 0 ] ) c -> release_buffer ( c , & s -> picture ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static PyObject * string_sizeof ( PyStringObject * v ) {
 Py_ssize_t res ;
 res = PyStringObject_SIZE + PyString_GET_SIZE ( v ) * Py_TYPE ( v ) -> tp_itemsize ;
 return PyInt_FromSsize_t ( res ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplDoublyLinkedList , key ) {
 spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_LONG ( intern -> traverse_position ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int gs_main_init0 ( gs_main_instance * minst , FILE * in , FILE * out , FILE * err , int max_lib_paths ) {
 ref * array ;
 gp_init ( ) ;
 # ifdef PACIFY_VALGRIND VALGRIND_HG_DISABLE_CHECKING ( gs_debug , 128 ) ;
 # endif memset ( gs_debug , 0 , 128 ) ;
 gs_log_errors = 0 ;
 gp_get_realtime ( minst -> base_time ) ;
 array = ( ref * ) gs_alloc_byte_array ( minst -> heap , max_lib_paths , sizeof ( ref ) , ""lib_path array"" ) ;
 if ( array == 0 ) {
 gs_lib_finit ( 1 , gs_error_VMerror , minst -> heap ) ;
 return_error ( gs_error_VMerror ) ;
 }
 make_array ( & minst -> lib_path . container , avm_foreign , max_lib_paths , array ) ;
 make_array ( & minst -> lib_path . list , avm_foreign | a_readonly , 0 , minst -> lib_path . container . value . refs ) ;
 minst -> lib_path . env = 0 ;
 minst -> lib_path . final = 0 ;
 minst -> lib_path . count = 0 ;
 minst -> user_errors = 1 ;
 minst -> init_done = 0 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * i_alloc_struct_array_immovable ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {
 gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;
 obj_header_t * obj ;
 # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;
 # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;
 obj = alloc_obj ( imem , ( ulong ) num_elements * pstype -> ssize , pstype , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;
 if_debug7m ( 'A' , mem , ""[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\n"" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;
 return ( char * ) obj ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_h225_ReleaseCompleteReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 701 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_ReleaseCompleteReason , ReleaseCompleteReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dwarf_elf_object_access_load_section ( void * obj_in , Dwarf_Half section_index , Dwarf_Small * * section_data , int * error ) {
 dwarf_elf_object_access_internals_t * obj = ( dwarf_elf_object_access_internals_t * ) obj_in ;
 if ( section_index == 0 ) {
 return DW_DLV_NO_ENTRY ;
 }
 {
 Elf_Scn * scn = 0 ;
 Elf_Data * data = 0 ;
 scn = elf_getscn ( obj -> elf , section_index ) ;
 if ( scn == NULL ) {
 * error = DW_DLE_MDE ;
 return DW_DLV_ERROR ;
 }
 data = elf_getdata ( scn , NULL ) ;
 if ( data == NULL ) {
 * error = DW_DLE_MDE ;
 return DW_DLV_ERROR ;
 }
 * section_data = data -> d_buf ;
 }
 return DW_DLV_OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"bool challenge_h ( connection_t * c ) {
 char buffer [ MAX_STRING_SIZE ] ;
 int len ;
 if ( sscanf ( c -> buffer , ""%*d "" MAX_STRING , buffer ) != 1 ) {
 logger ( LOG_ERR , ""Got bad %s from %s (%s)"" , ""CHALLENGE"" , c -> name , c -> hostname ) ;
 return false ;
 }
 len = RSA_size ( myself -> connection -> rsa_key ) ;
 if ( strlen ( buffer ) != ( size_t ) len * 2 ) {
 logger ( LOG_ERR , ""Possible intruder %s (%s): %s"" , c -> name , c -> hostname , ""wrong challenge length"" ) ;
 return false ;
 }
 c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;
 if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {
 logger ( LOG_ERR , ""Got bad %s from %s(%s): %s"" , ""CHALLENGE"" , c -> name , c -> hostname , ""invalid challenge"" ) ;
 return false ;
 }
 c -> allow_request = CHAL_REPLY ;
 return send_chal_reply ( c ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void word ( struct vars * v , int dir , struct state * lp , struct state * rp ) {
 assert ( dir == AHEAD || dir == BEHIND ) ;
 cloneouts ( v -> nfa , v -> wordchrs , lp , rp , dir ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * string_slice ( register PyStringObject * a , register Py_ssize_t i , register Py_ssize_t j ) {
 if ( i < 0 ) i = 0 ;
 if ( j < 0 ) j = 0 ;
 if ( j > Py_SIZE ( a ) ) j = Py_SIZE ( a ) ;
 if ( i == 0 && j == Py_SIZE ( a ) && PyString_CheckExact ( a ) ) {
 Py_INCREF ( a ) ;
 return ( PyObject * ) a ;
 }
 if ( j < i ) j = i ;
 return PyString_FromStringAndSize ( a -> ob_sval + i , j - i ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int ff_find_unused_picture ( MpegEncContext * s , int shared ) {
 int ret = find_unused_picture ( s , shared ) ;
 if ( ret >= 0 && ret < s -> picture_range_end ) {
 if ( s -> picture [ ret ] . needs_realloc ) {
 s -> picture [ ret ] . needs_realloc = 0 ;
 free_picture ( s , & s -> picture [ ret ] ) ;
 avcodec_get_frame_defaults ( & s -> picture [ ret ] . f ) ;
 }
 }
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void update_frames ( AVCodecContext * avctx ) {
 Vp3DecodeContext * s = avctx -> priv_data ;
 if ( s -> last_frame . data [ 0 ] && s -> last_frame . type != FF_BUFFER_TYPE_COPY ) ff_thread_release_buffer ( avctx , & s -> last_frame ) ;
 s -> last_frame = s -> current_frame ;
 if ( s -> keyframe ) {
 if ( s -> golden_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;
 s -> golden_frame = s -> current_frame ;
 s -> last_frame . type = FF_BUFFER_TYPE_COPY ;
 }
 s -> current_frame . data [ 0 ] = NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int decode_cabac_field_decoding_flag ( H264Context * h ) {
 const long mbb_xy = h -> mb_xy - 2L * h -> mb_stride ;
 unsigned long ctx = 0 ;
 ctx += h -> mb_field_decoding_flag & ! ! h -> mb_x ;
 ctx += ( h -> cur_pic . f . mb_type [ mbb_xy ] >> 7 ) & ( h -> slice_table [ mbb_xy ] == h -> slice_num ) ;
 return get_cabac_noinline ( & h -> cabac , & ( h -> cabac_state + 70 ) [ ctx ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlChar * xsltEvalXPathString ( xsltTransformContextPtr ctxt , xmlXPathCompExprPtr comp ) {
 return ( xsltEvalXPathStringNs ( ctxt , comp , 0 , NULL ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Connect_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 528 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Connect_UUIE , Connect_UUIE_sequence ) ;
 # line 532 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_CONNECT ;
 if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , ""%s OLC (%s)"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) , h225_pi -> frame_label ) ;
 else g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCloseWithChecked ) {
 ShowDialog ( ) ;
 SetChecked ( true ) ;
 EXPECT_TRUE ( dialog_ -> Close ( ) ) ;
 EXPECT_TRUE ( called_ ) ;
 EXPECT_FALSE ( accept_ ) ;
 EXPECT_TRUE ( cancel_ ) ;
 EXPECT_FALSE ( dont_block_ ) ;
 histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct8x8_12_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 8 * 8 ] = {
 0 }
 ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 8 ] , temp_out [ 8 ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 idct8 ( input , outptr ) ;
 input += 8 ;
 outptr += 8 ;
 }
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;
 idct8 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int svq3_decode_end ( AVCodecContext * avctx ) {
 SVQ3Context * s = avctx -> priv_data ;
 H264Context * h = & s -> h ;
 free_picture ( avctx , s -> cur_pic ) ;
 free_picture ( avctx , s -> next_pic ) ;
 free_picture ( avctx , s -> last_pic ) ;
 ff_h264_free_context ( h ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int seqvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 SeqVideoContext * seq = avctx -> priv_data ;
 seq -> frame . reference = 1 ;
 seq -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( avctx -> reget_buffer ( avctx , & seq -> frame ) ) {
 av_log ( seq -> avctx , AV_LOG_ERROR , ""tiertexseqvideo: reget_buffer() failed\n"" ) ;
 return - 1 ;
 }
 if ( seqvideo_decode ( seq , buf , buf_size ) ) return AVERROR_INVALIDDATA ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = seq -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void rlvl_destroy ( jpc_enc_rlvl_t * rlvl ) {
 jpc_enc_band_t * band ;
 uint_fast16_t bandno ;
 if ( rlvl -> bands ) {
 for ( bandno = 0 , band = rlvl -> bands ;
 bandno < rlvl -> numbands ;
 ++ bandno , ++ band ) {
 band_destroy ( band ) ;
 }
 jas_free ( rlvl -> bands ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"double mcv_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , double * sumcommonp ) {
 double mcv_selec , sumcommon ;
 Datum * values ;
 int nvalues ;
 float4 * numbers ;
 int nnumbers ;
 int i ;
 mcv_selec = 0.0 ;
 sumcommon = 0.0 ;
 if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values , & nvalues , & numbers , & nnumbers ) ) {
 for ( i = 0 ;
 i < nvalues ;
 i ++ ) {
 if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) mcv_selec += numbers [ i ] ;
 sumcommon += numbers [ i ] ;
 }
 free_attstatsslot ( vardata -> atttype , values , nvalues , numbers , nnumbers ) ;
 }
 * sumcommonp = sumcommon ;
 return mcv_selec ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void print_field_types ( MYSQL_RES * result ) {
 MYSQL_FIELD * field ;
 uint i = 0 ;
 while ( ( field = mysql_fetch_field ( result ) ) ) {
 tee_fprintf ( PAGER , ""Field %3u: `%s`\n"" ""Catalog: `%s`\n"" ""Database: `%s`\n"" ""Table: `%s`\n"" ""Org_table: `%s`\n"" ""Type: %s\n"" ""Collation: %s (%u)\n"" ""Length: %lu\n"" ""Max_length: %lu\n"" ""Decimals: %u\n"" ""Flags: %s\n\n"" , ++ i , field -> name , field -> catalog , field -> db , field -> table , field -> org_table , fieldtype2str ( field -> type ) , get_charset_name ( field -> charsetnr ) , field -> charsetnr , field -> length , field -> max_length , field -> decimals , fieldflags2str ( field -> flags ) ) ;
 }
 tee_puts ( """" , PAGER ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cmd_network_remove ( const char * data ) {
 IRC_CHATNET_REC * rec ;
 if ( * data == '\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;
 rec = ircnet_find ( data ) ;
 if ( rec == NULL ) printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , IRCTXT_NETWORK_NOT_FOUND , data ) ;
 else {
 server_setup_remove_chatnet ( data ) ;
 channel_setup_remove_chatnet ( data ) ;
 printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , IRCTXT_NETWORK_REMOVED , data ) ;
 chatnet_remove ( CHATNET ( rec ) ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , UncommittedLoadWithError ) {
 StartHttpsServer ( true ) ;
 TabStripModel * tab_strip_model = browser ( ) -> tab_strip_model ( ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , https_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 content : : WebContentsDestroyedWatcher destroyed_watcher ( tab_strip_model -> GetActiveWebContents ( ) ) ;
 EXPECT_TRUE ( tab_strip_model -> CloseWebContentsAt ( tab_strip_model -> active_index ( ) , 0 ) ) ;
 destroyed_watcher . Wait ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int roq_encode_init ( AVCodecContext * avctx ) {
 RoqContext * enc = avctx -> priv_data ;
 av_lfg_init ( & enc -> randctx , 1 ) ;
 enc -> framesSinceKeyframe = 0 ;
 if ( ( avctx -> width & 0xf ) || ( avctx -> height & 0xf ) ) {
 av_log ( avctx , AV_LOG_ERROR , ""Dimensions must be divisible by 16\n"" ) ;
 return - 1 ;
 }
 if ( ( ( avctx -> width ) & ( avctx -> width - 1 ) ) || ( ( avctx -> height ) & ( avctx -> height - 1 ) ) ) av_log ( avctx , AV_LOG_ERROR , ""Warning: dimensions not power of two\n"" ) ;
 enc -> width = avctx -> width ;
 enc -> height = avctx -> height ;
 enc -> framesSinceKeyframe = 0 ;
 enc -> first_frame = 1 ;
 enc -> last_frame = & enc -> frames [ 0 ] ;
 enc -> current_frame = & enc -> frames [ 1 ] ;
 enc -> tmpData = av_malloc ( sizeof ( RoqTempdata ) ) ;
 enc -> this_motion4 = av_mallocz ( ( enc -> width * enc -> height / 16 ) * sizeof ( motion_vect ) ) ;
 enc -> last_motion4 = av_malloc ( ( enc -> width * enc -> height / 16 ) * sizeof ( motion_vect ) ) ;
 enc -> this_motion8 = av_mallocz ( ( enc -> width * enc -> height / 64 ) * sizeof ( motion_vect ) ) ;
 enc -> last_motion8 = av_malloc ( ( enc -> width * enc -> height / 64 ) * sizeof ( motion_vect ) ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSReturnCode sdk_sanity_check_mbuffer ( TSMBuffer bufp ) {
 HdrHeapSDKHandle * handle = ( HdrHeapSDKHandle * ) bufp ;
 if ( ( handle == nullptr ) || ( handle -> m_heap == nullptr ) || ( handle -> m_heap -> m_magic != HDR_BUF_MAGIC_ALIVE ) ) {
 return TS_ERROR ;
 }
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) {
 char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ;
 char buf [ STRING ] ;
 int rc ;
 if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) {
 mutt_message ( _ ( ""LOGIN disabled on this server."" ) ) ;
 return IMAP_AUTH_UNAVAIL ;
 }
 if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;
 if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;
 mutt_message ( _ ( ""Logging in..."" ) ) ;
 imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ;
 imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ;
 if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending LOGIN command for %s...\n"" , idata -> conn -> account . user ) ;
 snprintf ( buf , sizeof ( buf ) , ""LOGIN %s %s"" , q_user , q_pass ) ;
 rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ;
 if ( ! rc ) {
 mutt_clear_error ( ) ;
 return IMAP_AUTH_SUCCESS ;
 }
 mutt_error ( _ ( ""Login failed."" ) ) ;
 return IMAP_AUTH_FAILURE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_btgatt_microbit_pin_data ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {
 btatt_data_t * att_data = ( btatt_data_t * ) data ;
 proto_item * sub_item ;
 proto_tree * sub_tree ;
 gint offset = 0 ;
 gint num_pins ;
 guint32 number , value ;
 if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;
 num_pins = tvb_captured_length ( tvb ) / 2 ;
 for ( gint i = 0 ;
 i < num_pins ;
 i ++ ) {
 sub_item = proto_tree_add_item ( tree , hf_gatt_microbit_pin_data , tvb , offset , 2 , ENC_NA ) ;
 sub_tree = proto_item_add_subtree ( sub_item , ett_btgatt_microbit_pin_data ) ;
 proto_tree_add_item_ret_uint ( sub_tree , hf_gatt_microbit_pin_number , tvb , offset , 1 , ENC_NA , & number ) ;
 offset ++ ;
 value = tvb_get_guint8 ( tvb , offset ) * 4 ;
 proto_tree_add_uint ( sub_tree , hf_gatt_microbit_pin_value , tvb , offset , 1 , value ) ;
 offset ++ ;
 proto_item_set_text ( sub_item , ""Pin %u: %u"" , number , value ) ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void idct_put ( MDECContext * a , int mb_x , int mb_y ) {
 int16_t ( * block ) [ 64 ] = a -> block ;
 int linesize = a -> picture . linesize [ 0 ] ;
 uint8_t * dest_y = a -> picture . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = a -> picture . data [ 1 ] + ( mb_y * 8 * a -> picture . linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = a -> picture . data [ 2 ] + ( mb_y * 8 * a -> picture . linesize [ 2 ] ) + mb_x * 8 ;
 a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;
 if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 a -> dsp . idct_put ( dest_cb , a -> picture . linesize [ 1 ] , block [ 4 ] ) ;
 a -> dsp . idct_put ( dest_cr , a -> picture . linesize [ 2 ] , block [ 5 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int file_alloc_security ( struct file * file ) {
 struct file_security_struct * fsec ;
 u32 sid = current_sid ( ) ;
 fsec = kmem_cache_zalloc ( file_security_cache , GFP_KERNEL ) ;
 if ( ! fsec ) return - ENOMEM ;
 fsec -> sid = sid ;
 fsec -> fown_sid = sid ;
 file -> f_security = fsec ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static struct archive_wstring * archive_wstring_append ( struct archive_wstring * as , const wchar_t * p , size_t s ) {
 if ( archive_wstring_ensure ( as , as -> length + s + 1 ) == NULL ) return ( NULL ) ;
 wmemmove ( as -> s + as -> length , p , s ) ;
 as -> length += s ;
 as -> s [ as -> length ] = 0 ;
 return ( as ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int rawv6_rcv_skb ( struct sock * sk , struct sk_buff * skb ) {
 if ( ( raw6_sk ( sk ) -> checksum || sk -> sk_filter ) && skb_checksum_complete ( skb ) ) {
 atomic_inc ( & sk -> sk_drops ) ;
 kfree_skb ( skb ) ;
 return NET_RX_DROP ;
 }
 if ( sock_queue_rcv_skb ( sk , skb ) < 0 ) {
 kfree_skb ( skb ) ;
 return NET_RX_DROP ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int spl_filesystem_file_is_empty_line ( spl_filesystem_object * intern TSRMLS_DC ) {
 if ( intern -> u . file . current_line ) {
 return intern -> u . file . current_line_len == 0 ;
 }
 else if ( intern -> u . file . current_zval ) {
 switch ( Z_TYPE_P ( intern -> u . file . current_zval ) ) {
 case IS_STRING : return Z_STRLEN_P ( intern -> u . file . current_zval ) == 0 ;
 case IS_ARRAY : if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) && zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 1 ) {
 zval * * first = Z_ARRVAL_P ( intern -> u . file . current_zval ) -> pListHead -> pData ;
 return Z_TYPE_PP ( first ) == IS_STRING && Z_STRLEN_PP ( first ) == 0 ;
 }
 return zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 0 ;
 case IS_NULL : return 1 ;
 default : return 0 ;
 }
 }
 else {
 return 1 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"char * xmlrpc_normalizeBuffer ( const char * buf ) {
 char * newbuf ;
 int i , len , j = 0 ;
 len = strlen ( buf ) ;
 newbuf = ( char * ) smalloc ( sizeof ( char ) * len + 1 ) ;
 for ( i = 0 ;
 i < len ;
 i ++ ) {
 switch ( buf [ i ] ) {
 case 1 : break ;
 case 2 : break ;
 case 3 : if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {
 i ++ ;
 if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {
 i ++ ;
 }
 if ( buf [ i + 1 ] == ',' ) {
 i ++ ;
 if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {
 i ++ ;
 }
 if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {
 i ++ ;
 }
 }
 }
 break ;
 case 9 : break ;
 case 10 : break ;
 case 13 : break ;
 case 22 : break ;
 case 31 : break ;
 default : if ( buf [ i ] > 31 ) {
 newbuf [ j ] = buf [ i ] ;
 j ++ ;
 }
 }
 }
 newbuf [ j ] = 0 ;
 return ( newbuf ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"gs_main_instance * gs_main_alloc_instance ( gs_memory_t * mem ) {
 gs_main_instance * minst ;
 if ( mem == NULL ) return NULL ;
 minst = ( gs_main_instance * ) gs_alloc_bytes_immovable ( mem , sizeof ( gs_main_instance ) , ""init_main_instance"" ) ;
 if ( minst == NULL ) return NULL ;
 memcpy ( minst , & gs_main_instance_init_values , sizeof ( gs_main_instance_init_values ) ) ;
 minst -> heap = mem ;
 mem -> gs_lib_ctx -> top_of_system = minst ;
 return minst ;
 }",0
Detect whether the following code contains vulnerabilities.,"static byte * i_alloc_byte_array ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {
 gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;
 obj_header_t * obj ;
 # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;
 # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_DIRECT , cname ) ;
 if_debug6m ( 'A' , mem , ""[a%d:+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;
 return ( byte * ) obj ;
 }",1
Detect whether the following code contains vulnerabilities.,"static cmsBool Read16bitTables ( cmsContext ContextID , cmsIOHANDLER * io , cmsPipeline * lut , int nChannels , int nEntries ) {
 int i ;
 cmsToneCurve * Tables [ cmsMAXCHANNELS ] ;
 if ( nEntries <= 0 ) return TRUE ;
 if ( nEntries < 2 ) return FALSE ;
 if ( nChannels > cmsMAXCHANNELS ) return FALSE ;
 memset ( Tables , 0 , sizeof ( Tables ) ) ;
 for ( i = 0 ;
 i < nChannels ;
 i ++ ) {
 Tables [ i ] = cmsBuildTabulatedToneCurve16 ( ContextID , nEntries , NULL ) ;
 if ( Tables [ i ] == NULL ) goto Error ;
 if ( ! _cmsReadUInt16Array ( io , nEntries , Tables [ i ] -> Table16 ) ) goto Error ;
 }
 if ( ! cmsPipelineInsertStage ( lut , cmsAT_END , cmsStageAllocToneCurves ( ContextID , nChannels , Tables ) ) ) goto Error ;
 for ( i = 0 ;
 i < nChannels ;
 i ++ ) cmsFreeToneCurve ( Tables [ i ] ) ;
 return TRUE ;
 Error : for ( i = 0 ;
 i < nChannels ;
 i ++ ) {
 if ( Tables [ i ] ) cmsFreeToneCurve ( Tables [ i ] ) ;
 }
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void free_picture ( MpegEncContext * s , Picture * pic ) {
 int i ;
 if ( pic -> f . data [ 0 ] && pic -> f . type != FF_BUFFER_TYPE_SHARED ) {
 free_frame_buffer ( s , pic ) ;
 }
 av_freep ( & pic -> mb_var ) ;
 av_freep ( & pic -> mc_mb_var ) ;
 av_freep ( & pic -> mb_mean ) ;
 av_freep ( & pic -> f . mbskip_table ) ;
 av_freep ( & pic -> qscale_table_base ) ;
 pic -> f . qscale_table = NULL ;
 av_freep ( & pic -> mb_type_base ) ;
 pic -> f . mb_type = NULL ;
 av_freep ( & pic -> f . dct_coeff ) ;
 av_freep ( & pic -> f . pan_scan ) ;
 pic -> f . mb_type = NULL ;
 for ( i = 0 ;
 i < 2 ;
 i ++ ) {
 av_freep ( & pic -> motion_val_base [ i ] ) ;
 av_freep ( & pic -> f . ref_index [ i ] ) ;
 pic -> f . motion_val [ i ] = NULL ;
 }
 if ( pic -> f . type == FF_BUFFER_TYPE_SHARED ) {
 for ( i = 0 ;
 i < 4 ;
 i ++ ) {
 pic -> f . base [ i ] = pic -> f . data [ i ] = NULL ;
 }
 pic -> f . type = 0 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void proto_tree_set_system_id_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {
 proto_tree_set_system_id ( fi , tvb_get_ptr ( tvb , start , length ) , length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_max_filter_level ( const VP9_COMP * cpi ) {
 if ( cpi -> oxcf . pass == 2 ) {
 return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;
 }
 else {
 return MAX_LOOP_FILTER ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_x509name_cmp ( VALUE self , VALUE other ) {
 int result ;
 result = ossl_x509name_cmp0 ( self , other ) ;
 if ( result < 0 ) return INT2FIX ( - 1 ) ;
 if ( result > 1 ) return INT2FIX ( 1 ) ;
 return INT2FIX ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int X509_REQ_sign_ctx ( X509_REQ * x , EVP_MD_CTX * ctx ) {
 return ASN1_item_sign_ctx ( ASN1_ITEM_rptr ( X509_REQ_INFO ) , x -> sig_alg , NULL , x -> signature , x -> req_info , ctx ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSHttpTxnConfigIntSet ( TSHttpTxn txnp , TSOverridableConfigKey conf , TSMgmtInt value ) {
 sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;
 HttpSM * s = reinterpret_cast < HttpSM * > ( txnp ) ;
 OverridableDataType type ;
 s -> t_state . setup_per_txn_configs ( ) ;
 void * dest = _conf_to_memberp ( conf , s -> t_state . txn_conf , & type ) ;
 if ( ! dest ) {
 return TS_ERROR ;
 }
 switch ( type ) {
 case OVERRIDABLE_TYPE_INT : * ( static_cast < TSMgmtInt * > ( dest ) ) = value ;
 break ;
 case OVERRIDABLE_TYPE_BYTE : * ( static_cast < TSMgmtByte * > ( dest ) ) = static_cast < TSMgmtByte > ( value ) ;
 break ;
 default : return TS_ERROR ;
 }
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"TSReturnCode TSUuidInitialize ( TSUuid uuid , TSUuidVersion v ) {
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) uuid ) == TS_SUCCESS ) ;
 ATSUuid * u = ( ATSUuid * ) uuid ;
 u -> initialize ( v ) ;
 return u -> valid ( ) ? TS_SUCCESS : TS_ERROR ;
 }",0
Detect whether the following code contains vulnerabilities.,"vpx_codec_err_t vpx_svc_get_layer_resolution ( const SvcContext * svc_ctx , int layer , unsigned int * width , unsigned int * height ) {
 int w , h , index , num , den ;
 const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL || width == NULL || height == NULL ) {
 return VPX_CODEC_INVALID_PARAM ;
 }
 if ( layer < 0 || layer >= si -> layers ) return VPX_CODEC_INVALID_PARAM ;
 index = layer + VPX_SS_MAX_LAYERS - si -> layers ;
 num = si -> scaling_factor_num [ index ] ;
 den = si -> scaling_factor_den [ index ] ;
 if ( num == 0 || den == 0 ) return VPX_CODEC_INVALID_PARAM ;
 w = si -> width * num / den ;
 h = si -> height * num / den ;
 w += w % 2 ;
 h += h % 2 ;
 * width = w ;
 * height = h ;
 return VPX_CODEC_OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const u_char * print_sl_change ( netdissect_options * ndo , const char * str , register const u_char * cp ) {
 register u_int i ;
 if ( ( i = * cp ++ ) == 0 ) {
 i = EXTRACT_16BITS ( cp ) ;
 cp += 2 ;
 }
 ND_PRINT ( ( ndo , "" %s%d"" , str , i ) ) ;
 return ( cp ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint32 pad_offset ( struct tcpinfo * tcpinfo , guint32 fpdu_total_len , guint8 pad_len ) {
 if ( ( tcpinfo -> nxtseq - MPA_CRC_LEN - MPA_MARKER_LEN ) % MPA_MARKER_INTERVAL == 0 ) {
 return fpdu_total_len - MPA_CRC_LEN - MPA_MARKER_LEN - pad_len ;
 }
 else {
 return fpdu_total_len - MPA_CRC_LEN - pad_len ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void set_partial_b64x64_partition ( MODE_INFO * mi , int mis , int bh_in , int bw_in , int row8x8_remaining , int col8x8_remaining , BLOCK_SIZE bsize , MODE_INFO * * mi_8x8 ) {
 int bh = bh_in ;
 int r , c ;
 for ( r = 0 ;
 r < MI_BLOCK_SIZE ;
 r += bh ) {
 int bw = bw_in ;
 for ( c = 0 ;
 c < MI_BLOCK_SIZE ;
 c += bw ) {
 const int index = r * mis + c ;
 mi_8x8 [ index ] = mi + index ;
 mi_8x8 [ index ] -> mbmi . sb_type = find_partition_size ( bsize , row8x8_remaining - r , col8x8_remaining - c , & bh , & bw ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , getFilename ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * getPosixID ( const ILcidPosixMap * this_0 , uint32_t hostID ) {
 uint32_t i ;
 for ( i = 0 ;
 i <= this_0 -> numRegions ;
 i ++ ) {
 if ( this_0 -> regionMaps [ i ] . hostID == hostID ) {
 return this_0 -> regionMaps [ i ] . posixID ;
 }
 }
 return this_0 -> regionMaps [ 0 ] . posixID ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int array_min_int16 ( const int16_t * array , int nel ) {
 int i , min = array [ 0 ] ;
 for ( i = 1 ;
 i < nel ;
 i ++ ) min = FFMIN ( array [ i ] , min ) ;
 return min ;
 }",1
Detect whether the following code contains vulnerabilities.,"int parse_CRangeCategSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 proto_item * item ;
 proto_tree * tree ;
 va_list ap ;
 unsigned i ;
 const char * txt ;
 guint32 cRange ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRangeCategSpec , & item , txt ) ;
 offset = parse_lcid ( tvb , offset , tree , ""lcid"" ) ;
 cRange = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_crangecategspec_crange , tvb , offset , 4 , cRange ) ;
 offset += 4 ;
 for ( i = 0 ;
 i < cRange ;
 i ++ ) {
 offset = parse_RANGEBOUNDARY ( tvb , offset , tree , pad_tree , ""aRangeBegin[%u]"" , i ) ;
 }
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {
 size_t used = buf -> misalign + buf -> off ;
 assert ( buf -> totallen >= used ) ;
 if ( buf -> totallen - used >= datlen ) return ( 0 ) ;
 if ( datlen > SIZE_MAX - buf -> off ) return ( - 1 ) ;
 if ( buf -> totallen - buf -> off >= datlen ) {
 evbuffer_align ( buf ) ;
 }
 else {
 void * newbuf ;
 size_t length = buf -> totallen ;
 size_t need = buf -> off + datlen ;
 if ( length < 256 ) length = 256 ;
 if ( need < SIZE_MAX / 2 ) {
 while ( length < need ) {
 length <<= 1 ;
 }
 }
 else {
 length = need ;
 }
 if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;
 if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;
 buf -> orig_buffer = buf -> buffer = newbuf ;
 buf -> totallen = length ;
 }
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cpu_request_exit ( void * opaque , int irq , int level ) {
 CPUMIPSState * env = cpu_single_env ;
 if ( env && level ) {
 cpu_exit ( CPU ( mips_env_get_cpu ( env ) ) ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void sbr_hf_apply_noise_0 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {
 sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 1.0 , 0.0 , m_max ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void evsignal_dealloc ( struct event_base * base ) {
 int i = 0 ;
 if ( base -> sig . ev_signal_added ) {
 event_del ( & base -> sig . ev_signal ) ;
 base -> sig . ev_signal_added = 0 ;
 }
 for ( i = 0 ;
 i < NSIG ;
 ++ i ) {
 if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;
 }
 EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ;
 base -> sig . ev_signal_pair [ 0 ] = - 1 ;
 EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ;
 base -> sig . ev_signal_pair [ 1 ] = - 1 ;
 base -> sig . sh_old_max = 0 ;
 free ( base -> sig . sh_old ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _SCSUClose ( UConverter * cnv ) {
 if ( cnv -> extraInfo != NULL ) {
 if ( ! cnv -> isExtraLocal ) {
 uprv_free ( cnv -> extraInfo ) ;
 }
 cnv -> extraInfo = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int UnblendedCompare ( real u1 [ MmMax ] , real u2 [ MmMax ] , int cnt ) {
 int i ;
 for ( i = 0 ;
 i < cnt ;
 ++ i ) {
 if ( u1 [ i ] != u2 [ i ] ) return ( u1 [ i ] > u2 [ i ] ? 1 : - 1 ) ;
 }
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_current_cpu ( void ) {
 CPUState * cpu_single_cpu ;
 if ( ! cpu_single_env ) {
 return - 1 ;
 }
 cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;
 return cpu_single_cpu -> cpu_index ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_PRINTER_INFO_3 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_printer_flags , NULL ) ;
 offset = dissect_nt_sec_desc ( tvb , offset , pinfo , tree , drep , FALSE , - 1 , & spoolss_printer_access_mask_info ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void FLOATING_POINT_RESTORE ( ) {
 }",0
Detect whether the following code contains vulnerabilities.,"int keyring_lock ( KEYRING_HANDLE hd , int yes ) {
 KR_NAME kr ;
 int rc = 0 ;
 ( void ) hd ;
 if ( yes ) {
 for ( kr = kr_names ;
 kr ;
 kr = kr -> next ) {
 if ( ! keyring_is_writable ( kr ) ) continue ;
 if ( ! kr -> lockhd ) {
 kr -> lockhd = dotlock_create ( kr -> fname , 0 ) ;
 if ( ! kr -> lockhd ) {
 log_info ( ""can't allocate lock for '%s'\n"" , kr -> fname ) ;
 rc = GPG_ERR_GENERAL ;
 }
 }
 }
 if ( rc ) return rc ;
 for ( kr = kr_names ;
 kr ;
 kr = kr -> next ) {
 if ( ! keyring_is_writable ( kr ) ) continue ;
 if ( kr -> is_locked ) ;
 else if ( dotlock_take ( kr -> lockhd , - 1 ) ) {
 log_info ( ""can't lock '%s'\n"" , kr -> fname ) ;
 rc = GPG_ERR_GENERAL ;
 }
 else kr -> is_locked = 1 ;
 }
 }
 if ( rc || ! yes ) {
 for ( kr = kr_names ;
 kr ;
 kr = kr -> next ) {
 if ( ! keyring_is_writable ( kr ) ) continue ;
 if ( ! kr -> is_locked ) ;
 else if ( dotlock_release ( kr -> lockhd ) ) log_info ( ""can't unlock '%s'\n"" , kr -> fname ) ;
 else kr -> is_locked = 0 ;
 }
 }
 return rc ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t get_send_time ( ASFContext * asf , int64_t pres_time , uint64_t * offset ) {
 int i ;
 int32_t send_time = 0 ;
 * offset = asf -> data_offset + DATA_HEADER_SIZE ;
 for ( i = 0 ;
 i < asf -> next_start_sec ;
 i ++ ) {
 if ( pres_time <= asf -> index_ptr [ i ] . send_time ) break ;
 send_time = asf -> index_ptr [ i ] . send_time ;
 * offset = asf -> index_ptr [ i ] . offset ;
 }
 return send_time / 10000 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static __inline__ void ethtool_cmd_speed_set ( struct ethtool_cmd * ep , __u32 speed ) {
 ep -> speed = ( __u16 ) ( speed & 0xFFFF ) ;
 ep -> speed_hi = ( __u16 ) ( speed >> 16 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"GHashTable * prplcb_ui_info ( ) {
 static GHashTable * ret ;
 if ( ret == NULL ) {
 ret = g_hash_table_new ( g_str_hash , g_str_equal ) ;
 g_hash_table_insert ( ret , ""name"" , ""BitlBee"" ) ;
 g_hash_table_insert ( ret , ""version"" , BITLBEE_VERSION ) ;
 }
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline my_bool general_log_or_slow_log_tables ( const char * db , const char * table ) {
 return ( ! my_strcasecmp ( charset_info , db , ""mysql"" ) ) && ( ! my_strcasecmp ( charset_info , table , ""general_log"" ) || ! my_strcasecmp ( charset_info , table , ""slow_log"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int rawv6_init_sk ( struct sock * sk ) {
 struct raw6_sock * rp = raw6_sk ( sk ) ;
 switch ( inet_sk ( sk ) -> inet_num ) {
 case IPPROTO_ICMPV6 : rp -> checksum = 1 ;
 rp -> offset = 2 ;
 break ;
 case IPPROTO_MH : rp -> checksum = 1 ;
 rp -> offset = 4 ;
 break ;
 default : break ;
 }
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_UnregRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 614 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_UnregRejectReason , UnregRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void ff_update_block_index ( MpegEncContext * s ) {
 const int block_size = 8 ;
 s -> block_index [ 0 ] += 2 ;
 s -> block_index [ 1 ] += 2 ;
 s -> block_index [ 2 ] += 2 ;
 s -> block_index [ 3 ] += 2 ;
 s -> block_index [ 4 ] ++ ;
 s -> block_index [ 5 ] ++ ;
 s -> dest [ 0 ] += 2 * block_size ;
 s -> dest [ 1 ] += block_size ;
 s -> dest [ 2 ] += block_size ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_disable_segmentation ( struct segmentation * seg ) {
 seg -> enabled = 0 ;
 seg -> update_map = 0 ;
 seg -> update_data = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( UnloadTest , DISABLED_CrossSiteInfiniteBeforeUnloadSync ) {
 if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;
 NavigateToDataURL ( INFINITE_BEFORE_UNLOAD_HTML , ""infinitebeforeunload"" ) ;
 NavigateToNolistenersFileTwice ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pcnet_bcr_writew ( PCNetState * s , uint32_t rap , uint32_t val ) {
 rap &= 127 ;
 # ifdef PCNET_DEBUG_BCR printf ( ""pcnet_bcr_writew rap=%d val=0x%04x\n"" , rap , val ) ;
 # endif switch ( rap ) {
 case BCR_SWS : if ( ! ( CSR_STOP ( s ) || CSR_SPND ( s ) ) ) return ;
 val &= ~ 0x0300 ;
 switch ( val & 0x00ff ) {
 case 0 : val |= 0x0200 ;
 break ;
 case 1 : val |= 0x0100 ;
 break ;
 case 2 : case 3 : val |= 0x0300 ;
 break ;
 default : printf ( ""Bad SWSTYLE=0x%02x\n"" , val & 0xff ) ;
 val = 0x0200 ;
 break ;
 }
 # ifdef PCNET_DEBUG printf ( ""BCR_SWS=0x%04x\n"" , val ) ;
 # endif case BCR_LNKST : case BCR_LED1 : case BCR_LED2 : case BCR_LED3 : case BCR_MC : case BCR_FDC : case BCR_BSBC : case BCR_EECAS : case BCR_PLAT : s -> bcr [ rap ] = val ;
 break ;
 default : break ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static __always_inline __u32 __be32_to_cpup ( const __be32 * p ) {
 return __swab32p ( ( __u32 * ) p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void compute_curve_gamma_table_type0 ( float gamma_table [ 256 ] ) {
 unsigned int i ;
 for ( i = 0 ;
 i < 256 ;
 i ++ ) {
 gamma_table [ i ] = i / 255. ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {
 gx_ttfReader * r = ( gx_ttfReader * ) self ;
 const byte * q ;
 if ( ! r -> error ) {
 if ( r -> extra_glyph_index != - 1 ) {
 q = r -> glyph_data . bits . data + r -> pos ;
 r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;
 if ( r -> error == 0 ) memcpy ( p , q , n ) ;
 }
 else {
 unsigned int cnt ;
 for ( cnt = 0 ;
 cnt < ( uint ) n ;
 cnt += r -> error ) {
 r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;
 if ( r -> error < 0 ) break ;
 else if ( r -> error == 0 ) {
 memcpy ( ( char * ) p + cnt , q , n - cnt ) ;
 break ;
 }
 else {
 memcpy ( ( char * ) p + cnt , q , r -> error ) ;
 }
 }
 }
 }
 if ( r -> error ) {
 memset ( p , 0 , n ) ;
 return ;
 }
 r -> pos += n ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void t38_defragment_init ( void ) {
 reassembly_table_init ( & data_reassembly_table , & addresses_reassembly_table_functions ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_signal_restore ( void ) {
 struct event ev ;
 struct event_base * base = event_init ( ) ;
 # ifdef HAVE_SIGACTION struct sigaction sa ;
 # endif test_ok = 0 ;
 printf ( ""Signal handler restore: "" ) ;
 # ifdef HAVE_SIGACTION sa . sa_handler = signal_cb_sa ;
 sa . sa_flags = 0x0 ;
 sigemptyset ( & sa . sa_mask ) ;
 if ( sigaction ( SIGUSR1 , & sa , NULL ) == - 1 ) goto out ;
 # else if ( signal ( SIGUSR1 , signal_cb_sa ) == SIG_ERR ) goto out ;
 # endif signal_set ( & ev , SIGUSR1 , signal_cb , & ev ) ;
 signal_add ( & ev , NULL ) ;
 signal_del ( & ev ) ;
 raise ( SIGUSR1 ) ;
 if ( test_ok != 2 ) test_ok = 0 ;
 out : event_base_free ( base ) ;
 cleanup_test ( ) ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"int get_file_params_count_resume ( char * * params , int paramcount ) {
 int pos , best ;
 if ( * params [ 0 ] == '""' ) {
 for ( pos = 0 ;
 pos < paramcount - 2 ;
 pos ++ ) {
 if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '""' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;
 }
 }
 best = paramcount - 2 ;
 for ( pos = paramcount - 2 ;
 pos > 0 ;
 pos -- ) {
 if ( get_params_match_resume ( params , pos ) ) best = pos ;
 }
 return best ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void virtio_balloon_receive_stats ( VirtIODevice * vdev , VirtQueue * vq ) {
 VirtIOBalloon * s = DO_UPCAST ( VirtIOBalloon , vdev , vdev ) ;
 VirtQueueElement * elem = & s -> stats_vq_elem ;
 VirtIOBalloonStat stat ;
 size_t offset = 0 ;
 if ( ! virtqueue_pop ( vq , elem ) ) {
 return ;
 }
 reset_stats ( s ) ;
 while ( iov_to_buf ( elem -> out_sg , elem -> out_num , & stat , offset , sizeof ( stat ) ) == sizeof ( stat ) ) {
 uint16_t tag = tswap16 ( stat . tag ) ;
 uint64_t val = tswap64 ( stat . val ) ;
 offset += sizeof ( stat ) ;
 if ( tag < VIRTIO_BALLOON_S_NR ) s -> stats [ tag ] = val ;
 }
 s -> stats_vq_offset = offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int gs_main_add_lib_path ( gs_main_instance * minst , const char * lpath ) {
 int first_is_here = ( r_size ( & minst -> lib_path . list ) != 0 && minst -> lib_path . container . value . refs [ 0 ] . value . bytes == ( const byte * ) gp_current_directory_name ? 1 : 0 ) ;
 int code ;
 r_set_size ( & minst -> lib_path . list , minst -> lib_path . count + first_is_here ) ;
 code = file_path_add ( minst , & minst -> lib_path , lpath ) ;
 minst -> lib_path . count = r_size ( & minst -> lib_path . list ) - first_is_here ;
 if ( code < 0 ) return code ;
 return gs_main_set_lib_paths ( minst ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * size_checked_realloc ( void * ptr , size_t size ) {
 if ( size > MAX_LIBXML_MALLOC ) {
 * ( volatile char * ) 0 = '\0' ;
 return NULL ;
 }
 return realloc ( ptr , size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_t35Extension ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , & t35Extension , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {
 guint32 size ;
 int end_offset ;
 if ( di -> conformant_run ) return offset ;
 offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ;
 end_offset = offset + ( size * 2 ) ;
 if ( end_offset < offset ) {
 end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ;
 }
 while ( offset < end_offset ) offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode , SEQUENCE_OF_MultiplePayloadStreamElementMode_sequence_of ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ScoredHistoryMatchTest , ScoringBookmarks ) {
 base : : Time now = base : : Time : : NowFromSystemTime ( ) ;
 std : : string url_string ( ""http://fedcba"" ) ;
 const GURL url ( url_string ) ;
 history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , ""abcd bcd"" , 8 , 3 , 1 ) ) ;
 RowWordStarts word_starts ;
 PopulateWordStarts ( row , & word_starts ) ;
 WordStarts one_word_no_offset ( 1 , 0u ) ;
 VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;
 ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""abc"" ) , Make1Term ( ""abc"" ) , one_word_no_offset , word_starts , false , nullptr , now ) ;
 base : : AutoReset < int > reset ( & ScoredHistoryMatch : : bookmark_value_ , 5 ) ;
 ScoredHistoryMatch scored_with_bookmark ( row , visits , std : : string ( ) , ASCIIToUTF16 ( ""abc"" ) , Make1Term ( ""abc"" ) , one_word_no_offset , word_starts , true , nullptr , now ) ;
 EXPECT_GT ( scored_with_bookmark . raw_score , scored . raw_score ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"char * get_arg ( char * line , my_bool get_next_arg ) {
 char * ptr , * start ;
 my_bool quoted = 0 , valid_arg = 0 ;
 char qtype = 0 ;
 ptr = line ;
 if ( get_next_arg ) {
 for ( ;
 * ptr ;
 ptr ++ ) ;
 if ( * ( ptr + 1 ) ) ptr ++ ;
 }
 else {
 while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;
 if ( * ptr == '\\' ) ptr += 2 ;
 else while ( * ptr && ! my_isspace ( charset_info , * ptr ) ) ptr ++ ;
 }
 if ( ! * ptr ) return NullS ;
 while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;
 if ( * ptr == '\'' || * ptr == '\""' || * ptr == '`' ) {
 qtype = * ptr ;
 quoted = 1 ;
 ptr ++ ;
 }
 for ( start = ptr ;
 * ptr ;
 ptr ++ ) {
 if ( * ptr == '\\' && ptr [ 1 ] ) {
 strmov_overlapp ( ptr , ptr + 1 ) ;
 }
 else if ( ( ! quoted && * ptr == ' ' ) || ( quoted && * ptr == qtype ) ) {
 * ptr = 0 ;
 break ;
 }
 }
 valid_arg = ptr != start ;
 return valid_arg ? start : NullS ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {
 struct rfc822_parser_context parser ;
 const char * const * results , * filename2 ;
 string_t * str ;
 * filename_r = NULL ;
 if ( content_disposition == NULL ) return ;
 rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 str = t_str_new ( 32 ) ;
 if ( rfc822_parse_mime_token ( & parser , str ) < 0 ) {
 rfc822_parser_deinit ( & parser ) ;
 return ;
 }
 rfc2231_parse ( & parser , & results ) ;
 filename2 = NULL ;
 for ( ;
 * results != NULL ;
 results += 2 ) {
 if ( strcasecmp ( results [ 0 ] , ""filename"" ) == 0 ) {
 * filename_r = results [ 1 ] ;
 break ;
 }
 if ( strcasecmp ( results [ 0 ] , ""filename*"" ) == 0 ) filename2 = results [ 1 ] ;
 }
 if ( * filename_r == NULL ) {
 * filename_r = filename2 ;
 }
 rfc822_parser_deinit ( & parser ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int s390_virtio_console_init ( VirtIOS390Device * dev ) {
 VirtIOS390Bus * bus ;
 VirtIODevice * vdev ;
 int r ;
 bus = DO_UPCAST ( VirtIOS390Bus , bus , dev -> qdev . parent_bus ) ;
 vdev = virtio_console_init ( ( DeviceState * ) dev ) ;
 if ( ! vdev ) {
 return - 1 ;
 }
 r = s390_virtio_device_init ( dev , vdev ) ;
 if ( ! r ) {
 bus -> console = dev ;
 }
 return r ;
 }",1
Detect whether the following code contains vulnerabilities.,"void av_image_copy_plane ( uint8_t * dst , int dst_linesize , const uint8_t * src , int src_linesize , int bytewidth , int height ) {
 if ( ! dst || ! src ) return ;
 for ( ;
 height > 0 ;
 height -- ) {
 memcpy ( dst , src , bytewidth ) ;
 dst += dst_linesize ;
 src += src_linesize ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , InputEncodingBeforeSearchTerm ) {
 TemplateURLData data ;
 data . SetURL ( ""http://foox{
inputEncoding?}
a{
searchTerms}
y{
outputEncoding?}
b"" ) ;
 TemplateURL url ( data ) ;
 EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;
 ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data_ ) ) ;
 GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( ASCIIToUTF16 ( ""X"" ) ) , search_terms_data_ ) ) ;
 ASSERT_TRUE ( result . is_valid ( ) ) ;
 EXPECT_EQ ( ""http://fooxutf-8axyb/"" , result . spec ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * string_ljust ( PyStringObject * self , PyObject * args ) {
 Py_ssize_t width ;
 char fillchar = ' ' ;
 if ( ! PyArg_ParseTuple ( args , ""n|c:ljust"" , & width , & fillchar ) ) return NULL ;
 if ( PyString_GET_SIZE ( self ) >= width && PyString_CheckExact ( self ) ) {
 Py_INCREF ( self ) ;
 return ( PyObject * ) self ;
 }
 return pad ( self , 0 , width - PyString_GET_SIZE ( self ) , fillchar ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int selinux_skb_peerlbl_sid ( struct sk_buff * skb , u16 family , u32 * sid ) {
 int err ;
 u32 xfrm_sid ;
 u32 nlbl_sid ;
 u32 nlbl_type ;
 err = selinux_xfrm_skb_sid ( skb , & xfrm_sid ) ;
 if ( unlikely ( err ) ) return - EACCES ;
 err = selinux_netlbl_skbuff_getsid ( skb , family , & nlbl_type , & nlbl_sid ) ;
 if ( unlikely ( err ) ) return - EACCES ;
 err = security_net_peersid_resolve ( nlbl_sid , nlbl_type , xfrm_sid , sid ) ;
 if ( unlikely ( err ) ) {
 printk ( KERN_WARNING ""SELinux: failure in selinux_skb_peerlbl_sid(),"" "" unable to determine packet's peer label\n"" ) ;
 return - EACCES ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline bool e1000e_ring_empty ( E1000ECore * core , const E1000E_RingInfo * r ) {
 return core -> mac [ r -> dh ] == core -> mac [ r -> dt ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF32Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 _UTF32Reset ( cnv , UCNV_RESET_BOTH ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_init_second_pass_spatial_svc ( VP9_COMP * cpi ) {
 SVC * const svc = & cpi -> svc ;
 int i ;
 for ( i = 0 ;
 i < svc -> number_spatial_layers ;
 ++ i ) {
 TWO_PASS * const twopass = & svc -> layer_context [ i ] . twopass ;
 svc -> spatial_layer_id = i ;
 vp9_init_second_pass ( cpi ) ;
 twopass -> total_stats . spatial_layer_id = i ;
 twopass -> total_left_stats . spatial_layer_id = i ;
 }
 svc -> spatial_layer_id = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UConverter * _HZ_SafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {
 struct cloneHZStruct * localClone ;
 int32_t size , bufferSizeNeeded = sizeof ( struct cloneHZStruct ) ;
 if ( U_FAILURE ( * status ) ) {
 return 0 ;
 }
 if ( * pBufferSize == 0 ) {
 * pBufferSize = bufferSizeNeeded ;
 return 0 ;
 }
 localClone = ( struct cloneHZStruct * ) stackBuffer ;
 uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( UConverterDataHZ ) ) ;
 localClone -> cnv . extraInfo = & localClone -> mydata ;
 localClone -> cnv . isExtraLocal = TRUE ;
 size = ( int32_t ) ( sizeof ( UConverter ) + sizeof ( UAlignedMemory ) ) ;
 ( ( UConverterDataHZ * ) localClone -> cnv . extraInfo ) -> gbConverter = ucnv_safeClone ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter , & localClone -> subCnv , & size , status ) ;
 return & localClone -> cnv ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cancel_file_info_for_file ( NautilusDirectory * directory , NautilusFile * file ) {
 if ( directory -> details -> get_info_file == file ) {
 file_info_cancel ( directory ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void nlm_register_unmatched_res ( packet_info * pinfo , tvbuff_t * tvb , int offset ) {
 nlm_msg_res_unmatched_data umd ;
 nlm_msg_res_unmatched_data * old_umd ;
 umd . cookie_len = tvb_get_ntohl ( tvb , offset ) ;
 umd . cookie = tvb_get_ptr ( tvb , offset + 4 , - 1 ) ;
 old_umd = ( nlm_msg_res_unmatched_data * ) g_hash_table_lookup ( nlm_msg_res_unmatched , ( gconstpointer ) & umd ) ;
 if ( old_umd ) {
 nlm_msg_res_matched_data * md ;
 md = ( nlm_msg_res_matched_data * ) g_malloc ( sizeof ( nlm_msg_res_matched_data ) ) ;
 md -> req_frame = old_umd -> req_frame ;
 md -> rep_frame = pinfo -> fd -> num ;
 md -> ns = old_umd -> ns ;
 g_hash_table_insert ( nlm_msg_res_matched , GINT_TO_POINTER ( md -> req_frame ) , ( gpointer ) md ) ;
 g_hash_table_insert ( nlm_msg_res_matched , GINT_TO_POINTER ( md -> rep_frame ) , ( gpointer ) md ) ;
 g_hash_table_remove ( nlm_msg_res_unmatched , ( gconstpointer ) old_umd ) ;
 g_free ( ( gpointer ) old_umd -> cookie ) ;
 g_free ( old_umd ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void sig_message_public ( SERVER_REC * server , const char * msg , const char * nick , const char * address , const char * target ) {
 CHANNEL_REC * channel ;
 int own ;
 channel = channel_find ( server , target ) ;
 if ( channel != NULL ) {
 own = nick_match_msg ( channel , msg , server -> nick ) ;
 CHANNEL_LAST_MSG_ADD ( channel , nick , own ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ __u32 __fswab32 ( __u32 val ) {
 # if defined ( __arch_swab32 ) return __arch_swab32 ( val ) ;
 # else return ___constant_swab32 ( val ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"static inline uint16_t be16_to_cpu ( uint16_t v ) {
 return bswap16 ( v ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * formboundary ( struct SessionHandle * data ) {
 return aprintf ( ""------------------------%08x%08x"" , Curl_rand ( data ) , Curl_rand ( data ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int tipc_nl_compat_media_set ( struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {
 struct nlattr * prop ;
 struct nlattr * media ;
 struct tipc_link_config * lc ;
 lc = ( struct tipc_link_config * ) TLV_DATA ( msg -> req ) ;
 media = nla_nest_start ( skb , TIPC_NLA_MEDIA ) ;
 if ( ! media ) return - EMSGSIZE ;
 if ( nla_put_string ( skb , TIPC_NLA_MEDIA_NAME , lc -> name ) ) return - EMSGSIZE ;
 prop = nla_nest_start ( skb , TIPC_NLA_MEDIA_PROP ) ;
 if ( ! prop ) return - EMSGSIZE ;
 __tipc_add_link_prop ( skb , msg , lc ) ;
 nla_nest_end ( skb , prop ) ;
 nla_nest_end ( skb , media ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void curl_free ( void * p ) {
 free ( p ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {
 xmlListPtr l ;
 if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for list"" ) ;
 return ( NULL ) ;
 }
 memset ( l , 0 , sizeof ( xmlList ) ) ;
 if ( NULL == ( l -> sentinel = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for sentinel"" ) ;
 xmlFree ( l ) ;
 return ( NULL ) ;
 }
 l -> sentinel -> next = l -> sentinel ;
 l -> sentinel -> prev = l -> sentinel ;
 l -> sentinel -> data = NULL ;
 if ( deallocator != NULL ) l -> linkDeallocator = deallocator ;
 if ( compare != NULL ) l -> linkCompare = compare ;
 else l -> linkCompare = xmlLinkCompare ;
 return l ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void test_date_ts ( ) {
 int rc ;
 myheader ( ""test_date_ts"" ) ;
 rc = mysql_query ( mysql , ""DROP TABLE IF EXISTS test_date"" ) ;
 myquery ( rc ) ;
 rc = mysql_query ( mysql , ""CREATE TABLE test_date(c1 TIMESTAMP, \ c2 TIMESTAMP, \ c3 TIMESTAMP, \ c4 TIMESTAMP)"" ) ;
 myquery ( rc ) ;
 bind_date_conv ( 2 , FALSE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void Type_LUTB2A_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {
 cmsPipelineFree ( ( cmsPipeline * ) Ptr ) ;
 return ;
 cmsUNUSED_PARAMETER ( self ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_tunnelledSignallingMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 756 ""./asn1/h225/h225.cnf"" tp_handle = NULL ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_tunnelledSignallingMessage , T_tunnelledSignallingMessage_sequence ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;
 # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL )",1
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_broken_cluster ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {
 initial_reordering_standalone_cluster ( plan , face , buffer , start , end ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline uint32_t be32_to_cpu ( uint32_t v ) {
 return bswap32 ( v ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , BrowserRemoved ) {
 Browser * extra_browser = CreateBrowser ( profile ( ) ) ;
 ReplaceBlank ( extra_browser ) ;
 int starting_tab_count = extra_browser -> tab_strip_model ( ) -> count ( ) ;
 scoped_ptr < BookmarkBubbleDelegate > delegate ;
 delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;
 BrowserList : : SetLastActive ( extra_browser ) ;
 browser ( ) -> tab_strip_model ( ) -> CloseAllTabs ( ) ;
 content : : RunAllPendingInMessageLoop ( ) ;
 delegate -> OnSignInLinkClicked ( ) ;
 int tab_count = extra_browser -> tab_strip_model ( ) -> count ( ) ;
 EXPECT_EQ ( starting_tab_count + 1 , tab_count ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void virLogSourceUpdate ( virLogSourcePtr source ) {
 virLogLock ( ) ;
 if ( source -> serial < virLogFiltersSerial ) {
 unsigned int priority = virLogDefaultPriority ;
 unsigned int flags = 0 ;
 size_t i ;
 for ( i = 0 ;
 i < virLogNbFilters ;
 i ++ ) {
 if ( strstr ( source -> name , virLogFilters [ i ] -> match ) ) {
 priority = virLogFilters [ i ] -> priority ;
 flags = virLogFilters [ i ] -> flags ;
 break ;
 }
 }
 source -> priority = priority ;
 source -> flags = flags ;
 source -> serial = virLogFiltersSerial ;
 }
 virLogUnlock ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void evsignal_cb ( int fd , short what , void * arg ) {
 static char signals [ 1 ] ;
 # ifdef WIN32 SSIZE_T n ;
 # else ssize_t n ;
 # endif n = recv ( fd , signals , sizeof ( signals ) , 0 ) ;
 if ( n == - 1 ) event_err ( 1 , ""%s: read"" , __func__ ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void mark_object ( struct object * obj , const struct name_path * path , const char * name , void * data ) {
 update_progress ( data ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlLinkPtr xmlListFront ( xmlListPtr l ) {
 if ( l == NULL ) return ( NULL ) ;
 return ( l -> sentinel -> next ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {
 StartHttpServer ( ) ;
 base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vpx_svc_set_keyframe ( SvcContext * svc_ctx ) {
 SvcInternal * const si = get_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || si == NULL ) return ;
 si -> frame_within_gop = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_init_me_luts ( ) {
 int i ;
 for ( i = 0 ;
 i < QINDEX_RANGE ;
 ++ i ) {
 const double q = vp9_convert_qindex_to_q ( i ) ;
 sad_per_bit16lut [ i ] = ( int ) ( 0.0418 * q + 2.4107 ) ;
 sad_per_bit4lut [ i ] = ( int ) ( 0.063 * q + 2.742 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void s_aos_reset ( stream * s ) {
 s -> position = 0 ;
 s -> srptr = s -> srlimit = s -> cbuf - 1 ;
 s -> end_status = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_rsvp_hello ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length _U_ , int rsvp_class _U_ , int type ) {
 switch ( type ) {
 case 1 : case 2 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , tvb_get_guint8 ( tvb , offset + 3 ) , ""%d - HELLO %s object"" , tvb_get_guint8 ( tvb , offset + 3 ) , type == 1 ? ""REQUEST"" : ""ACK"" ) ;
 proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_source_instance , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;
 proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_destination_instance , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;
 proto_item_append_text ( ti , "": %s. Src Instance: 0x%0x. Dest Instance: 0x%0x. "" , type == 1 ? ""REQUEST"" : ""ACK"" , tvb_get_ntohl ( tvb , offset + 4 ) , tvb_get_ntohl ( tvb , offset + 8 ) ) ;
 break ;
 default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , ""%d - UNKNOWN"" , type ) ;
 break ;
 }
 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void ProcessArchiveRestoreOptions ( Archive * AHX ) {
 ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;
 RestoreOptions * ropt = AH -> public . ropt ;
 TocEntry * te ;
 teSection curSection ;
 curSection = SECTION_PRE_DATA ;
 for ( te = AH -> toc -> next ;
 te != AH -> toc ;
 te = te -> next ) {
 if ( AH -> mode != archModeRead ) {
 switch ( te -> section ) {
 case SECTION_NONE : break ;
 case SECTION_PRE_DATA : if ( curSection != SECTION_PRE_DATA ) write_msg ( modulename , ""WARNING: archive items not in correct section order\n"" ) ;
 break ;
 case SECTION_DATA : if ( curSection == SECTION_POST_DATA ) write_msg ( modulename , ""WARNING: archive items not in correct section order\n"" ) ;
 break ;
 case SECTION_POST_DATA : break ;
 default : exit_horribly ( modulename , ""unexpected section code %d\n"" , ( int ) te -> section ) ;
 break ;
 }
 }
 if ( te -> section != SECTION_NONE ) curSection = te -> section ;
 te -> reqs = _tocEntryRequired ( te , curSection , ropt ) ;
 }
 if ( ropt -> strict_names ) StrictNamesCheck ( ropt ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cpu_request_exit ( void * opaque , int irq , int level ) {
 CPUPPCState * env = cpu_single_env ;
 if ( env && level ) {
 cpu_exit ( CPU ( ppc_env_get_cpu ( env ) ) ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l )",1
Detect whether the following code contains vulnerabilities.,"static int libgsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 int i , ret ;
 LibGSMDecodeContext * s = avctx -> priv_data ;
 AVFrame * frame = data ;
 uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 int16_t * samples ;
 if ( buf_size < avctx -> block_align ) {
 av_log ( avctx , AV_LOG_ERROR , ""Packet is too small\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 frame -> nb_samples = avctx -> frame_size ;
 if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 samples = ( int16_t * ) frame -> data [ 0 ] ;
 for ( i = 0 ;
 i < avctx -> frame_size / GSM_FRAME_SIZE ;
 i ++ ) {
 if ( ( ret = gsm_decode ( s -> state , buf , samples ) ) < 0 ) return - 1 ;
 buf += GSM_BLOCK_SIZE ;
 samples += GSM_FRAME_SIZE ;
 }
 * got_frame_ptr = 1 ;
 return avctx -> block_align ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Https ) {
 StartHttpsServer ( false ) ;
 NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( ""/simple.html"" ) , https_test_server_ -> GetURL ( ""/empty.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( FilesystemIterator , key ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( SPL_FILE_DIR_KEY ( intern , SPL_FILE_DIR_KEY_AS_FILENAME ) ) {
 RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;
 }
 else {
 spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;
 RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void duplicate_mode_info_in_sb ( VP9_COMMON * cm , MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {
 const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ;
 const int block_height = num_8x8_blocks_high_lookup [ bsize ] ;
 int i , j ;
 for ( j = 0 ;
 j < block_height ;
 ++ j ) for ( i = 0 ;
 i < block_width ;
 ++ i ) {
 if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] = xd -> mi [ 0 ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static uint32_t pointerTOCEntryCount ( const UDataMemory * pData ) {
 const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;
 return ( uint32_t ) ( ( toc != NULL ) ? ( toc -> count ) : 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONAddPCINetwork ( qemuMonitorPtr mon ATTRIBUTE_UNUSED , const char * nicstr ATTRIBUTE_UNUSED , virDomainDevicePCIAddress * guestAddr ATTRIBUTE_UNUSED ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""pci_add not suppported in JSON mode"" ) ) ;
 return - 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void sbr_turnoff ( SpectralBandReplication * sbr ) {
 sbr -> start = 0 ;
 sbr -> kx [ 1 ] = 32 ;
 sbr -> m [ 1 ] = 0 ;
 sbr -> data [ 0 ] . e_a [ 1 ] = sbr -> data [ 1 ] . e_a [ 1 ] = - 1 ;
 memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void evhttp_send_reply_end ( struct evhttp_request * req ) {
 struct evhttp_connection * evcon = req -> evcon ;
 if ( req -> chunked ) {
 evbuffer_add ( req -> evcon -> output_buffer , ""0\r\n\r\n"" , 5 ) ;
 evhttp_write_buffer ( req -> evcon , evhttp_send_done , NULL ) ;
 req -> chunked = 0 ;
 }
 else if ( ! event_pending ( & evcon -> ev , EV_WRITE | EV_TIMEOUT , NULL ) ) {
 evhttp_send_done ( evcon , NULL ) ;
 }
 else {
 evcon -> cb = evhttp_send_done ;
 evcon -> cb_arg = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void decode_flush ( AVCodecContext * avctx ) {
 KgvContext * const c = avctx -> priv_data ;
 if ( c -> prev . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> prev ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF32Reset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> mode = 0 ;
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {
 struct bitmap * base = data ;
 bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ;
 mark_as_seen ( object ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void copy ( LZOContext * c , int cnt ) {
 register const uint8_t * src = c -> in ;
 register uint8_t * dst = c -> out ;
 if ( cnt > c -> in_end - src ) {
 cnt = FFMAX ( c -> in_end - src , 0 ) ;
 c -> error |= AV_LZO_INPUT_DEPLETED ;
 }
 if ( cnt > c -> out_end - dst ) {
 cnt = FFMAX ( c -> out_end - dst , 0 ) ;
 c -> error |= AV_LZO_OUTPUT_FULL ;
 }
 # if defined ( INBUF_PADDED ) && defined ( OUTBUF_PADDED ) AV_COPY32U ( dst , src ) ;
 src += 4 ;
 dst += 4 ;
 cnt -= 4 ;
 if ( cnt > 0 ) # endif memcpy ( dst , src , cnt ) ;
 c -> in = src + cnt ;
 c -> out = dst + cnt ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dissect_llmnr_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {
 col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""LLMNR"" ) ;
 dissect_dns_common ( tvb , pinfo , tree , FALSE , FALSE , TRUE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void ipv6_addr_prefix ( struct in6_addr * pfx , const struct in6_addr * addr , int plen ) {
 int o = plen >> 3 , b = plen & 0x7 ;
 memset ( pfx -> s6_addr , 0 , sizeof ( pfx -> s6_addr ) ) ;
 memcpy ( pfx -> s6_addr , addr , o ) ;
 if ( b != 0 ) pfx -> s6_addr [ o ] = addr -> s6_addr [ o ] & ( 0xff00 >> b ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Information_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 399 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Information_UUIE , Information_UUIE_sequence ) ;
 # line 403 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_INFORMATION ;
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int mbfl_strwidth ( mbfl_string * string ) {
 int len , n ;
 unsigned char * p ;
 mbfl_convert_filter * filter ;
 len = 0 ;
 if ( string -> len > 0 && string -> val != NULL ) {
 filter = mbfl_convert_filter_new ( string -> no_encoding , mbfl_no_encoding_wchar , filter_count_width , 0 , & len ) ;
 if ( filter == NULL ) {
 mbfl_convert_filter_delete ( filter ) ;
 return - 1 ;
 }
 p = string -> val ;
 n = string -> len ;
 while ( n > 0 ) {
 ( * filter -> filter_function ) ( * p ++ , filter ) ;
 n -- ;
 }
 mbfl_convert_filter_flush ( filter ) ;
 mbfl_convert_filter_delete ( filter ) ;
 }
 return len ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , ClosedWhileHidden_Https ) {
 StartHttpsServer ( false ) ;
 base : : TimeDelta upper_bound = NavigateInForegroundAndCloseInBackgroundWithTiming ( https_test_server_ -> GetURL ( ""/simple.html"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;
 int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;
 EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;
 EXPECT_LT ( 0 , bucket_min ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line24_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t r , g , b ;
 w = width ;
 do {
 r = s [ 0 ] ;
 g = s [ 1 ] ;
 b = s [ 2 ] ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 3 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void dtls1_stop_timer ( SSL * s ) {
 memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;
 memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;
 s -> d1 -> timeout_duration = 1 ;
 BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;
 dtls1_clear_record_buffer ( s ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void jpc_pi_destroy ( jpc_pi_t * pi ) {
 jpc_picomp_t * picomp ;
 int compno ;
 if ( pi -> picomps ) {
 for ( compno = 0 , picomp = pi -> picomps ;
 compno < pi -> numcomps ;
 ++ compno , ++ picomp ) {
 jpc_picomp_destroy ( picomp ) ;
 }
 jas_free ( pi -> picomps ) ;
 }
 if ( pi -> pchglist ) {
 jpc_pchglist_destroy ( pi -> pchglist ) ;
 }
 jas_free ( pi ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int build_def_list ( Picture * def , Picture * * in , int len , int is_long , int sel ) {
 int i [ 2 ] = {
 0 }
 ;
 int index = 0 ;
 while ( i [ 0 ] < len || i [ 1 ] < len ) {
 while ( i [ 0 ] < len && ! ( in [ i [ 0 ] ] && ( in [ i [ 0 ] ] -> f . reference & sel ) ) ) i [ 0 ] ++ ;
 while ( i [ 1 ] < len && ! ( in [ i [ 1 ] ] && ( in [ i [ 1 ] ] -> f . reference & ( sel ^ 3 ) ) ) ) i [ 1 ] ++ ;
 if ( i [ 0 ] < len ) {
 in [ i [ 0 ] ] -> pic_id = is_long ? i [ 0 ] : in [ i [ 0 ] ] -> frame_num ;
 split_field_copy ( & def [ index ++ ] , in [ i [ 0 ] ++ ] , sel , 1 ) ;
 }
 if ( i [ 1 ] < len ) {
 in [ i [ 1 ] ] -> pic_id = is_long ? i [ 1 ] : in [ i [ 1 ] ] -> frame_num ;
 split_field_copy ( & def [ index ++ ] , in [ i [ 1 ] ++ ] , sel ^ 3 , 0 ) ;
 }
 }
 return index ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , MAYBE_AbortClose ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 GURL url ( embedded_test_server ( ) -> GetURL ( ""/title1.html"" ) ) ;
 NavigateParams params ( browser ( ) , url , ui : : PAGE_TRANSITION_LINK ) ;
 content : : TestNavigationManager manager ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , url ) ;
 Navigate ( & params ) ;
 EXPECT_TRUE ( manager . WaitForRequestStart ( ) ) ;
 browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> Close ( ) ;
 manager . WaitForNavigationFinished ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHistogramAbortCloseBeforeCommit , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void compress_job_on_error ( AutoarCompressor * compressor , GError * error , gpointer user_data ) {
 CompressJob * compress_job = user_data ;
 char * status ;
 if ( compress_job -> total_files == 1 ) {
 status = f ( _ ( ""Error compressing “%B” into “%B”"" ) , G_FILE ( compress_job -> source_files -> data ) , compress_job -> output_file ) ;
 }
 else {
 status = f ( ngettext ( ""Error compressing %'d file into “%B”"" , ""Error compressing %'d files into “%B”"" , compress_job -> total_files ) , compress_job -> total_files , compress_job -> output_file ) ;
 }
 nautilus_progress_info_take_status ( compress_job -> common . progress , status ) ;
 run_error ( ( CommonJob * ) compress_job , g_strdup ( _ ( ""There was an error while compressing files."" ) ) , g_strdup ( error -> message ) , NULL , FALSE , CANCEL , NULL ) ;
 abort_job ( ( CommonJob * ) compress_job ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"byte * _gcry_mpi_get_secure_buffer ( gcry_mpi_t a , unsigned * nbytes , int * sign ) {
 return do_get_buffer ( a , nbytes , sign , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_broken_cluster ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {
 initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void parseArrayComplex ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName , const char * szTypeName , fctComplexTypeParser pParserFunction , const gint idx ) {
 proto_item * ti ;
 proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , idx , & ti , ""%s: Array of %s"" , szFieldName , szTypeName ) ;
 int i ;
 gint32 iLen ;
 iLen = tvb_get_letohl ( tvb , * pOffset ) ;
 proto_tree_add_item ( subtree , hf_opcua_ArraySize , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;
 if ( iLen > MAX_ARRAY_LEN ) {
 proto_tree_add_expert_format ( subtree , pinfo , & ei_array_length , tvb , * pOffset , 4 , ""Array length %d too large to process"" , iLen ) ;
 return ;
 }
 * pOffset += 4 ;
 for ( i = 0 ;
 i < iLen ;
 i ++ ) {
 char szNum [ 20 ] ;
 g_snprintf ( szNum , 20 , ""[%i]"" , i ) ;
 ( * pParserFunction ) ( subtree , tvb , pinfo , pOffset , szNum ) ;
 }
 proto_item_set_end ( ti , tvb , * pOffset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMainContextDuringIncognitoTeardown ) {
 Browser * incognito_browser = OpenURLOffTheRecord ( browser ( ) -> profile ( ) , GURL ( ""about:blank"" ) ) ;
 RunURLFetcherActiveDuringIncognitoTeardownTest ( incognito_browser , incognito_browser -> profile ( ) -> GetRequestContext ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void language_destroy ( hb_language_t * l ) {
 free ( l ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static PyObject * basestring_new ( PyTypeObject * type , PyObject * args , PyObject * kwds ) {
 PyErr_SetString ( PyExc_TypeError , ""The basestring type cannot be instantiated"" ) ;
 return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void e1000e_set_itr ( E1000ECore * core , int index , uint32_t val ) {
 uint32_t interval = val & 0xffff ;
 trace_e1000e_irq_itr_set ( val ) ;
 core -> itr_guest_value = interval ;
 core -> mac [ index ] = MAX ( interval , E1000E_MIN_XITR ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline uint8_t vga_read_byte ( VGACommonState * vga , uint32_t addr ) {
 return vga -> vram_ptr [ addr & vga -> vbe_size_mask ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {
 char * newp ;
 char * dictp ;
 char * ptr ;
 int len ;
 char ch ;
 int olen = 0 ;
 newp = curl_easy_unescape ( data , inputbuff , 0 , & len ) ;
 if ( ! newp ) return NULL ;
 dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;
 if ( dictp ) {
 for ( ptr = newp ;
 ( ch = * ptr ) != 0 ;
 ptr ++ ) {
 if ( ( ch <= 32 ) || ( ch == 127 ) || ( ch == '\'' ) || ( ch == '\""' ) || ( ch == '\\' ) ) {
 dictp [ olen ++ ] = '\\' ;
 }
 dictp [ olen ++ ] = ch ;
 }
 dictp [ olen ] = 0 ;
 }
 free ( newp ) ;
 return dictp ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void read_sbr_extension ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb , int bs_extension_id , int * num_bits_left ) {
 switch ( bs_extension_id ) {
 case EXTENSION_ID_PS : if ( ! ac -> oc [ 1 ] . m4ac . ps ) {
 av_log ( ac -> avctx , AV_LOG_ERROR , ""Parametric Stereo signaled to be not-present but was found in the bitstream.\n"" ) ;
 skip_bits_long ( gb , * num_bits_left ) ;
 * num_bits_left = 0 ;
 }
 else {
 # if 1 * num_bits_left -= ff_ps_read_data ( ac -> avctx , gb , & sbr -> ps , * num_bits_left ) ;
 ac -> avctx -> profile = FF_PROFILE_AAC_HE_V2 ;
 # else avpriv_report_missing_feature ( ac -> avctx , ""Parametric Stereo"" ) ;
 skip_bits_long ( gb , * num_bits_left ) ;
 * num_bits_left = 0 ;
 # endif }
 break ;
 default : if ( bs_extension_id || * num_bits_left > 16 || show_bits ( gb , * num_bits_left ) ) avpriv_request_sample ( ac -> avctx , ""Reserved SBR extensions"" ) ;
 skip_bits_long ( gb , * num_bits_left ) ;
 * num_bits_left = 0 ;
 break ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void jbig2_set_bits ( byte * line , int x0 , int x1 ) {
 int a0 , a1 , b0 , b1 , a ;
 a0 = x0 >> 3 ;
 a1 = x1 >> 3 ;
 b0 = x0 & 7 ;
 b1 = x1 & 7 ;
 if ( a0 == a1 ) {
 line [ a0 ] |= lm [ b0 ] & rm [ b1 ] ;
 }
 else {
 line [ a0 ] |= lm [ b0 ] ;
 for ( a = a0 + 1 ;
 a < a1 ;
 a ++ ) line [ a ] = 0xFF ;
 if ( b1 ) line [ a1 ] |= rm [ b1 ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static StkId adjust_varargs ( lua_State * L , Proto * p , int actual ) {
 int i ;
 int nfixargs = p -> numparams ;
 Table * htab = NULL ;
 StkId base , fixed ;
 for ( ;
 actual < nfixargs ;
 ++ actual ) setnilvalue ( L -> top ++ ) ;
 # if defined ( LUA_COMPAT_VARARG ) if ( p -> is_vararg & VARARG_NEEDSARG ) {
 int nvar = actual - nfixargs ;
 lua_assert ( p -> is_vararg & VARARG_HASARG ) ;
 luaC_checkGC ( L ) ;
 luaD_checkstack ( L , p -> maxstacksize ) ;
 htab = luaH_new ( L , nvar , 1 ) ;
 for ( i = 0 ;
 i < nvar ;
 i ++ ) setobj2n ( L , luaH_setnum ( L , htab , i + 1 ) , L -> top - nvar + i ) ;
 setnvalue ( luaH_setstr ( L , htab , luaS_newliteral ( L , ""n"" ) ) , cast_num ( nvar ) ) ;
 }
 # endif fixed = L -> top - actual ;
 base = L -> top ;
 for ( i = 0 ;
 i < nfixargs ;
 i ++ ) {
 setobjs2s ( L , L -> top ++ , fixed + i ) ;
 setnilvalue ( fixed + i ) ;
 }
 if ( htab ) {
 sethvalue ( L , L -> top ++ , htab ) ;
 lua_assert ( iswhite ( obj2gco ( htab ) ) ) ;
 }
 return base ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * checkPassword ( PyObject * self , PyObject * args ) {
 const char * user = NULL ;
 const char * pswd = NULL ;
 const char * service = NULL ;
 const char * default_realm = NULL ;
 int result = 0 ;
 if ( ! PyArg_ParseTuple ( args , ""ssss"" , & user , & pswd , & service , & default_realm ) ) return NULL ;
 result = authenticate_user_krb5pwd ( user , pswd , service , default_realm ) ;
 if ( result ) return Py_INCREF ( Py_True ) , Py_True ;
 else return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void read_index ( AVIOContext * pb , AVStream * st ) {
 uint64_t timestamp = 0 ;
 int i ;
 for ( i = 0 ;
 i < st -> nb_frames ;
 i ++ ) {
 uint32_t pos = avio_rb32 ( pb ) ;
 uint32_t size = avio_rb32 ( pb ) ;
 avio_skip ( pb , 8 ) ;
 av_add_index_entry ( st , pos , timestamp , size , 0 , AVINDEX_KEYFRAME ) ;
 if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) {
 timestamp += size / ( st -> codecpar -> channels * 2 ) ;
 }
 else {
 timestamp ++ ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void free_picture ( AVCodecContext * avctx , Picture * pic ) {
 int i ;
 for ( i = 0 ;
 i < 2 ;
 i ++ ) {
 av_freep ( & pic -> motion_val_base [ i ] ) ;
 av_freep ( & pic -> f . ref_index [ i ] ) ;
 }
 av_freep ( & pic -> mb_type_base ) ;
 if ( pic -> f . data [ 0 ] ) avctx -> release_buffer ( avctx , & pic -> f ) ;
 av_freep ( & pic ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _HZ_WriteSub ( UConverterFromUnicodeArgs * args , int32_t offsetIndex , UErrorCode * err ) {
 UConverter * cnv = args -> converter ;
 UConverterDataHZ * convData = ( UConverterDataHZ * ) cnv -> extraInfo ;
 char * p ;
 char buffer [ 4 ] ;
 p = buffer ;
 if ( convData -> isTargetUCharDBCS ) {
 * p ++ = UCNV_TILDE ;
 * p ++ = UCNV_CLOSE_BRACE ;
 convData -> isTargetUCharDBCS = FALSE ;
 }
 * p ++ = ( char ) cnv -> subChars [ 0 ] ;
 ucnv_cbFromUWriteBytes ( args , buffer , ( int32_t ) ( p - buffer ) , offsetIndex , err ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {
 OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;
 }
 LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {
 OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;
 }
 LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l ) ;
 __exctype_l ( ispunct_l )",1
Detect whether the following code contains vulnerabilities.,"static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {
 MACROBLOCK * const x = ( MACROBLOCK * ) arg ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 struct macroblock_plane * const p = & x -> plane [ plane ] ;
 struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;
 int i , j ;
 uint8_t * dst ;
 txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;
 dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ;
 vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;
 if ( p -> eobs [ block ] > 0 ) x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {
 remote_error rerr ;
 int ret ;
 VIR_DEBUG ( ""stream=%p proc=%d serial=%d"" , stream , msg -> hdr . proc , msg -> hdr . serial ) ;
 memset ( & rerr , 0 , sizeof rerr ) ;
 stream -> closed = 1 ;
 virStreamEventRemoveCallback ( stream -> st ) ;
 ret = virStreamFinish ( stream -> st ) ;
 if ( ret < 0 ) {
 remoteDispatchConnError ( & rerr , client -> conn ) ;
 return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;
 }
 else {
 if ( remoteSendStreamData ( client , stream , NULL , 0 ) < 0 ) return - 1 ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct ) ;
 __exctype ( isspace ) ;
 __exctype ( isupper ) ;
 __exctype ( isxdigit ) ;
 extern int tolower ( int __c ) __THROW ;
 extern int toupper ( int __c ) __THROW ;
 # ifdef __USE_ISOC99 __exctype ( isblank ) ;
 # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;
 # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;
 extern int toascii ( int __c ) __THROW ;
 __exctype ( _toupper )",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , MultipleUploads ) {
 StartHttpsServer ( false ) ;
 NavigateInForegroundAndCloseWithTiming ( https_test_server_ -> GetURL ( ""/"" ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 0 ) ;
 FakeUserMetricsUpload ( ) ;
 FakeUserMetricsUpload ( ) ;
 FakeUserMetricsUpload ( ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {
 if ( _hb_glyph_info_ligated ( & info ) ) return false ;
 return ! ! ( FLAG ( info . indic_category ( ) ) & flags ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _UTF16Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 if ( UCNV_GET_VERSION ( cnv ) <= 2 ) {
 if ( UCNV_GET_VERSION ( cnv ) == 2 && ! pArgs -> onlyTestIsLoadable ) {
 cnv -> sharedData = ( UConverterSharedData * ) & _UTF16v2Data ;
 uprv_memcpy ( cnv -> subChars , _UTF16v2Data . staticData -> subChar , UCNV_MAX_SUBCHAR_LEN ) ;
 }
 _UTF16Reset ( cnv , UCNV_RESET_BOTH ) ;
 }
 else {
 * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void prplcb_close_request ( PurpleRequestType type , void * data ) {
 struct prplcb_request_action_data * pqad ;
 struct request_input_data * ri ;
 struct purple_data * pd ;
 if ( ! data ) {
 return ;
 }
 switch ( type ) {
 case PURPLE_REQUEST_ACTION : pqad = data ;
 if ( pqad -> bee_data ) {
 query_del ( local_bee -> ui_data , pqad -> bee_data ) ;
 }
 g_free ( pqad ) ;
 break ;
 case PURPLE_REQUEST_INPUT : ri = data ;
 pd = ri -> ic -> proto_data ;
 imcb_remove_buddy ( ri -> ic , ri -> buddy , NULL ) ;
 g_free ( ri -> buddy ) ;
 g_hash_table_remove ( pd -> input_requests , GUINT_TO_POINTER ( ri -> id ) ) ;
 break ;
 default : g_free ( data ) ;
 break ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_OCTET_STRING_SIZE_6 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 6 , 6 , FALSE , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int very_broken_op ( int a , int b ) {
 int x = a * b + 200 ;
 int size ;
 const uint8_t * rtab ;
 if ( x % 400 || b % 5 ) return x / 400 ;
 x /= 400 ;
 size = tabs [ b / 5 ] . size ;
 rtab = tabs [ b / 5 ] . tab ;
 return x - rtab [ size * av_log2 ( 2 * ( x - 1 ) / size ) + ( x - 1 ) % size ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void data_destroy_arabic ( void * data ) {
 arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) data ;
 arabic_fallback_plan_destroy ( arabic_plan -> fallback_plan ) ;
 free ( data ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MaintenanceLoopAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MaintenanceLoopAck , MaintenanceLoopAck_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gchar get_priority ( const guint8 * priority ) {
 static gchar priorities [ ] = ""??VDIWEFS"" ;
 if ( * priority >= ( guint8 ) sizeof ( priorities ) ) return '?' ;
 return priorities [ ( int ) * priority ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline__ int TLV_SET ( void * tlv , __u16 type , void * data , __u16 len ) {
 struct tlv_desc * tlv_ptr ;
 int tlv_len ;
 tlv_len = TLV_LENGTH ( len ) ;
 tlv_ptr = ( struct tlv_desc * ) tlv ;
 tlv_ptr -> tlv_type = htons ( type ) ;
 tlv_ptr -> tlv_len = htons ( tlv_len ) ;
 if ( len && data ) {
 memcpy ( TLV_DATA ( tlv_ptr ) , data , len ) ;
 memset ( TLV_DATA ( tlv_ptr ) + len , 0 , TLV_SPACE ( len ) - tlv_len ) ;
 }
 return TLV_SPACE ( len ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_update_zbin_extra ( VP9_COMP * cpi , MACROBLOCK * x ) {
 const int qindex = x -> q_index ;
 const int y_zbin_extra = ( cpi -> common . y_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;
 const int uv_zbin_extra = ( cpi -> common . uv_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;
 x -> plane [ 0 ] . zbin_extra = ( int16_t ) y_zbin_extra ;
 x -> plane [ 1 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;
 x -> plane [ 2 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;
 }",0
Detect whether the following code contains vulnerabilities.,"static MB_MODE_INFO * set_offsets ( VP9_COMMON * const cm , MACROBLOCKD * const xd , const TileInfo * const tile , BLOCK_SIZE bsize , int mi_row , int mi_col ) {
 const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;
 const int bh = num_8x8_blocks_high_lookup [ bsize ] ;
 const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ;
 const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ;
 const int offset = mi_row * cm -> mi_stride + mi_col ;
 int x , y ;
 xd -> mi = cm -> mi_grid_visible + offset ;
 xd -> mi [ 0 ] = & cm -> mi [ offset ] ;
 xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;
 for ( y = 0 ;
 y < y_mis ;
 ++ y ) for ( x = ! y ;
 x < x_mis ;
 ++ x ) xd -> mi [ y * cm -> mi_stride + x ] = xd -> mi [ 0 ] ;
 set_skip_context ( xd , mi_row , mi_col ) ;
 set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ;
 vp9_setup_dst_planes ( xd -> plane , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;
 return & xd -> mi [ 0 ] -> mbmi ;
 }",1
Detect whether the following code contains vulnerabilities.,"int Curl_FormInit ( struct Form * form , struct FormData * formdata ) {
 if ( ! formdata ) return 1 ;
 form -> data = formdata ;
 form -> sent = 0 ;
 form -> fp = NULL ;
 form -> fread_func = ZERO_NULL ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void s390_virtio_device_update_status ( VirtIOS390Device * dev ) {
 VirtIODevice * vdev = dev -> vdev ;
 uint32_t features ;
 vdev -> status = ldub_phys ( dev -> dev_offs + VIRTIO_DEV_OFFS_STATUS ) ;
 features = ldl_phys ( dev -> feat_offs ) ;
 if ( vdev -> set_features ) {
 vdev -> set_features ( vdev , features ) ;
 }
 vdev -> guest_features = features ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void create_new_objects ( void ) {
 int dbnum ;
 prep_status ( ""Restoring database schemas in the new cluster\n"" ) ;
 for ( dbnum = 0 ;
 dbnum < old_cluster . dbarr . ndbs ;
 dbnum ++ ) {
 char sql_file_name [ MAXPGPATH ] , log_file_name [ MAXPGPATH ] ;
 DbInfo * old_db = & old_cluster . dbarr . dbs [ dbnum ] ;
 pg_log ( PG_STATUS , ""%s"" , old_db -> db_name ) ;
 snprintf ( sql_file_name , sizeof ( sql_file_name ) , DB_DUMP_FILE_MASK , old_db -> db_oid ) ;
 snprintf ( log_file_name , sizeof ( log_file_name ) , DB_DUMP_LOG_FILE_MASK , old_db -> db_oid ) ;
 parallel_exec_prog ( log_file_name , NULL , ""\""%s/pg_restore\"" %s --exit-on-error --verbose --dbname \""%s\"" \""%s\"""" , new_cluster . bindir , cluster_conn_opts ( & new_cluster ) , old_db -> db_name , sql_file_name ) ;
 }
 while ( reap_child ( true ) == true ) ;
 end_progress_output ( ) ;
 check_ok ( ) ;
 if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 903 ) set_frozenxids ( true ) ;
 get_db_and_rel_infos ( & new_cluster ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * memdup ( const char * src , size_t buffer_length ) {
 size_t length ;
 bool add = FALSE ;
 char * buffer ;
 if ( buffer_length ) length = buffer_length ;
 else if ( src ) {
 length = strlen ( src ) ;
 add = TRUE ;
 }
 else return strdup ( """" ) ;
 buffer = malloc ( length + add ) ;
 if ( ! buffer ) return NULL ;
 memcpy ( buffer , src , length ) ;
 if ( add ) buffer [ length ] = '\0' ;
 return buffer ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int tokenexec_continue ( i_ctx_t * i_ctx_p , scanner_state * pstate , bool save ) {
 os_ptr op ;
 int code ;
 pop ( 1 ) ;
 again : check_estack ( 1 ) ;
 code = gs_scan_token ( i_ctx_p , ( ref * ) ( esp + 1 ) , pstate ) ;
 op = osp ;
 switch ( code ) {
 case 0 : if ( r_is_proc ( esp + 1 ) ) {
 push ( 1 ) ;
 ref_assign ( op , esp + 1 ) ;
 code = 0 ;
 break ;
 }
 case scan_BOS : ++ esp ;
 code = o_push_estack ;
 break ;
 case scan_EOF : code = 0 ;
 break ;
 case scan_Refill : code = gs_scan_handle_refill ( i_ctx_p , pstate , save , ztokenexec_continue ) ;
 switch ( code ) {
 case 0 : goto again ;
 case o_push_estack : return code ;
 }
 break ;
 case scan_Comment : case scan_DSC_Comment : return ztoken_handle_comment ( i_ctx_p , pstate , esp + 1 , code , save , true , ztokenexec_continue ) ;
 default : gs_scanner_error_object ( i_ctx_p , pstate , & i_ctx_p -> error_object ) ;
 break ;
 }
 if ( ! save ) {
 gs_free_object ( ( ( scanner_state_dynamic * ) pstate ) -> mem , pstate , ""token_continue"" ) ;
 }
 return code ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void output_stats ( FIRSTPASS_STATS * stats , struct vpx_codec_pkt_list * pktlist ) {
 struct vpx_codec_cx_pkt pkt ;
 pkt . kind = VPX_CODEC_STATS_PKT ;
 pkt . data . twopass_stats . buf = stats ;
 pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ;
 vpx_codec_pkt_list_add ( pktlist , & pkt ) ;
 # if OUTPUT_FPF {
 FILE * fpfile ;
 fpfile = fopen ( ""firstpass.stt"" , ""a"" ) ;
 fprintf ( fpfile , ""%12.0f %12.0f %12.0f %12.0f %12.4f %12.4f"" ""%12.4f %12.4f %12.4f %12.4f %12.4f %12.4f %12.4f"" ""%12.0f %12.0f %12.4f %12.0f %12.0f %12.4f\n"" , stats -> frame , stats -> intra_error , stats -> coded_error , stats -> sr_coded_error , stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref , stats -> pcnt_neutral , stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ;
 fclose ( fpfile ) ;
 }
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void slavio_misc_init ( hwaddr base , hwaddr aux1_base , hwaddr aux2_base , qemu_irq irq , qemu_irq fdc_tc ) {
 DeviceState * dev ;
 SysBusDevice * s ;
 dev = qdev_create ( NULL , ""slavio_misc"" ) ;
 qdev_init_nofail ( dev ) ;
 s = SYS_BUS_DEVICE ( dev ) ;
 if ( base ) {
 sysbus_mmio_map ( s , 0 , base + MISC_CFG ) ;
 sysbus_mmio_map ( s , 1 , base + MISC_DIAG ) ;
 sysbus_mmio_map ( s , 2 , base + MISC_MDM ) ;
 sysbus_mmio_map ( s , 3 , base + MISC_LEDS ) ;
 sysbus_mmio_map ( s , 4 , base + MISC_SYS ) ;
 }
 if ( aux1_base ) {
 sysbus_mmio_map ( s , 5 , aux1_base ) ;
 }
 if ( aux2_base ) {
 sysbus_mmio_map ( s , 6 , aux2_base ) ;
 }
 sysbus_connect_irq ( s , 0 , irq ) ;
 sysbus_connect_irq ( s , 1 , fdc_tc ) ;
 slavio_system_powerdown = qdev_get_gpio_in ( dev , 0 ) ;
 qemu_register_powerdown_notifier ( & slavio_system_powerdown_notifier ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_decoder_remove ( VP9Decoder * pbi ) {
 VP9_COMMON * const cm = & pbi -> common ;
 int i ;
 vp9_get_worker_interface ( ) -> end ( & pbi -> lf_worker ) ;
 vpx_free ( pbi -> lf_worker . data1 ) ;
 vpx_free ( pbi -> tile_data ) ;
 for ( i = 0 ;
 i < pbi -> num_tile_workers ;
 ++ i ) {
 VP9Worker * const worker = & pbi -> tile_workers [ i ] ;
 vp9_get_worker_interface ( ) -> end ( worker ) ;
 vpx_free ( worker -> data1 ) ;
 vpx_free ( worker -> data2 ) ;
 }
 vpx_free ( pbi -> tile_workers ) ;
 if ( pbi -> num_tile_workers > 0 ) {
 vp9_loop_filter_dealloc ( & pbi -> lf_row_sync ) ;
 }
 vp9_remove_common ( cm ) ;
 vpx_free ( pbi ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int proto_get_id_by_filter_name ( const gchar * filter_name ) {
 const protocol_t * protocol = NULL ;
 DISSECTOR_ASSERT_HINT ( filter_name , ""No filter name present"" ) ;
 protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_filter_names , filter_name ) ;
 if ( protocol == NULL ) return - 1 ;
 return protocol -> proto_id ;
 }",0
Detect whether the following code contains vulnerabilities.,"bool message_search_more ( struct message_search_context * ctx , struct message_block * raw_block ) {
 struct message_block decoded_block ;
 return message_search_more_get_decoded ( ctx , raw_block , & decoded_block ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_pcp_message_pmns_child ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {
 proto_item * pcp_pmns_child_item ;
 proto_tree * pcp_pmns_child_tree ;
 guint32 name_len ;
 pcp_pmns_child_item = proto_tree_add_item ( tree , hf_pcp_pmns_child , tvb , offset , - 1 , ENC_NA ) ;
 pcp_pmns_child_tree = proto_item_add_subtree ( pcp_pmns_child_item , ett_pcp ) ;
 col_append_fstr ( pinfo -> cinfo , COL_INFO , ""[%s]"" , val_to_str ( PCP_PDU_PMNS_CHILD , packettypenames , ""Unknown Type:0x%02x"" ) ) ;
 proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_subtype , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;
 offset += 4 ;
 proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_namelen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;
 name_len = tvb_get_ntohl ( tvb , offset ) ;
 offset += 4 ;
 proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_name , tvb , offset , name_len , ENC_ASCII | ENC_NA ) ;
 offset += 4 ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int check_slice_end ( RV34DecContext * r , MpegEncContext * s ) {
 int bits ;
 if ( s -> mb_y >= s -> mb_height ) return 1 ;
 if ( ! s -> mb_num_left ) return 1 ;
 if ( r -> s . mb_skip_run > 1 ) return 0 ;
 bits = get_bits_left ( & s -> gb ) ;
 if ( bits < 0 || ( bits < 8 && ! show_bits ( & s -> gb , bits ) ) ) return 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorTextRemoveHostNetwork ( qemuMonitorPtr mon , int vlan , const char * netname ) {
 char * cmd ;
 char * reply = NULL ;
 int ret = - 1 ;
 if ( virAsprintf ( & cmd , ""host_net_remove %d %s"" , vlan , netname ) < 0 ) {
 virReportOOMError ( ) ;
 return - 1 ;
 }
 if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {
 qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( ""failed to remove host network in qemu with '%s'"" ) , cmd ) ;
 goto cleanup ;
 }
 ret = 0 ;
 cleanup : VIR_FREE ( cmd ) ;
 VIR_FREE ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int gx_ttfReader__default_get_metrics ( const ttfReader * ttf , uint glyph_index , bool bVertical , short * sideBearing , unsigned short * nAdvance ) {
 gx_ttfReader * self = ( gx_ttfReader * ) ttf ;
 float sbw [ 4 ] ;
 int sbw_offset = bVertical ;
 int code ;
 int factor = self -> pfont -> data . unitsPerEm ;
 code = self -> pfont -> data . get_metrics ( self -> pfont , glyph_index , bVertical , sbw ) ;
 if ( code < 0 ) return code ;
 * sideBearing = ( short ) floor ( sbw [ 0 + sbw_offset ] * factor + 0.5 ) ;
 * nAdvance = ( short ) floor ( sbw [ 2 + sbw_offset ] * factor + 0.5 ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void simple_read_cb ( int fd , short event , void * arg ) {
 char buf [ 256 ] ;
 int len ;
 if ( arg == NULL ) return ;
 len = read ( fd , buf , sizeof ( buf ) ) ;
 if ( len ) {
 if ( ! called ) {
 if ( event_add ( arg , NULL ) == - 1 ) exit ( 1 ) ;
 }
 }
 else if ( called == 1 ) test_ok = 1 ;
 called ++ ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dump_backtrace ( void ) {
 fputs ( ""Backtrace not available.\n"" , stderr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , RemovingHandlerMeansItCanBeAddedAgain ) {
 registry ( ) -> OnAcceptRegisterProtocolHandler ( test_protocol_handler ( ) ) ;
 ASSERT_TRUE ( registry ( ) -> CanSchemeBeOverridden ( ""test"" ) ) ;
 registry ( ) -> RemoveHandler ( test_protocol_handler ( ) ) ;
 ASSERT_TRUE ( registry ( ) -> CanSchemeBeOverridden ( ""test"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void event_process_active ( struct event_base * base ) {
 struct event * ev ;
 struct event_list * activeq = NULL ;
 int i ;
 short ncalls ;
 for ( i = 0 ;
 i < base -> nactivequeues ;
 ++ i ) {
 if ( TAILQ_FIRST ( base -> activequeues [ i ] ) != NULL ) {
 activeq = base -> activequeues [ i ] ;
 break ;
 }
 }
 assert ( activeq != NULL ) ;
 for ( ev = TAILQ_FIRST ( activeq ) ;
 ev ;
 ev = TAILQ_FIRST ( activeq ) ) {
 if ( ev -> ev_events & EV_PERSIST ) event_queue_remove ( base , ev , EVLIST_ACTIVE ) ;
 else event_del ( ev ) ;
 ncalls = ev -> ev_ncalls ;
 ev -> ev_pncalls = & ncalls ;
 while ( ncalls ) {
 ncalls -- ;
 ev -> ev_ncalls = ncalls ;
 ( * ev -> ev_callback ) ( ( int ) ev -> ev_fd , ev -> ev_res , ev -> ev_arg ) ;
 if ( base -> event_break ) return ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) {
 dst -> bs_freq_res [ 0 ] = dst -> bs_freq_res [ dst -> bs_num_env ] ;
 dst -> t_env_num_env_old = dst -> t_env [ dst -> bs_num_env ] ;
 dst -> e_a [ 0 ] = - ( dst -> e_a [ 1 ] != dst -> bs_num_env ) ;
 memcpy ( dst -> bs_freq_res + 1 , src -> bs_freq_res + 1 , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ;
 memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ;
 memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ;
 dst -> bs_num_env = src -> bs_num_env ;
 dst -> bs_amp_res = src -> bs_amp_res ;
 dst -> bs_num_noise = src -> bs_num_noise ;
 dst -> bs_frame_class = src -> bs_frame_class ;
 dst -> e_a [ 1 ] = src -> e_a [ 1 ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"void jpc_enc_tile_destroy ( jpc_enc_tile_t * tile ) {
 jpc_enc_tcmpt_t * tcmpt ;
 uint_fast16_t cmptno ;
 if ( tile -> tcmpts ) {
 for ( cmptno = 0 , tcmpt = tile -> tcmpts ;
 cmptno < tile -> numtcmpts ;
 ++ cmptno , ++ tcmpt ) {
 tcmpt_destroy ( tcmpt ) ;
 }
 jas_free ( tile -> tcmpts ) ;
 }
 if ( tile -> lyrsizes ) {
 jas_free ( tile -> lyrsizes ) ;
 }
 if ( tile -> pi ) {
 jpc_pi_destroy ( tile -> pi ) ;
 }
 jas_free ( tile ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * i_alloc_struct_array_immovable ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {
 gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;
 obj_header_t * obj ;
 ulong lsize ;
 # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;
 # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;
 if ( alloc_array_check_size ( num_elements , pstype -> ssize , & lsize ) == false ) return NULL ;
 obj = alloc_obj ( imem , lsize , pstype , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;
 if_debug7m ( 'A' , mem , ""[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\n"" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;
 return ( char * ) obj ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestReplaceHandler ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/updated-url/%s"" ) , ""test2"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph2 ) ) ;
 const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( ""mailto"" ) ) ;
 ASSERT_EQ ( handler . url ( ) , ph2 . url ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int roq_encode_end ( AVCodecContext * avctx ) {
 RoqContext * enc = avctx -> priv_data ;
 avctx -> release_buffer ( avctx , enc -> last_frame ) ;
 avctx -> release_buffer ( avctx , enc -> current_frame ) ;
 av_free ( enc -> tmpData ) ;
 av_free ( enc -> this_motion4 ) ;
 av_free ( enc -> last_motion4 ) ;
 av_free ( enc -> this_motion8 ) ;
 av_free ( enc -> last_motion8 ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int nntp_group_poll ( struct NntpData * nntp_data , int update_stat ) {
 char buf [ LONG_STRING ] = """" ;
 anum_t count , first , last ;
 if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) return - 1 ;
 if ( sscanf ( buf , ""211 "" ANUM "" "" ANUM "" "" ANUM , & count , & first , & last ) != 3 ) return 0 ;
 if ( first == nntp_data -> first_message && last == nntp_data -> last_message ) return 0 ;
 if ( last < nntp_data -> last_message ) {
 nntp_data -> last_cached = 0 ;
 if ( nntp_data -> newsrc_len ) {
 mutt_mem_realloc ( & nntp_data -> newsrc_ent , sizeof ( struct NewsrcEntry ) ) ;
 nntp_data -> newsrc_len = 1 ;
 nntp_data -> newsrc_ent [ 0 ] . first = 1 ;
 nntp_data -> newsrc_ent [ 0 ] . last = 0 ;
 }
 }
 nntp_data -> first_message = first ;
 nntp_data -> last_message = last ;
 if ( ! update_stat ) return 1 ;
 else if ( ! last || ( ! nntp_data -> newsrc_ent && ! nntp_data -> last_cached ) ) nntp_data -> unread = count ;
 else nntp_group_unread_stat ( nntp_data ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int token_continue ( i_ctx_t * i_ctx_p , scanner_state * pstate , bool save ) {
 os_ptr op = osp ;
 int code ;
 ref token ;
 pop ( 1 ) ;
 again : code = gs_scan_token ( i_ctx_p , & token , pstate ) ;
 op = osp ;
 switch ( code ) {
 default : if ( code > 0 ) code = gs_note_error ( gs_error_syntaxerror ) ;
 gs_scanner_error_object ( i_ctx_p , pstate , & i_ctx_p -> error_object ) ;
 break ;
 case scan_BOS : code = 0 ;
 case 0 : push ( 2 ) ;
 ref_assign ( op - 1 , & token ) ;
 make_true ( op ) ;
 break ;
 case scan_EOF : push ( 1 ) ;
 make_false ( op ) ;
 code = 0 ;
 break ;
 case scan_Refill : code = gs_scan_handle_refill ( i_ctx_p , pstate , save , ztoken_continue ) ;
 switch ( code ) {
 case 0 : goto again ;
 case o_push_estack : return code ;
 }
 break ;
 }
 if ( code <= 0 && ! save ) {
 ifree_object ( pstate , ""token_continue"" ) ;
 }
 return code ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int split_field_copy ( Picture * dest , Picture * src , int parity , int id_add ) {
 int match = ! ! ( src -> f . reference & parity ) ;
 if ( match ) {
 * dest = * src ;
 if ( parity != PICT_FRAME ) {
 pic_as_field ( dest , parity ) ;
 dest -> pic_id *= 2 ;
 dest -> pic_id += id_add ;
 }
 }
 return match ;
 }",1
Detect whether the following code contains vulnerabilities.,"static PyObject * authGSSServerUserName ( PyObject * self , PyObject * args ) {
 gss_server_state * state ;
 PyObject * pystate ;
 if ( ! PyArg_ParseTuple ( args , ""O"" , & pystate ) ) return NULL ;
 # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {
 # else if ( ! PyCObject_Check ( pystate ) ) {
 # endif PyErr_SetString ( PyExc_TypeError , ""Expected a context object"" ) ;
 return NULL ;
 }
 # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;
 # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;
 # endif if ( state == NULL ) return NULL ;
 return Py_BuildValue ( ""s"" , state -> username ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"char func_parallel ( Oid funcid ) {
 HeapTuple tp ;
 char result ;
 tp = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;
 if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , ""cache lookup failed for function %u"" , funcid ) ;
 result = ( ( Form_pg_proc ) GETSTRUCT ( tp ) ) -> proparallel ;
 ReleaseSysCache ( tp ) ;
 return result ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void await_reference_mb_row ( H264Context * const h , Picture * ref , int mb_y ) {
 int ref_field = ref -> f . reference - 1 ;
 int ref_field_picture = ref -> field_picture ;
 int ref_height = 16 * h -> mb_height >> ref_field_picture ;
 if ( ! HAVE_THREADS || ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) return ;
 ff_thread_await_progress ( & ref -> f , FFMIN ( 16 * mb_y >> ref_field_picture , ref_height - 1 ) , ref_field_picture && ref_field ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( tx_type == DCT_DCT ) {
 vp9_idct16x16_add ( input , dest , stride , eob ) ;
 }
 else {
 vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int gfboost_qadjust ( int qindex ) {
 const double q = vp9_convert_qindex_to_q ( qindex ) ;
 return ( int ) ( ( 0.00000828 * q * q * q ) + ( - 0.0055 * q * q ) + ( 1.32 * q ) + 79.3 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"fz_colorspace * fz_new_cal_colorspace ( fz_context * ctx , const char * name , float * wp , float * bp , float * gamma , float * matrix ) {
 fz_colorspace * cs = NULL ;
 enum fz_colorspace_type type ;
 int num ;
 fz_cal_colorspace * cal_data ;
 if ( matrix ) {
 type = FZ_COLORSPACE_RGB ;
 num = 3 ;
 }
 else {
 type = FZ_COLORSPACE_GRAY ;
 num = 1 ;
 }
 cal_data = fz_malloc_struct ( ctx , fz_cal_colorspace ) ;
 memcpy ( & cal_data -> bp , bp , sizeof ( float ) * 3 ) ;
 memcpy ( & cal_data -> wp , wp , sizeof ( float ) * 3 ) ;
 memcpy ( & cal_data -> gamma , gamma , sizeof ( float ) * num ) ;
 if ( matrix != NULL ) memcpy ( & cal_data -> matrix , matrix , sizeof ( float ) * 9 ) ;
 cal_data -> n = num ;
 fz_try ( ctx ) cs = fz_new_colorspace ( ctx , name , type , FZ_COLORSPACE_IS_CAL , num , NULL , NULL , NULL , NULL , free_cal , cal_data , sizeof ( cal_data ) ) ;
 fz_catch ( ctx ) {
 fz_free ( ctx , cal_data ) ;
 fz_rethrow ( ctx ) ;
 }
 return cs ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void segment_properties_destroy ( hb_segment_properties_t * g ) {
 free ( g ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint32_t U_CALLCONV _enumTypeValue ( const void * context , uint32_t value ) {
 return GET_CATEGORY ( value ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void copy_partitioning ( VP9_COMMON * cm , MODE_INFO * * mi_8x8 , MODE_INFO * * prev_mi_8x8 ) {
 const int mis = cm -> mi_stride ;
 int block_row , block_col ;
 for ( block_row = 0 ;
 block_row < 8 ;
 ++ block_row ) {
 for ( block_col = 0 ;
 block_col < 8 ;
 ++ block_col ) {
 MODE_INFO * const prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] ;
 const BLOCK_SIZE sb_type = prev_mi ? prev_mi -> mbmi . sb_type : 0 ;
 if ( prev_mi ) {
 const ptrdiff_t offset = prev_mi - cm -> prev_mi ;
 mi_8x8 [ block_row * mis + block_col ] = cm -> mi + offset ;
 mi_8x8 [ block_row * mis + block_col ] -> mbmi . sb_type = sb_type ;
 }
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void * size_checked_malloc ( size_t size ) {
 if ( size > MAX_LIBXML_MALLOC ) {
 * ( volatile char * ) 0 = '\0' ;
 return NULL ;
 }
 return malloc ( size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool qemu_in_vcpu_thread ( void ) {
 return cpu_single_env && qemu_cpu_is_self ( ENV_GET_CPU ( cpu_single_env ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelGreen ( const Image * restrict image , const Quantum green , Quantum * restrict pixel ) {
 pixel [ image -> channel_map [ GreenPixelChannel ] . offset ] = green ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int gsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 AVFrame * frame = data ;
 int res ;
 GetBitContext gb ;
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 int16_t * samples ;
 if ( buf_size < avctx -> block_align ) {
 av_log ( avctx , AV_LOG_ERROR , ""Packet is too small\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 frame -> nb_samples = avctx -> frame_size ;
 if ( ( res = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return res ;
 }
 samples = ( int16_t * ) frame -> data [ 0 ] ;
 switch ( avctx -> codec_id ) {
 case AV_CODEC_ID_GSM : init_get_bits ( & gb , buf , buf_size * 8 ) ;
 if ( get_bits ( & gb , 4 ) != 0xd ) av_log ( avctx , AV_LOG_WARNING , ""Missing GSM magic!\n"" ) ;
 res = gsm_decode_block ( avctx , samples , & gb ) ;
 if ( res < 0 ) return res ;
 break ;
 case AV_CODEC_ID_GSM_MS : res = ff_msgsm_decode_block ( avctx , samples , buf ) ;
 if ( res < 0 ) return res ;
 }
 * got_frame_ptr = 1 ;
 return avctx -> block_align ;
 }",1
Detect whether the following code contains vulnerabilities.,"char * TSHttpTxnEffectiveUrlStringGet ( TSHttpTxn txnp , int * length ) {
 sdk_assert ( TS_SUCCESS == sdk_sanity_check_txn ( txnp ) ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;
 HttpSM * sm = reinterpret_cast < HttpSM * > ( txnp ) ;
 return sm -> t_state . hdr_info . client_request . url_string_get ( nullptr , length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {
 const unsigned char * buffer ;
 ssize_t avail ;
 int bits_checked ;
 ( void ) self ;
 buffer = __archive_read_filter_ahead ( filter , 3 , & avail ) ;
 if ( buffer == NULL ) return ( 0 ) ;
 bits_checked = 0 ;
 if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;
 if ( buffer [ 2 ] & 0x20 ) return ( 0 ) ;
 if ( buffer [ 2 ] & 0x40 ) return ( 0 ) ;
 bits_checked += 18 ;
 return ( bits_checked ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_swap_mi_and_prev_mi ( VP9_COMMON * cm ) {
 const int tmp = cm -> mi_idx ;
 cm -> mi_idx = cm -> prev_mi_idx ;
 cm -> prev_mi_idx = tmp ;
 cm -> mip = cm -> mip_array [ cm -> mi_idx ] ;
 cm -> prev_mip = cm -> mip_array [ cm -> prev_mi_idx ] ;
 cm -> mi_grid_base = cm -> mi_grid_base_array [ cm -> mi_idx ] ;
 cm -> prev_mi_grid_base = cm -> mi_grid_base_array [ cm -> prev_mi_idx ] ;
 cm -> mi = cm -> mip + cm -> mi_stride + 1 ;
 cm -> prev_mi = cm -> prev_mip + cm -> mi_stride + 1 ;
 cm -> mi_grid_visible = cm -> mi_grid_base + cm -> mi_stride + 1 ;
 cm -> prev_mi_grid_visible = cm -> prev_mi_grid_base + cm -> mi_stride + 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int virtio_console_init_pci ( PCIDevice * pci_dev ) {
 VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ;
 VirtIODevice * vdev ;
 if ( proxy -> class_code != PCI_CLASS_COMMUNICATION_OTHER && proxy -> class_code != PCI_CLASS_DISPLAY_OTHER && proxy -> class_code != PCI_CLASS_OTHERS ) proxy -> class_code = PCI_CLASS_COMMUNICATION_OTHER ;
 vdev = virtio_console_init ( & pci_dev -> qdev ) ;
 if ( ! vdev ) {
 return - 1 ;
 }
 virtio_init_pci ( proxy , vdev , PCI_VENDOR_ID_REDHAT_QUMRANET , PCI_DEVICE_ID_VIRTIO_CONSOLE , proxy -> class_code , 0x00 ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * qemuMonitorJSONStringifyError ( virJSONValuePtr error ) {
 const char * klass = virJSONValueObjectGetString ( error , ""class"" ) ;
 const char * detail = NULL ;
 if ( klass ) detail = virJSONValueObjectGetString ( error , ""desc"" ) ;
 if ( ! detail ) detail = ""unknown QEMU command error"" ;
 return detail ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void e1000e_update_rx_stats ( E1000ECore * core , size_t data_size , size_t data_fcs_size ) {
 e1000x_update_rx_total_stats ( core -> mac , data_size , data_fcs_size ) ;
 switch ( net_rx_pkt_get_packet_type ( core -> rx_pkt ) ) {
 case ETH_PKT_BCAST : e1000x_inc_reg_if_not_full ( core -> mac , BPRC ) ;
 break ;
 case ETH_PKT_MCAST : e1000x_inc_reg_if_not_full ( core -> mac , MPRC ) ;
 break ;
 default : break ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean qio_channel_websock_source_check ( GSource * source ) {
 QIOChannelWebsockSource * wsource = ( QIOChannelWebsockSource * ) source ;
 GIOCondition cond = 0 ;
 if ( wsource -> wioc -> rawinput . offset || wsource -> wioc -> io_eof ) {
 cond |= G_IO_IN ;
 }
 if ( wsource -> wioc -> rawoutput . offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER ) {
 cond |= G_IO_OUT ;
 }
 return cond & wsource -> condition ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void test_show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {
 struct bitmap_test_data * tdata = data ;
 int bitmap_pos ;
 bitmap_pos = bitmap_position ( object -> oid . hash ) ;
 if ( bitmap_pos < 0 ) die ( ""Object not in bitmap: %s\n"" , oid_to_hex ( & object -> oid ) ) ;
 bitmap_set ( tdata -> base , bitmap_pos ) ;
 display_progress ( tdata -> prg , ++ tdata -> seen ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , DisregardPersistenceRequestIframe ) {
 base : : HistogramTester histogram_tester ;
 ContentSettingsForOneType host_settings ;
 HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;
 EXPECT_EQ ( 0u , host_settings . size ( ) ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_without_lifetime_with_iframe_url ( ) ) ;
 histogram_tester . ExpectTotalCount ( ""ClientHints.UpdateEventCount"" , 0 ) ;
 content : : FetchHistogramsFromChildProcesses ( ) ;
 SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;
 histogram_tester . ExpectTotalCount ( ""ClientHints.UpdateSize"" , 0 ) ;
 histogram_tester . ExpectTotalCount ( ""ClientHints.PersistDuration"" , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct4x4_1_add_c ( const int16_t * input , uint8_t * dest , int dest_stride ) {
 int i ;
 int a1 ;
 int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;
 out = dct_const_round_shift ( out * cospi_16_64 ) ;
 a1 = ROUND_POWER_OF_TWO ( out , 4 ) ;
 for ( i = 0 ;
 i < 4 ;
 i ++ ) {
 dest [ 0 ] = clip_pixel ( dest [ 0 ] + a1 ) ;
 dest [ 1 ] = clip_pixel ( dest [ 1 ] + a1 ) ;
 dest [ 2 ] = clip_pixel ( dest [ 2 ] + a1 ) ;
 dest [ 3 ] = clip_pixel ( dest [ 3 ] + a1 ) ;
 dest += dest_stride ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SafeJsonParserTest , Parse ) {
 TestParse ( ""{
}
"" ) ;
 TestParse ( ""choke"" ) ;
 TestParse ( ""{
\""awesome\"": true}
"" ) ;
 TestParse ( ""\""laser\"""" ) ;
 TestParse ( ""false"" ) ;
 TestParse ( ""null"" ) ;
 TestParse ( ""3.14"" ) ;
 TestParse ( ""["" ) ;
 TestParse ( ""\"""" ) ;
 TestParse ( std : : string ( ) ) ;
 TestParse ( ""☃"" ) ;
 TestParse ( ""\""☃\"""" ) ;
 TestParse ( ""\""\\ufdd0\"""" ) ;
 TestParse ( ""\""\\ufffe\"""" ) ;
 TestParse ( ""\""\\ud83f\\udffe\"""" ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _selectOutputSchema ( ArchiveHandle * AH , const char * schemaName ) {
 PQExpBuffer qry ;
 if ( ! schemaName || * schemaName == '\0' || ( AH -> currSchema && strcmp ( AH -> currSchema , schemaName ) == 0 ) ) return ;
 qry = createPQExpBuffer ( ) ;
 appendPQExpBuffer ( qry , ""SET search_path = %s"" , fmtId ( schemaName ) ) ;
 if ( strcmp ( schemaName , ""pg_catalog"" ) != 0 ) appendPQExpBufferStr ( qry , "", pg_catalog"" ) ;
 if ( RestoringToDB ( AH ) ) {
 PGresult * res ;
 res = PQexec ( AH -> connection , qry -> data ) ;
 if ( ! res || PQresultStatus ( res ) != PGRES_COMMAND_OK ) warn_or_exit_horribly ( AH , modulename , ""could not set search_path to \""%s\"": %s"" , schemaName , PQerrorMessage ( AH -> connection ) ) ;
 PQclear ( res ) ;
 }
 else ahprintf ( AH , ""%s;
\n\n"" , qry -> data ) ;
 if ( AH -> currSchema ) free ( AH -> currSchema ) ;
 AH -> currSchema = pg_strdup ( schemaName ) ;
 destroyPQExpBuffer ( qry ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"kadm5_ret_t kadm5_get_principal_keys ( void * server_handle , krb5_principal principal , krb5_keyblock * * keyblocks , int * n_keys ) {
 krb5_db_entry * kdb ;
 osa_princ_ent_rec adb ;
 kadm5_ret_t ret ;
 kadm5_server_handle_t handle = server_handle ;
 if ( keyblocks ) * keyblocks = NULL ;
 CHECK_HANDLE ( server_handle ) ;
 if ( principal == NULL ) return EINVAL ;
 if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;
 if ( keyblocks ) {
 ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;
 if ( ret ) goto done ;
 }
 ret = KADM5_OK ;
 done : kdb_free_entry ( handle , kdb , & adb ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline bool e1000e_ring_enabled ( E1000ECore * core , const E1000E_RingInfo * r ) {
 return core -> mac [ r -> dlen ] > 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int jbig2_find_changing_element ( const byte * line , int x , int w ) {
 int a , b ;
 if ( line == 0 ) return w ;
 if ( x == - 1 ) {
 a = 0 ;
 x = 0 ;
 }
 else {
 a = getbit ( line , x ) ;
 x ++ ;
 }
 while ( x < w ) {
 b = getbit ( line , x ) ;
 if ( a != b ) break ;
 x ++ ;
 }
 return x ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSVConn TSHttpConnectTransparent ( sockaddr const * client_addr , sockaddr const * server_addr ) {
 sdk_assert ( ats_is_ip ( client_addr ) ) ;
 sdk_assert ( ats_is_ip ( server_addr ) ) ;
 sdk_assert ( ! ats_is_ip_any ( client_addr ) ) ;
 sdk_assert ( ats_ip_port_cast ( client_addr ) ) ;
 sdk_assert ( ! ats_is_ip_any ( server_addr ) ) ;
 sdk_assert ( ats_ip_port_cast ( server_addr ) ) ;
 if ( plugin_http_transparent_accept ) {
 PluginVCCore * new_pvc = PluginVCCore : : alloc ( plugin_http_transparent_accept ) ;
 new_pvc -> set_active_addr ( client_addr ) ;
 new_pvc -> set_passive_addr ( server_addr ) ;
 new_pvc -> set_transparent ( true , true ) ;
 PluginVC * return_vc = new_pvc -> connect ( ) ;
 if ( return_vc != nullptr ) {
 PluginVC * other_side = return_vc -> get_other_side ( ) ;
 if ( other_side != nullptr ) {
 other_side -> set_is_internal_request ( true ) ;
 }
 }
 return reinterpret_cast < TSVConn > ( return_vc ) ;
 }
 return nullptr ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , int bsize ) {
 VP9_COMMON * const cm = & cpi -> common ;
 MACROBLOCK * const x = & cpi -> mb ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 const struct segmentation * const seg = & cm -> seg ;
 * ( xd -> mi [ 0 ] ) = ctx -> mic ;
 if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) {
 vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , 1 ) ;
 vp9_init_plane_quantizers ( cpi , x ) ;
 }
 if ( is_inter_block ( mbmi ) ) {
 vp9_update_mv_count ( cm , xd ) ;
 if ( cm -> interp_filter == SWITCHABLE ) {
 const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ;
 ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;
 }
 }
 x -> skip = ctx -> skip ;
 x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"int dissect_h225_ServiceControlSession ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_ServiceControlSession , ServiceControlSession_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void release_context ( compress_filter_context_t * ctx ) {
 xfree ( ctx ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {
 if ( page -> image == NULL ) {
 jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , ""page info possibly missing, no image defined"" ) ;
 return 0 ;
 }
 if ( page -> striped ) {
 int new_height = y + image -> height + page -> end_row ;
 if ( page -> image -> height < new_height ) {
 jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , ""growing page buffer to %d rows "" ""to accomodate new stripe"" , new_height ) ;
 jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;
 }
 }
 jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line16_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t v , r , g , b ;
 w = width ;
 do {
 v = lduw_be_p ( ( void * ) s ) ;
 r = ( v >> 8 ) & 0xf8 ;
 g = ( v >> 3 ) & 0xfc ;
 b = ( v << 3 ) & 0xf8 ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 2 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Datum ExecEvalCase ( CaseExprState * caseExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {
 List * clauses = caseExpr -> args ;
 ListCell * clause ;
 Datum save_datum ;
 bool save_isNull ;
 if ( isDone ) * isDone = ExprSingleResult ;
 save_datum = econtext -> caseValue_datum ;
 save_isNull = econtext -> caseValue_isNull ;
 if ( caseExpr -> arg ) {
 econtext -> caseValue_datum = ExecEvalExpr ( caseExpr -> arg , econtext , & econtext -> caseValue_isNull , NULL ) ;
 }
 foreach ( clause , clauses ) {
 CaseWhenState * wclause = lfirst ( clause ) ;
 Datum clause_value ;
 clause_value = ExecEvalExpr ( wclause -> expr , econtext , isNull , NULL ) ;
 if ( DatumGetBool ( clause_value ) && ! * isNull ) {
 econtext -> caseValue_datum = save_datum ;
 econtext -> caseValue_isNull = save_isNull ;
 return ExecEvalExpr ( wclause -> result , econtext , isNull , isDone ) ;
 }
 }
 econtext -> caseValue_datum = save_datum ;
 econtext -> caseValue_isNull = save_isNull ;
 if ( caseExpr -> defresult ) {
 return ExecEvalExpr ( caseExpr -> defresult , econtext , isNull , isDone ) ;
 }
 * isNull = true ;
 return ( Datum ) 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline u32 ipv6_addr_hash ( const struct in6_addr * a ) {
 # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) && BITS_PER_LONG == 64 const unsigned long * ul = ( const unsigned long * ) a ;
 unsigned long x = ul [ 0 ] ^ ul [ 1 ] ;
 return ( u32 ) ( x ^ ( x >> 32 ) ) ;
 # else return ( __force u32 ) ( a -> s6_addr32 [ 0 ] ^ a -> s6_addr32 [ 1 ] ^ a -> s6_addr32 [ 2 ] ^ a -> s6_addr32 [ 3 ] ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void sbr_hf_apply_noise_2 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {
 sbr_hf_apply_noise ( Y , s_m , q_filt , noise , - 1.0 , 0.0 , m_max ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static unsigned long xmlHashComputeKey ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {
 unsigned long value = 0L ;
 char ch ;
 if ( name != NULL ) {
 value += 30 * ( * name ) ;
 while ( ( ch = * name ++ ) != 0 ) {
 value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;
 }
 }
 if ( name2 != NULL ) {
 while ( ( ch = * name2 ++ ) != 0 ) {
 value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;
 }
 }
 if ( name3 != NULL ) {
 while ( ( ch = * name3 ++ ) != 0 ) {
 value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;
 }
 }
 return ( value % table -> size ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {
 hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;
 if ( unlikely ( ! c ) ) return NULL ;
 * c = * g ;
 return c ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _slurm_rpc_sib_job_unlock ( uint32_t uid , slurm_msg_t * msg ) {
 int rc ;
 sib_msg_t * sib_msg = msg -> data ;
 if ( ! msg -> conn ) {
 error ( ""Security violation, SIB_JOB_UNLOCK RPC from uid=%d"" , uid ) ;
 slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;
 return ;
 }
 rc = fed_mgr_job_lock_unset ( sib_msg -> job_id , sib_msg -> cluster_id ) ;
 slurm_send_rc_msg ( msg , rc ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int i2d_DSAPrivateKey_fp ( FILE * fp , DSA * dsa ) {
 return ASN1_i2d_fp_of_const ( DSA , i2d_DSAPrivateKey , fp , dsa ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"WRITE_CLASS_ENCODER ( CephXServiceTicketRequest ) struct CephXAuthorizeReply {
 uint64_t nonce_plus_one ;
 void encode ( bufferlist & bl ) const {
 __u8 struct_v = 1 ;
 : : encode ( struct_v , bl ) ;
 : : encode ( nonce_plus_one , bl ) ;
 }
 void decode ( bufferlist : : iterator & bl ) {
 __u8 struct_v ;
 : : decode ( struct_v , bl ) ;
 : : decode ( nonce_plus_one , bl ) ;
 }
 }
 ;
 WRITE_CLASS_ENCODER ( CephXAuthorizeReply ) struct CephXAuthorizer : public AuthAuthorizer {
 private : CephContext * cct ;
 public : uint64_t nonce ;
 explicit CephXAuthorizer ( CephContext * cct_ ) : AuthAuthorizer ( CEPH_AUTH_CEPHX ) , cct ( cct_ ) , nonce ( 0 ) {
 }
 bool build_authorizer ( ) ;
 bool verify_reply ( bufferlist : : iterator & reply ) override ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {
 gcry_err_code_t err = 0 ;
 int i , idx ;
 const char * name ;
 gcry_sexp_t list ;
 for ( name = element_names , idx = 0 ;
 * name && ! err ;
 name ++ , idx ++ ) {
 list = gcry_sexp_find_token ( key_sexp , name , 1 ) ;
 if ( ! list ) elements [ idx ] = NULL ;
 else {
 elements [ idx ] = gcry_sexp_nth_mpi ( list , 1 , GCRYMPI_FMT_USG ) ;
 gcry_sexp_release ( list ) ;
 if ( ! elements [ idx ] ) err = GPG_ERR_INV_OBJ ;
 }
 }
 if ( ! err ) {
 for ( name = element_names , i = 0 ;
 * name ;
 name ++ , i ++ ) if ( ! elements [ i ] ) break ;
 if ( * name ) {
 err = GPG_ERR_NO_OBJ ;
 if ( algo_name && ! strcmp ( algo_name , ""RSA"" ) && ! strcmp ( element_names , ""nedpqu"" ) ) {
 if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;
 }
 }
 }
 if ( err ) {
 for ( i = 0 ;
 i < idx ;
 i ++ ) if ( elements [ i ] ) mpi_free ( elements [ i ] ) ;
 }
 return err ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_one_option ( const char * option ) {
 if ( skip_prefix ( option , ""max-pack-size="" , & option ) ) {
 unsigned long v ;
 if ( ! git_parse_ulong ( option , & v ) ) return 0 ;
 if ( v < 8192 ) {
 warning ( ""max-pack-size is now in bytes, assuming --max-pack-size=%lum"" , v ) ;
 v *= 1024 * 1024 ;
 }
 else if ( v < 1024 * 1024 ) {
 warning ( ""minimum max-pack-size is 1 MiB"" ) ;
 v = 1024 * 1024 ;
 }
 max_packsize = v ;
 }
 else if ( skip_prefix ( option , ""big-file-threshold="" , & option ) ) {
 unsigned long v ;
 if ( ! git_parse_ulong ( option , & v ) ) return 0 ;
 big_file_threshold = v ;
 }
 else if ( skip_prefix ( option , ""depth="" , & option ) ) {
 option_depth ( option ) ;
 }
 else if ( skip_prefix ( option , ""active-branches="" , & option ) ) {
 option_active_branches ( option ) ;
 }
 else if ( skip_prefix ( option , ""export-pack-edges="" , & option ) ) {
 option_export_pack_edges ( option ) ;
 }
 else if ( starts_with ( option , ""quiet"" ) ) {
 show_stats = 0 ;
 }
 else if ( starts_with ( option , ""stats"" ) ) {
 show_stats = 1 ;
 }
 else {
 return 0 ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int monitor_key_compare ( gconstpointer a , gconstpointer data ) {
 const Monitor * monitor ;
 const Monitor * compare_monitor ;
 monitor = a ;
 compare_monitor = data ;
 if ( monitor -> client < compare_monitor -> client ) {
 return - 1 ;
 }
 if ( monitor -> client > compare_monitor -> client ) {
 return + 1 ;
 }
 if ( monitor -> file < compare_monitor -> file ) {
 return - 1 ;
 }
 if ( monitor -> file > compare_monitor -> file ) {
 return + 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLParserTest , PassOnHTTPS ) {
 ASSERT_NO_FATAL_FAILURE ( ParseFile ( ""https.xml"" , nullptr ) ) ;
 EXPECT_TRUE ( template_url_ ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) {
 int c_sz ;
 ( void ) _aux ;
 _dst += _y4m -> pic_w * _y4m -> pic_h ;
 c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;
 memset ( _dst , 128 , c_sz * 2 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void nlm_register_unmatched_msg ( packet_info * pinfo , tvbuff_t * tvb , int offset ) {
 nlm_msg_res_unmatched_data * umd ;
 nlm_msg_res_unmatched_data * old_umd ;
 umd = ( nlm_msg_res_unmatched_data * ) g_malloc ( sizeof ( nlm_msg_res_unmatched_data ) ) ;
 umd -> req_frame = pinfo -> fd -> num ;
 umd -> ns = pinfo -> fd -> abs_ts ;
 umd -> cookie_len = tvb_get_ntohl ( tvb , offset ) ;
 umd -> cookie = ( const guint8 * ) tvb_memdup ( NULL , tvb , offset + 4 , umd -> cookie_len ) ;
 old_umd = ( nlm_msg_res_unmatched_data * ) g_hash_table_lookup ( nlm_msg_res_unmatched , ( gconstpointer ) umd ) ;
 if ( old_umd ) {
 g_hash_table_remove ( nlm_msg_res_unmatched , ( gconstpointer ) old_umd ) ;
 g_free ( ( gpointer ) old_umd -> cookie ) ;
 g_free ( old_umd ) ;
 }
 g_hash_table_insert ( nlm_msg_res_unmatched , ( gpointer ) umd , ( gpointer ) umd ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_SetupAcknowledge_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 428 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_SetupAcknowledge_UUIE , SetupAcknowledge_UUIE_sequence ) ;
 # line 432 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_SETUP_ACK ;
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_kernel_read_file ( struct file * file , enum kernel_read_file_id id ) {
 int rc = 0 ;
 switch ( id ) {
 case READING_MODULE : rc = selinux_kernel_module_from_file ( file ) ;
 break ;
 default : break ;
 }
 return rc ;
 }",0
Detect whether the following code contains vulnerabilities.,"void rfbSetServerVersionIdentity ( rfbScreenInfoPtr screen , char * fmt , ... ) {
 char buffer [ 256 ] ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 vsnprintf ( buffer , sizeof ( buffer ) - 1 , fmt , ap ) ;
 va_end ( ap ) ;
 if ( screen -> versionString != NULL ) free ( screen -> versionString ) ;
 screen -> versionString = strdup ( buffer ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _isoent_free ( struct isoent * isoent ) {
 struct extr_rec * er , * er_next ;
 free ( isoent -> children_sorted ) ;
 free ( isoent -> identifier ) ;
 er = isoent -> extr_rec_list . first ;
 while ( er != NULL ) {
 er_next = er -> next ;
 free ( er ) ;
 er = er_next ;
 }
 free ( isoent ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * ts_unix_format ( netdissect_options * ndo # ifndef HAVE_PCAP_SET_TSTAMP_PRECISION _U_ # endif , int sec , int usec , char * buf ) {
 const char * format ;
 # ifdef HAVE_PCAP_SET_TSTAMP_PRECISION switch ( ndo -> ndo_tstamp_precision ) {
 case PCAP_TSTAMP_PRECISION_MICRO : format = ""%u.%06u"" ;
 break ;
 case PCAP_TSTAMP_PRECISION_NANO : format = ""%u.%09u"" ;
 break ;
 default : format = ""%u.{
unknown}
"" ;
 break ;
 }
 # else format = ""%u.%06u"" ;
 # endif snprintf ( buf , TS_BUF_SIZE , format , ( unsigned ) sec , ( unsigned ) usec ) ;
 return buf ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pbase_tree_put ( struct pbase_tree_cache * cache ) {
 if ( ! cache -> temporary ) {
 cache -> ref -- ;
 return ;
 }
 free ( cache -> tree_data ) ;
 free ( cache ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct8x8_64_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {
 tran_low_t out [ 8 * 8 ] ;
 tran_low_t * outptr = out ;
 int i , j ;
 tran_low_t temp_in [ 8 ] , temp_out [ 8 ] ;
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 idct8 ( input , outptr ) ;
 input += 8 ;
 outptr += 8 ;
 }
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;
 idct8 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int ilbc_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) {
 ILBCEncContext * s = avctx -> priv_data ;
 int ret ;
 if ( ( ret = ff_alloc_packet ( avpkt , 50 ) ) ) {
 av_log ( avctx , AV_LOG_ERROR , ""Error getting output packet\n"" ) ;
 return ret ;
 }
 WebRtcIlbcfix_EncodeImpl ( ( WebRtc_UWord16 * ) avpkt -> data , ( const WebRtc_Word16 * ) frame -> data [ 0 ] , & s -> encoder ) ;
 avpkt -> size = s -> encoder . no_of_bytes ;
 * got_packet_ptr = 1 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {
 long unsigned int i ;
 unsigned char c ;
 char buf2 [ 15 ] ;
 mowgli_string_t * s = mowgli_string_create ( ) ;
 * buf2 = '\0' ;
 * outbuffer = '\0' ;
 if ( ( ! ( s1 ) || ( * ( s1 ) == '\0' ) ) ) {
 return ;
 }
 for ( i = 0 ;
 s1 [ i ] != '\0' ;
 i ++ ) {
 c = s1 [ i ] ;
 if ( c > 127 ) {
 snprintf ( buf2 , sizeof buf2 , ""&#%d;
"" , c ) ;
 s -> append ( s , buf2 , strlen ( buf2 ) ) ;
 }
 else if ( c == '&' ) {
 s -> append ( s , ""&amp;
"" , 5 ) ;
 }
 else if ( c == '<' ) {
 s -> append ( s , ""&lt;
"" , 4 ) ;
 }
 else if ( c == '>' ) {
 s -> append ( s , ""&gt;
"" , 4 ) ;
 }
 else if ( c == '""' ) {
 s -> append ( s , ""&quot;
"" , 6 ) ;
 }
 else {
 s -> append_char ( s , c ) ;
 }
 }
 memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int i2d_PKCS8_fp ( FILE * fp , X509_SIG * p8 ) {
 return ASN1_i2d_fp_of ( X509_SIG , i2d_X509_SIG , fp , p8 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONBlockResize ( qemuMonitorPtr mon , const char * device , unsigned long long size ) {
 int ret ;
 virJSONValuePtr cmd ;
 virJSONValuePtr reply = NULL ;
 cmd = qemuMonitorJSONMakeCommand ( ""block_resize"" , ""s:device"" , device , ""U:size"" , size * 1024 , NULL ) ;
 if ( ! cmd ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) {
 if ( qemuMonitorJSONHasError ( reply , ""CommandNotFound"" ) ) {
 ret = - 2 ;
 goto cleanup ;
 }
 ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 }
 cleanup : virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"PHP_MINIT_FUNCTION ( uwsgi_php_minit ) {
 php_session_register_module ( & ps_mod_uwsgi ) ;
 struct uwsgi_string_list * usl = uphp . constants ;
 while ( usl ) {
 char * equal = strchr ( usl -> value , '=' ) ;
 if ( equal ) {
 size_t name_len = equal - usl -> value ;
 char * name = usl -> value ;
 char * strval = equal + 1 ;
 equal = NULL ;
 # ifndef UWSGI_PHP7 name_len = name_len + 1 ;
 # endif zend_register_string_constant ( name , name_len , strval , CONST_CS | CONST_PERSISTENT , module_number TSRMLS_CC ) ;
 }
 usl = usl -> next ;
 }
 return SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void initial_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {
 syllable_type_t syllable_type = ( syllable_type_t ) ( buffer -> info [ start ] . syllable ( ) & 0x0F ) ;
 switch ( syllable_type ) {
 case consonant_syllable : initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;
 return ;
 case vowel_syllable : initial_reordering_vowel_syllable ( plan , face , buffer , start , end ) ;
 return ;
 case standalone_cluster : initial_reordering_standalone_cluster ( plan , face , buffer , start , end ) ;
 return ;
 case symbol_cluster : initial_reordering_symbol_cluster ( plan , face , buffer , start , end ) ;
 return ;
 case broken_cluster : initial_reordering_broken_cluster ( plan , face , buffer , start , end ) ;
 return ;
 case non_indic_cluster : initial_reordering_non_indic_cluster ( plan , face , buffer , start , end ) ;
 return ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"inline uint char_val ( char X ) {
 return ( uint ) ( X >= '0' && X <= '9' ? X - '0' : X >= 'A' && X <= 'Z' ? X - 'A' + 10 : X - 'a' + 10 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {
 return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;
 }
 # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;
 typedef const char * OPENSSL_CSTRING ;
 DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;
 DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )",1
Detect whether the following code contains vulnerabilities.,"static void set_user ( const char * user , struct passwd * user_info_arg ) {
 # if ! defined ( __WIN__ ) DBUG_ASSERT ( user_info_arg != 0 ) ;
 # ifdef HAVE_INITGROUPS calling_initgroups = 1 ;
 initgroups ( ( char * ) user , user_info_arg -> pw_gid ) ;
 calling_initgroups = 0 ;
 # endif if ( setgid ( user_info_arg -> pw_gid ) == - 1 ) {
 sql_perror ( ""setgid"" ) ;
 unireg_abort ( 1 ) ;
 }
 if ( setuid ( user_info_arg -> pw_uid ) == - 1 ) {
 sql_perror ( ""setuid"" ) ;
 unireg_abort ( 1 ) ;
 }
 allow_coredumps ( ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_DialingInformationNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_DialingInformationNumber , DialingInformationNumber_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , FileAccess ) {
 ASSERT_TRUE ( RunExtensionTest ( ""cross_origin_xhr/file_access"" ) ) << message_ ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_quantize_dc_32x32 ( const int16_t * coeff_ptr , int skip_block , const int16_t * round_ptr , const int16_t quant , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t dequant_ptr , uint16_t * eob_ptr ) {
 const int rc = 0 ;
 const int coeff = coeff_ptr [ rc ] ;
 const int coeff_sign = ( coeff >> 31 ) ;
 const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;
 int tmp , eob = - 1 ;
 if ( ! skip_block ) {
 tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;
 tmp = ( tmp * quant ) >> 15 ;
 qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;
 dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr / 2 ;
 if ( tmp ) eob = 0 ;
 }
 * eob_ptr = eob + 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"SRP_VBASE * SRP_VBASE_new ( char * seed_key ) {
 SRP_VBASE * vb = ( SRP_VBASE * ) OPENSSL_malloc ( sizeof ( SRP_VBASE ) ) ;
 if ( vb == NULL ) return NULL ;
 if ( ! ( vb -> users_pwd = sk_SRP_user_pwd_new_null ( ) ) || ! ( vb -> gN_cache = sk_SRP_gN_cache_new_null ( ) ) ) {
 OPENSSL_free ( vb ) ;
 return NULL ;
 }
 vb -> default_g = NULL ;
 vb -> default_N = NULL ;
 vb -> seed_key = NULL ;
 if ( ( seed_key != NULL ) && ( vb -> seed_key = BUF_strdup ( seed_key ) ) == NULL ) {
 sk_SRP_user_pwd_free ( vb -> users_pwd ) ;
 sk_SRP_gN_cache_free ( vb -> gN_cache ) ;
 OPENSSL_free ( vb ) ;
 return NULL ;
 }
 return vb ;
 }",0
Detect whether the following code contains vulnerabilities.,"int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {
 Jbig2MmrCtx mmr ;
 const int rowstride = image -> stride ;
 byte * dst = image -> data ;
 byte * ref = NULL ;
 int y ;
 int code = 0 ;
 const uint32_t EOFB = 0x001001 ;
 jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;
 for ( y = 0 ;
 y < image -> height ;
 y ++ ) {
 memset ( dst , 0 , rowstride ) ;
 code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;
 if ( code < 0 ) return code ;
 ref = dst ;
 dst += rowstride ;
 }
 if ( mmr . word >> 8 == EOFB ) {
 mmr . data_index += 3 ;
 }
 * consumed_bytes += mmr . data_index + ( mmr . bit_index >> 3 ) + ( mmr . bit_index > 0 ? 1 : 0 ) ;
 return code ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int send_certificate_request ( SSL * s ) {
 if ( s -> verify_mode & SSL_VERIFY_PEER && ( ( s -> session -> peer == NULL ) || ! ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) && ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) || ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aPSK ) ) {
 return 1 ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int xmlListCopy ( xmlListPtr cur , const xmlListPtr old ) {
 xmlLinkPtr lk ;
 if ( ( old == NULL ) || ( cur == NULL ) ) return ( 1 ) ;
 for ( lk = old -> sentinel -> next ;
 lk != old -> sentinel ;
 lk = lk -> next ) {
 if ( 0 != xmlListInsert ( cur , lk -> data ) ) {
 xmlListDelete ( cur ) ;
 return ( 1 ) ;
 }
 }
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_rc_init_minq_luts ( ) {
 int i ;
 for ( i = 0 ;
 i < QINDEX_RANGE ;
 i ++ ) {
 const double maxq = vp9_convert_qindex_to_q ( i ) ;
 kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.125 ) ;
 kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ;
 arfgf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.30 ) ;
 arfgf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ;
 inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.90 ) ;
 rtc_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.70 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"rfbClientPtr rfbReverseConnection ( rfbScreenInfoPtr rfbScreen , char * host , int port ) {
 int sock ;
 rfbClientPtr cl ;
 if ( ( sock = rfbConnect ( rfbScreen , host , port ) ) < 0 ) return ( rfbClientPtr ) NULL ;
 cl = rfbNewClient ( rfbScreen , sock ) ;
 if ( cl ) {
 cl -> reverseConnection = TRUE ;
 }
 return cl ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void apply_frame_size ( VP9_COMMON * cm , int width , int height ) {
 if ( cm -> width != width || cm -> height != height ) {
 if ( width > cm -> width || height > cm -> height ) {
 if ( vp9_resize_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed to allocate frame buffers"" ) ;
 }
 cm -> width = width ;
 cm -> height = height ;
 vp9_update_frame_size ( cm ) ;
 }
 if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {
 vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , ""Failed to allocate frame buffer"" ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int X509_REQ_sign ( X509_REQ * x , EVP_PKEY * pkey , const EVP_MD * md ) {
 return ( ASN1_item_sign ( ASN1_ITEM_rptr ( X509_REQ_INFO ) , x -> sig_alg , NULL , x -> signature , x -> req_info , pkey , md ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline int16_t inverse_quant ( G726Context * c , int i ) {
 int dql , dex , dqt ;
 dql = c -> tbls . iquant [ i ] + ( c -> y >> 2 ) ;
 dex = ( dql >> 7 ) & 0xf ;
 dqt = ( 1 << 7 ) + ( dql & 0x7f ) ;
 return ( dql < 0 ) ? 0 : ( ( dqt << dex ) >> 7 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {
 struct evhttp * http = arg ;
 struct evhttp_cb * cb = NULL ;
 if ( req -> uri == NULL ) {
 evhttp_send_error ( req , HTTP_BADREQUEST , ""Bad Request"" ) ;
 return ;
 }
 if ( ( cb = evhttp_dispatch_callback ( & http -> callbacks , req ) ) != NULL ) {
 ( * cb -> cb ) ( req , cb -> cbarg ) ;
 return ;
 }
 if ( http -> gencb ) {
 ( * http -> gencb ) ( req , http -> gencbarg ) ;
 return ;
 }
 else {
 # define ERR_FORMAT ""<html><head>"" ""<title>404 Not Found</title>"" ""</head><body>"" ""<h1>Not Found</h1>"" ""<p>The requested URL %s was not found on this server.</p>"" ""</body></html>\n"" char * escaped_html = evhttp_htmlescape ( req -> uri ) ;
 struct evbuffer * buf = evbuffer_new ( ) ;
 evhttp_response_code ( req , HTTP_NOTFOUND , ""Not Found"" ) ;
 evbuffer_add_printf ( buf , ERR_FORMAT , escaped_html ) ;
 free ( escaped_html ) ;
 evhttp_send_page ( req , buf ) ;
 evbuffer_free ( buf ) ;
 # undef ERR_FORMAT }
 }",1
Detect whether the following code contains vulnerabilities.,"static void rm_read_metadata ( AVFormatContext * s , AVIOContext * pb , int wide ) {
 char buf [ 1024 ] ;
 int i ;
 for ( i = 0 ;
 i < FF_ARRAY_ELEMS ( ff_rm_metadata ) ;
 i ++ ) {
 int len = wide ? avio_rb16 ( pb ) : avio_r8 ( pb ) ;
 get_strl ( pb , buf , sizeof ( buf ) , len ) ;
 av_dict_set ( & s -> metadata , ff_rm_metadata [ i ] , buf , 0 ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static uint32_t offsetTOCEntryCount ( const UDataMemory * pData ) {
 int32_t retVal = 0 ;
 const UDataOffsetTOC * toc = ( UDataOffsetTOC * ) pData -> toc ;
 if ( toc != NULL ) {
 retVal = toc -> count ;
 }
 return retVal ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xE_16 ( IpvideoContext * s ) {
 int x , y ;
 uint16_t pix ;
 uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;
 pix = bytestream2_get_le16 ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 for ( x = 0 ;
 x < 8 ;
 x ++ ) pixel_ptr [ x ] = pix ;
 pixel_ptr += s -> stride ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , IgnoreProtocolHandler ) {
 registry ( ) -> OnIgnoreRegisterProtocolHandler ( test_protocol_handler ( ) ) ;
 ASSERT_TRUE ( registry ( ) -> IsIgnored ( test_protocol_handler ( ) ) ) ;
 registry ( ) -> RemoveIgnoredHandler ( test_protocol_handler ( ) ) ;
 ASSERT_FALSE ( registry ( ) -> IsIgnored ( test_protocol_handler ( ) ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( array_nl , T_STRING ) ;
 len = RSTRING_LEN ( array_nl ) ;
 if ( len == 0 ) {
 if ( state -> array_nl ) {
 ruby_xfree ( state -> array_nl ) ;
 state -> array_nl = NULL ;
 }
 }
 else {
 if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;
 state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;
 state -> array_nl_len = len ;
 }
 return Qnil ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uchar * get_key_column ( GRANT_COLUMN * buff , size_t * length , my_bool not_used __attribute__ ( ( unused ) ) ) {
 * length = buff -> key_length ;
 return ( uchar * ) buff -> column ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_poll_ctrl_attr_data ( proto_tree * tree , tvbuff_t * tvb , guint * offset , guint16 attr_id _U_ , guint data_type ) {
 dissect_zcl_attr_data ( tvb , tree , offset , data_type ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline unsigned int next_commit_index ( unsigned int idx ) {
 static const unsigned int MIN_COMMITS = 100 ;
 static const unsigned int MAX_COMMITS = 5000 ;
 static const unsigned int MUST_REGION = 100 ;
 static const unsigned int MIN_REGION = 20000 ;
 unsigned int offset , next ;
 if ( idx <= MUST_REGION ) return 0 ;
 if ( idx <= MIN_REGION ) {
 offset = idx - MUST_REGION ;
 return ( offset < MIN_COMMITS ) ? offset : MIN_COMMITS ;
 }
 offset = idx - MIN_REGION ;
 next = ( offset < MAX_COMMITS ) ? offset : MAX_COMMITS ;
 return ( next > MIN_COMMITS ) ? next : MIN_COMMITS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_e164Address ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , ""0123456789#*,"" , 13 , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint32 get_uint32 ( tvbuff_t * tvb , gint32 offset , gint encoding ) {
 return ( ENC_BIG_ENDIAN == encoding ) ? tvb_get_ntohl ( tvb , offset ) : tvb_get_letohl ( tvb , offset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {
 int ret ;
 int i ;
 uint8_t * buf ;
 if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {
 return ENOMEM ;
 }
 memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;
 for ( i = 0 ;
 i < ( 2 << 20 ) ;
 i += 256 ) {
 int j ;
 int off = mt_random ( & static_mtrand ) % 10 ;
 for ( j = 0 ;
 j < 256 ;
 j ++ ) {
 buf [ i + j ] = j + off ;
 }
 }
 if ( SIZEOF_XOFF_T == 4 ) {
 ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;
 if ( ret == XD3_INVALID_INPUT && MSG_IS ( ""decoder file offset overflow"" ) ) {
 ret = 0 ;
 }
 else {
 XPR ( NT XD3_LIB_ERRMSG ( stream , ret ) ) ;
 stream -> msg = ""expected overflow condition"" ;
 ret = XD3_INTERNAL ;
 goto fail ;
 }
 }
 if ( ( ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , << 12 ) ) ) {
 goto fail ;
 }
 fail : free ( buf ) ;
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __inline __uint64_t __uint64_identity ( __uint64_t __x ) {
 return __x ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void evhttp_send ( struct evhttp_request * req , struct evbuffer * databuf ) {
 struct evhttp_connection * evcon = req -> evcon ;
 assert ( TAILQ_FIRST ( & evcon -> requests ) == req ) ;
 if ( databuf != NULL ) evbuffer_add_buffer ( req -> output_buffer , databuf ) ;
 evhttp_make_header ( evcon , req ) ;
 evhttp_write_buffer ( evcon , evhttp_send_done , NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_INTEGER_1_32 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 32U , NULL , FALSE ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"char * curl_easy_unescape ( struct Curl_easy * data , const char * string , int length , int * olen ) {
 char * str = NULL ;
 if ( length >= 0 ) {
 size_t inputlen = length ;
 size_t outputlen ;
 CURLcode res = Curl_urldecode ( data , string , inputlen , & str , & outputlen , FALSE ) ;
 if ( res ) return NULL ;
 if ( olen ) * olen = curlx_uztosi ( outputlen ) ;
 }
 return str ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decode_color_temperature ( gchar * s , guint16 value ) {
 if ( value == 0 ) {
 g_snprintf ( s , ITEM_LABEL_LENGTH , ""%u [Mired]"" , value ) ;
 }
 else {
 g_snprintf ( s , ITEM_LABEL_LENGTH , ""%u [Mired] (%u [K])"" , value , 1000000 / value ) ;
 }
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _CompoundTextClose ( UConverter * converter ) {
 UConverterDataCompoundText * myConverterData = ( UConverterDataCompoundText * ) ( converter -> extraInfo ) ;
 int32_t i ;
 if ( converter -> extraInfo != NULL ) {
 for ( i = 0 ;
 i < NUM_OF_CONVERTERS ;
 i ++ ) {
 if ( myConverterData -> myConverterArray [ i ] != NULL ) {
 ucnv_unloadSharedDataIfReady ( myConverterData -> myConverterArray [ i ] ) ;
 }
 }
 uprv_free ( converter -> extraInfo ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void one_remote_ref ( const char * refname ) {
 struct ref * ref ;
 struct object * obj ;
 ref = alloc_ref ( refname ) ;
 if ( http_fetch_ref ( repo -> url , ref ) != 0 ) {
 fprintf ( stderr , ""Unable to fetch ref %s from %s\n"" , refname , repo -> url ) ;
 free ( ref ) ;
 return ;
 }
 if ( repo -> can_update_info_refs && ! has_object_file ( & ref -> old_oid ) ) {
 obj = lookup_unknown_object ( ref -> old_oid . hash ) ;
 if ( obj ) {
 fprintf ( stderr , "" fetch %s for %s\n"" , oid_to_hex ( & ref -> old_oid ) , refname ) ;
 add_fetch_request ( obj ) ;
 }
 }
 ref -> next = remote_refs ;
 remote_refs = ref ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void * main_malloc ( size_t size ) {
 void * r = main_malloc1 ( size ) ;
 if ( r ) {
 IF_DEBUG ( main_mallocs += 1 ) ;
 }
 return r ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , eof ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_BOOL ( php_stream_eof ( intern -> u . file . stream ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int option_parse_unpack_unreachable ( const struct option * opt , const char * arg , int unset ) {
 if ( unset ) {
 unpack_unreachable = 0 ;
 unpack_unreachable_expiration = 0 ;
 }
 else {
 unpack_unreachable = 1 ;
 if ( arg ) unpack_unreachable_expiration = approxidate ( arg ) ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST ( DownloadPrefsTest , NoAutoOpenForDisallowedFileTypes ) {
 const base : : FilePath kDangerousFilePath ( FILE_PATH_LITERAL ( ""/b/very-bad.swf"" ) ) ;
 content : : TestBrowserThreadBundle threads_are_required_for_testing_profile ;
 TestingProfile profile ;
 DownloadPrefs prefs ( & profile ) ;
 EXPECT_FALSE ( prefs . EnableAutoOpenBasedOnExtension ( kDangerousFilePath ) ) ;
 EXPECT_FALSE ( prefs . IsAutoOpenEnabledBasedOnExtension ( kDangerousFilePath ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_horizontal_16_sse2 ( unsigned char * s , int p , const unsigned char * _blimit , const unsigned char * _limit , const unsigned char * _thresh , int count ) {
 if ( count == 1 ) mb_lpf_horizontal_edge_w_sse2_8 ( s , p , _blimit , _limit , _thresh ) ;
 else mb_lpf_horizontal_edge_w_sse2_16 ( s , p , _blimit , _limit , _thresh ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int libspeex_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 LibSpeexContext * s = avctx -> priv_data ;
 AVFrame * frame = data ;
 int16_t * output ;
 int ret , consumed = 0 ;
 frame -> nb_samples = s -> frame_size ;
 if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 output = ( int16_t * ) frame -> data [ 0 ] ;
 if ( speex_bits_remaining ( & s -> bits ) < 5 || speex_bits_peek_unsigned ( & s -> bits , 5 ) == 0x1F ) {
 if ( ! buf || ! buf_size ) {
 * got_frame_ptr = 0 ;
 return buf_size ;
 }
 speex_bits_read_from ( & s -> bits , buf , buf_size ) ;
 consumed = buf_size ;
 }
 ret = speex_decode_int ( s -> dec_state , & s -> bits , output ) ;
 if ( ret <= - 2 ) {
 av_log ( avctx , AV_LOG_ERROR , ""Error decoding Speex frame.\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 if ( avctx -> channels == 2 ) speex_decode_stereo_int ( output , s -> frame_size , & s -> stereo ) ;
 * got_frame_ptr = 1 ;
 return consumed ;
 }",1
Detect whether the following code contains vulnerabilities.,"static unsigned int get_joining_type ( hb_codepoint_t u , hb_unicode_general_category_t gen_cat ) {
 unsigned int j_type = joining_type ( u ) ;
 if ( likely ( j_type != JOINING_TYPE_X ) ) return j_type ;
 return ( FLAG ( gen_cat ) & ( FLAG ( HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ) | FLAG ( HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK ) | FLAG ( HB_UNICODE_GENERAL_CATEGORY_FORMAT ) ) ) ? JOINING_TYPE_T : JOINING_TYPE_U ;
 }",1
Detect whether the following code contains vulnerabilities.,"int evbuffer_remove ( struct evbuffer * buf , void * data , size_t datlen ) {
 size_t nread = datlen ;
 if ( nread >= buf -> off ) nread = buf -> off ;
 memcpy ( data , buf -> buffer , nread ) ;
 evbuffer_drain ( buf , nread ) ;
 return ( nread ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {
 SvcInternal * const si = get_svc_internal ( svc_ctx ) ;
 if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {
 return VPX_CODEC_INVALID_PARAM ;
 }
 strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;
 si -> quantizers [ sizeof ( si -> quantizers ) - 1 ] = '\0' ;
 return VPX_CODEC_OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void option_depth ( const char * depth ) {
 max_depth = ulong_arg ( ""--depth"" , depth ) ;
 if ( max_depth > MAX_DEPTH ) die ( ""--depth cannot exceed %u"" , MAX_DEPTH ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int TSMimeHdrFieldEqual ( TSMBuffer bufp , TSMLoc hdr_obj , TSMLoc field1_obj , TSMLoc field2_obj ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_field_handle ( field1_obj , hdr_obj ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_field_handle ( field2_obj , hdr_obj ) == TS_SUCCESS ) ;
 MIMEFieldSDKHandle * field1_handle = ( MIMEFieldSDKHandle * ) field1_obj ;
 MIMEFieldSDKHandle * field2_handle = ( MIMEFieldSDKHandle * ) field2_obj ;
 if ( ( field1_handle == nullptr ) || ( field2_handle == nullptr ) ) {
 return ( field1_handle == field2_handle ) ;
 }
 return ( field1_handle -> field_ptr == field2_handle -> field_ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( array_nl , T_STRING ) ;
 len = RSTRING_LEN ( array_nl ) ;
 if ( len == 0 ) {
 if ( state -> array_nl ) {
 ruby_xfree ( state -> array_nl ) ;
 state -> array_nl = NULL ;
 }
 }
 else {
 if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;
 state -> array_nl = fstrndup ( RSTRING_PTR ( array_nl ) , len ) ;
 state -> array_nl_len = len ;
 }
 return Qnil ;
 }",0
Detect whether the following code contains vulnerabilities.,"const char * TSHttpHdrMethodGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;
 sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;
 HTTPHdr h ;
 SET_HTTP_HDR ( h , bufp , obj ) ;
 return h . method_get ( length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void mark_commit ( struct commit * c , void * data ) {
 mark_object ( & c -> object , NULL , NULL , data ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void xhci_run ( XHCIState * xhci ) {
 trace_usb_xhci_run ( ) ;
 xhci -> usbsts &= ~ USBSTS_HCH ;
 xhci -> mfindex_start = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static enum nss_status gaih_getanswer ( const querybuf * answer1 , int anslen1 , const querybuf * answer2 , int anslen2 , const char * qname , struct gaih_addrtuple * * pat , char * buffer , size_t buflen , int * errnop , int * h_errnop , int32_t * ttlp ) {
 int first = 1 ;
 enum nss_status status = NSS_STATUS_NOTFOUND ;
 if ( anslen1 > 0 ) status = gaih_getanswer_slice ( answer1 , anslen1 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;
 if ( ( status == NSS_STATUS_SUCCESS || status == NSS_STATUS_NOTFOUND || ( status == NSS_STATUS_TRYAGAIN && ( * errnop != ERANGE || * h_errnop == NO_RECOVERY ) ) ) && answer2 != NULL && anslen2 > 0 ) {
 enum nss_status status2 = gaih_getanswer_slice ( answer2 , anslen2 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;
 if ( status != NSS_STATUS_SUCCESS && status2 != NSS_STATUS_NOTFOUND ) status = status2 ;
 }
 return status ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _HZOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * errorCode ) {
 UConverter * gbConverter ;
 if ( pArgs -> onlyTestIsLoadable ) {
 ucnv_canCreateConverter ( ""GBK"" , errorCode ) ;
 return ;
 }
 gbConverter = ucnv_open ( ""GBK"" , errorCode ) ;
 if ( U_FAILURE ( * errorCode ) ) {
 return ;
 }
 cnv -> toUnicodeStatus = 0 ;
 cnv -> fromUnicodeStatus = 0 ;
 cnv -> mode = 0 ;
 cnv -> fromUChar32 = 0x0000 ;
 cnv -> extraInfo = uprv_calloc ( 1 , sizeof ( UConverterDataHZ ) ) ;
 if ( cnv -> extraInfo != NULL ) {
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter = gbConverter ;
 }
 else {
 ucnv_close ( gbConverter ) ;
 * errorCode = U_MEMORY_ALLOCATION_ERROR ;
 return ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_CloseLogicalChannelAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CloseLogicalChannelAck , CloseLogicalChannelAck_sequence ) ;
 # line 554 ""../../asn1/h245/h245.cnf"" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_CloseLogChnAck ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( WebFrameTest , ContextMenuDataNonLocatedMenu ) {
 ContextMenuWebFrameClient frame ;
 FrameTestHelpers : : WebViewHelper web_view_helper ;
 WebViewImpl * web_view = web_view_helper . Initialize ( & frame ) ;
 const std : : string & html = ""<div style='font-size: 1000%;
 line-height: 0.7em'>Select me<br/>"" ""Next line</div>"" ;
 FrameTestHelpers : : LoadHTMLString ( web_view -> MainFrameImpl ( ) , html , ToKURL ( ""about:blank"" ) ) ;
 web_view -> Resize ( WebSize ( 500 , 300 ) ) ;
 web_view -> UpdateAllLifecyclePhases ( ) ;
 RunPendingTasks ( ) ;
 web_view -> SetInitialFocus ( false ) ;
 RunPendingTasks ( ) ;
 WebMouseEvent mouse_event ( WebInputEvent : : kMouseDown , WebInputEvent : : kNoModifiers , WebInputEvent : : GetStaticTimeStampForTests ( ) ) ;
 mouse_event . button = WebMouseEvent : : Button : : kLeft ;
 mouse_event . SetPositionInWidget ( 0 , 0 ) ;
 mouse_event . click_count = 2 ;
 web_view -> HandleInputEvent ( WebCoalescedInputEvent ( mouse_event ) ) ;
 web_view -> ShowContextMenu ( kMenuSourceTouch ) ;
 RunPendingTasks ( ) ;
 web_view_helper . Reset ( ) ;
 EXPECT_EQ ( frame . GetMenuData ( ) . source_type , kMenuSourceTouch ) ;
 EXPECT_FALSE ( frame . GetMenuData ( ) . selected_text . IsEmpty ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_empty_flg ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 375 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;
 # line 379 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_EMPTY ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int linux_udev_stop_event_monitor ( void ) {
 char dummy = 1 ;
 int r ;
 assert ( udev_ctx != NULL ) ;
 assert ( udev_monitor != NULL ) ;
 assert ( udev_monitor_fd != - 1 ) ;
 r = usbi_write ( udev_control_pipe [ 1 ] , & dummy , sizeof ( dummy ) ) ;
 if ( r <= 0 ) {
 usbi_warn ( NULL , ""udev control pipe signal failed"" ) ;
 }
 pthread_join ( linux_event_thread , NULL ) ;
 udev_monitor_unref ( udev_monitor ) ;
 udev_monitor = NULL ;
 udev_monitor_fd = - 1 ;
 udev_unref ( udev_ctx ) ;
 udev_ctx = NULL ;
 close ( udev_control_pipe [ 0 ] ) ;
 close ( udev_control_pipe [ 1 ] ) ;
 udev_control_pipe [ 0 ] = - 1 ;
 udev_control_pipe [ 1 ] = - 1 ;
 return LIBUSB_SUCCESS ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( RecursiveDirectoryIterator , getSubPath ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( intern -> u . dir . sub_path ) {
 RETURN_STRINGL ( intern -> u . dir . sub_path , intern -> u . dir . sub_path_len , 1 ) ;
 }
 else {
 RETURN_STRINGL ( """" , 0 , 1 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void indent ( int32_t count , FILE * f ) {
 char c [ BUF_SIZE ] ;
 if ( count <= 0 ) {
 return ;
 }
 if ( count < BUF_SIZE ) {
 memset ( c , ( int ) ' ' , count ) ;
 fwrite ( c , sizeof ( char ) , count , f ) ;
 }
 else {
 int32_t i ;
 for ( i = 0 ;
 i < count ;
 ++ i ) putc ( ' ' , f ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int read_sbr_single_channel_element ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb ) {
 if ( get_bits1 ( gb ) ) skip_bits ( gb , 4 ) ;
 if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;
 read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ;
 read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ;
 read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;
 read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;
 if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlChar * xsltEvalTemplateString ( xsltTransformContextPtr ctxt , xmlNodePtr contextNode , xmlNodePtr inst ) {
 xmlNodePtr oldInsert , insert = NULL ;
 xmlChar * ret ;
 if ( ( ctxt == NULL ) || ( contextNode == NULL ) || ( inst == NULL ) ) return ( NULL ) ;
 if ( inst -> children == NULL ) return ( NULL ) ;
 insert = xmlNewDocNode ( ctxt -> output , NULL , ( const xmlChar * ) ""fake"" , NULL ) ;
 if ( insert == NULL ) {
 xsltTransformError ( ctxt , NULL , contextNode , ""Failed to create temporary node\n"" ) ;
 return ( NULL ) ;
 }
 oldInsert = ctxt -> insert ;
 ctxt -> insert = insert ;
 xsltApplyOneTemplate ( ctxt , contextNode , inst -> children , NULL , NULL ) ;
 ctxt -> insert = oldInsert ;
 ret = xmlNodeGetContent ( insert ) ;
 if ( insert != NULL ) xmlFreeNode ( insert ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void _Latin1GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 sa -> addRange ( sa -> set , 0 , 0xff ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {
 char * name = path_name ( path , last ) ;
 add_preferred_base_object ( name ) ;
 add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;
 obj -> flags |= OBJECT_ADDED ;
 free ( ( char * ) name ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_vertical_8_sse2 ( unsigned char * s , int p , const unsigned char * blimit , const unsigned char * limit , const unsigned char * thresh , int count ) {
 DECLARE_ALIGNED_ARRAY ( 8 , unsigned char , t_dst , 8 * 8 ) ;
 unsigned char * src [ 1 ] ;
 unsigned char * dst [ 1 ] ;
 ( void ) count ;
 src [ 0 ] = s - 4 ;
 dst [ 0 ] = t_dst ;
 transpose ( src , p , dst , 8 , 1 ) ;
 vp9_lpf_horizontal_8_sse2 ( t_dst + 4 * 8 , 8 , blimit , limit , thresh , 1 ) ;
 src [ 0 ] = t_dst ;
 dst [ 0 ] = s - 4 ;
 transpose ( src , 8 , dst , p , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {
 struct rfc822_parser_context parser ;
 const char * const * results , * filename2 ;
 string_t * str ;
 * filename_r = NULL ;
 if ( content_disposition == NULL ) return ;
 rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 str = t_str_new ( 32 ) ;
 if ( rfc822_parse_mime_token ( & parser , str ) < 0 ) return ;
 rfc2231_parse ( & parser , & results ) ;
 filename2 = NULL ;
 for ( ;
 * results != NULL ;
 results += 2 ) {
 if ( strcasecmp ( results [ 0 ] , ""filename"" ) == 0 ) {
 * filename_r = results [ 1 ] ;
 break ;
 }
 if ( strcasecmp ( results [ 0 ] , ""filename*"" ) == 0 ) filename2 = results [ 1 ] ;
 }
 if ( * filename_r == NULL ) {
 * filename_r = filename2 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static apr_status_t modsecurity_process_phase_response_headers ( modsec_rec * msr ) {
 apr_time_t time_before ;
 apr_status_t rc = 0 ;
 if ( msr -> allow_scope == ACTION_ALLOW ) {
 if ( msr -> txcfg -> debuglog_level >= 4 ) {
 msr_log ( msr , 4 , ""Skipping phase RESPONSE_HEADERS (allow used)."" ) ;
 }
 return 0 ;
 }
 else {
 if ( msr -> txcfg -> debuglog_level >= 4 ) {
 msr_log ( msr , 4 , ""Starting phase RESPONSE_HEADERS."" ) ;
 }
 }
 time_before = apr_time_now ( ) ;
 if ( msr -> txcfg -> ruleset != NULL ) {
 rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;
 }
 msr -> time_phase3 = apr_time_now ( ) - time_before ;
 return rc ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UChar32 _Latin1GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {
 const uint8_t * source = ( const uint8_t * ) pArgs -> source ;
 if ( source < ( const uint8_t * ) pArgs -> sourceLimit ) {
 pArgs -> source = ( const char * ) ( source + 1 ) ;
 return * source ;
 }
 * pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR ;
 return 0xffff ;
 }",1
Detect whether the following code contains vulnerabilities.,"int mbfl_oddlen ( mbfl_string * string ) {
 int len , n , m , k ;
 unsigned char * p ;
 const unsigned char * mbtab ;
 const mbfl_encoding * encoding ;
 if ( string == NULL ) {
 return - 1 ;
 }
 encoding = mbfl_no2encoding ( string -> no_encoding ) ;
 if ( encoding == NULL ) {
 return - 1 ;
 }
 len = 0 ;
 if ( encoding -> flag & MBFL_ENCTYPE_SBCS ) {
 return 0 ;
 }
 else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE ) ) {
 return len % 2 ;
 }
 else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) {
 return len % 4 ;
 }
 else if ( encoding -> mblen_table != NULL ) {
 mbtab = encoding -> mblen_table ;
 n = 0 ;
 p = string -> val ;
 k = string -> len ;
 if ( p != NULL ) {
 while ( n < k ) {
 m = mbtab [ * p ] ;
 n += m ;
 p += m ;
 }
 ;
 }
 return n - k ;
 }
 else {
 return 0 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_quantize_dc ( const int16_t * coeff_ptr , int skip_block , const int16_t * round_ptr , const int16_t quant , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t dequant_ptr , uint16_t * eob_ptr ) {
 const int rc = 0 ;
 const int coeff = coeff_ptr [ rc ] ;
 const int coeff_sign = ( coeff >> 31 ) ;
 const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;
 int tmp , eob = - 1 ;
 if ( ! skip_block ) {
 tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;
 tmp = ( tmp * quant ) >> 16 ;
 qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;
 dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr ;
 if ( tmp ) eob = 0 ;
 }
 * eob_ptr = eob + 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_ParallelH245Control_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 361 ""./asn1/h225/h225.cnf"" tvbuff_t * h245_tvb = NULL ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h245_tvb ) ;
 next_tvb_add_handle ( & h245_list , h245_tvb , ( h225_h245_in_tree ) ? tree : NULL , h245dg_handle ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int opt_show_ ## section ( const char * opt , const char * arg ) {
 mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;
 return 0 ;
 }
 DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS )",0
Detect whether the following code contains vulnerabilities.,"void pkg_deleteList ( CharList * l ) {
 CharList * tmp ;
 while ( l != NULL ) {
 uprv_free ( ( void * ) l -> str ) ;
 tmp = l ;
 l = l -> next ;
 uprv_free ( tmp ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"MIMEField * _mime_hdr_field_list_search_by_slotnum ( MIMEHdrImpl * mh , int slotnum ) {
 unsigned int block_num , block_index ;
 MIMEFieldBlockImpl * fblock ;
 if ( slotnum < MIME_FIELD_BLOCK_SLOTS ) {
 fblock = & ( mh -> m_first_fblock ) ;
 block_index = slotnum ;
 if ( block_index >= fblock -> m_freetop ) {
 return nullptr ;
 }
 else {
 return & ( fblock -> m_field_slots [ block_index ] ) ;
 }
 }
 else {
 block_num = slotnum / MIME_FIELD_BLOCK_SLOTS ;
 block_index = slotnum % MIME_FIELD_BLOCK_SLOTS ;
 fblock = & ( mh -> m_first_fblock ) ;
 while ( block_num -- && fblock ) {
 fblock = fblock -> m_next ;
 }
 if ( ( fblock == nullptr ) || ( block_index >= fblock -> m_freetop ) ) {
 return nullptr ;
 }
 else {
 return & ( fblock -> m_field_slots [ block_index ] ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MultiplexEntrySend ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySend , MultiplexEntrySend_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void hscroll ( AVCodecContext * avctx ) {
 AnsiContext * s = avctx -> priv_data ;
 int i ;
 if ( s -> y < avctx -> height - s -> font_height ) {
 s -> y += s -> font_height ;
 return ;
 }
 i = 0 ;
 for ( ;
 i < avctx -> height - s -> font_height ;
 i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;
 for ( ;
 i < avctx -> height ;
 i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int rpza_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 RpzaContext * s = avctx -> priv_data ;
 int ret ;
 s -> buf = buf ;
 s -> size = buf_size ;
 s -> frame . reference = 1 ;
 s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""reget_buffer() failed\n"" ) ;
 return ret ;
 }
 rpza_decode_stream ( s ) ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , LoadingMetrics ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 auto waiter = CreatePageLoadMetricsWaiter ( ) ;
 waiter -> AddPageExpectation ( TimingField : : LOAD_TIMING_INFO ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/title1.html"" ) ) ;
 waiter -> Wait ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_delta ( struct rev_info * revs , struct remote_lock * lock ) {
 int i ;
 struct commit * commit ;
 struct object_list * * p = & objects ;
 int count = 0 ;
 while ( ( commit = get_revision ( revs ) ) != NULL ) {
 p = process_tree ( commit -> tree , p , NULL , """" ) ;
 commit -> object . flags |= LOCAL ;
 if ( ! ( commit -> object . flags & UNINTERESTING ) ) count += add_send_request ( & commit -> object , lock ) ;
 }
 for ( i = 0 ;
 i < revs -> pending . nr ;
 i ++ ) {
 struct object_array_entry * entry = revs -> pending . objects + i ;
 struct object * obj = entry -> item ;
 const char * name = entry -> name ;
 if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ;
 if ( obj -> type == OBJ_TAG ) {
 obj -> flags |= SEEN ;
 p = add_one_object ( obj , p ) ;
 continue ;
 }
 if ( obj -> type == OBJ_TREE ) {
 p = process_tree ( ( struct tree * ) obj , p , NULL , name ) ;
 continue ;
 }
 if ( obj -> type == OBJ_BLOB ) {
 p = process_blob ( ( struct blob * ) obj , p , NULL , name ) ;
 continue ;
 }
 die ( ""unknown pending object %s (%s)"" , oid_to_hex ( & obj -> oid ) , name ) ;
 }
 while ( objects ) {
 if ( ! ( objects -> item -> flags & UNINTERESTING ) ) count += add_send_request ( objects -> item , lock ) ;
 objects = objects -> next ;
 }
 return count ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dec_lpc_spectrum_inv ( TwinContext * tctx , float * lsp , enum FrameType ftype , float * lpc ) {
 int i ;
 int size = tctx -> mtab -> size / tctx -> mtab -> fmode [ ftype ] . sub ;
 for ( i = 0 ;
 i < tctx -> mtab -> n_lsp ;
 i ++ ) lsp [ i ] = 2 * cos ( lsp [ i ] ) ;
 switch ( ftype ) {
 case FT_LONG : eval_lpcenv_2parts ( tctx , ftype , lsp , lpc , size , 8 ) ;
 break ;
 case FT_MEDIUM : eval_lpcenv_2parts ( tctx , ftype , lsp , lpc , size , 2 ) ;
 break ;
 case FT_SHORT : eval_lpcenv ( tctx , lsp , lpc ) ;
 break ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void fixup ( UScriptRun * scriptRun , UScriptCode scriptCode ) {
 int32_t fixupSP = DEC ( scriptRun -> parenSP , scriptRun -> fixupCount ) ;
 while ( scriptRun -> fixupCount -- > 0 ) {
 fixupSP = INC1 ( fixupSP ) ;
 scriptRun -> parenStack [ fixupSP ] . scriptCode = scriptCode ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestDisablePreventsHandling ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""test"" , ""test1"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 ASSERT_TRUE ( registry ( ) -> IsHandledProtocol ( ""test"" ) ) ;
 registry ( ) -> Disable ( ) ;
 ASSERT_FALSE ( registry ( ) -> IsHandledProtocol ( ""test"" ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void tee_puts ( const char * s , FILE * file ) {
 fputs ( s , file ) ;
 fputc ( '\n' , file ) ;
 if ( opt_outfile ) {
 fputs ( s , OUTFILE ) ;
 fputc ( '\n' , OUTFILE ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_int ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , gint32 value ) {
 proto_item * pi = NULL ;
 header_field_info * hfinfo ;
 CHECK_FOR_NULL_TREE ( tree ) ;
 TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;
 switch ( hfinfo -> type ) {
 case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;
 proto_tree_set_int ( PNODE_FINFO ( pi ) , value ) ;
 break ;
 default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;
 }
 return pi ;
 }",0
Detect whether the following code contains vulnerabilities.,"void printFirst ( UBreakIterator * boundary , UChar * str ) {
 int32_t end ;
 int32_t start = ubrk_first ( boundary ) ;
 end = ubrk_next ( boundary ) ;
 printTextRange ( str , start , end ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void cirrus_mem_writeb_mode4and5_8bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {
 int x ;
 unsigned val = mem_value ;
 uint8_t * dst ;
 dst = s -> vga . vram_ptr + ( offset &= s -> cirrus_addr_mask ) ;
 for ( x = 0 ;
 x < 8 ;
 x ++ ) {
 if ( val & 0x80 ) {
 * dst = s -> cirrus_shadow_gr1 ;
 }
 else if ( mode == 5 ) {
 * dst = s -> cirrus_shadow_gr0 ;
 }
 val <<= 1 ;
 dst ++ ;
 }
 memory_region_set_dirty ( & s -> vga . vram , offset , 8 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( FilesystemIterator , current ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_PATHNAME ) ) {
 spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;
 RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;
 }
 else if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ) {
 spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;
 spl_filesystem_object_create_type ( 0 , intern , SPL_FS_INFO , NULL , return_value TSRMLS_CC ) ;
 }
 else {
 RETURN_ZVAL ( getThis ( ) , 1 , 0 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , MAYBE_TestInstallDefaultHandler ) {
 RecreateRegistry ( false ) ;
 registry ( ) -> AddPredefinedHandler ( CreateProtocolHandler ( ""test"" , GURL ( ""http://test.com/%s"" ) , ""Test"" ) ) ;
 registry ( ) -> InitProtocolSettings ( ) ;
 std : : vector < std : : string > protocols ;
 registry ( ) -> GetRegisteredProtocols ( & protocols ) ;
 ASSERT_EQ ( static_cast < size_t > ( 1 ) , protocols . size ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_ref ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int idx , int mi_row , int mi_col ) {
 MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;
 RefBuffer * ref_buffer = & cm -> frame_refs [ mbmi -> ref_frame [ idx ] - LAST_FRAME ] ;
 xd -> block_refs [ idx ] = ref_buffer ;
 if ( ! vp9_is_valid_scale ( & ref_buffer -> sf ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , ""Invalid scale factors"" ) ;
 if ( ref_buffer -> buf -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , ""Block reference is corrupt"" ) ;
 vp9_setup_pre_planes ( xd , idx , ref_buffer -> buf , mi_row , mi_col , & ref_buffer -> sf ) ;
 xd -> corrupted |= ref_buffer -> buf -> corrupted ;
 }",1
Detect whether the following code contains vulnerabilities.,"static long srec_canonicalize_symtab ( bfd * abfd , asymbol * * alocation ) {
 bfd_size_type symcount = bfd_get_symcount ( abfd ) ;
 asymbol * csymbols ;
 unsigned int i ;
 csymbols = abfd -> tdata . srec_data -> csymbols ;
 if ( csymbols == NULL && symcount != 0 ) {
 asymbol * c ;
 struct srec_symbol * s ;
 csymbols = ( asymbol * ) bfd_alloc ( abfd , symcount * sizeof ( asymbol ) ) ;
 if ( csymbols == NULL ) return - 1 ;
 abfd -> tdata . srec_data -> csymbols = csymbols ;
 for ( s = abfd -> tdata . srec_data -> symbols , c = csymbols ;
 s != NULL ;
 s = s -> next , ++ c ) {
 c -> the_bfd = abfd ;
 c -> name = s -> name ;
 c -> value = s -> val ;
 c -> flags = BSF_GLOBAL ;
 c -> section = bfd_abs_section_ptr ;
 c -> udata . p = NULL ;
 }
 }
 for ( i = 0 ;
 i < symcount ;
 i ++ ) * alocation ++ = csymbols ++ ;
 * alocation = NULL ;
 return symcount ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int check_user_and_ip ( int userid , struct query * q ) {
 struct sockaddr_in * tempin ;
 if ( userid < 0 || userid >= created_users ) {
 return 1 ;
 }
 if ( ! users [ userid ] . active || users [ userid ] . disabled ) {
 return 1 ;
 }
 if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) {
 return 1 ;
 }
 if ( ! check_ip ) {
 return 0 ;
 }
 tempin = ( struct sockaddr_in * ) & ( q -> from ) ;
 return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * pathToFullPath ( const char * path , const char * source ) {
 int32_t length ;
 int32_t newLength ;
 char * fullPath ;
 int32_t n ;
 length = ( uint32_t ) ( uprv_strlen ( path ) + 1 ) ;
 newLength = ( length + 1 + ( int32_t ) uprv_strlen ( source ) ) ;
 fullPath = ( char * ) uprv_malloc ( newLength ) ;
 if ( source != NULL ) {
 uprv_strcpy ( fullPath , source ) ;
 uprv_strcat ( fullPath , U_FILE_SEP_STRING ) ;
 }
 else {
 fullPath [ 0 ] = 0 ;
 }
 n = ( int32_t ) uprv_strlen ( fullPath ) ;
 fullPath [ n ] = 0 ;
 uprv_strcat ( fullPath , path ) ;
 # if ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) for ( ;
 fullPath [ n ] ;
 n ++ ) {
 if ( fullPath [ n ] == U_FILE_ALT_SEP_CHAR ) {
 fullPath [ n ] = U_FILE_SEP_CHAR ;
 }
 }
 # endif # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( ;
 fullPath [ n ] ;
 n ++ ) {
 if ( fullPath [ n ] == U_TREE_ENTRY_SEP_CHAR ) {
 fullPath [ n ] = U_FILE_SEP_CHAR ;
 }
 }
 # endif return fullPath ;
 }",0
Detect whether the following code contains vulnerabilities.,"int main ( int argc , char * * argv ) {
 if ( argc > 1 && ! strcmp ( argv [ 1 ] , ""--verbose"" ) ) verbose = 1 ;
 else if ( argc > 1 && ! strcmp ( argv [ 1 ] , ""--debug"" ) ) verbose = debug = 1 ;
 if ( ! gcry_check_version ( GCRYPT_VERSION ) ) die ( ""version mismatch\n"" ) ;
 gcry_control ( GCRYCTL_DISABLE_SECMEM , 0 ) ;
 gcry_control ( GCRYCTL_ENABLE_QUICK_RANDOM , 0 ) ;
 if ( debug ) gcry_control ( GCRYCTL_SET_DEBUG_FLAGS , 1u , 0 ) ;
 gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;
 set_get_point ( ) ;
 context_alloc ( ) ;
 context_param ( ) ;
 basic_ec_math ( ) ;
 basic_ec_math_simplified ( ) ;
 show ( ""All tests completed. Errors: %d\n"" , error_count ) ;
 return error_count ? 1 : 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void mc_part ( H264Context * h , int n , int square , int height , int delta , uint8_t * dest_y , uint8_t * dest_cb , uint8_t * dest_cr , int x_offset , int y_offset , qpel_mc_func * qpix_put , h264_chroma_mc_func chroma_put , qpel_mc_func * qpix_avg , h264_chroma_mc_func chroma_avg , h264_weight_func * weight_op , h264_biweight_func * weight_avg , int list0 , int list1 ) {
 if ( ( h -> use_weight == 2 && list0 && list1 && ( h -> implicit_weight [ h -> ref_cache [ 0 ] [ scan8 [ n ] ] ] [ h -> ref_cache [ 1 ] [ scan8 [ n ] ] ] [ h -> mb_y & 1 ] != 32 ) ) || h -> use_weight == 1 ) mc_part_weighted ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , weight_op [ 0 ] , weight_op [ 1 ] , weight_avg [ 0 ] , weight_avg [ 1 ] , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;
 else mc_part_std ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , qpix_avg , chroma_avg , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SiteDetailsBrowserTest , PlatformAppsNotIsolated ) {
 if ( content : : AreAllSitesIsolatedForTesting ( ) ) return ;
 CreateAppWithSandboxPage ( ""Extension One"" ) ;
 scoped_refptr < TestMemoryDetails > details = new TestMemoryDetails ( ) ;
 details -> StartFetchAndWait ( ) ;
 EXPECT_EQ ( 0 , details -> GetOutOfProcessIframeCount ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void graph_analysis_data_init ( void ) {
 the_tapinfo_struct . graph_analysis = ( seq_analysis_info_t * ) g_malloc ( sizeof ( seq_analysis_info_t ) ) ;
 the_tapinfo_struct . graph_analysis -> nconv = 0 ;
 the_tapinfo_struct . graph_analysis -> list = NULL ;
 the_tapinfo_struct . graph_analysis -> ht = g_hash_table_new ( g_int_hash , g_int_equal ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) {
 int start_index = rc -> worst_quality ;
 int target_index = rc -> worst_quality ;
 int i ;
 for ( i = rc -> best_quality ;
 i < rc -> worst_quality ;
 ++ i ) {
 start_index = i ;
 if ( vp9_convert_qindex_to_q ( i ) >= qstart ) break ;
 }
 for ( i = rc -> best_quality ;
 i < rc -> worst_quality ;
 ++ i ) {
 target_index = i ;
 if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) break ;
 }
 return target_index - start_index ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {
 int mi_row , mi_col ;
 int mi_index = 0 ;
 MODE_INFO * * mi = cm -> mi_grid_visible ;
 int rows = cm -> mi_rows ;
 int cols = cm -> mi_cols ;
 char prefix = descriptor [ 0 ] ;
 log_frame_info ( cm , descriptor , file ) ;
 mi_index = 0 ;
 for ( mi_row = 0 ;
 mi_row < rows ;
 mi_row ++ ) {
 fprintf ( file , ""%c "" , prefix ) ;
 for ( mi_col = 0 ;
 mi_col < cols ;
 mi_col ++ ) {
 fprintf ( file , ""%2d "" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;
 mi_index ++ ;
 }
 fprintf ( file , ""\n"" ) ;
 mi_index += 8 ;
 }
 fprintf ( file , ""\n"" ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void free_cal ( fz_context * ctx , fz_colorspace * cs ) {
 fz_cal_colorspace * cal_data = cs -> data ;
 if ( cal_data -> profile != NULL ) {
 fz_drop_buffer ( ctx , cal_data -> profile -> buffer ) ;
 fz_cmm_fin_profile ( ctx , cal_data -> profile ) ;
 fz_free ( ctx , cal_data -> profile ) ;
 }
 fz_free ( ctx , cal_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static guint16 de_clg_party_sub_addr ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {
 gchar * extr_addr ;
 de_sub_addr ( tvb , tree , pinfo , offset , len , & extr_addr ) ;
 if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , "" - (%s)"" , extr_addr ) ;
 return ( len ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {
 int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;
 if ( s != sizeof ( MBSPatchHeader ) ) return READ_ERROR ;
 header -> slen = ntohl ( header -> slen ) ;
 header -> scrc32 = ntohl ( header -> scrc32 ) ;
 header -> dlen = ntohl ( header -> dlen ) ;
 header -> cblen = ntohl ( header -> cblen ) ;
 header -> difflen = ntohl ( header -> difflen ) ;
 header -> extralen = ntohl ( header -> extralen ) ;
 struct stat hs ;
 s = fstat ( fd , & hs ) ;
 if ( s ) return READ_ERROR ;
 if ( memcmp ( header -> tag , ""MBDIFF10"" , 8 ) != 0 ) return UNEXPECTED_ERROR ;
 if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;
 return OK ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void idct_put ( ASV1Context * a , int mb_x , int mb_y ) {
 int16_t ( * block ) [ 64 ] = a -> block ;
 int linesize = a -> picture . linesize [ 0 ] ;
 uint8_t * dest_y = a -> picture . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = a -> picture . data [ 1 ] + ( mb_y * 8 * a -> picture . linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = a -> picture . data [ 2 ] + ( mb_y * 8 * a -> picture . linesize [ 2 ] ) + mb_x * 8 ;
 a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;
 if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 a -> dsp . idct_put ( dest_cb , a -> picture . linesize [ 1 ] , block [ 4 ] ) ;
 a -> dsp . idct_put ( dest_cr , a -> picture . linesize [ 2 ] , block [ 5 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line32_be ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {
 int w ;
 uint32_t r , g , b ;
 w = width ;
 do {
 r = vga_read_byte ( vga , addr + 1 ) ;
 g = vga_read_byte ( vga , addr + 2 ) ;
 b = vga_read_byte ( vga , addr + 3 ) ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 addr += 4 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static List * fetch_function_defaults ( HeapTuple func_tuple ) {
 List * defaults ;
 Datum proargdefaults ;
 bool isnull ;
 char * str ;
 proargdefaults = SysCacheGetAttr ( PROCOID , func_tuple , Anum_pg_proc_proargdefaults , & isnull ) ;
 if ( isnull ) elog ( ERROR , ""not enough default arguments"" ) ;
 str = TextDatumGetCString ( proargdefaults ) ;
 defaults = ( List * ) stringToNode ( str ) ;
 Assert ( IsA ( defaults , List ) ) ;
 pfree ( str ) ;
 return defaults ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( DirectoryIterator , key ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 if ( intern -> u . dir . dirp ) {
 RETURN_LONG ( intern -> u . dir . index ) ;
 }
 else {
 RETURN_FALSE ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_fdct32x32_rd_c ( const int16_t * input , int16_t * out , int stride ) {
 int i , j ;
 int output [ 32 * 32 ] ;
 for ( i = 0 ;
 i < 32 ;
 ++ i ) {
 int temp_in [ 32 ] , temp_out [ 32 ] ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;
 fdct32 ( temp_in , temp_out , 0 ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) output [ j * 32 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] > 0 ) ) >> 2 ;
 }
 for ( i = 0 ;
 i < 32 ;
 ++ i ) {
 int temp_in [ 32 ] , temp_out [ 32 ] ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) temp_in [ j ] = output [ j + i * 32 ] ;
 fdct32 ( temp_in , temp_out , 1 ) ;
 for ( j = 0 ;
 j < 32 ;
 ++ j ) out [ j + i * 32 ] = temp_out [ j ] ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line8 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 uint32_t * palette ;
 int x ;
 palette = s1 -> last_palette ;
 width >>= 3 ;
 for ( x = 0 ;
 x < width ;
 x ++ ) {
 ( ( uint32_t * ) d ) [ 0 ] = palette [ s [ 0 ] ] ;
 ( ( uint32_t * ) d ) [ 1 ] = palette [ s [ 1 ] ] ;
 ( ( uint32_t * ) d ) [ 2 ] = palette [ s [ 2 ] ] ;
 ( ( uint32_t * ) d ) [ 3 ] = palette [ s [ 3 ] ] ;
 ( ( uint32_t * ) d ) [ 4 ] = palette [ s [ 4 ] ] ;
 ( ( uint32_t * ) d ) [ 5 ] = palette [ s [ 5 ] ] ;
 ( ( uint32_t * ) d ) [ 6 ] = palette [ s [ 6 ] ] ;
 ( ( uint32_t * ) d ) [ 7 ] = palette [ s [ 7 ] ] ;
 d += 32 ;
 s += 8 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void selinux_sk_getsecid ( struct sock * sk , u32 * secid ) {
 if ( ! sk ) * secid = SECINITSID_ANY_SOCKET ;
 else {
 struct sk_security_struct * sksec = sk -> sk_security ;
 * secid = sksec -> sid ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_guid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 712 ""./asn1/h225/h225.cnf"" tvbuff_t * guid_tvb = NULL ;
 actx -> value_ptr = & guid_tvb ;
 offset = dissect_h225_GloballyUniqueID ( tvb , offset , actx , tree , hf_index ) ;
 if ( guid_tvb ) tvb_get_ntohguid ( guid_tvb , 0 , call_id_guid = wmem_new ( wmem_packet_scope ( ) , e_guid_t ) ) ;
 actx -> value_ptr = NULL ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Asn1Generic * DecodeAsn1DerSet ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {
 const unsigned char * d_ptr = buffer ;
 uint32_t d_length , numbytes , el_max_size ;
 uint8_t c ;
 uint32_t seq_index ;
 Asn1Generic * node ;
 Asn1Generic * child ;
 d_ptr ++ ;
 node = Asn1GenericNew ( ) ;
 if ( node == NULL ) return NULL ;
 node -> type = ASN1_SET ;
 node -> data = NULL ;
 c = d_ptr [ 0 ] ;
 if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {
 d_length = c ;
 d_ptr ++ ;
 }
 else {
 numbytes = c & 0x7f ;
 d_ptr ++ ;
 if ( DecodeAsn1BuildValue ( & d_ptr , & d_length , numbytes , errcode ) == - 1 ) {
 SCFree ( node ) ;
 return NULL ;
 }
 }
 node -> length = d_length + ( d_ptr - buffer ) ;
 if ( node -> length > max_size ) {
 if ( errcode ) * errcode = ERR_DER_ELEMENT_SIZE_TOO_BIG ;
 SCFree ( node ) ;
 return NULL ;
 }
 seq_index = 0 ;
 el_max_size = max_size - ( d_ptr - buffer ) ;
 child = DecodeAsn1DerGeneric ( d_ptr , el_max_size , depth , seq_index , errcode ) ;
 node -> data = child ;
 return ( Asn1Generic * ) node ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestIsEquivalentRegistered ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""test"" , GURL ( ""http://test/%s"" ) , ""test2"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;
 ASSERT_TRUE ( registry ( ) -> HasRegisteredEquivalent ( ph2 ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void Type_XYZ_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {
 _cmsFree ( self -> ContextID , Ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int qemuAgentIORead ( qemuAgentPtr mon ) {
 size_t avail = mon -> bufferLength - mon -> bufferOffset ;
 int ret = 0 ;
 if ( avail < 1024 ) {
 if ( VIR_REALLOC_N ( mon -> buffer , mon -> bufferLength + 1024 ) < 0 ) return - 1 ;
 mon -> bufferLength += 1024 ;
 avail += 1024 ;
 }
 while ( avail > 1 ) {
 int got ;
 got = read ( mon -> fd , mon -> buffer + mon -> bufferOffset , avail - 1 ) ;
 if ( got < 0 ) {
 if ( errno == EAGAIN ) break ;
 virReportSystemError ( errno , ""%s"" , _ ( ""Unable to read from monitor"" ) ) ;
 ret = - 1 ;
 break ;
 }
 if ( got == 0 ) break ;
 ret += got ;
 avail -= got ;
 mon -> bufferOffset += got ;
 mon -> buffer [ mon -> bufferOffset ] = '\0' ;
 }
 # if DEBUG_IO VIR_DEBUG ( ""Now read %zu bytes of data"" , mon -> bufferOffset ) ;
 # endif return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_callSpecific ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_callSpecific , T_callSpecific_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _HZReset ( UConverter * cnv , UConverterResetChoice choice ) {
 if ( choice <= UCNV_RESET_TO_UNICODE ) {
 cnv -> toUnicodeStatus = 0 ;
 cnv -> mode = 0 ;
 if ( cnv -> extraInfo != NULL ) {
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isStateDBCS = FALSE ;
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isEmptySegment = FALSE ;
 }
 }
 if ( choice != UCNV_RESET_TO_UNICODE ) {
 cnv -> fromUnicodeStatus = 0 ;
 cnv -> fromUChar32 = 0x0000 ;
 if ( cnv -> extraInfo != NULL ) {
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isEscapeAppended = FALSE ;
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> targetIndex = 0 ;
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> sourceIndex = 0 ;
 ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isTargetUCharDBCS = FALSE ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * hfinfo_numeric_value_format ( const header_field_info * hfinfo , char buf [ 32 ] , guint32 value ) {
 int display = hfinfo -> display & FIELD_DISPLAY_E_MASK ;
 if ( hfinfo -> type == FT_FRAMENUM ) {
 display = BASE_DEC ;
 }
 if ( IS_BASE_PORT ( display ) ) {
 display = BASE_DEC ;
 }
 switch ( display ) {
 case BASE_NONE : case BASE_DEC_HEX : case BASE_OCT : case BASE_CUSTOM : display = BASE_DEC ;
 break ;
 case BASE_HEX_DEC : display = BASE_HEX ;
 break ;
 }
 return hfinfo_number_value_format_display ( hfinfo , display , buf , value ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int gs_nulldevice ( gs_gstate * pgs ) {
 int code = 0 ;
 if ( pgs -> device == 0 || ! gx_device_is_null ( pgs -> device ) ) {
 gx_device * ndev ;
 code = gs_copydevice ( & ndev , ( const gx_device * ) & gs_null_device , pgs -> memory ) ;
 if ( code < 0 ) return code ;
 rc_init ( ndev , pgs -> memory , 0 ) ;
 if ( pgs -> device != NULL ) {
 if ( ( code = dev_proc ( pgs -> device , get_profile ) ( pgs -> device , & ( ndev -> icc_struct ) ) ) < 0 ) return code ;
 rc_increment ( ndev -> icc_struct ) ;
 set_dev_proc ( ndev , get_profile , gx_default_get_profile ) ;
 }
 if ( ( code = gs_setdevice_no_erase ( pgs , ndev ) ) < 0 ) gs_free_object ( pgs -> memory , ndev , ""gs_copydevice(device)"" ) ;
 }
 return code ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void readcb ( struct bufferevent * bev , void * arg ) {
 if ( EVBUFFER_LENGTH ( bev -> input ) == 8333 ) {
 bufferevent_disable ( bev , EV_READ ) ;
 test_ok ++ ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xF ( IpvideoContext * s ) {
 int x , y ;
 unsigned char sample [ 2 ] ;
 sample [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 sample [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) {
 for ( x = 0 ;
 x < 8 ;
 x += 2 ) {
 * s -> pixel_ptr ++ = sample [ y & 1 ] ;
 * s -> pixel_ptr ++ = sample [ ! ( y & 1 ) ] ;
 }
 s -> pixel_ptr += s -> line_inc ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) {
 int i ;
 struct commit * commit ;
 struct strbuf base ;
 strbuf_init ( & base , PATH_MAX ) ;
 while ( ( commit = get_revision ( revs ) ) != NULL ) {
 if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ;
 show_commit ( commit , data ) ;
 }
 for ( i = 0 ;
 i < revs -> pending . nr ;
 i ++ ) {
 struct object_array_entry * pending = revs -> pending . objects + i ;
 struct object * obj = pending -> item ;
 const char * name = pending -> name ;
 const char * path = pending -> path ;
 if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ;
 if ( obj -> type == OBJ_TAG ) {
 obj -> flags |= SEEN ;
 show_object ( obj , NULL , name , data ) ;
 continue ;
 }
 if ( ! path ) path = """" ;
 if ( obj -> type == OBJ_TREE ) {
 process_tree ( revs , ( struct tree * ) obj , show_object , NULL , & base , path , data ) ;
 continue ;
 }
 if ( obj -> type == OBJ_BLOB ) {
 process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ;
 continue ;
 }
 die ( ""unknown pending object %s (%s)"" , oid_to_hex ( & obj -> oid ) , name ) ;
 }
 object_array_clear ( & revs -> pending ) ;
 strbuf_release ( & base ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static double get_zero_motion_factor ( const FIRSTPASS_STATS * frame ) {
 const double sr_ratio = frame -> coded_error / DOUBLE_DIVIDE_CHECK ( frame -> sr_coded_error ) ;
 const double zero_motion_pct = frame -> pcnt_inter - frame -> pcnt_motion ;
 return MIN ( sr_ratio , zero_motion_pct ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * qemu_dummy_cpu_thread_fn ( void * arg ) {
 # ifdef _WIN32 fprintf ( stderr , ""qtest is not supported under Windows\n"" ) ;
 exit ( 1 ) ;
 # else CPUState * cpu = arg ;
 sigset_t waitset ;
 int r ;
 qemu_mutex_lock_iothread ( ) ;
 qemu_thread_get_self ( cpu -> thread ) ;
 cpu -> thread_id = qemu_get_thread_id ( ) ;
 sigemptyset ( & waitset ) ;
 sigaddset ( & waitset , SIG_IPI ) ;
 cpu -> created = true ;
 qemu_cond_signal ( & qemu_cpu_cond ) ;
 cpu_single_env = cpu -> env_ptr ;
 while ( 1 ) {
 cpu_single_env = NULL ;
 qemu_mutex_unlock_iothread ( ) ;
 do {
 int sig ;
 r = sigwait ( & waitset , & sig ) ;
 }
 while ( r == - 1 && ( errno == EAGAIN || errno == EINTR ) ) ;
 if ( r == - 1 ) {
 perror ( ""sigwait"" ) ;
 exit ( 1 ) ;
 }
 qemu_mutex_lock_iothread ( ) ;
 cpu_single_env = cpu -> env_ptr ;
 qemu_wait_io_event_common ( cpu ) ;
 }
 return NULL ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"void * xmlListReverseSearch ( xmlListPtr l , void * data ) {
 xmlLinkPtr lk ;
 if ( l == NULL ) return ( NULL ) ;
 lk = xmlListLinkReverseSearch ( l , data ) ;
 if ( lk ) return ( lk -> data ) ;
 return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"int xmlListPushFront ( xmlListPtr l , void * data ) {
 xmlLinkPtr lkPlace , lkNew ;
 if ( l == NULL ) return ( 0 ) ;
 lkPlace = l -> sentinel ;
 lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;
 if ( lkNew == NULL ) {
 xmlGenericError ( xmlGenericErrorContext , ""Cannot initialize memory for new link"" ) ;
 return ( 0 ) ;
 }
 lkNew -> data = data ;
 lkNew -> next = lkPlace -> next ;
 ( lkPlace -> next ) -> prev = lkNew ;
 lkPlace -> next = lkNew ;
 lkNew -> prev = lkPlace ;
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( eob == 1 ) vp9_idct16x16_1_add ( input , dest , stride ) ;
 else if ( eob <= 10 ) vp9_idct16x16_10_add ( input , dest , stride ) ;
 else vp9_idct16x16_256_add ( input , dest , stride ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestReplaceNonDefaultHandler ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/%s"" ) , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://test.com/updated-url/%s"" ) , ""test2"" ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""mailto"" , GURL ( ""http://else.com/%s"" ) , ""test3"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;
 ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph2 ) ) ;
 const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( ""mailto"" ) ) ;
 ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline hwaddr prep_IO_address ( sysctrl_t * sysctrl , hwaddr addr ) {
 if ( sysctrl -> contiguous_map == 0 ) {
 addr &= 0xFFFF ;
 }
 else {
 addr = ( addr & 0x1F ) | ( ( addr & 0x007FFF000 ) >> 7 ) ;
 }
 return addr ;
 }",0
Detect whether the following code contains vulnerabilities.,"static OFCondition parseDummy ( unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {
 unsigned short userLength ;
 if ( availData < 4 ) return makeLengthError ( ""dummy item"" , availData , 4 ) ;
 buf ++ ;
 buf ++ ;
 EXTRACT_SHORT_BIG ( buf , userLength ) ;
 buf += 2 ;
 if ( availData - 4 < userLength ) return makeLengthError ( ""dummy item"" , availData , 0 , userLength ) ;
 * itemLength = userLength + 4 ;
 return EC_Normal ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_T_g7231 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_g7231 , T_g7231_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_BandwidthConfirm ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_BandwidthConfirm , BandwidthConfirm_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {
 int i ;
 InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ;
 if ( int_fb_list == NULL ) return - 1 ;
 for ( i = 0 ;
 i < int_fb_list -> num_internal_frame_buffers ;
 ++ i ) {
 if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ;
 }
 if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ;
 if ( int_fb_list -> int_fb [ i ] . size < min_size ) {
 int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ;
 if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;
 vpx_memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;
 int_fb_list -> int_fb [ i ] . size = min_size ;
 }
 fb -> data = int_fb_list -> int_fb [ i ] . data ;
 fb -> size = int_fb_list -> int_fb [ i ] . size ;
 int_fb_list -> int_fb [ i ] . in_use = 1 ;
 fb -> priv = & int_fb_list -> int_fb [ i ] ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"REGRESSION_TEST ( SDK_API_TSIOBufferStart ) ( RegressionTest * test , int , int * pstatus ) {
 bool test_passed = false ;
 * pstatus = REGRESSION_TEST_INPROGRESS ;
 TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;
 TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;
 if ( TSIOBufferStart ( bufp ) == TSIOBufferReaderStart ( readerp ) ) {
 SDK_RPRINT ( test , ""TSIOBufferStart"" , ""TestCase1"" , TC_PASS , ""ok"" ) ;
 SDK_RPRINT ( test , ""TSIOBufferReaderStart"" , ""TestCase1"" , TC_PASS , ""ok"" ) ;
 test_passed = true ;
 }
 else {
 SDK_RPRINT ( test , ""TSIOBufferStart"" , ""TestCase1"" , TC_FAIL , ""failed"" ) ;
 SDK_RPRINT ( test , ""TSIOBufferReaderStart"" , ""TestCase1"" , TC_FAIL , ""failed"" ) ;
 }
 * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;
 return ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_vertical_8_dual_sse2 ( uint8_t * s , int p , const uint8_t * blimit0 , const uint8_t * limit0 , const uint8_t * thresh0 , const uint8_t * blimit1 , const uint8_t * limit1 , const uint8_t * thresh1 ) {
 DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 16 * 8 ) ;
 unsigned char * src [ 2 ] ;
 unsigned char * dst [ 2 ] ;
 transpose8x16 ( s - 4 , s - 4 + p * 8 , p , t_dst , 16 ) ;
 vp9_lpf_horizontal_8_dual_sse2 ( t_dst + 4 * 16 , 16 , blimit0 , limit0 , thresh0 , blimit1 , limit1 , thresh1 ) ;
 src [ 0 ] = t_dst ;
 src [ 1 ] = t_dst + 8 ;
 dst [ 0 ] = s - 4 ;
 dst [ 1 ] = s - 4 + p * 8 ;
 transpose ( src , 16 , dst , p , 2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {
 unsigned char * dst = s -> frame . data [ 0 ] ;
 int i ;
 for ( i = 0 ;
 i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;
 i ++ ) {
 memcpy ( dst , buf , s -> avctx -> width ) ;
 dst += s -> frame . linesize [ 0 ] ;
 buf += s -> avctx -> width ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int virLogOnceInit ( void ) {
 if ( virMutexInit ( & virLogMutex ) < 0 ) return - 1 ;
 virLogLock ( ) ;
 virLogDefaultPriority = VIR_LOG_DEFAULT ;
 if ( VIR_ALLOC_QUIET ( virLogRegex ) >= 0 ) {
 if ( regcomp ( virLogRegex , VIR_LOG_REGEX , REG_EXTENDED ) != 0 ) VIR_FREE ( virLogRegex ) ;
 }
 virLogUnlock ( ) ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( eob > 1 ) vp9_idct4x4_16_add ( input , dest , stride ) ;
 else vp9_idct4x4_1_add ( input , dest , stride ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"size_t compile_tree ( struct filter_op * * fop ) {
 int i = 1 ;
 struct filter_op * array = NULL ;
 struct unfold_elm * ue ;
 BUG_IF ( tree_root == NULL ) ;
 fprintf ( stdout , "" Unfolding the meta-tree "" ) ;
 fflush ( stdout ) ;
 unfold_blk ( & tree_root ) ;
 fprintf ( stdout , "" done.\n\n"" ) ;
 labels_to_offsets ( ) ;
 TAILQ_FOREACH ( ue , & unfolded_tree , next ) {
 if ( ue -> label == 0 ) {
 SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;
 memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;
 i ++ ;
 }
 }
 SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;
 array [ i - 1 ] . opcode = FOP_EXIT ;
 * fop = array ;
 return ( i ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decode_pitch_lag_high ( int * lag_int , int * lag_frac , int pitch_index , uint8_t * base_lag_int , int subframe ) {
 if ( subframe == 0 || subframe == 2 ) {
 if ( pitch_index < 376 ) {
 * lag_int = ( pitch_index + 137 ) >> 2 ;
 * lag_frac = pitch_index - ( * lag_int << 2 ) + 136 ;
 }
 else if ( pitch_index < 440 ) {
 * lag_int = ( pitch_index + 257 - 376 ) >> 1 ;
 * lag_frac = ( pitch_index - ( * lag_int << 1 ) + 256 - 376 ) << 1 ;
 }
 else {
 * lag_int = pitch_index - 280 ;
 * lag_frac = 0 ;
 }
 * base_lag_int = av_clip ( * lag_int - 8 - ( * lag_frac < 0 ) , AMRWB_P_DELAY_MIN , AMRWB_P_DELAY_MAX - 15 ) ;
 }
 else {
 * lag_int = ( pitch_index + 1 ) >> 2 ;
 * lag_frac = pitch_index - ( * lag_int << 2 ) ;
 * lag_int += * base_lag_int ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"int test_small_prime ( BIO * bp , BN_CTX * ctx ) {
 static const int bits = 10 ;
 int ret = 0 ;
 BIGNUM r ;
 BN_init ( & r ) ;
 if ( ! BN_generate_prime_ex ( & r , bits , 0 , NULL , NULL , NULL ) ) goto err ;
 if ( BN_num_bits ( & r ) != bits ) {
 BIO_printf ( bp , ""Expected %d bit prime, got %d bit number\n"" , bits , BN_num_bits ( & r ) ) ;
 goto err ;
 }
 ret = 1 ;
 err : BN_clear ( & r ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"int dissect_h225_IntegrityMechanism ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_IntegrityMechanism , IntegrityMechanism_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_pvfs_time ( tvbuff_t * tvb , proto_tree * tree , int offset , int hf_time , int hf_time_sec , int hf_time_nsec ) {
 guint32 seconds ;
 guint32 nseconds ;
 nstime_t ts ;
 proto_item * time_item ;
 proto_tree * time_tree ;
 ts . secs = seconds = tvb_get_letohl ( tvb , offset ) ;
 ts . nsecs = nseconds = tvb_get_letohl ( tvb , offset + 4 ) ;
 time_item = proto_tree_add_time ( tree , hf_time , tvb , offset , 8 , & ts ) ;
 time_tree = proto_item_add_subtree ( time_item , ett_pvfs_time ) ;
 proto_tree_add_uint ( time_tree , hf_time_sec , tvb , offset , 4 , seconds ) ;
 proto_tree_add_uint ( time_tree , hf_time_nsec , tvb , offset + 4 , 4 , nseconds ) ;
 offset += 8 ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {
 size_t need = buf -> misalign + buf -> off + datlen ;
 if ( buf -> totallen >= need ) return ( 0 ) ;
 if ( buf -> misalign >= datlen ) {
 evbuffer_align ( buf ) ;
 }
 else {
 void * newbuf ;
 size_t length = buf -> totallen ;
 if ( length < 256 ) length = 256 ;
 while ( length < need ) length <<= 1 ;
 if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;
 if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;
 buf -> orig_buffer = buf -> buffer = newbuf ;
 buf -> totallen = length ;
 }
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void fd_free ( struct FrameData * p ) {
 if ( p ) {
 if ( p -> buf ) vpx_free ( p -> buf ) ;
 vpx_free ( p ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) {
 int i , j ;
 for ( j = 0 ;
 j < SWITCHABLE_FILTER_CONTEXTS ;
 ++ j ) for ( i = 0 ;
 i < SWITCHABLE_FILTERS - 1 ;
 ++ i ) vp9_diff_update_prob ( r , & fc -> switchable_interp_prob [ j ] [ i ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int dissect_h225_GenericData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 816 ""./asn1/h225/h225.cnf"" void * priv_data = actx -> private_data ;
 gef_ctx_t * gefx ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( ! gefx ) {
 gefx = gef_ctx_alloc ( NULL , ""GenericData"" ) ;
 actx -> private_data = gefx ;
 }
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_GenericData , GenericData_sequence ) ;
 # line 826 ""./asn1/h225/h225.cnf"" actx -> private_data = priv_data ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int parse_PropertySetArray ( tvbuff_t * tvb , int offset , int size_offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 const int offset_in = offset ;
 guint32 size , num ;
 int i ;
 proto_tree * tree ;
 proto_item * item ;
 const char * txt ;
 va_list ap ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CDbPropSet_Array , & item , txt ) ;
 size = tvb_get_letohl ( tvb , size_offset ) ;
 proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_Blob1 , tvb , size_offset , 4 , ENC_LITTLE_ENDIAN ) ;
 num = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_PropSets_num , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;
 offset += 4 ;
 for ( i = 0 ;
 i < ( int ) num ;
 i ++ ) {
 offset = parse_CDbPropSet ( tvb , offset , tree , pad_tree , ""PropertySet[%d]"" , i ) ;
 }
 proto_item_set_end ( item , tvb , offset ) ;
 DISSECTOR_ASSERT ( offset - offset_in == ( int ) size ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cmd_server_connect ( const char * data ) {
 GHashTable * optlist ;
 char * addr ;
 void * free_arg ;
 if ( ! cmd_get_params ( data , & free_arg , 1 | PARAM_FLAG_OPTIONS , ""connect"" , & optlist , & addr ) ) return ;
 if ( * addr == '\0' || g_strcmp0 ( addr , ""+"" ) == 0 ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;
 if ( * addr == '+' ) window_create ( NULL , FALSE ) ;
 cmd_params_free ( free_arg ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void dynstr_append_sorted ( DYNAMIC_STRING * ds , DYNAMIC_STRING * ds_input , bool keep_header ) {
 unsigned i ;
 char * start = ds_input -> str ;
 DYNAMIC_ARRAY lines ;
 DBUG_ENTER ( ""dynstr_append_sorted"" ) ;
 if ( ! * start ) DBUG_VOID_RETURN ;
 my_init_dynamic_array ( & lines , sizeof ( const char * ) , 32 , 32 ) ;
 if ( keep_header ) {
 while ( * start && * start != '\n' ) start ++ ;
 start ++ ;
 dynstr_append_mem ( ds , ds_input -> str , start - ds_input -> str ) ;
 }
 while ( * start ) {
 char * line_end = ( char * ) start ;
 while ( * line_end && * line_end != '\n' ) line_end ++ ;
 * line_end = 0 ;
 if ( insert_dynamic ( & lines , ( uchar * ) & start ) ) die ( ""Out of memory inserting lines to sort"" ) ;
 start = line_end + 1 ;
 }
 qsort ( lines . buffer , lines . elements , sizeof ( char * * ) , ( qsort_cmp ) comp_lines ) ;
 for ( i = 0 ;
 i < lines . elements ;
 i ++ ) {
 const char * * line = dynamic_element ( & lines , i , const char * * ) ;
 dynstr_append ( ds , * line ) ;
 dynstr_append ( ds , ""\n"" ) ;
 }
 delete_dynamic ( & lines ) ;
 DBUG_VOID_RETURN ;
 }",0
Detect whether the following code contains vulnerabilities.,"guint16 de_cell_id ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string , int string_len ) {
 guint32 curr_offset ;
 curr_offset = offset ;
 curr_offset += be_cell_id_aux ( tvb , tree , pinfo , offset , len , add_string , string_len , 0x02 ) ;
 return ( curr_offset - offset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void tgq_idct_put_mb_dconly ( TgqContext * s , int mb_x , int mb_y , const int8_t * dc ) {
 int linesize = s -> frame . linesize [ 0 ] ;
 uint8_t * dest_y = s -> frame . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = s -> frame . data [ 1 ] + ( mb_y * 8 * s -> frame . linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = s -> frame . data [ 2 ] + ( mb_y * 8 * s -> frame . linesize [ 2 ] ) + mb_x * 8 ;
 tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;
 tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;
 tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;
 tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;
 if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 tgq_dconly ( s , dest_cb , s -> frame . linesize [ 1 ] , dc [ 4 ] ) ;
 tgq_dconly ( s , dest_cr , s -> frame . linesize [ 2 ] , dc [ 5 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct16x16_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int i , j ;
 int a1 ;
 int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;
 out = dct_const_round_shift ( out * cospi_16_64 ) ;
 a1 = ROUND_POWER_OF_TWO ( out , 6 ) ;
 for ( j = 0 ;
 j < 16 ;
 ++ j ) {
 for ( i = 0 ;
 i < 16 ;
 ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;
 dest += stride ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int ref_frames ( Vp3DecodeContext * dst , Vp3DecodeContext * src ) {
 int ret ;
 if ( ( ret = ref_frame ( dst , & dst -> current_frame , & src -> current_frame ) ) < 0 || ( ret = ref_frame ( dst , & dst -> golden_frame , & src -> golden_frame ) ) < 0 || ( ret = ref_frame ( dst , & dst -> last_frame , & src -> last_frame ) ) < 0 ) return ret ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _HZ_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 sa -> addRange ( sa -> set , 0 , 0x7f ) ;
 ucnv_MBCSGetFilteredUnicodeSetForUnicode ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter -> sharedData , sa , which , UCNV_SET_FILTER_HZ , pErrorCode ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline guint32 gst_asf_demux_identify_guid ( const ASFGuidHash * guids , ASFGuid * guid ) {
 guint32 ret ;
 ret = gst_asf_identify_guid ( guids , guid ) ;
 GST_LOG ( ""%s 0x%08x-0x%08x-0x%08x-0x%08x"" , gst_asf_get_guid_nick ( guids , ret ) , guid -> v1 , guid -> v2 , guid -> v3 , guid -> v4 ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"void setup_masks_arabic_plan ( const arabic_shape_plan_t * arabic_plan , hb_buffer_t * buffer , hb_script_t script ) {
 HB_BUFFER_ALLOCATE_VAR ( buffer , arabic_shaping_action ) ;
 arabic_joining ( buffer ) ;
 if ( script == HB_SCRIPT_MONGOLIAN ) mongolian_variation_selectors ( buffer ) ;
 unsigned int count = buffer -> len ;
 hb_glyph_info_t * info = buffer -> info ;
 for ( unsigned int i = 0 ;
 i < count ;
 i ++ ) info [ i ] . mask |= arabic_plan -> mask_array [ info [ i ] . arabic_shaping_action ( ) ] ;
 HB_BUFFER_DEALLOCATE_VAR ( buffer , arabic_shaping_action ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static rfbBool rectSwapIfLEAndClip ( uint16_t * x , uint16_t * y , uint16_t * w , uint16_t * h , rfbClientPtr cl ) {
 int x1 = Swap16IfLE ( * x ) ;
 int y1 = Swap16IfLE ( * y ) ;
 int w1 = Swap16IfLE ( * w ) ;
 int h1 = Swap16IfLE ( * h ) ;
 rfbScaledCorrection ( cl -> scaledScreen , cl -> screen , & x1 , & y1 , & w1 , & h1 , ""rectSwapIfLEAndClip"" ) ;
 * x = x1 ;
 * y = y1 ;
 * w = w1 ;
 * h = h1 ;
 if ( * w > cl -> screen -> width - * x ) * w = cl -> screen -> width - * x ;
 if ( * w > cl -> screen -> width - * x ) return FALSE ;
 if ( * h > cl -> screen -> height - * y ) * h = cl -> screen -> height - * y ;
 if ( * h > cl -> screen -> height - * y ) return FALSE ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) {
 const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;
 const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;
 const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;
 const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ;
 if ( has_rows && has_cols ) {
 vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ;
 }
 else if ( ! has_rows && has_cols ) {
 assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ;
 vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;
 }
 else if ( has_rows && ! has_cols ) {
 assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ;
 vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;
 }
 else {
 assert ( p == PARTITION_SPLIT ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void dist_block ( int plane , int block , TX_SIZE tx_size , struct rdcost_block_args * args ) {
 const int ss_txfrm_size = tx_size << 1 ;
 MACROBLOCK * const x = args -> x ;
 MACROBLOCKD * const xd = & x -> e_mbd ;
 const struct macroblock_plane * const p = & x -> plane [ plane ] ;
 const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 int64_t this_sse ;
 int shift = tx_size == TX_32X32 ? 0 : 2 ;
 int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;
 int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;
 args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ;
 args -> sse = this_sse >> shift ;
 if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ) {
 int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ;
 args -> dist += ( p >> 4 ) ;
 args -> sse += p ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void server_port_ready_callback ( int fd , short events , void * arg ) {
 struct evdns_server_port * port = ( struct evdns_server_port * ) arg ;
 ( void ) fd ;
 if ( events & EV_WRITE ) {
 port -> choked = 0 ;
 server_port_flush ( port ) ;
 }
 if ( events & EV_READ ) {
 server_port_read ( port ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void cancel_mount_for_file ( NautilusDirectory * directory , NautilusFile * file ) {
 if ( directory -> details -> mount_state != NULL && directory -> details -> mount_state -> file == file ) {
 mount_cancel ( directory ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_loop_filter_alloc ( VP9_COMMON * cm , VP9LfSync * lf_sync , int rows , int width ) {
 lf_sync -> rows = rows ;
 # if CONFIG_MULTITHREAD {
 int i ;
 CHECK_MEM_ERROR ( cm , lf_sync -> mutex_ , vpx_malloc ( sizeof ( * lf_sync -> mutex_ ) * rows ) ) ;
 for ( i = 0 ;
 i < rows ;
 ++ i ) {
 pthread_mutex_init ( & lf_sync -> mutex_ [ i ] , NULL ) ;
 }
 CHECK_MEM_ERROR ( cm , lf_sync -> cond_ , vpx_malloc ( sizeof ( * lf_sync -> cond_ ) * rows ) ) ;
 for ( i = 0 ;
 i < rows ;
 ++ i ) {
 pthread_cond_init ( & lf_sync -> cond_ [ i ] , NULL ) ;
 }
 }
 # endif CHECK_MEM_ERROR ( cm , lf_sync -> cur_sb_col , vpx_malloc ( sizeof ( * lf_sync -> cur_sb_col ) * rows ) ) ;
 lf_sync -> sync_range = get_sync_range ( width ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void decCopyFit ( decNumber * dest , const decNumber * src , decContext * set , Int * residue , uInt * status ) {
 dest -> bits = src -> bits ;
 dest -> exponent = src -> exponent ;
 decSetCoeff ( dest , set , src -> lsu , src -> digits , residue , status ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int mime_parse_integer ( const char * & buf , const char * end , int * integer ) {
 int val ;
 bool negative ;
 negative = false ;
 while ( ( buf != end ) && * buf && ! is_digit ( * buf ) && ( * buf != '-' ) ) {
 buf += 1 ;
 }
 if ( ( buf == end ) || ( * buf == '\0' ) ) {
 return 0 ;
 }
 if ( * buf == '-' ) {
 negative = true ;
 buf += 1 ;
 }
 val = 0 ;
 while ( ( buf != end ) && is_digit ( * buf ) ) {
 val = ( val * 10 ) + ( * buf ++ - '0' ) ;
 }
 if ( negative ) {
 * integer = - val ;
 }
 else {
 * integer = val ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"int parse_CCategSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {
 proto_item * item ;
 proto_tree * tree ;
 va_list ap ;
 guint32 type ;
 const char * txt ;
 va_start ( ap , fmt ) ;
 txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;
 va_end ( ap ) ;
 tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCategSpec , & item , txt ) ;
 type = tvb_get_letohl ( tvb , offset ) ;
 proto_tree_add_uint ( tree , hf_mswsp_ccategspec_type , tvb , offset , 4 , type ) ;
 proto_item_append_text ( item , "" Type %u"" , type ) ;
 offset += 4 ;
 offset = parse_CSort ( tvb , offset , tree , pad_tree , ""CSort"" ) ;
 offset = parse_CRangeCategSpec ( tvb , offset , tree , pad_tree , ""CRangeCategSpec"" ) ;
 proto_item_set_end ( item , tvb , offset ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_h245Ip6 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 348 ""./asn1/h225/h225.cnf"" tvbuff_t * value_tvb ;
 ipv6_address = ipv6_address_zeros ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 16 , 16 , FALSE , & value_tvb ) ;
 if ( value_tvb ) tvb_get_ipv6 ( value_tvb , 0 , & ipv6_address ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void selinux_task_getsecid ( struct task_struct * p , u32 * secid ) {
 * secid = task_sid ( p ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vdpau_h264_set_rf ( VdpReferenceFrameH264 * rf , Picture * pic , int pic_structure ) {
 VdpVideoSurface surface = ff_vdpau_get_surface_id ( pic ) ;
 if ( pic_structure == 0 ) pic_structure = pic -> f . reference ;
 rf -> surface = surface ;
 rf -> is_long_term = pic -> f . reference && pic -> long_ref ;
 rf -> top_is_reference = ( pic_structure & PICT_TOP_FIELD ) != 0 ;
 rf -> bottom_is_reference = ( pic_structure & PICT_BOTTOM_FIELD ) != 0 ;
 rf -> field_order_cnt [ 0 ] = h264_foc ( pic -> field_poc [ 0 ] ) ;
 rf -> field_order_cnt [ 1 ] = h264_foc ( pic -> field_poc [ 1 ] ) ;
 rf -> frame_idx = pic -> long_ref ? pic -> pic_id : pic -> frame_num ;
 }",1
Detect whether the following code contains vulnerabilities.,"void ttfFont__destroy ( ttfFont * self , gs_font_dir * dir ) {
 gs_memory_t * mem = dir -> memory -> stable_memory ;
 ttfFont__finit ( self ) ;
 gs_free_object ( mem , self , ""ttfFont__destroy"" ) ;
 ttfInterpreter__release ( & dir -> tti ) ;
 gx_san__release ( & dir -> san ) ;
 if ( dir -> tti == NULL && dir -> ttm != NULL ) {
 gs_free_object ( mem , dir -> ttm , ""ttfFont__destroy(gx_ttfMemory)"" ) ;
 dir -> ttm = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int jbig2_find_changing_element_of_color ( const byte * line , int x , int w , int color ) {
 if ( line == 0 ) return w ;
 x = jbig2_find_changing_element ( line , x , w ) ;
 if ( x < w && getbit ( line , x ) != color ) x = jbig2_find_changing_element ( line , x , w ) ;
 return x ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_block_thresholds ( const VP9_COMMON * cm , RD_OPT * rd ) {
 int i , bsize , segment_id ;
 for ( segment_id = 0 ;
 segment_id < MAX_SEGMENTS ;
 ++ segment_id ) {
 const int qindex = clamp ( vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) + cm -> y_dc_delta_q , 0 , MAXQ ) ;
 const int q = compute_rd_thresh_factor ( qindex ) ;
 for ( bsize = 0 ;
 bsize < BLOCK_SIZES ;
 ++ bsize ) {
 const int t = q * rd_thresh_block_size_factor [ bsize ] ;
 const int thresh_max = INT_MAX / t ;
 if ( bsize >= BLOCK_8X8 ) {
 for ( i = 0 ;
 i < MAX_MODES ;
 ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult [ i ] < thresh_max ? rd -> thresh_mult [ i ] * t / 4 : INT_MAX ;
 }
 else {
 for ( i = 0 ;
 i < MAX_REFS ;
 ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult_sub8x8 [ i ] < thresh_max ? rd -> thresh_mult_sub8x8 [ i ] * t / 4 : INT_MAX ;
 }
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_FastStart_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 272 ""./asn1/h225/h225.cnf"" tvbuff_t * value_tvb = NULL ;
 char codec_str [ 50 ] ;
 h225_packet_info * h225_pi ;
 codec_str [ 0 ] = '\0' ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;
 if ( value_tvb && tvb_reported_length ( value_tvb ) ) {
 dissect_h245_FastStart_OLC ( value_tvb , actx -> pinfo , tree , codec_str ) ;
 }
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s %s"" , h225_pi -> frame_label , codec_str ) ;
 h225_pi -> is_faststart = TRUE ;
 }
 contains_faststart = TRUE ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) {
 ECDSA_SIG * s ;
 int ret = - 1 ;
 s = ECDSA_SIG_new ( ) ;
 if ( s == NULL ) return ( ret ) ;
 if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;
 ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;
 err : ECDSA_SIG_free ( s ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( space_before , T_STRING ) ;
 len = RSTRING_LEN ( space_before ) ;
 if ( len == 0 ) {
 if ( state -> space_before ) {
 ruby_xfree ( state -> space_before ) ;
 state -> space_before = NULL ;
 state -> space_before_len = 0 ;
 }
 }
 else {
 if ( state -> space_before ) ruby_xfree ( state -> space_before ) ;
 state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;
 state -> space_before_len = len ;
 }
 return Qnil ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , getFilename ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 int path_len ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;
 if ( path_len && path_len < intern -> file_name_len ) {
 RETURN_STRINGL ( intern -> file_name + path_len + 1 , intern -> file_name_len - ( path_len + 1 ) , 1 ) ;
 }
 else {
 RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_LogicalChannelRateReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_LogicalChannelRateReject , LogicalChannelRateReject_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileListDesktopBrowserTest , MAYBE_SignOut ) {
 if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;
 ProfileManager * profile_manager = g_browser_process -> profile_manager ( ) ;
 Profile * current_profile = browser ( ) -> profile ( ) ;
 ProfileInfoCache & cache = profile_manager -> GetProfileInfoCache ( ) ;
 size_t index = cache . GetIndexOfProfileWithPath ( current_profile -> GetPath ( ) ) ;
 AvatarMenu * menu = GetAvatarMenu ( & cache ) ;
 menu -> RebuildMenu ( ) ;
 BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;
 EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;
 content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;
 EXPECT_FALSE ( cache . ProfileIsSigninRequiredAtIndex ( index ) ) ;
 profiles : : LockProfile ( current_profile ) ;
 window_close_observer . Wait ( ) ;
 EXPECT_TRUE ( cache . ProfileIsSigninRequiredAtIndex ( index ) ) ;
 EXPECT_EQ ( 0U , browser_list -> size ( ) ) ;
 chrome : : HideUserManager ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_file_mprotect ( struct vm_area_struct * vma , unsigned long reqprot , unsigned long prot ) {
 const struct cred * cred = current_cred ( ) ;
 if ( selinux_checkreqprot ) prot = reqprot ;
 if ( default_noexec && ( prot & PROT_EXEC ) && ! ( vma -> vm_flags & VM_EXEC ) ) {
 int rc = 0 ;
 if ( vma -> vm_start >= vma -> vm_mm -> start_brk && vma -> vm_end <= vma -> vm_mm -> brk ) {
 rc = cred_has_perm ( cred , cred , PROCESS__EXECHEAP ) ;
 }
 else if ( ! vma -> vm_file && ( ( vma -> vm_start <= vma -> vm_mm -> start_stack && vma -> vm_end >= vma -> vm_mm -> start_stack ) || vma_is_stack_for_current ( vma ) ) ) {
 rc = current_has_perm ( current , PROCESS__EXECSTACK ) ;
 }
 else if ( vma -> vm_file && vma -> anon_vma ) {
 rc = file_has_perm ( cred , vma -> vm_file , FILE__EXECMOD ) ;
 }
 if ( rc ) return rc ;
 }
 return file_map_prot_check ( vma -> vm_file , prot , vma -> vm_flags & VM_SHARED ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {
 char * buffer ;
 size_t bufferLen = REMOTE_MESSAGE_PAYLOAD_MAX ;
 int ret ;
 VIR_DEBUG ( ""stream=%p"" , stream ) ;
 if ( ! stream -> tx ) return 0 ;
 if ( VIR_ALLOC_N ( buffer , bufferLen ) < 0 ) return - 1 ;
 ret = virStreamRecv ( stream -> st , buffer , bufferLen ) ;
 if ( ret == - 2 ) {
 ret = 0 ;
 }
 else if ( ret < 0 ) {
 remote_error rerr ;
 memset ( & rerr , 0 , sizeof rerr ) ;
 remoteDispatchConnError ( & rerr , NULL ) ;
 ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;
 }
 else {
 stream -> tx = 0 ;
 if ( ret == 0 ) stream -> recvEOF = 1 ;
 ret = remoteSendStreamData ( client , stream , buffer , ret ) ;
 }
 VIR_FREE ( buffer ) ;
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void tgq_idct_put_mb_dconly ( TgqContext * s , AVFrame * frame , int mb_x , int mb_y , const int8_t * dc ) {
 int linesize = frame -> linesize [ 0 ] ;
 uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;
 tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;
 tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;
 tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;
 tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;
 if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 tgq_dconly ( s , dest_cb , frame -> linesize [ 1 ] , dc [ 4 ] ) ;
 tgq_dconly ( s , dest_cr , frame -> linesize [ 2 ] , dc [ 5 ] ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void gsm_a_dtap_mm_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {
 gsm_a_stat_init ( new_stat , gui_callback , gui_data , ""GSM A-I/F DTAP Mobility Management Statistics"" , gsm_a_dtap_msg_mm_strings ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vpx_svc_release ( SvcContext * svc_ctx ) {
 SvcInternal * si ;
 if ( svc_ctx == NULL ) return ;
 si = ( SvcInternal * ) svc_ctx -> internal ;
 if ( si != NULL ) {
 fd_free ( si -> frame_temp ) ;
 fd_free_list ( si -> frame_list ) ;
 if ( si -> rc_stats_buf ) {
 free ( si -> rc_stats_buf ) ;
 }
 free ( si ) ;
 svc_ctx -> internal = NULL ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void ff_copy_picture ( Picture * dst , Picture * src ) {
 * dst = * src ;
 dst -> f . type = FF_BUFFER_TYPE_COPY ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const unsigned char * seq_decode_op2 ( SeqVideoContext * seq , const unsigned char * src , const unsigned char * src_end , unsigned char * dst ) {
 int i ;
 if ( src_end - src < 8 * 8 ) return NULL ;
 for ( i = 0 ;
 i < 8 ;
 i ++ ) {
 memcpy ( dst , src , 8 ) ;
 src += 8 ;
 dst += seq -> frame . linesize [ 0 ] ;
 }
 return src ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vp3_decode_flush ( AVCodecContext * avctx ) {
 Vp3DecodeContext * s = avctx -> priv_data ;
 if ( s -> golden_frame . data [ 0 ] ) {
 if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;
 if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;
 ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;
 }
 if ( s -> last_frame . data [ 0 ] ) {
 if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;
 ff_thread_release_buffer ( avctx , & s -> last_frame ) ;
 }
 if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void sbr_sum64x5_c ( float * z ) {
 int k ;
 for ( k = 0 ;
 k < 64 ;
 k ++ ) {
 float f = z [ k ] + z [ k + 64 ] + z [ k + 128 ] + z [ k + 192 ] + z [ k + 256 ] ;
 z [ k ] = f ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_FacilityReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 593 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_FacilityReason , FacilityReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {
 xsltDocumentPtr cur ;
 cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;
 if ( cur == NULL ) {
 xsltTransformError ( ctxt , NULL , ( xmlNodePtr ) doc , ""xsltNewDocument : malloc failed\n"" ) ;
 return ( NULL ) ;
 }
 memset ( cur , 0 , sizeof ( xsltDocument ) ) ;
 cur -> doc = doc ;
 if ( ctxt != NULL ) {
 if ( ! XSLT_IS_RES_TREE_FRAG ( doc ) ) {
 cur -> next = ctxt -> docList ;
 ctxt -> docList = cur ;
 }
 }
 return ( cur ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , intptr_t block_size , int64_t * ssz ) {
 int i ;
 int64_t error = 0 , sqcoeff = 0 ;
 for ( i = 0 ;
 i < block_size ;
 i ++ ) {
 const int diff = coeff [ i ] - dqcoeff [ i ] ;
 error += diff * diff ;
 sqcoeff += coeff [ i ] * coeff [ i ] ;
 }
 * ssz = sqcoeff ;
 return error ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void generate_psnr_packet ( VP9_COMP * cpi ) {
 struct vpx_codec_cx_pkt pkt ;
 int i ;
 PSNR_STATS psnr ;
 calc_psnr ( cpi -> Source , cpi -> common . frame_to_show , & psnr ) ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 pkt . data . psnr . samples [ i ] = psnr . samples [ i ] ;
 pkt . data . psnr . sse [ i ] = psnr . sse [ i ] ;
 pkt . data . psnr . psnr [ i ] = psnr . psnr [ i ] ;
 }
 pkt . kind = VPX_CODEC_PSNR_PKT ;
 vpx_codec_pkt_list_add ( cpi -> output_pkt_list , & pkt ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dissect_mdns_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {
 col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""MDNS"" ) ;
 dissect_dns_common ( tvb , pinfo , tree , FALSE , TRUE , FALSE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void mark_trusted_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {
 MarkTrustedJob * job = user_data ;
 g_object_unref ( job -> file ) ;
 if ( job -> done_callback ) {
 job -> done_callback ( ! job_aborted ( ( CommonJob * ) job ) , job -> done_callback_data ) ;
 }
 finalize_common ( ( CommonJob * ) job ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void evhttp_make_header_request ( struct evhttp_connection * evcon , struct evhttp_request * req ) {
 const char * method ;
 evhttp_remove_header ( req -> output_headers , ""Proxy-Connection"" ) ;
 method = evhttp_method ( req -> type ) ;
 evbuffer_add_printf ( evcon -> output_buffer , ""%s %s HTTP/%d.%d\r\n"" , method , req -> uri , req -> major , req -> minor ) ;
 if ( req -> type == EVHTTP_REQ_POST && evhttp_find_header ( req -> output_headers , ""Content-Length"" ) == NULL ) {
 char size [ 12 ] ;
 evutil_snprintf ( size , sizeof ( size ) , ""%ld"" , ( long ) EVBUFFER_LENGTH ( req -> output_buffer ) ) ;
 evhttp_add_header ( req -> output_headers , ""Content-Length"" , size ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void virtio_balloon_handle_output ( VirtIODevice * vdev , VirtQueue * vq ) {
 VirtIOBalloon * s = to_virtio_balloon ( vdev ) ;
 VirtQueueElement elem ;
 MemoryRegionSection section ;
 while ( virtqueue_pop ( vq , & elem ) ) {
 size_t offset = 0 ;
 uint32_t pfn ;
 while ( iov_to_buf ( elem . out_sg , elem . out_num , & pfn , offset , 4 ) == 4 ) {
 ram_addr_t pa ;
 ram_addr_t addr ;
 pa = ( ram_addr_t ) ldl_p ( & pfn ) << VIRTIO_BALLOON_PFN_SHIFT ;
 offset += 4 ;
 section = memory_region_find ( get_system_memory ( ) , pa , 1 ) ;
 if ( ! section . size || ! memory_region_is_ram ( section . mr ) ) continue ;
 addr = section . offset_within_region ;
 balloon_page ( memory_region_get_ram_ptr ( section . mr ) + addr , ! ! ( vq == s -> dvq ) ) ;
 }
 virtqueue_push ( vq , & elem , offset ) ;
 virtio_notify ( vdev , vq ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , ReadAll ) {
 multibuffer_ . SetMaxWriters ( 1 ) ;
 size_t pos = 0 ;
 size_t end = 10000 ;
 multibuffer_ . SetFileSize ( 10000 ) ;
 multibuffer_ . SetMustReadWholeFile ( true ) ;
 media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;
 reader . SetMaxBuffer ( 2000 , 5000 ) ;
 reader . SetPreload ( 1000 , 1000 ) ;
 while ( pos < end ) {
 unsigned char buffer [ 27 ] ;
 buffer [ 17 ] = 17 ;
 size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;
 int64_t bytes_read = reader . TryRead ( buffer , to_read ) ;
 if ( bytes_read ) {
 EXPECT_EQ ( buffer [ 17 ] , 17 ) ;
 for ( int64_t i = 0 ;
 i < bytes_read ;
 i ++ ) {
 uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;
 EXPECT_EQ ( expected , buffer [ i ] ) << "" pos = "" << pos ;
 pos ++ ;
 }
 }
 else {
 Advance ( ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"struct key_type * key_type_lookup ( const char * type ) {
 struct key_type * ktype ;
 down_read ( & key_types_sem ) ;
 list_for_each_entry ( ktype , & key_types_list , link ) {
 if ( strcmp ( ktype -> name , type ) == 0 ) goto found_kernel_type ;
 }
 up_read ( & key_types_sem ) ;
 ktype = ERR_PTR ( - ENOKEY ) ;
 found_kernel_type : return ktype ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void prplcb_conn_disconnected ( PurpleConnection * gc ) {
 struct im_connection * ic = purple_ic_by_gc ( gc ) ;
 if ( ic != NULL ) {
 imc_logout ( ic , ! gc -> wants_to_die ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"fz_colorspace * fz_keep_colorspace_store_key ( fz_context * ctx , fz_colorspace * cs ) {
 return fz_keep_key_storable_key ( ctx , & cs -> key_storable ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line15_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t v , r , g , b ;
 w = width ;
 do {
 v = lduw_be_p ( ( void * ) s ) ;
 r = ( v >> 7 ) & 0xf8 ;
 g = ( v >> 2 ) & 0xf8 ;
 b = ( v << 3 ) & 0xf8 ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 2 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static VALUE cState_indent_set ( VALUE self , VALUE indent ) {
 unsigned long len ;
 GET_STATE ( self ) ;
 Check_Type ( indent , T_STRING ) ;
 len = RSTRING_LEN ( indent ) ;
 if ( len == 0 ) {
 if ( state -> indent ) {
 ruby_xfree ( state -> indent ) ;
 state -> indent = NULL ;
 state -> indent_len = 0 ;
 }
 }
 else {
 if ( state -> indent ) ruby_xfree ( state -> indent ) ;
 state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;
 state -> indent_len = len ;
 }
 return Qnil ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void relocate_doit ( void * a ) {
 struct relocate_args * args = ( struct relocate_args * ) a ;
 _dl_relocate_object ( args -> l , args -> l -> l_scope , args -> reloc_mode , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONAddPCIDisk ( qemuMonitorPtr mon ATTRIBUTE_UNUSED , const char * path ATTRIBUTE_UNUSED , const char * bus ATTRIBUTE_UNUSED , virDomainDevicePCIAddress * guestAddr ATTRIBUTE_UNUSED ) {
 qemuReportError ( VIR_ERR_INTERNAL_ERROR , ""%s"" , _ ( ""pci_add not suppported in JSON mode"" ) ) ;
 return - 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_LocationRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 668 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_LocationRejectReason , LocationRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"apr_status_t xml_cleanup ( modsec_rec * msr ) {
 if ( msr -> xml -> doc != NULL ) {
 xmlFreeDoc ( msr -> xml -> doc ) ;
 msr -> xml -> doc = NULL ;
 }
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void evhttp_connection_fail ( struct evhttp_connection * evcon , enum evhttp_connection_error error ) {
 struct evhttp_request * req = TAILQ_FIRST ( & evcon -> requests ) ;
 void ( * cb ) ( struct evhttp_request * , void * ) ;
 void * cb_arg ;
 assert ( req != NULL ) ;
 if ( evcon -> flags & EVHTTP_CON_INCOMING ) {
 if ( evhttp_connection_incoming_fail ( req , error ) == - 1 ) evhttp_connection_free ( evcon ) ;
 return ;
 }
 cb = req -> cb ;
 cb_arg = req -> cb_arg ;
 TAILQ_REMOVE ( & evcon -> requests , req , next ) ;
 evhttp_request_free ( req ) ;
 evhttp_connection_reset ( evcon ) ;
 if ( TAILQ_FIRST ( & evcon -> requests ) != NULL ) evhttp_connection_connect ( evcon ) ;
 if ( cb != NULL ) ( * cb ) ( NULL , cb_arg ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static gpgme_error_t uiserver_set_protocol ( void * engine , gpgme_protocol_t protocol ) {
 engine_uiserver_t uiserver = engine ;
 if ( protocol != GPGME_PROTOCOL_OpenPGP && protocol != GPGME_PROTOCOL_CMS && protocol != GPGME_PROTOCOL_DEFAULT ) return gpg_error ( GPG_ERR_INV_VALUE ) ;
 uiserver -> protocol = protocol ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha )",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , ParseURLNoTemplateEnd ) {
 TemplateURLData data ;
 data . SetURL ( ""{
"" ) ;
 TemplateURL url ( data ) ;
 TemplateURLRef : : Replacements replacements ;
 bool valid = false ;
 EXPECT_EQ ( std : : string ( ) , url . url_ref ( ) . ParseURL ( ""{
"" , & replacements , NULL , & valid ) ) ;
 EXPECT_TRUE ( replacements . empty ( ) ) ;
 EXPECT_FALSE ( valid ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void xmlHashFree ( xmlHashTablePtr table , xmlHashDeallocator f ) {
 int i ;
 xmlHashEntryPtr iter ;
 xmlHashEntryPtr next ;
 int inside_table = 0 ;
 int nbElems ;
 if ( table == NULL ) return ;
 if ( table -> table ) {
 nbElems = table -> nbElems ;
 for ( i = 0 ;
 ( i < table -> size ) && ( nbElems > 0 ) ;
 i ++ ) {
 iter = & ( table -> table [ i ] ) ;
 if ( iter -> valid == 0 ) continue ;
 inside_table = 1 ;
 while ( iter ) {
 next = iter -> next ;
 if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , iter -> name ) ;
 if ( table -> dict == NULL ) {
 if ( iter -> name ) xmlFree ( iter -> name ) ;
 if ( iter -> name2 ) xmlFree ( iter -> name2 ) ;
 if ( iter -> name3 ) xmlFree ( iter -> name3 ) ;
 }
 iter -> payload = NULL ;
 if ( ! inside_table ) xmlFree ( iter ) ;
 nbElems -- ;
 inside_table = 0 ;
 iter = next ;
 }
 }
 xmlFree ( table -> table ) ;
 }
 if ( table -> dict ) xmlDictFree ( table -> dict ) ;
 xmlFree ( table ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void auth_server_connection_disconnect ( struct auth_server_connection * conn , const char * reason ) {
 if ( ! conn -> connected ) return ;
 conn -> connected = FALSE ;
 conn -> handshake_received = FALSE ;
 conn -> version_received = FALSE ;
 conn -> has_plain_mech = FALSE ;
 conn -> server_pid = 0 ;
 conn -> connect_uid = 0 ;
 conn -> cookie = NULL ;
 array_clear ( & conn -> available_auth_mechs ) ;
 timeout_remove ( & conn -> to ) ;
 io_remove ( & conn -> io ) ;
 if ( conn -> fd != - 1 ) {
 i_stream_destroy ( & conn -> input ) ;
 o_stream_destroy ( & conn -> output ) ;
 if ( close ( conn -> fd ) < 0 ) i_error ( ""close(auth server connection) failed: %m"" ) ;
 conn -> fd = - 1 ;
 }
 auth_server_connection_remove_requests ( conn , reason ) ;
 if ( conn -> client -> connect_notify_callback != NULL ) {
 conn -> client -> connect_notify_callback ( conn -> client , FALSE , conn -> client -> connect_notify_context ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static void reconstruct_inter_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {
 struct inter_args * args = ( struct inter_args * ) arg ;
 VP9_COMMON * const cm = args -> cm ;
 MACROBLOCKD * const xd = args -> xd ;
 struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;
 int x , y , eob ;
 txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;
 eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ;
 inverse_transform_block ( xd , plane , block , tx_size , & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , pd -> dst . stride , eob ) ;
 * args -> eobtotal += eob ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void set_partial_b64x64_partition ( MODE_INFO * mi , int mis , int bh_in , int bw_in , int row8x8_remaining , int col8x8_remaining , BLOCK_SIZE bsize , MODE_INFO * mi_8x8 ) {
 int bh = bh_in ;
 int r , c ;
 for ( r = 0 ;
 r < MI_BLOCK_SIZE ;
 r += bh ) {
 int bw = bw_in ;
 for ( c = 0 ;
 c < MI_BLOCK_SIZE ;
 c += bw ) {
 const int index = r * mis + c ;
 mi_8x8 [ index ] . src_mi = mi + index ;
 mi_8x8 [ index ] . src_mi -> mbmi . sb_type = find_partition_size ( bsize , row8x8_remaining - r , col8x8_remaining - c , & bh , & bw ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"hb_blob_t * hb_blob_reference ( hb_blob_t * blob ) {
 return hb_object_reference ( blob ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PQExpBuffer defaultGetLocalPQExpBuffer ( void ) {
 static PQExpBuffer id_return = NULL ;
 if ( id_return ) {
 resetPQExpBuffer ( id_return ) ;
 }
 else {
 id_return = createPQExpBuffer ( ) ;
 }
 return id_return ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {
 char * protocol ;
 char * number ;
 char * readable ;
 protocol = strsep ( & line , "" "" ) ;
 if ( line == NULL ) return ( - 1 ) ;
 number = strsep ( & line , "" "" ) ;
 if ( line == NULL ) return ( - 1 ) ;
 readable = line ;
 if ( strcmp ( protocol , ""HTTP/1.0"" ) == 0 ) {
 req -> major = 1 ;
 req -> minor = 0 ;
 }
 else if ( strcmp ( protocol , ""HTTP/1.1"" ) == 0 ) {
 req -> major = 1 ;
 req -> minor = 1 ;
 }
 else {
 event_debug ( ( ""%s: bad protocol \""%s\"""" , __func__ , protocol ) ) ;
 return ( - 1 ) ;
 }
 req -> response_code = atoi ( number ) ;
 if ( ! evhttp_valid_response_code ( req -> response_code ) ) {
 event_debug ( ( ""%s: bad response code \""%s\"""" , __func__ , number ) ) ;
 return ( - 1 ) ;
 }
 if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , ""%s: strdup"" , __func__ ) ;
 return ( 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void kadm5_free_principal ( krb5_context context , krb5_principal val ) {
 register krb5_int32 i ;
 if ( ! val ) return ;
 if ( val -> data ) {
 i = krb5_princ_size ( context , val ) ;
 while ( -- i >= 0 ) krb5_db_free ( context , krb5_princ_component ( context , val , i ) -> data ) ;
 krb5_db_free ( context , val -> data ) ;
 }
 if ( val -> realm . data ) krb5_db_free ( context , val -> realm . data ) ;
 krb5_db_free ( context , val ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_twopass_postencode_update ( VP9_COMP * cpi ) {
 TWO_PASS * const twopass = & cpi -> twopass ;
 RATE_CONTROL * const rc = & cpi -> rc ;
 const int bits_used = rc -> base_frame_target ;
 rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ;
 twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ;
 if ( cpi -> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) {
 twopass -> kf_group_bits -= bits_used ;
 }
 twopass -> kf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ;
 ++ twopass -> gf_group . index ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelAlpha ( const Image * restrict image , const Quantum alpha , Quantum * restrict pixel ) {
 if ( image -> channel_map [ AlphaPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ AlphaPixelChannel ] . offset ] = alpha ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void parse_content_type ( struct message_search_context * ctx , struct message_header_line * hdr ) {
 struct rfc822_parser_context parser ;
 string_t * content_type ;
 rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 content_type = t_str_new ( 64 ) ;
 ( void ) rfc822_parse_content_type ( & parser , content_type ) ;
 ctx -> content_type_text = strncasecmp ( str_c ( content_type ) , ""text/"" , 5 ) == 0 || strncasecmp ( str_c ( content_type ) , ""message/"" , 8 ) == 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ImmersiveModeControllerAshTest , EnabledCommands ) {
 ASSERT_FALSE ( controller ( ) -> IsEnabled ( ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_OPEN_CURRENT_URL ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_ABOUT ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_FOCUS_LOCATION ) ) ;
 ToggleFullscreen ( ) ;
 EXPECT_TRUE ( controller ( ) -> IsEnabled ( ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_OPEN_CURRENT_URL ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_ABOUT ) ) ;
 EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_FOCUS_LOCATION ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_init_dequantizer ( VP9_COMMON * cm ) {
 int q ;
 for ( q = 0 ;
 q < QINDEX_RANGE ;
 q ++ ) {
 cm -> y_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> y_dc_delta_q ) ;
 cm -> y_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , 0 ) ;
 cm -> uv_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> uv_dc_delta_q ) ;
 cm -> uv_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void * concat_gen_fifos ( void * first , void * second ) {
 gen_fifo * pf1 ;
 gen_fifo * pf2 ;
 pf1 = first ;
 pf2 = second ;
 if ( NULL == pf1 ) return pf2 ;
 else if ( NULL == pf2 ) return pf1 ;
 CONCAT_FIFO ( * pf1 , * pf2 , link ) ;
 free ( pf2 ) ;
 return pf1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint32_t cpuid_entry_get_reg ( struct kvm_cpuid_entry2 * entry , int reg ) {
 uint32_t ret = 0 ;
 switch ( reg ) {
 case R_EAX : ret = entry -> eax ;
 break ;
 case R_EBX : ret = entry -> ebx ;
 break ;
 case R_ECX : ret = entry -> ecx ;
 break ;
 case R_EDX : ret = entry -> edx ;
 break ;
 }
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_IsupPrivatePartyNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_IsupPrivatePartyNumber , IsupPrivatePartyNumber_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_ota_upgradeendrsp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {
 proto_tree_add_item ( tree , hf_zbee_zcl_ota_manufacturer_code , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_ota_image_type , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 dissect_zcl_ota_file_version_field ( tvb , tree , offset ) ;
 proto_tree_add_item ( tree , hf_zbee_zcl_ota_current_time , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;
 * offset += 4 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_ota_upgrade_time , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;
 * offset += 4 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _LMBCSClose ( UConverter * _this ) {
 if ( _this -> extraInfo != NULL ) {
 ulmbcs_byte_t Ix ;
 UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;
 for ( Ix = 0 ;
 Ix <= ULMBCS_GRP_LAST ;
 Ix ++ ) {
 if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;
 }
 if ( ! _this -> isExtraLocal ) {
 uprv_free ( _this -> extraInfo ) ;
 _this -> extraInfo = NULL ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x2 ( IpvideoContext * s ) {
 unsigned char B ;
 int x , y ;
 if ( ! s -> is_16bpp ) {
 B = bytestream2_get_byte ( & s -> stream_ptr ) ;
 }
 else {
 B = bytestream2_get_byte ( & s -> mv_ptr ) ;
 }
 if ( B < 56 ) {
 x = 8 + ( B % 7 ) ;
 y = B / 7 ;
 }
 else {
 x = - 14 + ( ( B - 56 ) % 29 ) ;
 y = 8 + ( ( B - 56 ) / 29 ) ;
 }
 av_dlog ( NULL , "" motion byte = %d, (x, y) = (%d, %d)\n"" , B , x , y ) ;
 return copy_from ( s , & s -> second_last_frame , x , y ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingExtensionContextDuringShutdown ) {
 StartActiveFetcherDuringProfileShutdownTest ( browser ( ) -> profile ( ) -> GetRequestContextForExtensions ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_mv_bit_cost ( const MV * mv , const MV * ref , const int * mvjcost , int * mvcost [ 2 ] , int weight ) {
 const MV diff = {
 mv -> row - ref -> row , mv -> col - ref -> col }
 ;
 return ROUND_POWER_OF_TWO ( mv_cost ( & diff , mvjcost , mvcost ) * weight , 7 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_initialize_me_consts ( VP9_COMP * cpi , int qindex ) {
 cpi -> mb . sadperbit16 = sad_per_bit16lut [ qindex ] ;
 cpi -> mb . sadperbit4 = sad_per_bit4lut [ qindex ] ;
 }",1
Detect whether the following code contains vulnerabilities.,"gboolean logcat_text_time_dump_open ( wtap_dumper * wdh , int * err _U_ ) {
 struct dumper_t * dumper ;
 dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;
 dumper -> type = DUMP_TIME ;
 wdh -> priv = dumper ;
 wdh -> subtype_write = logcat_dump_text ;
 wdh -> subtype_close = NULL ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int vp3_init_thread_copy ( AVCodecContext * avctx ) {
 Vp3DecodeContext * s = avctx -> priv_data ;
 s -> superblock_coding = NULL ;
 s -> all_fragments = NULL ;
 s -> coded_fragment_list [ 0 ] = NULL ;
 s -> dct_tokens_base = NULL ;
 s -> superblock_fragments = NULL ;
 s -> macroblock_coding = NULL ;
 s -> motion_val [ 0 ] = NULL ;
 s -> motion_val [ 1 ] = NULL ;
 s -> edge_emu_buffer = NULL ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int evhttp_del_cb ( struct evhttp * http , const char * uri ) {
 struct evhttp_cb * http_cb ;
 TAILQ_FOREACH ( http_cb , & http -> callbacks , next ) {
 if ( strcmp ( http_cb -> what , uri ) == 0 ) break ;
 }
 if ( http_cb == NULL ) return ( - 1 ) ;
 TAILQ_REMOVE ( & http -> callbacks , http_cb , next ) ;
 free ( http_cb -> what ) ;
 free ( http_cb ) ;
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void vmport_class_initfn ( ObjectClass * klass , void * data ) {
 DeviceClass * dc = DEVICE_CLASS ( klass ) ;
 dc -> realize = vmport_realizefn ;
 dc -> no_user = 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_pvfs_handle_extent ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo , guint32 nCount ) {
 proto_tree * extent_tree ;
 extent_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 8 , ett_pvfs_extent_item , NULL , ""Item %d"" , nCount ) ;
 offset = dissect_pvfs_fh ( tvb , offset , pinfo , extent_tree , ""first handle"" , NULL ) ;
 offset = dissect_pvfs_fh ( tvb , offset , pinfo , extent_tree , ""last handle"" , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void glyph_info_destroy ( hb_glyph_info_t * g ) {
 free ( g ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static bool contain_volatile_functions_walker ( Node * node , void * context ) {
 if ( node == NULL ) return false ;
 if ( check_functions_in_node ( node , contain_volatile_functions_checker , context ) ) return true ;
 if ( IsA ( node , Query ) ) {
 return query_tree_walker ( ( Query * ) node , contain_volatile_functions_walker , context , 0 ) ;
 }
 return expression_tree_walker ( node , contain_volatile_functions_walker , context ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int update_picture_tables ( Picture * dst , Picture * src ) {
 int i ;
 # define UPDATE_TABLE ( table ) do {
 if ( src -> table && ( ! dst -> table || dst -> table -> buffer != src -> table -> buffer ) ) {
 av_buffer_unref ( & dst -> table ) ;
 dst -> table = av_buffer_ref ( src -> table ) ;
 if ( ! dst -> table ) {
 free_picture_tables ( dst ) ;
 return AVERROR ( ENOMEM ) ;
 }
 }
 \ }
 while ( 0 ) UPDATE_TABLE ( mb_var_buf ) ;
 UPDATE_TABLE ( mc_mb_var_buf ) ;
 UPDATE_TABLE ( mb_mean_buf ) ;
 UPDATE_TABLE ( mbskip_table_buf ) ;
 UPDATE_TABLE ( qscale_table_buf ) ;
 UPDATE_TABLE ( mb_type_buf ) ;
 for ( i = 0 ;
 i < 2 ;
 i ++ ) {
 UPDATE_TABLE ( motion_val_buf [ i ] ) ;
 UPDATE_TABLE ( ref_index_buf [ i ] ) ;
 }
 dst -> mb_var = src -> mb_var ;
 dst -> mc_mb_var = src -> mc_mb_var ;
 dst -> mb_mean = src -> mb_mean ;
 dst -> mbskip_table = src -> mbskip_table ;
 dst -> qscale_table = src -> qscale_table ;
 dst -> mb_type = src -> mb_type ;
 for ( i = 0 ;
 i < 2 ;
 i ++ ) {
 dst -> motion_val [ i ] = src -> motion_val [ i ] ;
 dst -> ref_index [ i ] = src -> ref_index [ i ] ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void fz_drop_colorspace_context ( fz_context * ctx ) {
 if ( ! ctx ) return ;
 if ( fz_drop_imp ( ctx , ctx -> colorspace , & ctx -> colorspace -> ctx_refs ) ) {
 fz_drop_colorspace ( ctx , ctx -> colorspace -> gray ) ;
 fz_drop_colorspace ( ctx , ctx -> colorspace -> rgb ) ;
 fz_drop_colorspace ( ctx , ctx -> colorspace -> bgr ) ;
 fz_drop_colorspace ( ctx , ctx -> colorspace -> cmyk ) ;
 fz_drop_colorspace ( ctx , ctx -> colorspace -> lab ) ;
 fz_drop_cmm_context ( ctx ) ;
 fz_free ( ctx , ctx -> colorspace ) ;
 ctx -> colorspace = NULL ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer )",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( NewAvatarMenuButtonTest , MAYBE_SignOut ) {
 if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;
 CreateTestingProfile ( ) ;
 ASSERT_NO_FATAL_FAILURE ( StartAvatarMenu ( ) ) ;
 BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;
 EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;
 content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;
 AvatarMenu * menu = ProfileChooserView : : profile_bubble_ -> avatar_menu_ . get ( ) ;
 const AvatarMenu : : Item & menu_item_before = menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) ;
 EXPECT_FALSE ( menu_item_before . signin_required ) ;
 ui : : MouseEvent mouse_ev ( ui : : ET_MOUSE_RELEASED , gfx : : Point ( ) , gfx : : Point ( ) , 0 , 0 ) ;
 ProfileChooserView : : profile_bubble_ -> ButtonPressed ( ProfileChooserView : : profile_bubble_ -> lock_button_ , mouse_ev ) ;
 EXPECT_TRUE ( menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) . signin_required ) ;
 window_close_observer . Wait ( ) ;
 EXPECT_TRUE ( browser_list -> empty ( ) ) ;
 if ( ! UserManagerView : : IsShowing ( ) ) base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;
 chrome : : HideUserManager ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static guint16 de_bcc_cause ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {
 guint32 curr_offset ;
 int curr_len ;
 curr_len = len ;
 curr_offset = offset ;
 proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_cause_structure , tvb , curr_offset , 1 , ENC_NA ) ;
 proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_cause , tvb , curr_offset , 1 , ENC_NA ) ;
 curr_offset ++ ;
 curr_len -- ;
 EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;
 return ( curr_offset - offset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int dissect_h225_NonStandardParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 803 ""./asn1/h225/h225.cnf"" nsp_handle = NULL ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardParameter , NonStandardParameter_sequence ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DestinationInfo_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 310 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> is_destinationInfo = TRUE ;
 }
 offset = dissect_h225_AliasAddress ( tvb , offset , actx , tree , hf_index ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"int TSStatCreate ( const char * the_name , TSRecordDataType the_type , TSStatPersistence persist , TSStatSync sync ) {
 int id = ink_atomic_increment ( & api_rsb_index , 1 ) ;
 RecRawStatSyncCb syncer = RecRawStatSyncCount ;
 if ( ( sdk_sanity_check_null_ptr ( ( void * ) the_name ) != TS_SUCCESS ) || ( sdk_sanity_check_null_ptr ( ( void * ) api_rsb ) != TS_SUCCESS ) || ( id >= api_rsb -> max_stats ) ) {
 return TS_ERROR ;
 }
 switch ( sync ) {
 case TS_STAT_SYNC_SUM : syncer = RecRawStatSyncSum ;
 break ;
 case TS_STAT_SYNC_AVG : syncer = RecRawStatSyncAvg ;
 break ;
 case TS_STAT_SYNC_TIMEAVG : syncer = RecRawStatSyncHrTimeAvg ;
 break ;
 default : syncer = RecRawStatSyncCount ;
 break ;
 }
 switch ( persist ) {
 case TS_STAT_PERSISTENT : RecRegisterRawStat ( api_rsb , RECT_PLUGIN , the_name , ( RecDataT ) the_type , RECP_PERSISTENT , id , syncer ) ;
 break ;
 case TS_STAT_NON_PERSISTENT : RecRegisterRawStat ( api_rsb , RECT_PLUGIN , the_name , ( RecDataT ) the_type , RECP_NON_PERSISTENT , id , syncer ) ;
 break ;
 default : return TS_ERROR ;
 }
 return id ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateLocalBlockStateCopiedAndResetOnProfilePref ) {
 base : : DictionaryValue prefs_local ;
 prefs_local . SetBoolean ( ""tel"" , true ) ;
 local_state_ -> Set ( prefs : : kExcludedSchemes , prefs_local ) ;
 ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( ""tel"" , profile_ . get ( ) ) ;
 EXPECT_EQ ( ExternalProtocolHandler : : UNKNOWN , block_state ) ;
 EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( AccountChooserDialogAndroidTest , CheckHistogramsReportingOnceAccountViaOnAccountClick ) {
 base : : HistogramTester histogram_tester ;
 AccountChooserDialogAndroid * dialog = CreateDialogOneAccount ( ) ;
 dialog -> OnCredentialClicked ( base : : android : : AttachCurrentThread ( ) , nullptr , , static_cast < int > ( password_manager : : CredentialType : : CREDENTIAL_TYPE_PASSWORD ) , false ) ;
 dialog -> Destroy ( base : : android : : AttachCurrentThread ( ) , nullptr ) ;
 histogram_tester . ExpectUniqueSample ( ""PasswordManager.AccountChooserDialog"" , password_manager : : metrics_util : : ACCOUNT_CHOOSER_CREDENTIAL_CHOSEN , 1 ) ;
 histogram_tester . ExpectUniqueSample ( ""PasswordManager.AccountChooserDialogOneAccount"" , password_manager : : metrics_util : : ACCOUNT_CHOOSER_CREDENTIAL_CHOSEN , 1 ) ;
 histogram_tester . ExpectTotalCount ( ""PasswordManager.AccountChooserDialogMultipleAccounts"" , 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST ( BuildTime , TimeLooksValid ) {
 # if defined ( DONT_EMBED_BUILD_METADATA ) char build_time [ ] = ""08:00:00"" ;
 # else char build_time [ ] = __TIME__ ;
 # endif EXPECT_EQ ( 8u , strlen ( build_time ) ) ;
 EXPECT_EQ ( ':' , build_time [ 2 ] ) ;
 EXPECT_EQ ( ':' , build_time [ 5 ] ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static char * wv_csp10_opaque_binary_tag ( tvbuff_t * tvb , guint32 offset , guint8 token , guint8 codepage , guint32 * length ) {
 guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;
 char * str = NULL ;
 switch ( codepage ) {
 case 0 : switch ( token ) {
 case 0x0B : case 0x0F : case 0x1A : case 0x3C : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;
 break ;
 case 0x11 : str = wv_datetime_from_opaque ( tvb , offset + * length , data_len ) ;
 break ;
 default : break ;
 }
 break ;
 case 1 : switch ( token ) {
 case 0x1C : case 0x32 : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;
 break ;
 default : break ;
 }
 break ;
 case 3 : switch ( token ) {
 case 0x06 : case 0x0C : case 0x0D : case 0x0E : case 0x11 : case 0x12 : case 0x13 : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;
 break ;
 default : break ;
 }
 break ;
 default : break ;
 }
 if ( str == NULL ) {
 str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""(%d bytes of unparsed opaque data)"" , data_len ) ;
 }
 * length += data_len ;
 return str ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void check_data_home ( const char * path ) {
 }",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0x6_16 ( IpvideoContext * s ) {
 signed char x , y ;
 x = bytestream2_get_byte ( & s -> stream_ptr ) ;
 y = bytestream2_get_byte ( & s -> stream_ptr ) ;
 av_dlog ( NULL , "" motion bytes = %d, %d\n"" , x , y ) ;
 return copy_from ( s , & s -> second_last_frame , x , y ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int64_t num = args [ 0 ] . int64Value ;
 UChar result [ UPRINTF_BUFFER_SIZE ] ;
 int32_t len = UPRINTF_BUFFER_SIZE ;
 if ( info -> fIsShort ) num &= UINT16_MAX ;
 else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;
 ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;
 if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {
 memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;
 result [ 0 ] = 0x0030 ;
 len += 1 ;
 }
 return handler -> pad_and_justify ( context , info , result , len ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph ) ;
 __exctype ( isprint ) ;
 __exctype ( ispunct )",1
Detect whether the following code contains vulnerabilities.,"static void final_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font HB_UNUSED , hb_buffer_t * buffer ) {
 unsigned int count = buffer -> len ;
 if ( unlikely ( ! count ) ) return ;
 hb_glyph_info_t * info = buffer -> info ;
 unsigned int last = 0 ;
 unsigned int last_syllable = info [ 0 ] . syllable ( ) ;
 for ( unsigned int i = 1 ;
 i < count ;
 i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {
 final_reordering_syllable ( plan , buffer , last , i ) ;
 last = i ;
 last_syllable = info [ last ] . syllable ( ) ;
 }
 final_reordering_syllable ( plan , buffer , last , count ) ;
 HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_category ) ;
 HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_position ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l ) ;
 __exctype_l ( ispunct_l ) ;
 __exctype_l ( isspace_l ) ;
 __exctype_l ( isupper_l )",1
Detect whether the following code contains vulnerabilities.,"static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int ret = 0 , buf_size = avpkt -> size ;
 CinepakContext * s = avctx -> priv_data ;
 s -> data = buf ;
 s -> size = buf_size ;
 if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) ) {
 av_log ( avctx , AV_LOG_ERROR , ""reget_buffer() failed\n"" ) ;
 return ret ;
 }
 if ( s -> palette_video ) {
 const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;
 if ( pal ) {
 s -> frame . palette_has_changed = 1 ;
 memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;
 }
 }
 cinepak_decode ( s ) ;
 if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
 if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ;
 * got_frame = 1 ;
 return buf_size ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void curl_setup_http_get ( CURL * curl , const char * url , const char * custom_req ) {
 curl_easy_setopt ( curl , CURLOPT_HTTPGET , 1 ) ;
 curl_easy_setopt ( curl , CURLOPT_URL , url ) ;
 curl_easy_setopt ( curl , CURLOPT_CUSTOMREQUEST , custom_req ) ;
 curl_easy_setopt ( curl , CURLOPT_WRITEFUNCTION , fwrite_null ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_DestinationInfo_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 312 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> is_destinationInfo = TRUE ;
 }
 offset = dissect_h225_AliasAddress ( tvb , offset , actx , tree , hf_index ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pdf_run_W ( fz_context * ctx , pdf_processor * proc ) {
 pdf_run_processor * pr = ( pdf_run_processor * ) proc ;
 pr -> clip = 1 ;
 pr -> clip_even_odd = 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_energy_phase ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_energy_phase_id , tvb , * offset , 1 , ENC_NA ) ;
 * offset += 1 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_macro_phase_id , tvb , * offset , 1 , ENC_NA ) ;
 * offset += 1 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_expect_duration , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_peak_power , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_energy , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_max_active_delay , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int floor_log2 ( uint32 n ) {
 int logval = 0 ;
 if ( n == 0 ) return - 1 ;
 if ( n >= ( 1 << 16 ) ) {
 n >>= 16 ;
 logval += 16 ;
 }
 if ( n >= ( 1 << 8 ) ) {
 n >>= 8 ;
 logval += 8 ;
 }
 if ( n >= ( 1 << 4 ) ) {
 n >>= 4 ;
 logval += 4 ;
 }
 if ( n >= ( 1 << 2 ) ) {
 n >>= 2 ;
 logval += 2 ;
 }
 if ( n >= ( 1 << 1 ) ) {
 logval += 1 ;
 }
 return logval ;
 }",0
Detect whether the following code contains vulnerabilities.,"int RECORD_LAYER_read_pending ( const RECORD_LAYER * rl ) {
 return SSL3_BUFFER_get_left ( & rl -> rbuf ) != 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"END_TEST START_TEST ( test_find_user_by_ip ) {
 in_addr_t ip ;
 unsigned int testip ;
 ip = inet_addr ( ""127.0.0.1"" ) ;
 init_users ( ip , 27 ) ;
 users [ 0 ] . conn = CONN_DNS_NULL ;
 testip = ( unsigned int ) inet_addr ( ""10.0.0.1"" ) ;
 fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;
 testip = ( unsigned int ) inet_addr ( ""127.0.0.2"" ) ;
 fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;
 users [ 0 ] . active = 1 ;
 testip = ( unsigned int ) inet_addr ( ""127.0.0.2"" ) ;
 fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;
 users [ 0 ] . last_pkt = time ( NULL ) ;
 testip = ( unsigned int ) inet_addr ( ""127.0.0.2"" ) ;
 fail_unless ( find_user_by_ip ( testip ) == 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_ptrace_traceme ( struct task_struct * parent ) {
 return task_has_perm ( parent , current , PROCESS__PTRACE ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"PKCS7 * d2i_PKCS7_fp ( FILE * fp , PKCS7 * * p7 ) {
 return ASN1_item_d2i_fp ( ASN1_ITEM_rptr ( PKCS7 ) , fp , p7 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t compareMappingsBytesFirst ( const void * context , const void * left , const void * right ) {
 UCMTable * table = ( UCMTable * ) context ;
 int32_t l = * ( const int32_t * ) left , r = * ( const int32_t * ) right ;
 return compareMappings ( table , table -> mappings + l , table , table -> mappings + r , FALSE ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_IS11172AudioCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172AudioCapability , IS11172AudioCapability_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * authGSSServerTargetName ( PyObject * self , PyObject * args ) {
 gss_server_state * state ;
 PyObject * pystate ;
 if ( ! PyArg_ParseTuple ( args , ""O"" , & pystate ) ) return NULL ;
 # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {
 # else if ( ! PyCObject_Check ( pystate ) ) {
 # endif PyErr_SetString ( PyExc_TypeError , ""Expected a context object"" ) ;
 return NULL ;
 }
 # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;
 # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;
 # endif if ( state == NULL ) return NULL ;
 return Py_BuildValue ( ""s"" , state -> targetname ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_Ind_multiplex ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Ind_multiplex , Ind_multiplex_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int SpoolssDeletePrinter_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {
 offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;
 offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int init_dumping ( char * database , int init_func ( char * ) ) {
 if ( mysql_select_db ( mysql , database ) ) {
 DB_error ( mysql , ""when selecting the database"" ) ;
 return 1 ;
 }
 if ( ! path && ! opt_xml ) {
 if ( opt_databases || opt_alldbs ) {
 char quoted_database_buf [ NAME_LEN * 2 + 3 ] ;
 char * qdatabase = quote_name ( database , quoted_database_buf , opt_quoted ) ;
 print_comment ( md_result_file , 0 , ""\n--\n-- Current Database: %s\n--\n"" , qdatabase ) ;
 init_func ( qdatabase ) ;
 fprintf ( md_result_file , ""\nUSE %s;
\n"" , qdatabase ) ;
 check_io ( md_result_file ) ;
 }
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int find_fp_qindex ( ) {
 int i ;
 for ( i = 0 ;
 i < QINDEX_RANGE ;
 ++ i ) if ( vp9_convert_qindex_to_q ( i ) >= 30.0 ) break ;
 if ( i == QINDEX_RANGE ) i -- ;
 return i ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void tqi_idct_put ( TqiContext * t , int16_t ( * block ) [ 64 ] ) {
 MpegEncContext * s = & t -> s ;
 int linesize = t -> frame . linesize [ 0 ] ;
 uint8_t * dest_y = t -> frame . data [ 0 ] + ( s -> mb_y * 16 * linesize ) + s -> mb_x * 16 ;
 uint8_t * dest_cb = t -> frame . data [ 1 ] + ( s -> mb_y * 8 * t -> frame . linesize [ 1 ] ) + s -> mb_x * 8 ;
 uint8_t * dest_cr = t -> frame . data [ 2 ] + ( s -> mb_y * 8 * t -> frame . linesize [ 2 ] ) + s -> mb_x * 8 ;
 ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;
 ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;
 if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 ff_ea_idct_put_c ( dest_cb , t -> frame . linesize [ 1 ] , block [ 4 ] ) ;
 ff_ea_idct_put_c ( dest_cr , t -> frame . linesize [ 2 ] , block [ 5 ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {
 const uint8_t * buf = avpkt -> data ;
 int ret = 0 , buf_size = avpkt -> size ;
 CinepakContext * s = avctx -> priv_data ;
 s -> data = buf ;
 s -> size = buf_size ;
 s -> frame . reference = 1 ;
 s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;
 if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) ) {
 av_log ( avctx , AV_LOG_ERROR , ""reget_buffer() failed\n"" ) ;
 return ret ;
 }
 if ( s -> palette_video ) {
 const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;
 if ( pal ) {
 s -> frame . palette_has_changed = 1 ;
 memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;
 }
 }
 cinepak_decode ( s ) ;
 if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;
 * got_frame = 1 ;
 * ( AVFrame * ) data = s -> frame ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;
 __exctype_l ( isalpha_l ) ;
 __exctype_l ( iscntrl_l ) ;
 __exctype_l ( isdigit_l ) ;
 __exctype_l ( islower_l ) ;
 __exctype_l ( isgraph_l ) ;
 __exctype_l ( isprint_l ) ;
 __exctype_l ( ispunct_l ) ;
 __exctype_l ( isspace_l )",1
Detect whether the following code contains vulnerabilities.,"static void mark_all_files_unconfirmed ( NautilusDirectory * directory ) {
 GList * node ;
 NautilusFile * file ;
 for ( node = directory -> details -> file_list ;
 node != NULL ;
 node = node -> next ) {
 file = node -> data ;
 set_file_unconfirmed ( file , TRUE ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"int jpc_ft_analyze ( jpc_fix_t * a , int xstart , int ystart , int width , int height , int stride ) {
 int numrows = height ;
 int numcols = width ;
 int rowparity = ystart & 1 ;
 int colparity = xstart & 1 ;
 int i ;
 jpc_fix_t * startptr ;
 int maxcols ;
 maxcols = ( numcols / JPC_QMFB_COLGRPSIZE ) * JPC_QMFB_COLGRPSIZE ;
 startptr = & a [ 0 ] ;
 for ( i = 0 ;
 i < maxcols ;
 i += JPC_QMFB_COLGRPSIZE ) {
 jpc_qmfb_split_colgrp ( startptr , numrows , stride , rowparity ) ;
 jpc_ft_fwdlift_colgrp ( startptr , numrows , stride , rowparity ) ;
 startptr += JPC_QMFB_COLGRPSIZE ;
 }
 if ( maxcols < numcols ) {
 jpc_qmfb_split_colres ( startptr , numrows , numcols - maxcols , stride , rowparity ) ;
 jpc_ft_fwdlift_colres ( startptr , numrows , numcols - maxcols , stride , rowparity ) ;
 }
 startptr = & a [ 0 ] ;
 for ( i = 0 ;
 i < numrows ;
 ++ i ) {
 jpc_qmfb_split_row ( startptr , numcols , colparity ) ;
 jpc_ft_fwdlift_row ( startptr , numcols , colparity ) ;
 startptr += stride ;
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void * pdf_new_processor ( fz_context * ctx , int size ) {
 return Memento_label ( fz_calloc ( ctx , 1 , size ) , ""pdf_processor"" ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"extern int name ( int ) __THROW __exctype ( isalnum ) ;
 __exctype ( isalpha ) ;
 __exctype ( iscntrl ) ;
 __exctype ( isdigit ) ;
 __exctype ( islower ) ;
 __exctype ( isgraph )",1
Detect whether the following code contains vulnerabilities.,"void vp9_encode_sby_pass1 ( MACROBLOCK * x , BLOCK_SIZE bsize ) {
 vp9_subtract_plane ( x , bsize , 0 ) ;
 vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , 0 , encode_block_pass1 , x ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int encode_offset ( char * string , struct filter_op * fop ) {
 char * str , * p , * q , * tok ;
 int ret ;
 memset ( fop , 0 , sizeof ( struct filter_op ) ) ;
 str = strdup ( string ) ;
 p = ec_strtok ( str , ""."" , & tok ) ;
 q = ec_strtok ( NULL , ""."" , & tok ) ;
 if ( q == NULL ) return - E_NOTFOUND ;
 ret = get_virtualpointer ( p , q , & fop -> op . test . level , & fop -> op . test . offset , & fop -> op . test . size ) ;
 SAFE_FREE ( str ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) {
 struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ;
 struct tipc_link_info link_info ;
 int err ;
 if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ;
 err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ;
 if ( err ) return err ;
 link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ;
 link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ;
 strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;
 return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static Asn1Generic * DecodeAsn1DerPrintableString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {
 const unsigned char * d_ptr = buffer ;
 uint32_t length , numbytes ;
 Asn1Generic * a ;
 unsigned char c ;
 d_ptr ++ ;
 c = d_ptr [ 0 ] ;
 if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {
 length = c ;
 d_ptr ++ ;
 }
 else {
 numbytes = c & 0x7f ;
 d_ptr ++ ;
 if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {
 return NULL ;
 }
 }
 if ( length > max_size ) return NULL ;
 a = Asn1GenericNew ( ) ;
 if ( a == NULL ) return NULL ;
 a -> type = ASN1_PRINTSTRING ;
 a -> strlen = length ;
 a -> str = SCMalloc ( length + 1 ) ;
 if ( a -> str == NULL ) {
 SCFree ( a ) ;
 return NULL ;
 }
 strlcpy ( a -> str , ( const char * ) d_ptr , length + 1 ) ;
 a -> str [ length ] = '\0' ;
 d_ptr += length ;
 a -> length = ( d_ptr - buffer ) ;
 return a ;
 }",1
Detect whether the following code contains vulnerabilities.,"int fn_printn ( netdissect_options * ndo , register const u_char * s , register u_int n , register const u_char * ep ) {
 register u_char c ;
 while ( n > 0 && ( ep == NULL || s < ep ) ) {
 n -- ;
 c = * s ++ ;
 if ( ! ND_ISASCII ( c ) ) {
 c = ND_TOASCII ( c ) ;
 ND_PRINT ( ( ndo , ""M-"" ) ) ;
 }
 if ( ! ND_ISPRINT ( c ) ) {
 c ^= 0x40 ;
 ND_PRINT ( ( ndo , ""^"" ) ) ;
 }
 ND_PRINT ( ( ndo , ""%c"" , c ) ) ;
 }
 return ( n == 0 ) ? 0 : 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void set_num_733 ( unsigned char * p , uint32_t value ) {
 archive_le32enc ( p , value ) ;
 archive_be32enc ( p + 4 , value ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 871 ""./asn1/h225/h225.cnf"" const gchar * oid_str = NULL ;
 gef_ctx_t * gefx ;
 offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) gefx -> id = oid_str ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void spl_ptr_llist_destroy ( spl_ptr_llist * llist TSRMLS_DC ) {
 spl_ptr_llist_element * current = llist -> head , * next ;
 spl_ptr_llist_dtor_func dtor = llist -> dtor ;
 while ( current ) {
 next = current -> next ;
 if ( current && dtor ) {
 dtor ( current TSRMLS_CC ) ;
 }
 SPL_LLIST_DELREF ( current ) ;
 current = next ;
 }
 efree ( llist ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {
 int i ;
 memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;
 memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;
 for ( i = 0 ;
 i < 32 ;
 i ++ ) {
 dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;
 sbrdsp -> sum64x5 ( z ) ;
 sbrdsp -> qmf_pre_shuffle ( z ) ;
 mdct -> imdct_half ( mdct , z , z + 64 ) ;
 sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ;
 x += 32 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_fill_rect ( struct vmsvga_state_s * s , uint32_t c , int x , int y , int w , int h ) {
 DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
 int bypl = surface_stride ( surface ) ;
 int width = surface_bytes_per_pixel ( surface ) * w ;
 int line = h ;
 int column ;
 uint8_t * fst ;
 uint8_t * dst ;
 uint8_t * src ;
 uint8_t col [ 4 ] ;
 col [ 0 ] = c ;
 col [ 1 ] = c >> 8 ;
 col [ 2 ] = c >> 16 ;
 col [ 3 ] = c >> 24 ;
 fst = s -> vga . vram_ptr + surface_bytes_per_pixel ( surface ) * x + bypl * y ;
 if ( line -- ) {
 dst = fst ;
 src = col ;
 for ( column = width ;
 column > 0 ;
 column -- ) {
 * ( dst ++ ) = * ( src ++ ) ;
 if ( src - col == surface_bytes_per_pixel ( surface ) ) {
 src = col ;
 }
 }
 dst = fst ;
 for ( ;
 line > 0 ;
 line -- ) {
 dst += bypl ;
 memcpy ( dst , fst , width ) ;
 }
 }
 vmsvga_update_rect_delayed ( s , x , y , w , h ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ps2_kbd_pre_save ( void * opaque ) {
 PS2KbdState * s = ( PS2KbdState * ) opaque ;
 PS2State * ps2 = & s -> common ;
 ps2_common_post_load ( ps2 ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void init_mv ( FourXContext * f ) {
 int i ;
 for ( i = 0 ;
 i < 256 ;
 i ++ ) {
 if ( f -> version > 1 ) f -> mv [ i ] = mv [ i ] [ 0 ] + mv [ i ] [ 1 ] * f -> current_picture -> linesize [ 0 ] / 2 ;
 else f -> mv [ i ] = ( i & 15 ) - 8 + ( ( i >> 4 ) - 8 ) * f -> current_picture -> linesize [ 0 ] / 2 ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , NoNavigationObserverBlock ) {
 Profile * profile = browser ( ) -> profile ( ) ;
 SupervisedUserSettingsService * supervised_user_settings_service = SupervisedUserSettingsServiceFactory : : GetForProfile ( profile ) ;
 supervised_user_settings_service -> SetLocalSetting ( supervised_users : : kContentPackDefaultFilteringBehavior , std : : unique_ptr < base : : Value > ( new base : : Value ( SupervisedUserURLFilter : : BLOCK ) ) ) ;
 std : : unique_ptr < WebContents > web_contents ( WebContents : : Create ( WebContents : : CreateParams ( profile ) ) ) ;
 NavigationController & controller = web_contents -> GetController ( ) ;
 content : : TestNavigationObserver observer ( web_contents . get ( ) ) ;
 controller . LoadURL ( GURL ( ""http://www.example.com"" ) , content : : Referrer ( ) , ui : : PAGE_TRANSITION_TYPED , std : : string ( ) ) ;
 observer . Wait ( ) ;
 content : : NavigationEntry * entry = controller . GetActiveEntry ( ) ;
 ASSERT_TRUE ( entry ) ;
 EXPECT_EQ ( content : : PAGE_TYPE_NORMAL , entry -> GetPageType ( ) ) ;
 EXPECT_FALSE ( observer . last_navigation_succeeded ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( tx_type == DCT_DCT ) {
 vp9_idct8x8_add ( input , dest , stride , eob ) ;
 }
 else {
 vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void * Type_MPE_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {
 return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;
 cmsUNUSED_PARAMETER ( n ) ;
 cmsUNUSED_PARAMETER ( self ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_ConferenceResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_ConferenceResponse , ConferenceResponse_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_RegistrationRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 679 ""./asn1/h225/h225.cnf"" gint32 value ;
 h225_packet_info * h225_pi ;
 h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_RegistrationRejectReason , RegistrationRejectReason_choice , & value ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> reason = value ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileInfo , getPath ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 char * path ;
 int path_len ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 path = spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;
 RETURN_STRINGL ( path , path_len , 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"zend_object_iterator * spl_filesystem_dir_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {
 spl_filesystem_iterator * iterator ;
 spl_filesystem_object * dir_object ;
 if ( by_ref ) {
 zend_error ( E_ERROR , ""An iterator cannot be used with foreach by reference"" ) ;
 }
 dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;
 iterator = spl_filesystem_object_to_iterator ( dir_object ) ;
 if ( iterator -> intern . data == NULL ) {
 iterator -> intern . data = object ;
 iterator -> intern . funcs = & spl_filesystem_dir_it_funcs ;
 iterator -> current = object ;
 }
 zval_add_ref ( & object ) ;
 return ( zend_object_iterator * ) iterator ;
 }",1
Detect whether the following code contains vulnerabilities.,"int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {
 unsigned char * p , * d ;
 int i ;
 unsigned long l ;
 if ( s -> state == a ) {
 d = ( unsigned char * ) s -> init_buf -> data ;
 p = & ( d [ 4 ] ) ;
 i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;
 s -> s3 -> tmp . finish_md_len = i ;
 memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;
 p += i ;
 l = i ;
 if ( s -> type == SSL_ST_CONNECT ) {
 OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;
 memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;
 s -> s3 -> previous_client_finished_len = i ;
 }
 else {
 OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;
 memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;
 s -> s3 -> previous_server_finished_len = i ;
 }
 # ifdef OPENSSL_SYS_WIN16 l &= 0xffff ;
 # endif * ( d ++ ) = SSL3_MT_FINISHED ;
 l2n3 ( l , d ) ;
 s -> init_num = ( int ) l + 4 ;
 s -> init_off = 0 ;
 s -> state = b ;
 }
 return ( ssl3_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void vvalue_strbuf_append_blob ( wmem_strbuf_t * strbuf , void * ptr ) {
 struct data_blob * blob = ( struct data_blob * ) ptr ;
 wmem_strbuf_append_printf ( strbuf , ""size: %d"" , ( int ) blob -> size ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {
 int i , j ;
 int16_t out [ 8 * 8 ] ;
 int16_t * outptr = out ;
 int16_t temp_in [ 8 ] , temp_out [ 8 ] ;
 const transform_2d ht = IHT_8 [ tx_type ] ;
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 ht . rows ( input , outptr ) ;
 input += 8 ;
 outptr += 8 ;
 }
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int i2d_EC_PUBKEY_fp ( FILE * fp , EC_KEY * eckey ) {
 return ASN1_i2d_fp_of ( EC_KEY , i2d_EC_PUBKEY , fp , eckey ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int test_compare_files ( const char * tgt , const char * rec ) {
 FILE * orig , * recons ;
 static uint8_t obuf [ TESTBUFSIZE ] , rbuf [ TESTBUFSIZE ] ;
 xoff_t offset = 0 ;
 size_t i ;
 size_t oc , rc ;
 xoff_t diffs = 0 ;
 if ( ( orig = fopen ( tgt , ""r"" ) ) == NULL ) {
 XPR ( NT ""open %s failed\n"" , tgt ) ;
 return get_errno ( ) ;
 }
 if ( ( recons = fopen ( rec , ""r"" ) ) == NULL ) {
 XPR ( NT ""open %s failed\n"" , rec ) ;
 return get_errno ( ) ;
 }
 for ( ;
 ;
 ) {
 oc = fread ( obuf , 1 , TESTBUFSIZE , orig ) ;
 rc = fread ( rbuf , 1 , TESTBUFSIZE , recons ) ;
 if ( oc != rc ) {
 return XD3_INTERNAL ;
 }
 if ( oc == 0 ) {
 break ;
 }
 for ( i = 0 ;
 i < oc ;
 i += 1 ) {
 if ( obuf [ i ] != rbuf [ i ] ) {
 XPR ( NT ""byte %u (read %u @ %"" Q ""u) %d != %d\n"" , ( int ) i , ( int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ;
 diffs ++ ;
 return XD3_INTERNAL ;
 }
 }
 offset += oc ;
 }
 fclose ( orig ) ;
 fclose ( recons ) ;
 if ( diffs != 0 ) {
 return XD3_INTERNAL ;
 }
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_OCTET_STRING_SIZE_2_32 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 2 , 32 , FALSE , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"rfbBool rfbSendXvp ( rfbClientPtr cl , uint8_t version , uint8_t code ) {
 rfbXvpMsg xvp ;
 xvp . type = rfbXvp ;
 xvp . pad = 0 ;
 xvp . version = version ;
 xvp . code = code ;
 LOCK ( cl -> sendMutex ) ;
 if ( rfbWriteExact ( cl , ( char * ) & xvp , sz_rfbXvpMsg ) < 0 ) {
 rfbLogPerror ( ""rfbSendXvp: write"" ) ;
 rfbCloseClient ( cl ) ;
 }
 UNLOCK ( cl -> sendMutex ) ;
 rfbStatRecordMessageSent ( cl , rfbXvp , sz_rfbXvpMsg , sz_rfbXvpMsg ) ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void setup_mi ( VP9_COMMON * cm ) {
 cm -> mi = cm -> mip + cm -> mi_stride + 1 ;
 cm -> prev_mi = cm -> prev_mip + cm -> mi_stride + 1 ;
 cm -> mi_grid_visible = cm -> mi_grid_base + cm -> mi_stride + 1 ;
 cm -> prev_mi_grid_visible = cm -> prev_mi_grid_base + cm -> mi_stride + 1 ;
 vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ;
 vpx_memset ( cm -> mi_grid_base , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mi_grid_base ) ) ;
 clear_mi_border ( cm , cm -> prev_mip ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int proc_setconfig ( struct usb_dev_state * ps , void __user * arg ) {
 int u ;
 int status = 0 ;
 struct usb_host_config * actconfig ;
 if ( get_user ( u , ( int __user * ) arg ) ) return - EFAULT ;
 actconfig = ps -> dev -> actconfig ;
 if ( actconfig ) {
 int i ;
 for ( i = 0 ;
 i < actconfig -> desc . bNumInterfaces ;
 ++ i ) {
 if ( usb_interface_claimed ( actconfig -> interface [ i ] ) ) {
 dev_warn ( & ps -> dev -> dev , ""usbfs: interface %d claimed by %s "" ""while '%s' sets config #%d\n"" , actconfig -> interface [ i ] -> cur_altsetting -> desc . bInterfaceNumber , actconfig -> interface [ i ] -> dev . driver -> name , current -> comm , u ) ;
 status = - EBUSY ;
 break ;
 }
 }
 }
 if ( status == 0 ) {
 if ( actconfig && actconfig -> desc . bConfigurationValue == u ) status = usb_reset_configuration ( ps -> dev ) ;
 else status = usb_set_configuration ( ps -> dev , u ) ;
 }
 return status ;
 }",0
Detect whether the following code contains vulnerabilities.,"void Curl_formclean ( struct FormData * * form_ptr ) {
 struct FormData * next , * form ;
 form = * form_ptr ;
 if ( ! form ) return ;
 do {
 next = form -> next ;
 if ( form -> type <= FORM_CONTENT ) free ( form -> line ) ;
 free ( form ) ;
 }
 while ( ( form = next ) != NULL ) ;
 * form_ptr = NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) {
 int i ;
 const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , maxq ) ;
 if ( minqtarget <= 2.0 ) return 0 ;
 for ( i = 0 ;
 i < QINDEX_RANGE ;
 i ++ ) if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) return i ;
 return QINDEX_RANGE - 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int ogg_new_stream ( AVFormatContext * s , uint32_t serial ) {
 struct ogg * ogg = s -> priv_data ;
 int idx = ogg -> nstreams ;
 AVStream * st ;
 struct ogg_stream * os ;
 size_t size ;
 if ( ogg -> state ) {
 av_log ( s , AV_LOG_ERROR , ""New streams are not supposed to be added "" ""in between Ogg context save/restore operations.\n"" ) ;
 return AVERROR_BUG ;
 }
 if ( av_size_mult ( ogg -> nstreams + 1 , sizeof ( * ogg -> streams ) , & size ) < 0 || ! ( os = av_realloc ( ogg -> streams , size ) ) ) return AVERROR ( ENOMEM ) ;
 ogg -> streams = os ;
 os = ogg -> streams + idx ;
 memset ( os , 0 , sizeof ( * os ) ) ;
 os -> serial = serial ;
 os -> bufsize = DECODER_BUFFER_SIZE ;
 os -> buf = av_malloc ( os -> bufsize + AV_INPUT_BUFFER_PADDING_SIZE ) ;
 os -> header = - 1 ;
 os -> start_granule = OGG_NOGRANULE_VALUE ;
 if ( ! os -> buf ) return AVERROR ( ENOMEM ) ;
 st = avformat_new_stream ( s , NULL ) ;
 if ( ! st ) {
 av_freep ( & os -> buf ) ;
 return AVERROR ( ENOMEM ) ;
 }
 st -> id = idx ;
 avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ;
 ogg -> nstreams ++ ;
 return idx ;
 }",0
Detect whether the following code contains vulnerabilities.,"gr_font * hb_graphite2_font_get_gr_font ( hb_font_t * font ) {
 if ( unlikely ( ! hb_graphite2_shaper_font_data_ensure ( font ) ) ) return NULL ;
 return HB_SHAPER_DATA_GET ( font ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int task_has_system ( struct task_struct * tsk , u32 perms ) {
 u32 sid = task_sid ( tsk ) ;
 return avc_has_perm ( sid , SECINITSID_KERNEL , SECCLASS_SYSTEM , perms , NULL ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void test_rfc822_parse_quoted_string ( void ) {
 const struct {
 const char * input , * output ;
 int ret ;
 }
 tests [ ] = {
 {
 ""\"""" , """" , - 1 }
 , {
 ""\""\"""" , """" , 0 }
 , {
 ""\""foo\"""" , ""foo"" , 0 }
 , {
 ""\""\""foo"" , """" , 1 }
 , {
 ""\""\""\"""" , """" , 1 }
 , {
 ""\""\\\""\"""" , ""\"""" , 0 }
 , {
 ""\""\\\\\"""" , ""\\"" , 0 }
 , {
 ""\""\\\\foo\\\\foo\\\\\"""" , ""\\foo\\foo\\"" , 0 }
 }
 ;
 struct rfc822_parser_context parser ;
 string_t * str = t_str_new ( 64 ) ;
 unsigned int i = 0 ;
 test_begin ( ""rfc822 parse quoted string"" ) ;
 for ( i = 0 ;
 i < N_ELEMENTS ( tests ) ;
 i ++ ) {
 rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;
 test_assert_idx ( rfc822_parse_quoted_string ( & parser , str ) == tests [ i ] . ret , i ) ;
 test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;
 str_truncate ( str , 0 ) ;
 }
 test_end ( ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vp9_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end , int mi_row , int mi_col ) {
 const VP9_COMMON * const cm = & cpi -> common ;
 MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;
 MODE_INFO * m ;
 xd -> mi = cm -> mi_grid_visible + ( mi_row * cm -> mi_stride + mi_col ) ;
 m = xd -> mi [ 0 ] ;
 set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;
 if ( frame_is_intra_only ( cm ) ) {
 write_mb_modes_kf ( cm , xd , xd -> mi , w ) ;
 }
 else {
 pack_inter_mode_mvs ( cpi , m , w ) ;
 }
 assert ( * tok < tok_end ) ;
 pack_mb_tokens ( w , tok , tok_end ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static OFCondition parseDummy ( unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {
 if ( availData < 4 ) return makeLengthError ( ""dummy item"" , availData , 4 ) ;
 unsigned short userLength ;
 buf ++ ;
 buf ++ ;
 EXTRACT_SHORT_BIG ( buf , userLength ) ;
 buf += 2 ;
 * itemLength = userLength + 4 ;
 if ( availData - 4 < userLength ) return makeLengthError ( ""dummy item"" , availData , 0 , userLength ) ;
 return EC_Normal ;
 }",0
Detect whether the following code contains vulnerabilities.,"qemu_irq qdev_get_gpio_in ( DeviceState * dev , int n ) {
 assert ( n >= 0 && n < dev -> num_gpio_in ) ;
 return dev -> gpio_in [ n ] ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_messageContent_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 758 ""./asn1/h225/h225.cnf"" tvbuff_t * next_tvb = NULL ;
 offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & next_tvb ) ;
 next_tvb_add_handle ( & tp_list , next_tvb , ( h225_tp_in_tree ) ? tree : NULL , tp_handle ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"const char * mime_field_value_get ( const MIMEField * field , int * length ) {
 * length = field -> m_len_value ;
 return field -> m_ptr_value ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( FilesystemIterator , getFlags ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_LONG ( intern -> flags & ( SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __always_inline __u32 __le32_to_cpup ( const __le32 * p ) {
 return ( __u32 ) * p ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , cavs_vector * src , int distp ) {
 int den = h -> scale_den [ src -> ref ] ;
 * d_x = ( src -> x * distp * den + 256 + ( src -> x >> 31 ) ) >> 9 ;
 * d_y = ( src -> y * distp * den + 256 + ( src -> y >> 31 ) ) >> 9 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_MaximumHeaderIntervalReq ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MaximumHeaderIntervalReq , MaximumHeaderIntervalReq_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static krb5_error_code randkey_princ ( krb5_principal princ , krb5_boolean keepold , int n_ks , krb5_key_salt_tuple * ks ) {
 if ( keepold || ks ) {
 return kadm5_randkey_principal_3 ( handle , princ , keepold , n_ks , ks , NULL , NULL ) ;
 }
 else return kadm5_randkey_principal ( handle , princ , NULL , NULL ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void ff_MPV_common_defaults ( MpegEncContext * s ) {
 s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ;
 s -> chroma_qscale_table = ff_default_chroma_qscale_table ;
 s -> progressive_frame = 1 ;
 s -> progressive_sequence = 1 ;
 s -> picture_structure = PICT_FRAME ;
 s -> coded_picture_number = 0 ;
 s -> picture_number = 0 ;
 s -> input_picture_number = 0 ;
 s -> picture_in_gop_number = 0 ;
 s -> f_code = 1 ;
 s -> b_code = 1 ;
 s -> picture_range_start = 0 ;
 s -> picture_range_end = MAX_PICTURE_COUNT ;
 s -> slice_context_count = 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void mp_get_code ( MotionPixelsContext * mp , GetBitContext * gb , int size , int code ) {
 while ( get_bits1 ( gb ) ) {
 ++ size ;
 if ( size > mp -> max_codes_bits ) {
 av_log ( mp -> avctx , AV_LOG_ERROR , ""invalid code size %d/%d\n"" , size , mp -> max_codes_bits ) ;
 return ;
 }
 code <<= 1 ;
 mp_get_code ( mp , gb , size , code + 1 ) ;
 }
 if ( mp -> current_codes_count >= MAX_HUFF_CODES ) {
 av_log ( mp -> avctx , AV_LOG_ERROR , ""too many codes\n"" ) ;
 return ;
 }
 mp -> codes [ mp -> current_codes_count ] . code = code ;
 mp -> codes [ mp -> current_codes_count ++ ] . size = size ;
 }",0
Detect whether the following code contains vulnerabilities.,"static unsigned char * do_get_buffer ( gcry_mpi_t a , unsigned int * nbytes , int * sign , int force_secure ) {
 unsigned char * p , * buffer ;
 mpi_limb_t alimb ;
 int i ;
 size_t n ;
 if ( sign ) * sign = a -> sign ;
 * nbytes = a -> nlimbs * BYTES_PER_MPI_LIMB ;
 n = * nbytes ? * nbytes : 1 ;
 p = buffer = ( force_secure || mpi_is_secure ( a ) ) ? gcry_malloc_secure ( n ) : gcry_malloc ( n ) ;
 if ( ! buffer ) return NULL ;
 for ( i = a -> nlimbs - 1 ;
 i >= 0 ;
 i -- ) {
 alimb = a -> d [ i ] ;
 # if BYTES_PER_MPI_LIMB == 4 * p ++ = alimb >> 24 ;
 * p ++ = alimb >> 16 ;
 * p ++ = alimb >> 8 ;
 * p ++ = alimb ;
 # elif BYTES_PER_MPI_LIMB == 8 * p ++ = alimb >> 56 ;
 * p ++ = alimb >> 48 ;
 * p ++ = alimb >> 40 ;
 * p ++ = alimb >> 32 ;
 * p ++ = alimb >> 24 ;
 * p ++ = alimb >> 16 ;
 * p ++ = alimb >> 8 ;
 * p ++ = alimb ;
 # else # error please implement for this limb size . # endif }
 for ( p = buffer ;
 * nbytes && ! * p ;
 p ++ , -- * nbytes ) ;
 if ( p != buffer ) memmove ( buffer , p , * nbytes ) ;
 return buffer ;
 }",1
Detect whether the following code contains vulnerabilities.,"xmlRegisterNodeFunc * __xmlRegisterNodeDefaultValue ( void ) {
 if ( IS_MAIN_THREAD ) return ( & xmlRegisterNodeDefaultValue ) ;
 else return ( & xmlGetGlobalState ( ) -> xmlRegisterNodeDefaultValue ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Status_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 386 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Status_UUIE , Status_UUIE_sequence ) ;
 # line 390 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_STATUS ;
 g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ;
 else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int proto_get_next_protocol ( void * * cookie ) {
 GList * list_item = ( GList * ) * cookie ;
 protocol_t * protocol ;
 list_item = g_list_next ( list_item ) ;
 if ( list_item == NULL ) return - 1 ;
 * cookie = list_item ;
 protocol = ( protocol_t * ) list_item -> data ;
 return protocol -> proto_id ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_T_standard ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 862 ""./asn1/h225/h225.cnf"" guint32 value_int = ( guint32 ) - 1 ;
 gef_ctx_t * gefx ;
 offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 16383U , & value_int , TRUE ) ;
 gefx = gef_ctx_get ( actx -> private_data ) ;
 if ( gefx ) gefx -> id = wmem_strdup_printf ( wmem_packet_scope ( ) , ""%u"" , value_int ) ;
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int decode_udvm_address_operand ( guint8 * buff , guint operand_address , guint16 * value , guint current_address ) {
 guint32 result ;
 guint16 value1 ;
 guint next_opreand_address ;
 next_opreand_address = decode_udvm_multitype_operand ( buff , operand_address , & value1 ) ;
 result = value1 & 0xffff ;
 result = result + current_address ;
 * value = result & 0xffff ;
 return next_opreand_address ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int kq_insert ( struct kqop * kqop , struct kevent * kev ) {
 int nevents = kqop -> nevents ;
 if ( kqop -> nchanges == nevents ) {
 struct kevent * newchange ;
 struct kevent * newresult ;
 nevents *= 2 ;
 newchange = realloc ( kqop -> changes , nevents * sizeof ( struct kevent ) ) ;
 if ( newchange == NULL ) {
 event_warn ( ""%s: malloc"" , __func__ ) ;
 return ( - 1 ) ;
 }
 kqop -> changes = newchange ;
 newresult = realloc ( kqop -> events , nevents * sizeof ( struct kevent ) ) ;
 if ( newresult == NULL ) {
 event_warn ( ""%s: malloc"" , __func__ ) ;
 return ( - 1 ) ;
 }
 kqop -> events = newresult ;
 kqop -> nevents = nevents ;
 }
 memcpy ( & kqop -> changes [ kqop -> nchanges ++ ] , kev , sizeof ( struct kevent ) ) ;
 event_debug ( ( ""%s: fd %d %s%s"" , __func__ , ( int ) kev -> ident , kev -> filter == EVFILT_READ ? ""EVFILT_READ"" : ""EVFILT_WRITE"" , kev -> flags == EV_DELETE ? "" (del)"" : """" ) ) ;
 return ( 0 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_text_valist_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , va_list ap ) {
 proto_item * pi ;
 header_field_info * hfinfo ;
 CHECK_FOR_NULL_TREE ( tree ) ;
 TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;
 pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;
 TRY_TO_FAKE_THIS_REPR ( pi ) ;
 proto_tree_set_representation ( pi , format , ap ) ;
 return pi ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int get_aq_c_strength ( int q_index ) {
 int base_quant = vp9_ac_quant ( q_index , 0 ) / 4 ;
 return ( base_quant > 20 ) + ( base_quant > 45 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {
 DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
 uint8_t * vram = s -> vga . vram_ptr ;
 int bypl = surface_stride ( surface ) ;
 int bypp = surface_bytes_per_pixel ( surface ) ;
 int width = bypp * w ;
 int line = h ;
 uint8_t * ptr [ 2 ] ;
 if ( y1 > y0 ) {
 ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;
 ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;
 for ( ;
 line > 0 ;
 line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {
 memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;
 }
 }
 else {
 ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;
 ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;
 for ( ;
 line > 0 ;
 line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {
 memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;
 }
 }
 vmsvga_update_rect_delayed ( s , x1 , y1 , w , h ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static struct object_list * * process_blob ( struct blob * blob , struct object_list * * p , struct name_path * path , const char * name ) {
 struct object * obj = & blob -> object ;
 obj -> flags |= LOCAL ;
 if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;
 obj -> flags |= SEEN ;
 return add_one_object ( obj , p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void * DecoderThread ( void * p_data ) {
 decoder_t * p_dec = ( decoder_t * ) p_data ;
 decoder_owner_sys_t * p_owner = p_dec -> p_owner ;
 for ( ;
 ;
 ) {
 block_t * p_block = block_FifoGet ( p_owner -> p_fifo ) ;
 bool end_wait = ! p_block || p_block -> i_flags & BLOCK_FLAG_CORE_EOS ;
 DecoderSignalWait ( p_dec , end_wait ) ;
 if ( end_wait ) input_DecoderStopWait ( p_dec ) ;
 if ( p_block ) {
 int canc = vlc_savecancel ( ) ;
 if ( p_block -> i_flags & BLOCK_FLAG_CORE_EOS ) {
 block_Release ( p_block ) ;
 p_block = NULL ;
 }
 DecoderProcess ( p_dec , p_block ) ;
 vlc_restorecancel ( canc ) ;
 }
 }
 return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"int NETSCAPE_SPKI_verify ( NETSCAPE_SPKI * a , EVP_PKEY * r ) {
 return ( ASN1_item_verify ( ASN1_ITEM_rptr ( NETSCAPE_SPKAC ) , a -> sig_algor , a -> signature , a -> spkac , r ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {
 if ( eob == 1 ) vp9_idct8x8_1_add ( input , dest , stride ) ;
 else if ( eob <= 12 ) vp9_idct8x8_12_add ( input , dest , stride ) ;
 else vp9_idct8x8_64_add ( input , dest , stride ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , getMaxLineLen ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 if ( zend_parse_parameters_none ( ) == FAILURE ) {
 return ;
 }
 RETURN_LONG ( ( long ) intern -> u . file . max_line_len ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"PyObject * PyString_AsDecodedString ( PyObject * str , const char * encoding , const char * errors ) {
 PyObject * v ;
 v = PyString_AsDecodedObject ( str , encoding , errors ) ;
 if ( v == NULL ) goto onError ;
 # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( v ) ) {
 PyObject * temp = v ;
 v = PyUnicode_AsEncodedString ( v , NULL , NULL ) ;
 Py_DECREF ( temp ) ;
 if ( v == NULL ) goto onError ;
 }
 # endif if ( ! PyString_Check ( v ) ) {
 PyErr_Format ( PyExc_TypeError , ""decoder did not return a string object (type=%.400s)"" , Py_TYPE ( v ) -> tp_name ) ;
 Py_DECREF ( v ) ;
 goto onError ;
 }
 return v ;
 onError : return NULL ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int xsltCheckFilename ( const char * path ) {
 # ifdef HAVE_STAT struct stat stat_buffer ;
 # if defined ( WIN32 ) && ! defined ( __CYGWIN__ ) DWORD dwAttrs ;
 dwAttrs = GetFileAttributesA ( path ) ;
 if ( dwAttrs != INVALID_FILE_ATTRIBUTES ) {
 if ( dwAttrs & FILE_ATTRIBUTE_DIRECTORY ) {
 return 2 ;
 }
 }
 # endif if ( stat ( path , & stat_buffer ) == - 1 ) return 0 ;
 # ifdef S_ISDIR if ( S_ISDIR ( stat_buffer . st_mode ) ) {
 return 2 ;
 }
 # endif # endif return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void intra_pred_lp_left ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {
 int x , y ;
 for ( y = 0 ;
 y < 8 ;
 y ++ ) for ( x = 0 ;
 x < 8 ;
 x ++ ) d [ y * stride + x ] = LOWPASS ( left , y + 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void nautilus_directory_cancel ( NautilusDirectory * directory ) {
 deep_count_cancel ( directory ) ;
 directory_count_cancel ( directory ) ;
 file_info_cancel ( directory ) ;
 file_list_cancel ( directory ) ;
 link_info_cancel ( directory ) ;
 mime_list_cancel ( directory ) ;
 new_files_cancel ( directory ) ;
 extension_info_cancel ( directory ) ;
 thumbnail_cancel ( directory ) ;
 mount_cancel ( directory ) ;
 filesystem_info_cancel ( directory ) ;
 if ( waiting_directories != NULL ) {
 g_hash_table_remove ( waiting_directories , directory ) ;
 }
 async_job_wake_up ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void http_large_delay_cb ( struct evhttp_request * req , void * arg ) {
 struct timeval tv ;
 timerclear ( & tv ) ;
 tv . tv_sec = 3 ;
 event_once ( - 1 , EV_TIMEOUT , http_delay_reply , req , & tv ) ;
 evhttp_connection_fail ( delayed_client , EVCON_HTTP_EOF ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fht8x8_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {
 if ( tx_type == DCT_DCT ) {
 vp9_fdct8x8_c ( input , output , stride ) ;
 }
 else {
 int16_t out [ 64 ] ;
 int16_t * outptr = & out [ 0 ] ;
 int i , j ;
 int16_t temp_in [ 8 ] , temp_out [ 8 ] ;
 const transform_2d ht = FHT_8 [ tx_type ] ;
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) outptr [ j * 8 + i ] = temp_out [ j ] ;
 }
 for ( i = 0 ;
 i < 8 ;
 ++ i ) {
 for ( j = 0 ;
 j < 8 ;
 ++ j ) temp_in [ j ] = out [ j + i * 8 ] ;
 ht . rows ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 8 ;
 ++ j ) output [ j + i * 8 ] = ( temp_out [ j ] + ( temp_out [ j ] < 0 ) ) >> 1 ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"enum message_cte message_decoder_parse_cte ( struct message_header_line * hdr ) {
 struct rfc822_parser_context parser ;
 enum message_cte message_cte ;
 string_t * value ;
 value = t_str_new ( 64 ) ;
 rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 ( void ) rfc822_parse_mime_token ( & parser , value ) ;
 message_cte = MESSAGE_CTE_UNKNOWN ;
 switch ( str_len ( value ) ) {
 case 4 : if ( i_memcasecmp ( str_data ( value ) , ""7bit"" , 4 ) == 0 || i_memcasecmp ( str_data ( value ) , ""8bit"" , 4 ) == 0 ) message_cte = MESSAGE_CTE_78BIT ;
 break ;
 case 6 : if ( i_memcasecmp ( str_data ( value ) , ""base64"" , 6 ) == 0 ) message_cte = MESSAGE_CTE_BASE64 ;
 else if ( i_memcasecmp ( str_data ( value ) , ""binary"" , 6 ) == 0 ) message_cte = MESSAGE_CTE_BINARY ;
 break ;
 case 16 : if ( i_memcasecmp ( str_data ( value ) , ""quoted-printable"" , 16 ) == 0 ) message_cte = MESSAGE_CTE_QP ;
 break ;
 }
 return message_cte ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int bind_socket ( const char * address , u_short port , int reuse ) {
 int fd ;
 struct addrinfo * aitop = NULL ;
 if ( address == NULL && port == 0 ) return bind_socket_ai ( NULL , 0 ) ;
 aitop = make_addrinfo ( address , port ) ;
 if ( aitop == NULL ) return ( - 1 ) ;
 fd = bind_socket_ai ( aitop , reuse ) ;
 # ifdef HAVE_GETADDRINFO freeaddrinfo ( aitop ) ;
 # else fake_freeaddrinfo ( aitop ) ;
 # endif return ( fd ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToExtensionAction ) {
 TestBubbleAnchoredToExtensionAction ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_ustring_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 int32_t len , written ;
 const UChar * arg = ( const UChar * ) ( args [ 0 ] . ptrValue ) ;
 if ( arg == NULL ) {
 arg = gNullStr ;
 }
 len = u_strlen ( arg ) ;
 if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {
 len = info -> fPrecision ;
 }
 written = handler -> pad_and_justify ( context , info , arg , len ) ;
 return written ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void dtap_mm_auth_fail ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {
 guint32 curr_offset ;
 guint32 consumed ;
 guint curr_len ;
 curr_offset = offset ;
 curr_len = len ;
 is_uplink = IS_UPLINK_TRUE ;
 ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_REJ_CAUSE , NULL ) ;
 ELEM_OPT_TLV ( 0x22 , GSM_A_PDU_TYPE_DTAP , DE_AUTH_FAIL_PARAM , NULL ) ;
 EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_Progress_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 # line 412 ""./asn1/h225/h225.cnf"" h225_packet_info * h225_pi ;
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Progress_UUIE , Progress_UUIE_sequence ) ;
 # line 416 ""./asn1/h225/h225.cnf"" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;
 if ( h225_pi != NULL ) {
 h225_pi -> cs_type = H225_PROGRESS ;
 if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , ""%s OLC (%s)"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) , h225_pi -> frame_label ) ;
 else g_snprintf ( h225_pi -> frame_label , 50 , ""%s"" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , ""<unknown>"" ) ) ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int xhci_fire_transfer ( XHCIState * xhci , XHCITransfer * xfer , XHCIEPContext * epctx ) {
 trace_usb_xhci_xfer_start ( xfer , xfer -> epctx -> slotid , xfer -> epctx -> epid , xfer -> streamid ) ;
 return xhci_submit ( xhci , xfer , epctx ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q ) {
 const double error_term = err_per_mb / err_divisor ;
 const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , pt_high ) ;
 if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ;
 return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_bytes_format ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const guint8 * start_ptr , const char * format , ... ) {
 proto_item * pi ;
 va_list ap ;
 header_field_info * hfinfo ;
 gint item_length ;
 PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;
 get_hfi_length ( hfinfo , tvb , start , & length , & item_length ) ;
 test_length ( hfinfo , tvb , start , item_length ) ;
 CHECK_FOR_NULL_TREE ( tree ) ;
 TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;
 if ( start_ptr ) pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , start_ptr ) ;
 else pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , tvb_get_ptr ( tvb , start , length ) ) ;
 TRY_TO_FAKE_THIS_REPR ( pi ) ;
 va_start ( ap , format ) ;
 proto_tree_set_representation ( pi , format , ap ) ;
 va_end ( ap ) ;
 return pi ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void process_downstream_ack ( int userid , int down_seq , int down_frag ) {
 if ( users [ userid ] . outpacket . len <= 0 ) return ;
 if ( users [ userid ] . outpacket . seqno != down_seq || users [ userid ] . outpacket . fragment != down_frag ) return ;
 users [ userid ] . outpacket . offset += users [ userid ] . outpacket . sentlen ;
 users [ userid ] . outpacket . sentlen = 0 ;
 users [ userid ] . outpacket . fragment ++ ;
 users [ userid ] . outfragresent = 0 ;
 if ( users [ userid ] . outpacket . offset >= users [ userid ] . outpacket . len ) {
 users [ userid ] . outpacket . len = 0 ;
 users [ userid ] . outpacket . offset = 0 ;
 users [ userid ] . outpacket . fragment -- ;
 # ifdef OUTPACKETQ_LEN get_from_outpacketq ( userid ) ;
 # endif }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_ProtocolIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_object_identifier ( tvb , offset , actx , tree , hf_index , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"int evbuffer_add_vprintf ( struct evbuffer * buf , const char * fmt , va_list ap ) {
 char * buffer ;
 size_t space ;
 size_t oldoff = buf -> off ;
 int sz ;
 va_list aq ;
 evbuffer_expand ( buf , 64 ) ;
 for ( ;
 ;
 ) {
 size_t used = buf -> misalign + buf -> off ;
 buffer = ( char * ) buf -> buffer + buf -> off ;
 assert ( buf -> totallen >= used ) ;
 space = buf -> totallen - used ;
 # ifndef va_copy # define va_copy ( dst , src ) memcpy ( & ( dst ) , & ( src ) , sizeof ( va_list ) ) # endif va_copy ( aq , ap ) ;
 sz = evutil_vsnprintf ( buffer , space , fmt , aq ) ;
 va_end ( aq ) ;
 if ( sz < 0 ) return ( - 1 ) ;
 if ( ( size_t ) sz < space ) {
 buf -> off += sz ;
 if ( buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;
 return ( sz ) ;
 }
 if ( evbuffer_expand ( buf , sz + 1 ) == - 1 ) return ( - 1 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_dec_build_inter_predictors_sb ( MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {
 int plane ;
 const int mi_x = mi_col * MI_SIZE ;
 const int mi_y = mi_row * MI_SIZE ;
 for ( plane = 0 ;
 plane < MAX_MB_PLANE ;
 ++ plane ) {
 const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , & xd -> plane [ plane ] ) ;
 const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ;
 const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ;
 const int bw = 4 * num_4x4_w ;
 const int bh = 4 * num_4x4_h ;
 if ( xd -> mi [ 0 ] -> mbmi . sb_type < BLOCK_8X8 ) {
 int i = 0 , x , y ;
 assert ( bsize == BLOCK_8X8 ) ;
 for ( y = 0 ;
 y < num_4x4_h ;
 ++ y ) for ( x = 0 ;
 x < num_4x4_w ;
 ++ x ) dec_build_inter_predictors ( xd , plane , i ++ , bw , bh , * x , 4 * y , 4 , 4 , mi_x , mi_y ) ;
 }
 else {
 dec_build_inter_predictors ( xd , plane , 0 , bw , bh , 0 , 0 , bw , bh , mi_x , mi_y ) ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int spl_filesystem_file_read_csv ( spl_filesystem_object * intern , char delimiter , char enclosure , char escape , zval * return_value TSRMLS_DC ) {
 int ret = SUCCESS ;
 do {
 ret = spl_filesystem_file_read ( intern , 1 TSRMLS_CC ) ;
 }
 while ( ret == SUCCESS && ! intern -> u . file . current_line_len && SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_SKIP_EMPTY ) ) ;
 if ( ret == SUCCESS ) {
 size_t buf_len = intern -> u . file . current_line_len ;
 char * buf = estrndup ( intern -> u . file . current_line , buf_len ) ;
 if ( intern -> u . file . current_zval ) {
 zval_ptr_dtor ( & intern -> u . file . current_zval ) ;
 }
 ALLOC_INIT_ZVAL ( intern -> u . file . current_zval ) ;
 php_fgetcsv ( intern -> u . file . stream , delimiter , enclosure , escape , buf_len , buf , intern -> u . file . current_zval TSRMLS_CC ) ;
 if ( return_value ) {
 if ( Z_TYPE_P ( return_value ) != IS_NULL ) {
 zval_dtor ( return_value ) ;
 ZVAL_NULL ( return_value ) ;
 }
 ZVAL_ZVAL ( return_value , intern -> u . file . current_zval , 1 , 0 ) ;
 }
 }
 return ret ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( ProtocolHandlerRegistryTest , TestRemovingDefaultDoesntChangeHandlers ) {
 ProtocolHandler ph1 = CreateProtocolHandler ( ""mailto"" , ""test1"" ) ;
 ProtocolHandler ph2 = CreateProtocolHandler ( ""mailto"" , ""test2"" ) ;
 ProtocolHandler ph3 = CreateProtocolHandler ( ""mailto"" , ""test3"" ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;
 registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;
 registry ( ) -> RemoveHandler ( ph3 ) ;
 ProtocolHandlerRegistry : : ProtocolHandlerList handlers = registry ( ) -> GetHandlersFor ( ""mailto"" ) ;
 ASSERT_EQ ( static_cast < size_t > ( 2 ) , handlers . size ( ) ) ;
 ASSERT_EQ ( ph2 , handlers [ 0 ] ) ;
 ASSERT_EQ ( ph1 , handlers [ 1 ] ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static TABLE * GetTable ( cmsIT8 * it8 ) {
 if ( ( it8 -> nTable >= it8 -> TablesCount ) ) {
 SynError ( it8 , ""Table %d out of sequence"" , it8 -> nTable ) ;
 return it8 -> Tab ;
 }
 return it8 -> Tab + it8 -> nTable ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * debug_ntoa ( u32 address ) {
 static char buf [ 32 ] ;
 u32 a = ntohl ( address ) ;
 evutil_snprintf ( buf , sizeof ( buf ) , ""%d.%d.%d.%d"" , ( int ) ( u8 ) ( ( a >> 24 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 16 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 8 ) & 0xff ) , ( int ) ( u8 ) ( ( a ) & 0xff ) ) ;
 return buf ;
 }",0
Detect whether the following code contains vulnerabilities.,"int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {
 Jbig2MmrCtx mmr ;
 const int rowstride = image -> stride ;
 byte * dst = image -> data ;
 byte * ref = NULL ;
 int y ;
 int code = 0 ;
 jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;
 for ( y = 0 ;
 y < image -> height ;
 y ++ ) {
 memset ( dst , 0 , rowstride ) ;
 code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;
 if ( code < 0 ) return code ;
 ref = dst ;
 dst += rowstride ;
 }
 return code ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int evdns_transmit ( void ) {
 char did_try_to_transmit = 0 ;
 if ( req_head ) {
 struct request * const started_at = req_head , * req = req_head ;
 do {
 if ( req -> transmit_me ) {
 did_try_to_transmit = 1 ;
 evdns_request_transmit ( req ) ;
 }
 req = req -> next ;
 }
 while ( req != started_at ) ;
 }
 return did_try_to_transmit ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_pcp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {
 tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , PCP_HEADER_LEN , get_pcp_message_len , dissect_pcp_message , data ) ;
 return tvb_captured_length ( tvb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int write_output ( void ) {
 int fd ;
 struct filter_op * fop ;
 struct filter_header fh ;
 size_t ninst , i ;
 u_char * data ;
 ninst = compile_tree ( & fop ) ;
 if ( fop == NULL ) return - E_NOTHANDLED ;
 fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;
 ON_ERROR ( fd , - 1 , ""Can't create file %s"" , EF_GBL_OPTIONS -> output_file ) ;
 fprintf ( stdout , "" Writing output to \'%s\' "" , EF_GBL_OPTIONS -> output_file ) ;
 fflush ( stdout ) ;
 fh . magic = htons ( EC_FILTER_MAGIC ) ;
 strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;
 fh . data = sizeof ( fh ) ;
 data = create_data_segment ( & fh , fop , ninst ) ;
 write ( fd , & fh , sizeof ( struct filter_header ) ) ;
 write ( fd , data , fh . code - fh . data ) ;
 for ( i = 0 ;
 i <= ninst ;
 i ++ ) {
 print_progress_bar ( & fop [ i ] ) ;
 write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ;
 }
 close ( fd ) ;
 fprintf ( stdout , "" done.\n\n"" ) ;
 fprintf ( stdout , "" -> Script encoded into %d instructions.\n\n"" , ( int ) ( i - 1 ) ) ;
 return E_SUCCESS ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void proto_tree_set_oid_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {
 proto_tree_set_oid ( fi , tvb_get_ptr ( tvb , start , length ) , length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) {
 unsigned char * buf ;
 assert ( m -> buf_ ) ;
 assert ( bufsize >= 0 ) ;
 if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {
 return - 1 ;
 }
 m -> buf_ = buf ;
 m -> bufsize_ = bufsize ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int decode_udvm_literal_operand ( guint8 * buff , guint operand_address , guint16 * value ) {
 guint bytecode ;
 guint16 operand ;
 guint test_bits ;
 guint offset = operand_address ;
 guint8 temp_data ;
 bytecode = buff [ operand_address ] ;
 test_bits = bytecode >> 7 ;
 if ( test_bits == 1 ) {
 test_bits = bytecode >> 6 ;
 if ( test_bits == 2 ) {
 temp_data = buff [ operand_address ] & 0x1f ;
 operand = temp_data << 8 ;
 temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;
 operand = operand | temp_data ;
 * value = operand ;
 offset = offset + 2 ;
 }
 else {
 offset ++ ;
 temp_data = buff [ operand_address ] & 0x1f ;
 operand = temp_data << 8 ;
 temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;
 operand = operand | temp_data ;
 * value = operand ;
 offset = offset + 2 ;
 }
 }
 else {
 operand = ( bytecode & 0x7f ) ;
 * value = operand ;
 offset ++ ;
 }
 return offset ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_iwht4x4_1_add_c ( const int16_t * in , uint8_t * dest , int dest_stride ) {
 int i ;
 int a1 , e1 ;
 int16_t tmp [ 4 ] ;
 const int16_t * ip = in ;
 int16_t * op = tmp ;
 a1 = ip [ 0 ] >> UNIT_QUANT_SHIFT ;
 e1 = a1 >> 1 ;
 a1 -= e1 ;
 op [ 0 ] = a1 ;
 op [ 1 ] = op [ 2 ] = op [ 3 ] = e1 ;
 ip = tmp ;
 for ( i = 0 ;
 i < 4 ;
 i ++ ) {
 e1 = ip [ 0 ] >> 1 ;
 a1 = ip [ 0 ] - e1 ;
 dest [ dest_stride * 0 ] = clip_pixel ( dest [ dest_stride * 0 ] + a1 ) ;
 dest [ dest_stride * 1 ] = clip_pixel ( dest [ dest_stride * 1 ] + e1 ) ;
 dest [ dest_stride * 2 ] = clip_pixel ( dest [ dest_stride * 2 ] + e1 ) ;
 dest [ dest_stride * 3 ] = clip_pixel ( dest [ dest_stride * 3 ] + e1 ) ;
 ip ++ ;
 dest ++ ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void _reconnectToDB ( ArchiveHandle * AH , const char * dbname ) {
 if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;
 else {
 PQExpBuffer qry = createPQExpBuffer ( ) ;
 appendPQExpBuffer ( qry , ""\\connect %s\n\n"" , dbname ? fmtId ( dbname ) : ""-"" ) ;
 ahprintf ( AH , ""%s"" , qry -> data ) ;
 destroyPQExpBuffer ( qry ) ;
 }
 if ( AH -> currUser ) free ( AH -> currUser ) ;
 AH -> currUser = NULL ;
 if ( AH -> currSchema ) free ( AH -> currSchema ) ;
 AH -> currSchema = NULL ;
 if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;
 AH -> currTablespace = NULL ;
 AH -> currWithOids = - 1 ;
 _doSetFixedOutputState ( AH ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"gint nautilus_mime_types_get_number_of_groups ( void ) {
 return G_N_ELEMENTS ( mimetype_groups ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {
 struct zip_cdir * cd ;
 if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {
 _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;
 return NULL ;
 }
 if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {
 _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;
 free ( cd ) ;
 return NULL ;
 }
 cd -> nentry = nentry ;
 cd -> size = cd -> offset = 0 ;
 cd -> comment = NULL ;
 cd -> comment_len = 0 ;
 return cd ;
 }",1
Detect whether the following code contains vulnerabilities.,"void nautilus_file_operations_new_file_from_template ( GtkWidget * parent_view , GdkPoint * target_point , const char * parent_dir , const char * target_filename , const char * template_uri , NautilusCreateCallback done_callback , gpointer done_callback_data ) {
 GTask * task ;
 CreateJob * job ;
 GtkWindow * parent_window ;
 parent_window = NULL ;
 if ( parent_view ) {
 parent_window = ( GtkWindow * ) gtk_widget_get_ancestor ( parent_view , GTK_TYPE_WINDOW ) ;
 }
 job = op_job_new ( CreateJob , parent_window ) ;
 job -> done_callback = done_callback ;
 job -> done_callback_data = done_callback_data ;
 job -> dest_dir = g_file_new_for_uri ( parent_dir ) ;
 if ( target_point != NULL ) {
 job -> position = * target_point ;
 job -> has_position = TRUE ;
 }
 job -> filename = g_strdup ( target_filename ) ;
 if ( template_uri ) {
 job -> src = g_file_new_for_uri ( template_uri ) ;
 }
 if ( ! nautilus_file_undo_manager_is_operating ( ) ) {
 job -> common . undo_info = nautilus_file_undo_info_create_new ( NAUTILUS_FILE_UNDO_OP_CREATE_FILE_FROM_TEMPLATE ) ;
 }
 task = g_task_new ( NULL , job -> common . cancellable , create_task_done , job ) ;
 g_task_set_task_data ( task , job , NULL ) ;
 g_task_run_in_thread ( task , create_task_thread_func ) ;
 g_object_unref ( task ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pdf_run_BMC ( fz_context * ctx , pdf_processor * proc , const char * tag ) {
 pdf_run_processor * pr = ( pdf_run_processor * ) proc ;
 if ( ! tag ) tag = ""UnnamedLayer"" ;
 fz_begin_layer ( ctx , pr -> dev , tag ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , GenerateKeyword ) {
 std : : string accept_languages = ""en,ru"" ;
 ASSERT_EQ ( ASCIIToUTF16 ( ""foo"" ) , TemplateURL : : GenerateKeyword ( GURL ( ""http://foo"" ) , accept_languages ) ) ;
 ASSERT_EQ ( ASCIIToUTF16 ( ""foo"" ) , TemplateURL : : GenerateKeyword ( GURL ( ""http://www.foo"" ) , accept_languages ) ) ;
 ASSERT_EQ ( ASCIIToUTF16 ( ""blah"" ) , TemplateURL : : GenerateKeyword ( GURL ( ""http://blah/"" ) , accept_languages ) ) ;
 ASSERT_EQ ( ASCIIToUTF16 ( ""www"" ) , TemplateURL : : GenerateKeyword ( GURL ( ""http://www."" ) , accept_languages ) ) ;
 ASSERT_EQ ( base : : UTF8ToUTF16 ( ""\xd0\xb0\xd0\xb1\xd0\xb2"" ) , TemplateURL : : GenerateKeyword ( GURL ( ""http://xn--80acd"" ) , accept_languages ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , Ignore204Pages ) {
 ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;
 ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( ""/page204.html"" ) ) ;
 NavigateToUntrackedUrl ( ) ;
 EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << ""Recorded metrics: "" << GetRecordedPageLoadMetricNames ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) {
 EVP_CIPHER_CTX * ctx ;
 const EVP_CIPHER * cipher ;
 char * name ;
 unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = {
 0 }
 ;
 name = StringValueCStr ( str ) ;
 GetCipherInit ( self , ctx ) ;
 if ( ctx ) {
 ossl_raise ( rb_eRuntimeError , ""Cipher already inititalized!"" ) ;
 }
 AllocCipher ( self , ctx ) ;
 if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) {
 ossl_raise ( rb_eRuntimeError , ""unsupported cipher algorithm (%"" PRIsVALUE "")"" , str ) ;
 }
 if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;
 return self ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void inject_user ( void ) {
 size_t len ;
 len = strescape ( ( char * ) injectbuf , ( char * ) injectbuf ) ;
 if ( wdg_c1 -> flags & WDG_OBJ_FOCUSED ) {
 user_inject ( injectbuf , len , curr_conn , 1 ) ;
 }
 else if ( wdg_c2 -> flags & WDG_OBJ_FOCUSED ) {
 user_inject ( injectbuf , len , curr_conn , 2 ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h225_RasUsageInfoTypes ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_RasUsageInfoTypes , RasUsageInfoTypes_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"void send_protected_args ( int fd , char * args [ ] ) {
 int i ;
 # ifdef ICONV_OPTION int convert = ic_send != ( iconv_t ) - 1 ;
 xbuf outbuf , inbuf ;
 if ( convert ) alloc_xbuf ( & outbuf , 1024 ) ;
 # endif for ( i = 0 ;
 args [ i ] ;
 i ++ ) {
 }
 args [ i ] = ""rsync"" ;
 if ( DEBUG_GTE ( CMD , 1 ) ) print_child_argv ( ""protected args:"" , args + i + 1 ) ;
 do {
 if ( ! args [ i ] [ 0 ] ) write_buf ( fd , ""."" , 2 ) ;
 # ifdef ICONV_OPTION else if ( convert ) {
 INIT_XBUF_STRLEN ( inbuf , args [ i ] ) ;
 iconvbufs ( ic_send , & inbuf , & outbuf , ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT ) ;
 outbuf . buf [ outbuf . len ] = '\0' ;
 write_buf ( fd , outbuf . buf , outbuf . len + 1 ) ;
 outbuf . len = 0 ;
 }
 # endif else write_buf ( fd , args [ i ] , strlen ( args [ i ] ) + 1 ) ;
 }
 while ( args [ ++ i ] ) ;
 write_byte ( fd , 0 ) ;
 # ifdef ICONV_OPTION if ( convert ) free ( outbuf . buf ) ;
 # endif }",0
Detect whether the following code contains vulnerabilities.,"static void vga_draw_line24_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {
 int w ;
 uint32_t r , g , b ;
 w = width ;
 do {
 b = s [ 0 ] ;
 g = s [ 1 ] ;
 r = s [ 2 ] ;
 ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;
 s += 3 ;
 d += 4 ;
 }
 while ( -- w != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void parse_content_type ( struct message_decoder_context * ctx , struct message_header_line * hdr ) {
 struct rfc822_parser_context parser ;
 const char * const * results ;
 string_t * str ;
 int ret ;
 if ( ctx -> content_type != NULL ) return ;
 rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 str = t_str_new ( 64 ) ;
 ret = rfc822_parse_content_type ( & parser , str ) ;
 ctx -> content_type = i_strdup ( str_c ( str ) ) ;
 if ( ret < 0 ) return ;
 rfc2231_parse ( & parser , & results ) ;
 for ( ;
 * results != NULL ;
 results += 2 ) {
 if ( strcasecmp ( results [ 0 ] , ""charset"" ) == 0 ) {
 ctx -> content_charset = i_strdup ( results [ 1 ] ) ;
 break ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;
 # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MINOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MAKEDEV ( __SYSMACROS_DECL_TEMPL )",1
Detect whether the following code contains vulnerabilities.,"static int get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , vpx_fixed_buf_t * stats ) {
 int got_pkts = 0 ;
 vpx_codec_iter_t iter = NULL ;
 const vpx_codec_cx_pkt_t * pkt = NULL ;
 const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ;
 if ( res != VPX_CODEC_OK ) die_codec ( ctx , ""Failed to get frame stats."" ) ;
 while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {
 got_pkts = 1 ;
 if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {
 const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;
 const size_t pkt_size = pkt -> data . twopass_stats . sz ;
 stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ;
 memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ;
 stats -> sz += pkt_size ;
 }
 }
 return got_pkts ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLTest , Defaults ) {
 TemplateURLData data ;
 EXPECT_FALSE ( data . show_in_default_list ) ;
 EXPECT_FALSE ( data . safe_for_autoreplace ) ;
 EXPECT_EQ ( 0 , data . prepopulate_id ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void qemu_cpu_kick_self ( void ) {
 # ifndef _WIN32 assert ( cpu_single_env ) ;
 CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;
 if ( ! cpu_single_cpu -> thread_kicked ) {
 qemu_cpu_kick_thread ( cpu_single_cpu ) ;
 cpu_single_cpu -> thread_kicked = true ;
 }
 # else abort ( ) ;
 # endif }",1
Detect whether the following code contains vulnerabilities.,"int query_get_string ( MYSQL * mysql , const char * query , int column , DYNAMIC_STRING * ds ) {
 MYSQL_RES * res = NULL ;
 MYSQL_ROW row ;
 if ( mysql_query ( mysql , query ) ) {
 report_or_die ( ""'%s' failed: %d %s"" , query , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;
 return 1 ;
 }
 if ( ( res = mysql_store_result ( mysql ) ) == NULL ) {
 report_or_die ( ""Failed to store result: %d %s"" , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;
 return 1 ;
 }
 if ( ( row = mysql_fetch_row ( res ) ) == NULL ) {
 mysql_free_result ( res ) ;
 return 1 ;
 }
 init_dynamic_string ( ds , ( row [ column ] ? row [ column ] : ""NULL"" ) , ~ 0 , 32 ) ;
 mysql_free_result ( res ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , LRUTest ) {
 int64_t max_size = 17 ;
 int64_t current_size = 0 ;
 lru_ -> IncrementMaxSize ( max_size ) ;
 multibuffer_ . SetMaxWriters ( 1 ) ;
 size_t pos = 0 ;
 size_t end = 10000 ;
 multibuffer_ . SetFileSize ( 10000 ) ;
 media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;
 reader . SetPreload ( 10000 , 10000 ) ;
 EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;
 current_size += max_size ;
 while ( AdvanceAll ( ) ) ;
 EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;
 lru_ -> IncrementMaxSize ( - max_size ) ;
 lru_ -> Prune ( 3 ) ;
 current_size -= 3 ;
 EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;
 lru_ -> Prune ( 3 ) ;
 current_size -= 3 ;
 EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;
 lru_ -> Prune ( 1000 ) ;
 EXPECT_EQ ( 0 , lru_ -> Size ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"proto_item * proto_tree_add_text_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , ... ) {
 proto_item * pi ;
 va_list ap ;
 header_field_info * hfinfo ;
 CHECK_FOR_NULL_TREE ( tree ) ;
 TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;
 pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;
 TRY_TO_FAKE_THIS_REPR ( pi ) ;
 va_start ( ap , format ) ;
 proto_tree_set_representation ( pi , format , ap ) ;
 va_end ( ap ) ;
 return pi ;
 }",1
Detect whether the following code contains vulnerabilities.,"static const char * _UTF16GetName ( const UConverter * cnv ) {
 if ( UCNV_GET_VERSION ( cnv ) == 0 ) {
 return ""UTF-16"" ;
 }
 else if ( UCNV_GET_VERSION ( cnv ) == 1 ) {
 return ""UTF-16,version=1"" ;
 }
 else {
 return ""UTF-16,version=2"" ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"void xsltFreeStyleDocuments ( xsltStylesheetPtr style ) {
 xsltDocumentPtr doc , cur ;
 # ifdef XSLT_REFACTORED_XSLT_NSCOMP xsltNsMapPtr nsMap ;
 # endif if ( style == NULL ) return ;
 # ifdef XSLT_REFACTORED_XSLT_NSCOMP if ( XSLT_HAS_INTERNAL_NSMAP ( style ) ) nsMap = XSLT_GET_INTERNAL_NSMAP ( style ) ;
 else nsMap = NULL ;
 # endif cur = style -> docList ;
 while ( cur != NULL ) {
 doc = cur ;
 cur = cur -> next ;
 # ifdef XSLT_REFACTORED_XSLT_NSCOMP if ( nsMap ) xsltRestoreDocumentNamespaces ( nsMap , doc -> doc ) ;
 # endif xsltFreeDocumentKeys ( doc ) ;
 if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;
 xmlFree ( doc ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static __always_inline __u64 __le64_to_cpup ( const __le64 * p ) {
 return ( __u64 ) * p ;
 }",1
Detect whether the following code contains vulnerabilities.,"int evdns_resolve_ipv6 ( const char * name , int flags , evdns_callback_type callback , void * ptr ) {
 log ( EVDNS_LOG_DEBUG , ""Resolve requested for %s"" , name ) ;
 if ( flags & DNS_QUERY_NO_SEARCH ) {
 struct request * const req = request_new ( TYPE_AAAA , name , flags , callback , ptr ) ;
 if ( req == NULL ) return ( 1 ) ;
 request_submit ( req ) ;
 return ( 0 ) ;
 }
 else {
 return ( search_request_new ( TYPE_AAAA , name , flags , callback , ptr ) ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_AddConnectionResp ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_AddConnectionResp , AddConnectionResp_sequence ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int try_shrink_lower ( MAIN_WINDOW_REC * window , int count ) {
 MAIN_WINDOW_REC * shrink_win ;
 shrink_win = mainwindows_find_lower ( window ) ;
 if ( shrink_win != NULL ) {
 int ok ;
 GSList * shrink_list , * tmp ;
 MAIN_WINDOW_REC * win ;
 ok = TRUE ;
 shrink_list = mainwindows_get_line ( shrink_win ) ;
 for ( tmp = shrink_list ;
 tmp != NULL ;
 tmp = tmp -> next ) {
 win = tmp -> data ;
 if ( MAIN_WINDOW_TEXT_HEIGHT ( win ) - count < WINDOW_MIN_SIZE ) {
 ok = FALSE ;
 break ;
 }
 }
 if ( ok ) {
 GSList * grow_list ;
 grow_list = mainwindows_get_line ( window ) ;
 for ( tmp = shrink_list ;
 tmp != NULL ;
 tmp = tmp -> next ) {
 win = tmp -> data ;
 win -> first_line += count ;
 }
 for ( tmp = grow_list ;
 tmp != NULL ;
 tmp = tmp -> next ) {
 win = tmp -> data ;
 win -> last_line += count ;
 }
 mainwindows_resize_two ( grow_list , shrink_list , count ) ;
 g_slist_free ( grow_list ) ;
 }
 g_slist_free ( shrink_list ) ;
 return ok ;
 }
 return FALSE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void tcmpt_destroy ( jpc_enc_tcmpt_t * tcmpt ) {
 jpc_enc_rlvl_t * rlvl ;
 uint_fast16_t rlvlno ;
 if ( tcmpt -> rlvls ) {
 for ( rlvlno = 0 , rlvl = tcmpt -> rlvls ;
 rlvlno < tcmpt -> numrlvls ;
 ++ rlvlno , ++ rlvl ) {
 rlvl_destroy ( rlvl ) ;
 }
 jas_free ( tcmpt -> rlvls ) ;
 }
 if ( tcmpt -> data ) {
 jas_seq2d_destroy ( tcmpt -> data ) ;
 }
 if ( tcmpt -> tsfb ) {
 jpc_tsfb_destroy ( tcmpt -> tsfb ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int vp9_release_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) {
 InternalFrameBuffer * const int_fb = ( InternalFrameBuffer * ) fb -> priv ;
 ( void ) cb_priv ;
 if ( int_fb ) int_fb -> in_use = 0 ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void virtio_balloon_set_config ( VirtIODevice * vdev , const uint8_t * config_data ) {
 VirtIOBalloon * dev = to_virtio_balloon ( vdev ) ;
 struct virtio_balloon_config config ;
 memcpy ( & config , config_data , 8 ) ;
 dev -> actual = le32_to_cpu ( config . actual ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int switch_character_set_results ( MYSQL * mysql , const char * cs_name ) {
 char query_buffer [ QUERY_LENGTH ] ;
 size_t query_length ;
 if ( ! server_supports_switching_charsets ) return FALSE ;
 query_length = my_snprintf ( query_buffer , sizeof ( query_buffer ) , ""SET SESSION character_set_results = '%s'"" , ( const char * ) cs_name ) ;
 return mysql_real_query ( mysql , query_buffer , query_length ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void report_clusters_compatible ( void ) {
 if ( user_opts . check ) {
 pg_log ( PG_REPORT , ""\n*Clusters are compatible*\n"" ) ;
 stop_postmaster ( false ) ;
 exit ( 0 ) ;
 }
 pg_log ( PG_REPORT , ""\n"" ""If pg_upgrade fails after this point, you must re-initdb the\n"" ""new cluster before continuing.\n"" ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * _SCSUGetName ( const UConverter * cnv ) {
 SCSUData * scsu = ( SCSUData * ) cnv -> extraInfo ;
 switch ( scsu -> locale ) {
 case l_ja : return ""SCSU,locale=ja"" ;
 default : return ""SCSU"" ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void decorrelate_stereo ( int32_t * buffer [ 2 ] , int nb_samples , int decorr_shift , int decorr_left_weight ) {
 int i ;
 for ( i = 0 ;
 i < nb_samples ;
 i ++ ) {
 int32_t a , b ;
 a = buffer [ 0 ] [ i ] ;
 b = buffer [ 1 ] [ i ] ;
 a -= ( b * decorr_left_weight ) >> decorr_shift ;
 b += a ;
 buffer [ 0 ] [ i ] = b ;
 buffer [ 1 ] [ i ] = a ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"int proto_get_id_by_short_name ( const gchar * short_name ) {
 const protocol_t * protocol = NULL ;
 DISSECTOR_ASSERT_HINT ( short_name , ""No short name present"" ) ;
 protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_short_names , short_name ) ;
 if ( protocol == NULL ) return - 1 ;
 return protocol -> proto_id ;
 }",0
Detect whether the following code contains vulnerabilities.,"GType hb_gobject_ ## name ## _get_type ( void ) \ {
 static gsize type_id = 0 ;
 if ( g_once_init_enter ( & type_id ) ) {
 GType id = g_boxed_type_register_static ( g_intern_static_string ( ""hb_"" # name ""_t"" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;
 g_once_init_leave ( & type_id , id ) ;
 }
 return type_id ;
 \ }
 # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;
 HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob )",1
Detect whether the following code contains vulnerabilities.,"int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {
 int x ;
 int chunk ;
 UINT8 * out ;
 UINT8 * ptr ;
 ptr = buf ;
 chunk = 3 * state -> xsize ;
 for ( ;
 ;
 ) {
 if ( bytes < chunk ) return ptr - buf ;
 out = state -> buffer ;
 for ( x = 0 ;
 x < state -> xsize ;
 x ++ ) {
 out [ 0 ] = ptr [ x ] ;
 out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;
 out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;
 out += 4 ;
 }
 state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;
 if ( ++ state -> y >= state -> ysize ) return - 1 ;
 out = state -> buffer ;
 for ( x = 0 ;
 x < state -> xsize ;
 x ++ ) {
 out [ 0 ] = ptr [ x + state -> xsize ] ;
 out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;
 out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;
 out += 4 ;
 }
 state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;
 if ( ++ state -> y >= state -> ysize ) return - 1 ;
 ptr += chunk ;
 bytes -= chunk ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int pfkey_add ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {
 struct net * net = sock_net ( sk ) ;
 struct xfrm_state * x ;
 int err ;
 struct km_event c ;
 x = pfkey_msg2xfrm_state ( net , hdr , ext_hdrs ) ;
 if ( IS_ERR ( x ) ) return PTR_ERR ( x ) ;
 xfrm_state_hold ( x ) ;
 if ( hdr -> sadb_msg_type == SADB_ADD ) err = xfrm_state_add ( x ) ;
 else err = xfrm_state_update ( x ) ;
 xfrm_audit_state_add ( x , err ? 0 : 1 , audit_get_loginuid ( current ) , audit_get_sessionid ( current ) , 0 ) ;
 if ( err < 0 ) {
 x -> km . state = XFRM_STATE_DEAD ;
 __xfrm_state_put ( x ) ;
 goto out ;
 }
 if ( hdr -> sadb_msg_type == SADB_ADD ) c . event = XFRM_MSG_NEWSA ;
 else c . event = XFRM_MSG_UPDSA ;
 c . seq = hdr -> sadb_msg_seq ;
 c . portid = hdr -> sadb_msg_pid ;
 km_state_notify ( x , & c ) ;
 out : xfrm_state_put ( x ) ;
 return err ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) {
 const MACROBLOCKD * const xd = & x -> e_mbd ;
 struct encode_b_args arg = {
 x , NULL , & xd -> mi [ 0 ] -> mbmi . skip }
 ;
 vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , & arg ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static UChar32 _UTF16GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {
 switch ( pArgs -> converter -> mode ) {
 case 8 : return _UTF16BEGetNextUChar ( pArgs , pErrorCode ) ;
 case 9 : return _UTF16LEGetNextUChar ( pArgs , pErrorCode ) ;
 default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void _ASCIIGetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {
 sa -> addRange ( sa -> set , 0 , 0x7f ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static jboolean ShouldUseSmartLockBranding ( JNIEnv * env , const JavaParamRef < jclass > & ) {
 const ProfileSyncService * sync_service = ProfileSyncServiceFactory : : GetForProfile ( ProfileManager : : GetLastUsedProfile ( ) ) ;
 return password_bubble_experiment : : IsSmartLockBrandingEnabled ( sync_service ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"bool handle_new_meta_connection ( int sock ) {
 connection_t * c ;
 sockaddr_t sa ;
 int fd ;
 socklen_t len = sizeof ( sa ) ;
 fd = accept ( sock , & sa . sa , & len ) ;
 if ( fd < 0 ) {
 logger ( LOG_ERR , ""Accepting a new connection failed: %s"" , sockstrerror ( sockerrno ) ) ;
 return false ;
 }
 sockaddrunmap ( & sa ) ;
 c = new_connection ( ) ;
 c -> name = xstrdup ( ""<unknown>"" ) ;
 c -> outcipher = myself -> connection -> outcipher ;
 c -> outdigest = myself -> connection -> outdigest ;
 c -> outmaclength = myself -> connection -> outmaclength ;
 c -> outcompression = myself -> connection -> outcompression ;
 c -> address = sa ;
 c -> hostname = sockaddr2hostname ( & sa ) ;
 c -> socket = fd ;
 c -> last_ping_time = now ;
 ifdebug ( CONNECTIONS ) logger ( LOG_NOTICE , ""Connection from %s"" , c -> hostname ) ;
 configure_tcp ( c ) ;
 connection_add ( c ) ;
 c -> allow_request = ID ;
 send_id ( c ) ;
 return true ;
 }",1
Detect whether the following code contains vulnerabilities.,"void vp9_idct4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride ) {
 int16_t out [ 4 * 4 ] ;
 int16_t * outptr = out ;
 int i , j ;
 int16_t temp_in [ 4 ] , temp_out [ 4 ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 idct4 ( input , outptr ) ;
 input += 4 ;
 outptr += 4 ;
 }
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = out [ j * 4 + i ] ;
 idct4 ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) + dest [ j * stride + i ] ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void _slurm_rpc_sib_msg ( uint32_t uid , slurm_msg_t * msg ) {
 if ( ! msg -> conn ) {
 error ( ""Security violation, SIB_SUBMISSION RPC from uid=%d"" , uid ) ;
 slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;
 return ;
 }
 fed_mgr_q_sib_msg ( msg , uid ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static PyObject * string_lower ( PyStringObject * self ) {
 char * s ;
 Py_ssize_t i , n = PyString_GET_SIZE ( self ) ;
 PyObject * newobj ;
 newobj = PyString_FromStringAndSize ( NULL , n ) ;
 if ( ! newobj ) return NULL ;
 s = PyString_AS_STRING ( newobj ) ;
 Py_MEMCPY ( s , PyString_AS_STRING ( self ) , n ) ;
 for ( i = 0 ;
 i < n ;
 i ++ ) {
 int c = Py_CHARMASK ( s [ i ] ) ;
 if ( isupper ( c ) ) s [ i ] = _tolower ( c ) ;
 }
 return newobj ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void pdf_process_end ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {
 while ( csi -> gstate > 0 ) pdf_process_grestore ( ctx , proc , csi ) ;
 if ( proc -> op_END ) proc -> op_END ( ctx , proc ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * fstrndup ( const char * ptr , unsigned long len ) {
 char * result ;
 if ( len <= 0 ) return NULL ;
 result = ALLOC_N ( char , len ) ;
 memccpy ( result , ptr , 0 , len ) ;
 return result ;
 }",1
Detect whether the following code contains vulnerabilities.,"const xmlChar * xsltEvalStaticAttrValueTemplate ( xsltStylesheetPtr style , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns , int * found ) {
 const xmlChar * ret ;
 xmlChar * expr ;
 if ( ( style == NULL ) || ( inst == NULL ) || ( name == NULL ) ) return ( NULL ) ;
 expr = xsltGetNsProp ( inst , name , ns ) ;
 if ( expr == NULL ) {
 * found = 0 ;
 return ( NULL ) ;
 }
 * found = 1 ;
 ret = xmlStrchr ( expr , '{
' ) ;
 if ( ret != NULL ) {
 xmlFree ( expr ) ;
 return ( NULL ) ;
 }
 ret = xmlDictLookup ( style -> dict , expr , - 1 ) ;
 xmlFree ( expr ) ;
 return ( ret ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) {
 section -> frame -= frame -> frame ;
 section -> intra_error -= frame -> intra_error ;
 section -> coded_error -= frame -> coded_error ;
 section -> sr_coded_error -= frame -> sr_coded_error ;
 section -> pcnt_inter -= frame -> pcnt_inter ;
 section -> pcnt_motion -= frame -> pcnt_motion ;
 section -> pcnt_second_ref -= frame -> pcnt_second_ref ;
 section -> pcnt_neutral -= frame -> pcnt_neutral ;
 section -> MVr -= frame -> MVr ;
 section -> mvr_abs -= frame -> mvr_abs ;
 section -> MVc -= frame -> MVc ;
 section -> mvc_abs -= frame -> mvc_abs ;
 section -> MVrv -= frame -> MVrv ;
 section -> MVcv -= frame -> MVcv ;
 section -> mv_in_out_count -= frame -> mv_in_out_count ;
 section -> new_mv_count -= frame -> new_mv_count ;
 section -> count -= frame -> count ;
 section -> duration -= frame -> duration ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int decode_subframe_lpc ( FLACContext * s , int32_t * decoded , int pred_order , int bps ) {
 int i ;
 int coeff_prec , qlevel ;
 int coeffs [ 32 ] ;
 for ( i = 0 ;
 i < pred_order ;
 i ++ ) {
 decoded [ i ] = get_sbits_long ( & s -> gb , bps ) ;
 }
 coeff_prec = get_bits ( & s -> gb , 4 ) + 1 ;
 if ( coeff_prec == 16 ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""invalid coeff precision\n"" ) ;
 return - 1 ;
 }
 qlevel = get_sbits ( & s -> gb , 5 ) ;
 if ( qlevel < 0 ) {
 av_log ( s -> avctx , AV_LOG_ERROR , ""qlevel %d not supported, maybe buggy stream\n"" , qlevel ) ;
 return - 1 ;
 }
 for ( i = 0 ;
 i < pred_order ;
 i ++ ) {
 coeffs [ pred_order - i - 1 ] = get_sbits ( & s -> gb , coeff_prec ) ;
 }
 if ( decode_residuals ( s , decoded , pred_order ) < 0 ) return - 1 ;
 s -> dsp . lpc ( decoded , coeffs , pred_order , qlevel , s -> blocksize ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gboolean logcat_binary_dump ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {
 if ( phdr -> rec_type != REC_TYPE_PACKET ) {
 * err = WTAP_ERR_REC_TYPE_UNSUPPORTED ;
 return FALSE ;
 }
 if ( ! wtap_dump_file_write ( wdh , pd , phdr -> caplen , err ) ) return FALSE ;
 wdh -> bytes_dumped += phdr -> caplen ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"static __inline__ __u32 __arch_swab32 ( __u32 val ) {
 __asm__ ( ""bswapl %0"" : ""=r"" ( val ) : ""0"" ( val ) ) ;
 return val ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int _warc_bid ( struct archive_read * a , int best_bid ) {
 const char * hdr ;
 ssize_t nrd ;
 unsigned int ver ;
 ( void ) best_bid ;
 if ( ( hdr = __archive_read_ahead ( a , 12U , & nrd ) ) == NULL ) {
 return - 1 ;
 }
 else if ( nrd < 12 ) {
 return - 1 ;
 }
 ver = _warc_rdver ( hdr , nrd ) ;
 if ( ver < 1200U || ver > 10000U ) {
 return - 1 ;
 }
 return ( 64 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , seek ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 long line_pos ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""l"" , & line_pos ) == FAILURE ) {
 return ;
 }
 if ( line_pos < 0 ) {
 zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , ""Can't seek file %s to negative line %ld"" , intern -> file_name , line_pos ) ;
 RETURN_FALSE ;
 }
 spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;
 while ( intern -> u . file . current_line_num < line_pos ) {
 if ( spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) == FAILURE ) {
 break ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"int psf_fopen ( SF_PRIVATE * psf ) {
 psf -> error = 0 ;
 psf -> file . filedes = psf_open_fd ( & psf -> file ) ;
 if ( psf -> file . filedes == - SFE_BAD_OPEN_MODE ) {
 psf -> error = SFE_BAD_OPEN_MODE ;
 psf -> file . filedes = - 1 ;
 return psf -> error ;
 }
 ;
 if ( psf -> file . filedes == - 1 ) psf_log_syserr ( psf , errno ) ;
 return psf -> error ;
 }",0
Detect whether the following code contains vulnerabilities.,"static struct im_connection * purple_ic_by_gc ( PurpleConnection * gc ) {
 return purple_ic_by_pa ( purple_connection_get_account ( gc ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void _UTF16LEOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {
 if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {
 _UTF16LEReset ( cnv , UCNV_RESET_BOTH ) ;
 }
 else {
 * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void prplcb_conn_connected ( PurpleConnection * gc ) {
 struct im_connection * ic = purple_ic_by_gc ( gc ) ;
 const char * dn ;
 set_t * s ;
 imcb_connected ( ic ) ;
 if ( ( dn = purple_connection_get_display_name ( gc ) ) && ( s = set_find ( & ic -> acc -> set , ""display_name"" ) ) ) {
 g_free ( s -> value ) ;
 s -> value = g_strdup ( dn ) ;
 }
 purple_gg_buddylist_import ( gc ) ;
 ic -> flags |= OPT_DOES_HTML ;
 }",0
Detect whether the following code contains vulnerabilities.,"static struct cvec * range ( struct vars * v , celt a , celt b , int cases ) {
 int nchrs ;
 struct cvec * cv ;
 celt c , lc , uc ;
 if ( a != b && ! before ( a , b ) ) {
 ERR ( REG_ERANGE ) ;
 return NULL ;
 }
 if ( ! cases ) {
 cv = getcvec ( v , 0 , 1 ) ;
 NOERRN ( ) ;
 addrange ( cv , a , b ) ;
 return cv ;
 }
 nchrs = ( b - a + 1 ) * 2 + 4 ;
 cv = getcvec ( v , nchrs , 0 ) ;
 NOERRN ( ) ;
 for ( c = a ;
 c <= b ;
 c ++ ) {
 addchr ( cv , c ) ;
 lc = pg_wc_tolower ( ( chr ) c ) ;
 if ( c != lc ) addchr ( cv , lc ) ;
 uc = pg_wc_toupper ( ( chr ) c ) ;
 if ( c != uc ) addchr ( cv , uc ) ;
 }
 return cv ;
 }",1
Detect whether the following code contains vulnerabilities.,"void xmlHashScan3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashScanner f , void * data ) {
 xmlHashScanFull3 ( table , name , name2 , name3 , ( xmlHashScannerFull ) f , data ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TEST_F ( MultiBufferTest , RandomTest ) {
 size_t file_size = 1000000 ;
 multibuffer_ . SetFileSize ( file_size ) ;
 multibuffer_ . SetMaxBlocksAfterDefer ( 10 ) ;
 std : : vector < ReadHelper * > read_helpers ;
 for ( size_t i = 0 ;
 i < 20 ;
 i ++ ) {
 read_helpers . push_back ( new ReadHelper ( file_size , 1000 , & multibuffer_ , & rnd_ ) ) ;
 }
 for ( int i = 0 ;
 i < 100 ;
 i ++ ) {
 for ( int j = 0 ;
 j < 100 ;
 j ++ ) {
 if ( rnd_ . Rand ( ) & 1 ) {
 if ( ! media : : writers . empty ( ) ) Advance ( ) ;
 }
 else {
 size_t j = rnd_ . Rand ( ) % read_helpers . size ( ) ;
 if ( rnd_ . Rand ( ) % 100 < 3 ) read_helpers [ j ] -> Seek ( ) ;
 read_helpers [ j ] -> StartRead ( ) ;
 }
 }
 multibuffer_ . CheckLRUState ( ) ;
 }
 multibuffer_ . CheckPresentState ( ) ;
 while ( ! read_helpers . empty ( ) ) {
 delete read_helpers . back ( ) ;
 read_helpers . pop_back ( ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void AssignNotdefNull ( SplineFont * sf , int * bygid , int iscff ) {
 int i ;
 for ( i = 0 ;
 i < sf -> glyphcnt ;
 ++ i ) if ( sf -> glyphs [ i ] != NULL ) {
 if ( bygid [ 0 ] == - 1 && strcmp ( sf -> glyphs [ i ] -> name , "".notdef"" ) == 0 ) {
 sf -> glyphs [ i ] -> ttf_glyph = 0 ;
 bygid [ 0 ] = i ;
 }
 else if ( ! iscff && bygid [ 1 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , "".null"" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , ""uni0000"" ) == 0 || ( i == 1 && strcmp ( sf -> glyphs [ 1 ] -> name , ""glyph1"" ) == 0 ) ) ) {
 sf -> glyphs [ i ] -> ttf_glyph = 1 ;
 bygid [ 1 ] = i ;
 }
 else if ( ! iscff && bygid [ 2 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , ""nonmarkingreturn"" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , ""uni000D"" ) == 0 || ( i == 2 && strcmp ( sf -> glyphs [ 2 ] -> name , ""glyph2"" ) == 0 ) ) ) {
 sf -> glyphs [ i ] -> ttf_glyph = 2 ;
 bygid [ 2 ] = i ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void reset_stats ( VirtIOBalloon * dev ) {
 int i ;
 for ( i = 0 ;
 i < VIRTIO_BALLOON_S_NR ;
 dev -> stats [ i ++ ] = - 1 ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void luaD_call ( lua_State * L , StkId func , int nResults ) {
 if ( ++ L -> nCcalls >= LUAI_MAXCCALLS ) {
 if ( L -> nCcalls == LUAI_MAXCCALLS ) luaG_runerror ( L , ""C stack overflow"" ) ;
 else if ( L -> nCcalls >= ( LUAI_MAXCCALLS + ( LUAI_MAXCCALLS >> 3 ) ) ) luaD_throw ( L , LUA_ERRERR ) ;
 }
 if ( luaD_precall ( L , func , nResults ) == PCRLUA ) luaV_execute ( L , 1 ) ;
 L -> nCcalls -- ;
 luaC_checkGC ( L ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , int qindex , double rate_target_ratio ) {
 int target_index = rc -> worst_quality ;
 int i ;
 const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ;
 const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;
 for ( i = rc -> best_quality ;
 i < rc -> worst_quality ;
 ++ i ) {
 target_index = i ;
 if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb ) break ;
 }
 return target_index - qindex ;
 }",1
Detect whether the following code contains vulnerabilities.,"hb_bool_t hb_shape_plan_execute ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {
 DEBUG_MSG_FUNC ( SHAPE_PLAN , shape_plan , ""num_features=%d shaper_func=%p"" , num_features , shape_plan -> shaper_func ) ;
 if ( unlikely ( hb_object_is_inert ( shape_plan ) || hb_object_is_inert ( font ) || hb_object_is_inert ( buffer ) ) ) return false ;
 assert ( shape_plan -> face_unsafe == font -> face ) ;
 assert ( hb_segment_properties_equal ( & shape_plan -> props , & buffer -> props ) ) ;
 # define HB_SHAPER_EXECUTE ( shaper ) HB_STMT_START {
 return HB_SHAPER_DATA ( shaper , shape_plan ) && hb_ ## shaper ## _shaper_font_data_ensure ( font ) && _hb_ ## shaper ## _shape ( shape_plan , font , buffer , features , num_features ) ;
 }
 HB_STMT_END if ( 0 ) ;
 # define HB_SHAPER_IMPLEMENT ( shaper ) else if ( shape_plan -> shaper_func == _hb_ ## shaper ## _shape ) HB_SHAPER_EXECUTE ( shaper ) ;
 # include ""hb-shaper-list.hh"" # undef HB_SHAPER_IMPLEMENT # undef HB_SHAPER_EXECUTE return false ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline uint16_t vga_read_word_be ( VGACommonState * vga , uint32_t addr ) {
 uint32_t offset = addr & vga -> vbe_size_mask & ~ 1 ;
 uint16_t * ptr = ( uint16_t * ) ( vga -> vram_ptr + offset ) ;
 return lduw_be_p ( ptr ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * strsep_quotes ( char * * stringp , const char delim ) {
 char * s ;
 int c ;
 char * tok ;
 if ( ( s = * stringp ) == NULL ) return ( NULL ) ;
 for ( tok = s ;
 ;
 ) {
 if ( * s == '\""' ) while ( * ( ++ s ) != '\""' && * s != '\0' ) ;
 c = * s ++ ;
 if ( c == delim || c == 0 ) {
 if ( c == 0 ) s = NULL ;
 else s [ - 1 ] = 0 ;
 * stringp = s ;
 return ( tok ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fdct16x16_1_c ( const int16_t * input , int16_t * output , int stride ) {
 int r , c ;
 int16_t sum = 0 ;
 for ( r = 0 ;
 r < 16 ;
 ++ r ) for ( c = 0 ;
 c < 16 ;
 ++ c ) sum += input [ r * stride + c ] ;
 output [ 0 ] = sum >> 1 ;
 output [ 1 ] = 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_RequestChannelCloseRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_RequestChannelCloseRejectCause , RequestChannelCloseRejectCause_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int virLogHostnameString ( char * * rawmsg , char * * msg ) {
 char * hostname = virGetHostnameQuiet ( ) ;
 char * hoststr ;
 if ( ! hostname ) return - 1 ;
 if ( virAsprintfQuiet ( & hoststr , ""hostname: %s"" , hostname ) < 0 ) {
 VIR_FREE ( hostname ) ;
 return - 1 ;
 }
 VIR_FREE ( hostname ) ;
 if ( virLogFormatString ( msg , 0 , NULL , VIR_LOG_INFO , hoststr ) < 0 ) {
 VIR_FREE ( hoststr ) ;
 return - 1 ;
 }
 * rawmsg = hoststr ;
 return 0 ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void set_block_size ( VP9_COMP * const cpi , int mi_row , int mi_col , BLOCK_SIZE bsize ) {
 if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {
 MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;
 set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;
 xd -> mi [ 0 ] . src_mi -> mbmi . sb_type = bsize ;
 duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"void completion_last_message_remove ( const char * nick ) {
 LAST_MSG_REC * rec ;
 g_return_if_fail ( nick != NULL ) ;
 rec = last_msg_find ( global_lastmsgs , nick ) ;
 if ( rec != NULL ) last_msg_destroy ( & global_lastmsgs , rec ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int png_decode_idat ( PNGDecContext * s , int length ) {
 int ret ;
 s -> zstream . avail_in = FFMIN ( length , bytestream2_get_bytes_left ( & s -> gb ) ) ;
 s -> zstream . next_in = s -> gb . buffer ;
 bytestream2_skip ( & s -> gb , length ) ;
 while ( s -> zstream . avail_in > 0 ) {
 ret = inflate ( & s -> zstream , Z_PARTIAL_FLUSH ) ;
 if ( ret != Z_OK && ret != Z_STREAM_END ) {
 return - 1 ;
 }
 if ( s -> zstream . avail_out == 0 ) {
 if ( ! ( s -> state & PNG_ALLIMAGE ) ) {
 png_handle_row ( s ) ;
 }
 s -> zstream . avail_out = s -> crow_size ;
 s -> zstream . next_out = s -> crow_buf ;
 }
 }
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int com_connect ( String * buffer , char * line ) {
 char * tmp , buff [ 256 ] ;
 my_bool save_rehash = opt_rehash ;
 int error ;
 bzero ( buff , sizeof ( buff ) ) ;
 if ( buffer ) {
 tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;
 # ifdef EXTRA_DEBUG tmp [ 1 ] = 0 ;
 # endif tmp = get_arg ( buff , 0 ) ;
 if ( tmp && * tmp ) {
 my_free ( current_db ) ;
 current_db = my_strdup ( tmp , MYF ( MY_WME ) ) ;
 tmp = get_arg ( buff , 1 ) ;
 if ( tmp ) {
 my_free ( current_host ) ;
 current_host = my_strdup ( tmp , MYF ( MY_WME ) ) ;
 }
 }
 else {
 opt_rehash = 0 ;
 }
 buffer -> length ( 0 ) ;
 }
 else opt_rehash = 0 ;
 error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;
 opt_rehash = save_rehash ;
 if ( connected ) {
 sprintf ( buff , ""Connection id: %lu"" , mysql_thread_id ( & mysql ) ) ;
 put_info ( buff , INFO_INFO ) ;
 sprintf ( buff , ""Current database: %.128s\n"" , current_db ? current_db : ""*** NONE ***"" ) ;
 put_info ( buff , INFO_INFO ) ;
 }
 return error ;
 }",1
Detect whether the following code contains vulnerabilities.,"char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {
 char * buffer = NULL ;
 int n = 0 ;
 FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( """" , cl , NULL ) ;
 if ( length > 0 ) {
 buffer = malloc ( length + 1 ) ;
 if ( buffer != NULL ) {
 if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) {
 if ( n != 0 ) rfbLogPerror ( ""rfbProcessFileTransferReadBuffer: read"" ) ;
 rfbCloseClient ( cl ) ;
 if ( buffer != NULL ) free ( buffer ) ;
 return NULL ;
 }
 buffer [ length ] = 0 ;
 }
 }
 return buffer ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , OtherScheme ) {
 NavigateInForegroundAndCloseWithTiming ( GURL ( chrome : : kChromeUIVersionURL ) ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;
 histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {
 size_t i , j ;
 i = c -> num ;
 if ( i != 0 ) {
 if ( i + len < MDC2_BLOCK ) {
 memcpy ( & ( c -> data [ i ] ) , in , len ) ;
 c -> num += ( int ) len ;
 return 1 ;
 }
 else {
 j = MDC2_BLOCK - i ;
 memcpy ( & ( c -> data [ i ] ) , in , j ) ;
 len -= j ;
 in += j ;
 c -> num = 0 ;
 mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;
 }
 }
 i = len & ~ ( ( size_t ) MDC2_BLOCK - 1 ) ;
 if ( i > 0 ) mdc2_body ( c , in , i ) ;
 j = len - i ;
 if ( j > 0 ) {
 memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;
 c -> num = ( int ) j ;
 }
 return 1 ;
 }",1
Detect whether the following code contains vulnerabilities.,"int test_sqr ( BIO * bp , BN_CTX * ctx ) {
 BIGNUM a , c , d , e ;
 int i ;
 BN_init ( & a ) ;
 BN_init ( & c ) ;
 BN_init ( & d ) ;
 BN_init ( & e ) ;
 for ( i = 0 ;
 i < num0 ;
 i ++ ) {
 BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ;
 a . neg = rand_neg ( ) ;
 BN_sqr ( & c , & a , ctx ) ;
 if ( bp != NULL ) {
 if ( ! results ) {
 BN_print ( bp , & a ) ;
 BIO_puts ( bp , "" * "" ) ;
 BN_print ( bp , & a ) ;
 BIO_puts ( bp , "" - "" ) ;
 }
 BN_print ( bp , & c ) ;
 BIO_puts ( bp , ""\n"" ) ;
 }
 BN_div ( & d , & e , & c , & a , ctx ) ;
 BN_sub ( & d , & d , & a ) ;
 if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {
 fprintf ( stderr , ""Square test failed!\n"" ) ;
 return 0 ;
 }
 }
 BN_free ( & a ) ;
 BN_free ( & c ) ;
 BN_free ( & d ) ;
 BN_free ( & e ) ;
 return ( 1 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"struct config_filter_parser * const * config_filter_find_subset ( struct config_filter_context * ctx , const struct config_filter * filter ) {
 ARRAY_TYPE ( config_filter_parsers ) matches ;
 struct config_filter tmp_mask ;
 unsigned int i ;
 t_array_init ( & matches , 8 ) ;
 for ( i = 0 ;
 ctx -> parsers [ i ] != NULL ;
 i ++ ) {
 const struct config_filter * mask = & ctx -> parsers [ i ] -> filter ;
 if ( filter -> service != NULL ) {
 if ( ! config_filter_match_service ( mask , filter ) ) continue ;
 }
 tmp_mask = * mask ;
 if ( filter -> local_name == NULL ) tmp_mask . local_name = NULL ;
 if ( filter -> local_bits == 0 ) tmp_mask . local_bits = 0 ;
 if ( filter -> remote_bits == 0 ) tmp_mask . remote_bits = 0 ;
 if ( config_filter_match_rest ( & tmp_mask , filter ) ) array_append ( & matches , & ctx -> parsers [ i ] , 1 ) ;
 }
 array_sort ( & matches , config_filter_parser_cmp_rev ) ;
 array_append_zero ( & matches ) ;
 return array_idx ( & matches , 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void typhoon_register_types ( void ) {
 type_register_static ( & typhoon_pcihost_info ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_q931_ie_cs0 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {
 dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 0 ) ;
 return tvb_captured_length ( tvb ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"List * find_nonnullable_vars ( Node * clause ) {
 return find_nonnullable_vars_walker ( clause , true ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"TEST_F ( TemplateURLParserTest , TestFirefoxEbay ) {
 ParamFilterImpl filter ( ""ebay"" , ""ebay"" ) ;
 ASSERT_NO_FATAL_FAILURE ( ParseFile ( ""firefox_ebay.xml"" , & filter ) ) ;
 ASSERT_TRUE ( template_url_ ) ;
 EXPECT_EQ ( ASCIIToUTF16 ( ""eBay"" ) , template_url_ -> short_name ( ) ) ;
 EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;
 EXPECT_EQ ( ""http://search.ebay.com/search/search.dll?query={
searchTerms}
&"" ""MfcISAPICommand=GetResult&ht=1&srchdesc=n&maxRecordsReturned=300&"" ""maxRecordsPerPage=50&SortProperty=MetaEndSort"" , template_url_ -> url ( ) ) ;
 ASSERT_EQ ( 1U , template_url_ -> input_encodings ( ) . size ( ) ) ;
 EXPECT_EQ ( ""ISO-8859-1"" , template_url_ -> input_encodings ( ) [ 0 ] ) ;
 EXPECT_EQ ( GURL ( ""http://search.ebay.com/favicon.ico"" ) , template_url_ -> favicon_url ( ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"int prepare_bitmap_git ( void ) {
 if ( bitmap_git . loaded ) return 0 ;
 if ( ! open_pack_bitmap ( ) ) return load_pack_bitmap ( ) ;
 return - 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static inline void idct_put ( MDECContext * a , AVFrame * frame , int mb_x , int mb_y ) {
 int16_t ( * block ) [ 64 ] = a -> block ;
 int linesize = frame -> linesize [ 0 ] ;
 uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;
 uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;
 uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;
 a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;
 a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;
 if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {
 a -> dsp . idct_put ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;
 a -> dsp . idct_put ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static struct evhttp * http_setup ( short * pport , struct event_base * base ) {
 int i ;
 struct evhttp * myhttp ;
 short port = - 1 ;
 myhttp = evhttp_new ( base ) ;
 for ( i = 0 ;
 i < 50 ;
 ++ i ) {
 if ( evhttp_bind_socket ( myhttp , ""127.0.0.1"" , 8080 + i ) != - 1 ) {
 port = 8080 + i ;
 break ;
 }
 }
 if ( port == - 1 ) event_errx ( 1 , ""Could not start web server"" ) ;
 evhttp_set_cb ( myhttp , ""/test"" , http_basic_cb , NULL ) ;
 evhttp_set_cb ( myhttp , ""/chunked"" , http_chunked_cb , NULL ) ;
 evhttp_set_cb ( myhttp , ""/postit"" , http_post_cb , NULL ) ;
 evhttp_set_cb ( myhttp , ""/largedelay"" , http_large_delay_cb , NULL ) ;
 evhttp_set_cb ( myhttp , ""/"" , http_dispatcher_cb , NULL ) ;
 * pport = port ;
 return ( myhttp ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int32_t u_printf_pointer_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {
 UChar result [ UPRINTF_BUFFER_SIZE ] ;
 int32_t len = UPRINTF_BUFFER_SIZE ;
 ufmt_ptou ( result , & len , args [ 0 ] . ptrValue , TRUE ) ;
 return handler -> pad_and_justify ( context , info , result , len ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void sbr_hf_apply_noise_1 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {
 float phi_sign = 1 - 2 * ( kx & 1 ) ;
 sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 0.0 , phi_sign , m_max ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"TSReturnCode sdk_sanity_check_alt_info ( TSHttpAltInfo info ) {
 if ( info == nullptr ) {
 return TS_ERROR ;
 }
 return TS_SUCCESS ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UBool U_CALLCONV _enumPropertyStartsRange ( const void * context , UChar32 start , UChar32 end , uint32_t value ) {
 const USetAdder * sa = ( const USetAdder * ) context ;
 sa -> add ( sa -> set , start ) ;
 return TRUE ;
 }",1
Detect whether the following code contains vulnerabilities.,"static uint32_t vmport_cmd_ram_size ( void * opaque , uint32_t addr ) {
 CPUX86State * env = cpu_single_env ;
 env -> regs [ R_EBX ] = 0x1177 ;
 return ram_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static __always_inline __u64 __be64_to_cpup ( const __be64 * p ) {
 return __swab64p ( ( __u64 * ) p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void encode_signal_range ( VC2EncContext * s ) {
 put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ;
 if ( ! s -> strict_compliance ) put_vc2_ue_uint ( & s -> pb , s -> bpp_idx ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static vpx_codec_err_t ctrl_set_noise_sensitivity ( vpx_codec_alg_priv_t * ctx , va_list args ) {
 struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;
 extra_cfg . noise_sensitivity = CAST ( VP8E_SET_NOISE_SENSITIVITY , args ) ;
 return update_extra_cfg ( ctx , & extra_cfg ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void cpu_halt_signal ( void * opaque , int irq , int level ) {
 if ( level && current_cpu ) {
 cpu_interrupt ( current_cpu , CPU_INTERRUPT_HALT ) ;
 }
 }",0
Detect whether the following code contains vulnerabilities.,"static const char * NoMeta ( const char * str ) {
 if ( strchr ( str , '%' ) != NULL ) return ""**** CORRUPTED FORMAT STRING ***"" ;
 return str ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_q931_ie_cs7 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {
 dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 7 , NULL ) ;
 return tvb_captured_length ( tvb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * ext_t_1_wml_10 ( tvbuff_t * tvb , guint32 value , guint32 str_tbl ) {
 char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , ""Variable substitution - unescaped: '%s'"" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;
 return str ;
 }",0
Detect whether the following code contains vulnerabilities.,"int gdev_mem_max_height ( const gx_device_memory * dev , int width , ulong size , bool page_uses_transparency ) {
 int height ;
 ulong max_height ;
 ulong data_size ;
 if ( page_uses_transparency ) {
 max_height = size / ( bitmap_raster_pad_align ( width * dev -> color_info . depth + ESTIMATED_PDF14_ROW_SPACE ( width , dev -> color_info . num_components ) , dev -> pad , dev -> log2_align_mod ) + sizeof ( byte * ) * ( dev -> is_planar ? dev -> color_info . num_components : 1 ) ) ;
 height = ( int ) min ( max_height , max_int ) ;
 }
 else {
 max_height = size / ( bitmap_raster_pad_align ( width * dev -> color_info . depth , dev -> pad , dev -> log2_align_mod ) + sizeof ( byte * ) * ( dev -> is_planar ? dev -> color_info . num_components : 1 ) ) ;
 height = ( int ) min ( max_height , max_int ) ;
 do {
 gdev_mem_data_size ( dev , width , height , & data_size ) ;
 if ( data_size <= size ) break ;
 -- height ;
 }
 while ( data_size > size ) ;
 }
 return height ;
 }",0
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , DISABLED_DiscardDangerousFile ) {
 GURL download_url ( embedded_test_server ( ) -> GetURL ( ""/downloads/dangerous/dangerous.swf"" ) ) ;
 content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( browser ( ) ) , 1u , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_IGNORE ) ;
 CreateDownloadForBrowserAndURL ( browser ( ) , download_url ) ;
 base : : FilePath filename = download_item ( ) -> GetFileNameToReportUser ( ) ;
 EXPECT_EQ ( download : : DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE , download_item ( ) -> GetDangerType ( ) ) ;
 EXPECT_TRUE ( download_item ( ) -> IsDangerous ( ) ) ;
 EXPECT_TRUE ( notification ( ) ) ;
 display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , 0 , base : : nullopt ) ;
 EXPECT_FALSE ( notification ( ) ) ;
 download_terminal_observer . WaitForFinished ( ) ;
 EXPECT_FALSE ( notification ( ) ) ;
 EXPECT_EQ ( 0u , GetDownloadNotifications ( ) . size ( ) ) ;
 std : : vector < download : : DownloadItem * > downloads ;
 GetDownloadManager ( browser ( ) ) -> GetAllDownloads ( & downloads ) ;
 EXPECT_EQ ( 0u , downloads . size ( ) ) ;
 EXPECT_FALSE ( base : : PathExists ( GetDownloadPath ( ) . Append ( filename . BaseName ( ) ) ) ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_kpcr_number ( CPUX86State * env ) {
 struct kpcr {
 uint8_t fill1 [ 0x1c ] ;
 uint32_t self ;
 uint8_t fill2 [ 0x31 ] ;
 uint8_t number ;
 }
 QEMU_PACKED kpcr ;
 if ( cpu_memory_rw_debug ( env , env -> segs [ R_FS ] . base , ( void * ) & kpcr , sizeof ( kpcr ) , 0 ) < 0 || kpcr . self != env -> segs [ R_FS ] . base ) {
 return - 1 ;
 }
 return kpcr . number ;
 }",0
Detect whether the following code contains vulnerabilities.,"static __always_inline __be32 __cpu_to_be32p ( const __u32 * p ) {
 return ( __be32 ) __swab32p ( p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void super_block_yrd ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * psse , BLOCK_SIZE bs , int64_t txfm_cache [ TX_MODES ] , int64_t ref_best_rd ) {
 MACROBLOCKD * xd = & x -> e_mbd ;
 int64_t sse ;
 int64_t * ret_sse = psse ? psse : & sse ;
 assert ( bs == xd -> mi [ 0 ] -> mbmi . sb_type ) ;
 if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL || xd -> lossless ) {
 vpx_memset ( txfm_cache , 0 , TX_MODES * sizeof ( int64_t ) ) ;
 choose_largest_tx_size ( cpi , x , rate , distortion , skip , ret_sse , ref_best_rd , bs ) ;
 }
 else {
 choose_tx_size_from_rd ( cpi , x , rate , distortion , skip , ret_sse , txfm_cache , ref_best_rd , bs ) ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD ( SplFileObject , fread ) {
 spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;
 long length = 0 ;
 if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""l"" , & length ) == FAILURE ) {
 return ;
 }
 if ( length <= 0 ) {
 php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Length parameter must be greater than 0"" ) ;
 RETURN_FALSE ;
 }
 Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;
 Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;
 Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ;
 Z_TYPE_P ( return_value ) = IS_STRING ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int remaining_bits ( WMAProDecodeCtx * s , GetBitContext * gb ) {
 return s -> buf_bit_size - get_bits_count ( gb ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"inline const OldUChar * toOldUCharPtr ( const char16_t * p ) {
 # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;
 # endif return reinterpret_cast < const OldUChar * > ( p ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void parse_content_type ( struct attachment_istream * astream , const struct message_header_line * hdr ) {
 struct rfc822_parser_context parser ;
 string_t * content_type ;
 if ( astream -> part . content_type != NULL ) return ;
 rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;
 rfc822_skip_lwsp ( & parser ) ;
 T_BEGIN {
 content_type = t_str_new ( 64 ) ;
 ( void ) rfc822_parse_content_type ( & parser , content_type ) ;
 astream -> part . content_type = i_strdup ( str_c ( content_type ) ) ;
 }
 T_END ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int dissect_pvfs2_truncate_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {
 offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , ""handle"" , NULL ) ;
 offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;
 offset += 4 ;
 proto_tree_add_item ( tree , hf_pvfs_size , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;
 offset += 8 ;
 proto_tree_add_item ( tree , hf_pvfs_truncate_request_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;
 offset += 4 ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_fht4x4_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {
 if ( tx_type == DCT_DCT ) {
 vp9_fdct4x4_c ( input , output , stride ) ;
 }
 else {
 int16_t out [ 4 * 4 ] ;
 int16_t * outptr = & out [ 0 ] ;
 int i , j ;
 int16_t temp_in [ 4 ] , temp_out [ 4 ] ;
 const transform_2d ht = FHT_4 [ tx_type ] ;
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;
 if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ;
 ht . cols ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;
 }
 for ( i = 0 ;
 i < 4 ;
 ++ i ) {
 for ( j = 0 ;
 j < 4 ;
 ++ j ) temp_in [ j ] = out [ j + i * 4 ] ;
 ht . rows ( temp_in , temp_out ) ;
 for ( j = 0 ;
 j < 4 ;
 ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ;
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static int decode_tag ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {
 AVFrame * frame = data ;
 const uint8_t * buf = avpkt -> data ;
 int buf_size = avpkt -> size ;
 NellyMoserDecodeContext * s = avctx -> priv_data ;
 int blocks , i , ret ;
 float * samples_flt ;
 blocks = buf_size / NELLY_BLOCK_LEN ;
 if ( blocks <= 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""Packet is too small\n"" ) ;
 return AVERROR_INVALIDDATA ;
 }
 if ( buf_size % NELLY_BLOCK_LEN ) {
 av_log ( avctx , AV_LOG_WARNING , ""Leftover bytes: %d.\n"" , buf_size % NELLY_BLOCK_LEN ) ;
 }
 frame -> nb_samples = NELLY_SAMPLES * blocks ;
 if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {
 av_log ( avctx , AV_LOG_ERROR , ""get_buffer() failed\n"" ) ;
 return ret ;
 }
 samples_flt = ( float * ) frame -> data [ 0 ] ;
 for ( i = 0 ;
 i < blocks ;
 i ++ ) {
 nelly_decode_block ( s , buf , samples_flt ) ;
 samples_flt += NELLY_SAMPLES ;
 buf += NELLY_BLOCK_LEN ;
 }
 * got_frame_ptr = 1 ;
 return buf_size ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void xps_draw_arc_segment ( fz_context * doc , fz_path * path , const fz_matrix * mtx , float th0 , float th1 , int iscw ) {
 float t , d ;
 fz_point p ;
 while ( th1 < th0 ) th1 += ( float ) M_PI * 2 ;
 d = ( float ) M_PI / 180 ;
 if ( iscw ) {
 for ( t = th0 + d ;
 t < th1 - d / 2 ;
 t += d ) {
 p . x = cosf ( t ) ;
 p . y = sinf ( t ) ;
 fz_transform_point ( & p , mtx ) ;
 fz_lineto ( doc , path , p . x , p . y ) ;
 }
 }
 else {
 th0 += ( float ) M_PI * 2 ;
 for ( t = th0 - d ;
 t > th1 + d / 2 ;
 t -= d ) {
 p . x = cosf ( t ) ;
 p . y = sinf ( t ) ;
 fz_transform_point ( & p , mtx ) ;
 fz_lineto ( doc , path , p . x , p . y ) ;
 }
 }
 }",0
Detect whether the following code contains vulnerabilities.,"vpx_codec_err_t vpx_codec_enc_config_set ( vpx_codec_ctx_t * ctx , const vpx_codec_enc_cfg_t * cfg ) {
 vpx_codec_err_t res ;
 if ( ! ctx || ! ctx -> iface || ! ctx -> priv || ! cfg ) res = VPX_CODEC_INVALID_PARAM ;
 else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;
 else res = ctx -> iface -> enc . cfg_set ( get_alg_priv ( ctx ) , cfg ) ;
 return SAVE_STATUS ( ctx , res ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"bool config_filters_equal ( const struct config_filter * f1 , const struct config_filter * f2 ) {
 if ( null_strcmp ( f1 -> service , f2 -> service ) != 0 ) return FALSE ;
 if ( f1 -> remote_bits != f2 -> remote_bits ) return FALSE ;
 if ( ! net_ip_compare ( & f1 -> remote_net , & f2 -> remote_net ) ) return FALSE ;
 if ( f1 -> local_bits != f2 -> local_bits ) return FALSE ;
 if ( ! net_ip_compare ( & f1 -> local_net , & f2 -> local_net ) ) return FALSE ;
 if ( null_strcasecmp ( f1 -> local_name , f2 -> local_name ) != 0 ) return FALSE ;
 return TRUE ;
 }",0
Detect whether the following code contains vulnerabilities.,"hb_blob_t * hb_blob_create ( const char * data , unsigned int length , hb_memory_mode_t mode , void * user_data , hb_destroy_func_t destroy ) {
 hb_blob_t * blob ;
 if ( ! length || ! ( blob = hb_object_create < hb_blob_t > ( ) ) ) {
 if ( destroy ) destroy ( user_data ) ;
 return hb_blob_get_empty ( ) ;
 }
 blob -> data = data ;
 blob -> length = length ;
 blob -> mode = mode ;
 blob -> user_data = user_data ;
 blob -> destroy = destroy ;
 if ( blob -> mode == HB_MEMORY_MODE_DUPLICATE ) {
 blob -> mode = HB_MEMORY_MODE_READONLY ;
 if ( ! _try_writable ( blob ) ) {
 hb_blob_destroy ( blob ) ;
 return hb_blob_get_empty ( ) ;
 }
 }
 return blob ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int rsvp_hostlist_packet ( void * pit , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * vip ) {
 conv_hash_t * hash = ( conv_hash_t * ) pit ;
 const rsvp_conversation_info * rsvph = ( const rsvp_conversation_info * ) vip ;
 add_hostlist_table_data ( hash , & rsvph -> source , 0 , TRUE , 1 , pinfo -> fd -> pkt_len , & rsvp_host_dissector_info , PT_NONE ) ;
 add_hostlist_table_data ( hash , & rsvph -> destination , 0 , FALSE , 1 , pinfo -> fd -> pkt_len , & rsvp_host_dissector_info , PT_NONE ) ;
 return 1 ;
 }",0
Detect whether the following code contains vulnerabilities.,"void xmlHashScanFull ( xmlHashTablePtr table , xmlHashScannerFull f , void * data ) {
 int i , nb ;
 xmlHashEntryPtr iter ;
 xmlHashEntryPtr next ;
 if ( table == NULL ) return ;
 if ( f == NULL ) return ;
 if ( table -> table ) {
 for ( i = 0 ;
 i < table -> size ;
 i ++ ) {
 if ( table -> table [ i ] . valid == 0 ) continue ;
 iter = & ( table -> table [ i ] ) ;
 while ( iter ) {
 next = iter -> next ;
 nb = table -> nbElems ;
 if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , data , iter -> name , iter -> name2 , iter -> name3 ) ;
 if ( nb != table -> nbElems ) {
 if ( iter == & ( table -> table [ i ] ) ) {
 if ( table -> table [ i ] . valid == 0 ) iter = NULL ;
 if ( table -> table [ i ] . next != next ) iter = & ( table -> table [ i ] ) ;
 }
 else iter = next ;
 }
 else iter = next ;
 }
 }
 }
 }",1
Detect whether the following code contains vulnerabilities.,"static void dtap_sms_cp_data ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {
 guint32 curr_offset ;
 guint32 consumed ;
 guint curr_len ;
 curr_offset = offset ;
 curr_len = len ;
 is_uplink = IS_UPLINK_TRUE ;
 ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_CP_USER_DATA , NULL ) ;
 EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int pfkey_promisc ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {
 struct pfkey_sock * pfk = pfkey_sk ( sk ) ;
 int satype = hdr -> sadb_msg_satype ;
 bool reset_errno = false ;
 if ( hdr -> sadb_msg_len == ( sizeof ( * hdr ) / sizeof ( uint64_t ) ) ) {
 reset_errno = true ;
 if ( satype != 0 && satype != 1 ) return - EINVAL ;
 pfk -> promisc = satype ;
 }
 if ( reset_errno && skb_cloned ( skb ) ) skb = skb_copy ( skb , GFP_KERNEL ) ;
 else skb = skb_clone ( skb , GFP_KERNEL ) ;
 if ( reset_errno && skb ) {
 struct sadb_msg * new_hdr = ( struct sadb_msg * ) skb -> data ;
 new_hdr -> sadb_msg_errno = 0 ;
 }
 pfkey_broadcast ( skb , GFP_KERNEL , BROADCAST_ALL , NULL , sock_net ( sk ) ) ;
 return 0 ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_h245_IS11172_multichannelType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {
 offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172_multichannelType , IS11172_multichannelType_choice , NULL ) ;
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static uint16_t * build_linear_table ( int length ) {
 int i ;
 uint16_t * output = malloc ( sizeof ( uint16_t ) * length ) ;
 if ( ! output ) return NULL ;
 for ( i = 0 ;
 i < length ;
 i ++ ) {
 double x = ( ( double ) i * 65535. ) / ( double ) ( length - 1 ) ;
 uint16_fract_t input = floor ( x + .5 ) ;
 output [ i ] = input ;
 }
 return output ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int dissect_type_bitmap_nxt ( proto_tree * rr_tree , tvbuff_t * tvb , int cur_offset , int rr_len ) {
 int mask ;
 int i , initial_offset , rr_type ;
 guint8 bits ;
 initial_offset = cur_offset ;
 rr_type = 0 ;
 while ( rr_len != 0 ) {
 bits = tvb_get_guint8 ( tvb , cur_offset ) ;
 mask = 1 << 7 ;
 for ( i = 0 ;
 i < 8 ;
 i ++ ) {
 if ( bits & mask ) {
 proto_tree_add_uint_format ( rr_tree , hf_dns_rr_type , tvb , cur_offset , 1 , rr_type , ""RR type in bit map: %s"" , val_to_str_ext ( rr_type , & dns_types_description_vals_ext , ""Unknown (%d)"" ) ) ;
 }
 mask >>= 1 ;
 rr_type ++ ;
 }
 cur_offset += 1 ;
 rr_len -= 1 ;
 }
 return ( initial_offset - cur_offset ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static gint dissect_AllJoyn_message ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset ) {
 proto_item * message_item ;
 proto_tree * message_tree ;
 gint last_offset = - 1 ;
 gint packet_length ;
 gboolean is_ardp = FALSE ;
 if ( offset != 0 ) {
 is_ardp = TRUE ;
 }
 pinfo -> desegment_len = 0 ;
 packet_length = tvb_reported_length ( tvb ) ;
 col_clear ( pinfo -> cinfo , COL_INFO ) ;
 col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""ALLJOYN"" ) ;
 message_item = proto_tree_add_item ( tree , proto_AllJoyn_mess , tvb , offset , - 1 , ENC_NA ) ;
 message_tree = proto_item_add_subtree ( message_item , ett_alljoyn_mess ) ;
 while ( offset < packet_length && offset > last_offset ) {
 last_offset = offset ;
 if ( ! is_ardp ) {
 offset = handle_message_connect ( tvb , pinfo , offset , message_tree ) ;
 if ( offset >= packet_length ) {
 break ;
 }
 offset = handle_message_sasl ( tvb , pinfo , offset , message_tree ) ;
 if ( offset >= packet_length ) {
 break ;
 }
 }
 offset = handle_message_header_body ( tvb , pinfo , offset , message_tree , is_ardp ) ;
 }
 return offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static char * rfc2047_decode_word ( const char * s , size_t len , enum ContentEncoding enc ) {
 const char * it = s ;
 const char * end = s + len ;
 if ( enc == ENCQUOTEDPRINTABLE ) {
 struct Buffer buf = {
 0 }
 ;
 for ( ;
 it < end ;
 ++ it ) {
 if ( * it == '_' ) {
 mutt_buffer_addch ( & buf , ' ' ) ;
 }
 else if ( ( * it == '=' ) && ( ! ( it [ 1 ] & ~ 127 ) && hexval ( it [ 1 ] ) != - 1 ) && ( ! ( it [ 2 ] & ~ 127 ) && hexval ( it [ 2 ] ) != - 1 ) ) {
 mutt_buffer_addch ( & buf , ( hexval ( it [ 1 ] ) << 4 ) | hexval ( it [ 2 ] ) ) ;
 it += 2 ;
 }
 else {
 mutt_buffer_addch ( & buf , * it ) ;
 }
 }
 mutt_buffer_addch ( & buf , '\0' ) ;
 return buf . data ;
 }
 else if ( enc == ENCBASE64 ) {
 char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ;
 int dlen = mutt_b64_decode ( out , it ) ;
 if ( dlen == - 1 ) {
 FREE ( & out ) ;
 return NULL ;
 }
 out [ dlen ] = '\0' ;
 return out ;
 }
 assert ( 0 ) ;
 return NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"int TSMimeHdrLengthGet ( TSMBuffer bufp , TSMLoc obj ) {
 sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;
 sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( obj ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ) ;
 MIMEHdrImpl * mh = _hdr_mloc_to_mime_hdr_impl ( obj ) ;
 return mime_hdr_length_get ( mh ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp8_mbpost_proc_across_ip_c ( unsigned char * src , int pitch , int rows , int cols , int flimit ) {
 int r , c , i ;
 unsigned char * s = src ;
 unsigned char d [ 16 ] ;
 for ( r = 0 ;
 r < rows ;
 r ++ ) {
 int sumsq = 0 ;
 int sum = 0 ;
 for ( i = - 8 ;
 i < 0 ;
 i ++ ) s [ i ] = s [ 0 ] ;
 for ( i = cols ;
 i < cols + 17 ;
 i ++ ) s [ i ] = s [ cols - 1 ] ;
 for ( i = - 8 ;
 i <= 6 ;
 i ++ ) {
 sumsq += s [ i ] * s [ i ] ;
 sum += s [ i ] ;
 d [ i + 8 ] = 0 ;
 }
 for ( c = 0 ;
 c < cols + 8 ;
 c ++ ) {
 int x = s [ c + 7 ] - s [ c - 8 ] ;
 int y = s [ c + 7 ] + s [ c - 8 ] ;
 sum += x ;
 sumsq += x * y ;
 d [ c & 15 ] = s [ c ] ;
 if ( sumsq * 15 - sum * sum < flimit ) {
 d [ c & 15 ] = ( 8 + sum + s [ c ] ) >> 4 ;
 }
 s [ c - 8 ] = d [ ( c - 8 ) & 15 ] ;
 }
 s += pitch ;
 }
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerWithDownloadsBrowserTest , TestWithDownloads ) {
 SetDownloadPathForProfile ( browser ( ) -> profile ( ) ) ;
 ASSERT_NO_FATAL_FAILURE ( CreateStalledDownload ( browser ( ) ) ) ;
 content : : TestNavigationObserver navigation_observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 1 ) ;
 TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_CANCELS_CLOSE ) ;
 EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;
 navigation_observer . Wait ( ) ;
 EXPECT_EQ ( GURL ( chrome : : kChromeUIDownloadsURL ) , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetURL ( ) ) ;
 RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;
 TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_ALLOWS_CLOSE ) ;
 close_observer . Wait ( ) ;
 EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;
 EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;
 if ( browser_defaults : : kBrowserAliveWithNoWindows ) EXPECT_EQ ( 1 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;
 else EXPECT_EQ ( 0 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"void remoteDispatchAuthError ( remote_error * rerr ) {
 remoteDispatchStringError ( rerr , VIR_ERR_AUTH_FAILED , ""authentication failed"" ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int get_gf_active_quality ( const RATE_CONTROL * const rc , int q ) {
 return get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , arfgf_low_motion_minq , arfgf_high_motion_minq ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"IN_PROC_BROWSER_TEST_F ( UnloadTest , CrossSiteInfiniteUnloadAsync ) {
 if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;
 NavigateToDataURL ( INFINITE_UNLOAD_HTML , ""infiniteunload"" ) ;
 NavigateToNolistenersFileTwiceAsync ( ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void dissect_zcl_groups_view_group_response ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {
 guint attr_uint ;
 guint8 * attr_string ;
 proto_tree_add_item ( tree , hf_zbee_zcl_groups_status , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;
 * offset += 1 ;
 proto_tree_add_item ( tree , hf_zbee_zcl_groups_group_id , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;
 * offset += 2 ;
 attr_uint = tvb_get_guint8 ( tvb , * offset ) ;
 if ( attr_uint == 0xff ) attr_uint = 0 ;
 proto_tree_add_uint ( tree , hf_zbee_zcl_groups_attr_str_len , tvb , * offset , 1 , attr_uint ) ;
 * offset += 1 ;
 attr_string = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , * offset , attr_uint , ENC_ASCII ) ;
 proto_item_append_text ( tree , "", String: %s"" , attr_string ) ;
 proto_tree_add_string ( tree , hf_zbee_zcl_groups_attr_str , tvb , * offset , attr_uint , attr_string ) ;
 * offset += attr_uint ;
 }",0
Detect whether the following code contains vulnerabilities.,"void vp9_lpf_vertical_4_dual_sse2 ( uint8_t * s , int p , const uint8_t * blimit0 , const uint8_t * limit0 , const uint8_t * thresh0 , const uint8_t * blimit1 , const uint8_t * limit1 , const uint8_t * thresh1 ) {
 DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 16 * 8 ) ;
 unsigned char * src [ 2 ] ;
 unsigned char * dst [ 2 ] ;
 transpose8x16 ( s - 4 , s - 4 + p * 8 , p , t_dst , 16 ) ;
 vp9_lpf_horizontal_4_dual_sse2 ( t_dst + 4 * 16 , 16 , blimit0 , limit0 , thresh0 , blimit1 , limit1 , thresh1 ) ;
 src [ 0 ] = t_dst ;
 src [ 1 ] = t_dst + 8 ;
 dst [ 0 ] = s - 4 ;
 dst [ 1 ] = s - 4 + p * 8 ;
 transpose ( src , 16 , dst , p , 2 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_inet_sys_rcv_skb ( struct net * ns , int ifindex , char * addrp , u16 family , u32 peer_sid , struct common_audit_data * ad ) {
 int err ;
 u32 if_sid ;
 u32 node_sid ;
 err = sel_netif_sid ( ns , ifindex , & if_sid ) ;
 if ( err ) return err ;
 err = avc_has_perm ( peer_sid , if_sid , SECCLASS_NETIF , NETIF__INGRESS , ad ) ;
 if ( err ) return err ;
 err = sel_netnode_sid ( addrp , family , & node_sid ) ;
 if ( err ) return err ;
 return avc_has_perm ( peer_sid , node_sid , SECCLASS_NODE , NODE__RECVFROM , ad ) ;
 }",0
Detect whether the following code contains vulnerabilities.,"static void ps2_common_post_load ( PS2State * s ) {
 PS2Queue * q = & s -> queue ;
 int size ;
 int i ;
 int tmp_data [ PS2_QUEUE_SIZE ] ;
 size = q -> count > PS2_QUEUE_SIZE ? 0 : q -> count ;
 if ( size > 0 ) {
 for ( i = 0 ;
 i < size ;
 i ++ ) {
 tmp_data [ i ] = q -> data [ q -> rptr ] ;
 if ( ++ q -> rptr == 256 ) {
 q -> rptr = 0 ;
 }
 }
 memcpy ( q -> data , tmp_data , size ) ;
 }
 q -> rptr = 0 ;
 q -> wptr = size ;
 q -> count = size ;
 s -> update_irq ( s -> update_arg , q -> count != 0 ) ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline void copy_backptr ( LZOContext * c , int back , int cnt ) {
 register uint8_t * dst = c -> out ;
 if ( dst - c -> out_start < back ) {
 c -> error |= AV_LZO_INVALID_BACKPTR ;
 return ;
 }
 if ( cnt > c -> out_end - dst ) {
 cnt = FFMAX ( c -> out_end - dst , 0 ) ;
 c -> error |= AV_LZO_OUTPUT_FULL ;
 }
 av_memcpy_backptr ( dst , back , cnt ) ;
 c -> out = dst + cnt ;
 }",1
Detect whether the following code contains vulnerabilities.,"int qemuMonitorJSONSetCapabilities ( qemuMonitorPtr mon ) {
 int ret ;
 virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( ""qmp_capabilities"" , NULL ) ;
 virJSONValuePtr reply = NULL ;
 if ( ! cmd ) return - 1 ;
 ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;
 if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;
 virJSONValueFree ( cmd ) ;
 virJSONValueFree ( reply ) ;
 return ret ;
 }",0
Detect whether the following code contains vulnerabilities.,"static int32_t U_CALLCONV compareFallbacks ( const void * context , const void * fb1 , const void * fb2 ) {
 ( void ) context ;
 return ( ( const _MBCSToUFallback * ) fb1 ) -> offset - ( ( const _MBCSToUFallback * ) fb2 ) -> offset ;
 }",0
Detect whether the following code contains vulnerabilities.,"static UChar32 _ASCIIGetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {
 const uint8_t * source ;
 uint8_t b ;
 source = ( const uint8_t * ) pArgs -> source ;
 if ( source < ( const uint8_t * ) pArgs -> sourceLimit ) {
 b = * source ++ ;
 pArgs -> source = ( const char * ) source ;
 if ( b <= 0x7f ) {
 return b ;
 }
 else {
 UConverter * cnv = pArgs -> converter ;
 cnv -> toUBytes [ 0 ] = b ;
 cnv -> toULength = 1 ;
 * pErrorCode = U_ILLEGAL_CHAR_FOUND ;
 return 0xffff ;
 }
 }
 * pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR ;
 return 0xffff ;
 }",1
Detect whether the following code contains vulnerabilities.,"static void free_mi ( VP9_COMMON * cm ) {
 int i ;
 for ( i = 0 ;
 i < 2 ;
 ++ i ) {
 vpx_free ( cm -> mip_array [ i ] ) ;
 cm -> mip_array [ i ] = NULL ;
 vpx_free ( cm -> mi_grid_base_array [ i ] ) ;
 cm -> mi_grid_base_array [ i ] = NULL ;
 }
 cm -> mip = NULL ;
 cm -> prev_mip = NULL ;
 cm -> mi_grid_base = NULL ;
 cm -> prev_mi_grid_base = NULL ;
 }",1
Detect whether the following code contains vulnerabilities.,"static inline int get_scale ( GetBitContext * gb , int level , int value , int log2range ) {
 if ( level < 5 ) {
 value += get_bitalloc ( gb , & dca_scalefactor , level ) ;
 value = av_clip ( value , 0 , ( 1 << log2range ) - 1 ) ;
 }
 else if ( level < 8 ) {
 if ( level + 1 > log2range ) {
 skip_bits ( gb , level + 1 - log2range ) ;
 value = get_bits ( gb , log2range ) ;
 }
 else {
 value = get_bits ( gb , level + 1 ) ;
 }
 }
 return value ;
 }",0
