instruction,input,output
Detect whether the following code contains vulnerabilities.,"flatpak_context_features_to_string (FlatpakContextFeatures features, FlatpakContextFeatures valid)
{
  return flatpak_context_bitmask_to_string (features, valid, flatpak_context_features);
}",0
Detect whether the following code contains vulnerabilities.,"static void mov_text_cleanup_ftab(MovTextContext *m)

{

    int i;

    for(i = 0; i < m->count_f; i++) {

        av_freep(&m->ftab[i]->font);

        av_freep(&m->ftab[i]);

    }

    av_freep(&m->ftab);

}
",1
Detect whether the following code contains vulnerabilities.,"GF_Err hmhd_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_HintMediaHeaderBox *ptr = (GF_HintMediaHeaderBox *)s;

	ISOM_DECREASE_SIZE(ptr, 16);
	ptr->maxPDUSize = gf_bs_read_u16(bs);
	ptr->avgPDUSize = gf_bs_read_u16(bs);
	ptr->maxBitrate = gf_bs_read_u32(bs);
	ptr->avgBitrate = gf_bs_read_u32(bs);
	ptr->slidingAverageBitrate = gf_bs_read_u32(bs);
	return GF_OK;
}",0
Detect whether the following code contains vulnerabilities.,"TEST_P(Http2MetadataIntegrationTest, DecodingHeadersOnlyRequestWithRequestMetadataEmptyData) {
  addFilters({request_metadata_filter, decode_headers_only});

  // Send a request with body, and body size is 0.
  runHeaderOnlyTest(true, 0);
  verifyHeadersOnlyTest();
}",0
Detect whether the following code contains vulnerabilities.,"gnutls_handshake_set_hook_function(gnutls_session_t session,
				   unsigned int htype,
				   int when,
				   gnutls_handshake_hook_func func)
{
	session->internals.h_hook = func;
	session->internals.h_type = htype;
	session->internals.h_post = when;
}",0
Detect whether the following code contains vulnerabilities.,"void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
                                          const char *name,
                                          uint64_t ram_size)
{
    uint64_t addr = 0;
    int i;
    if (nb_numa_nodes == 0 || !have_memdevs) {
        allocate_system_memory_nonnuma(mr, owner, name, ram_size);
        return;
    memory_region_init(mr, owner, name, ram_size);
    for (i = 0; i < MAX_NODES; i++) {
        Error *local_err = NULL;
        uint64_t size = numa_info[i].node_mem;
        HostMemoryBackend *backend = numa_info[i].node_memdev;
        if (!backend) {
            continue;
        MemoryRegion *seg = host_memory_backend_get_memory(backend, &local_err);
        if (local_err) {
            qerror_report_err(local_err);
        memory_region_add_subregion(mr, addr, seg);
        vmstate_register_ram_global(seg);
        addr += size;",1
Detect whether the following code contains vulnerabilities.,"static void qemu_rbd_close(BlockDriverState *bs)

{

    BDRVRBDState *s = bs->opaque;



    close(s->fds[0]);

    close(s->fds[1]);

    qemu_aio_set_fd_handler(s->fds[RBD_FD_READ], NULL, NULL, NULL);



    rbd_close(s->image);

    rados_ioctx_destroy(s->io_ctx);

    g_free(s->snap);

    rados_shutdown(s->cluster);

}
",1
Detect whether the following code contains vulnerabilities.,"static int ism_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    SmoothStreamingContext *c = s->priv_data;

    AVStream *st = s->streams[pkt->stream_index];

    OutputStream *os = &c->streams[pkt->stream_index];

    int64_t end_dts = (c->nb_fragments + 1) * c->min_frag_duration;

    int ret;



    if (st->first_dts == AV_NOPTS_VALUE)

        st->first_dts = pkt->dts;



    if ((!c->has_video || st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&

        av_compare_ts(pkt->dts - st->first_dts, st->time_base,

                      end_dts, AV_TIME_BASE_Q) >= 0 &&

        pkt->flags & AV_PKT_FLAG_KEY && os->packets_written) {



        if ((ret = ism_flush(s, 0)) < 0)

            return ret;

        c->nb_fragments++;

    }



    os->packets_written++;

    return ff_write_chained(os->ctx, 0, pkt, s);

}
",1
Detect whether the following code contains vulnerabilities.,"    X509_LOOKUP* X509_STORE_add_lookup(X509_STORE*, X509_LOOKUP_METHOD*)
    {
        // TODO:
        return 0;
    }",0
Detect whether the following code contains vulnerabilities.,"static u32 __ipv6_select_ident(struct net *net,
			       const struct in6_addr *dst,
			       const struct in6_addr *src)
{
	const struct {
		struct in6_addr dst;
		struct in6_addr src;
	} __aligned(SIPHASH_ALIGNMENT) combined = {
		.dst = *dst,
		.src = *src,
	};
	u32 hash, id;

	/* Note the following code is not safe, but this is okay. */
	if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))
		get_random_bytes(&net->ipv4.ip_id_key,
				 sizeof(net->ipv4.ip_id_key));

	hash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);

	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
	 * set the hight order instead thus minimizing possible future
	 * collisions.
	 */
	id = ip_idents_reserve(hash, 1);
	if (unlikely(!id))
		id = 1 << 31;

	return id;
}",1
Detect whether the following code contains vulnerabilities.,"static int cd_read_sector(IDEState *s, int lba, uint8_t *buf, int sector_size)

{

    int ret;



    switch(sector_size) {

    case 2048:

        block_acct_start(blk_get_stats(s->blk), &s->acct,

                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);

        ret = blk_read(s->blk, (int64_t)lba << 2, buf, 4);

        block_acct_done(blk_get_stats(s->blk), &s->acct);

        break;

    case 2352:

        block_acct_start(blk_get_stats(s->blk), &s->acct,

                         4 * BDRV_SECTOR_SIZE, BLOCK_ACCT_READ);

        ret = blk_read(s->blk, (int64_t)lba << 2, buf + 16, 4);

        block_acct_done(blk_get_stats(s->blk), &s->acct);

        if (ret < 0)

            return ret;

        cd_data_to_raw(buf, lba);

        break;

    default:

        ret = -EIO;

        break;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"void OPPROTO op_check_addo (void)

{

    if (likely(!(((uint32_t)T2 ^ (uint32_t)T1 ^ UINT32_MAX) &

                 ((uint32_t)T2 ^ (uint32_t)T0) & (1UL << 31)))) {

        xer_ov = 0;

    } else {

        xer_so = 1;

        xer_ov = 1;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"netscreen_seek_read(wtap *wth, gint64 seek_off,
	struct wtap_pkthdr *phdr, Buffer *buf,
	int *err, gchar **err_info)
{
	int		pkt_len;
	char		line[NETSCREEN_LINE_LENGTH];
	char		cap_int[NETSCREEN_MAX_INT_NAME_LENGTH];
	gboolean	cap_dir;
	char		cap_dst[13];

	if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {
		return FALSE;
	}

	if (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {
		*err = file_error(wth->random_fh, err_info);
		if (*err == 0) {
			*err = WTAP_ERR_SHORT_READ;
		}
		return FALSE;
	}

	pkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,
	    cap_dst, err, err_info);
	if (pkt_len == -1)
		return FALSE;

	if (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,
	    cap_dst, phdr, buf, err, err_info))
		return FALSE;
	return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"static void cms_env_set_version(CMS_EnvelopedData *env)
{
    int i;
    CMS_RecipientInfo *ri;

    /*
     * Can't set version higher than 4 so if 4 or more already nothing to do.
     */
    if (env->version >= 4)
        return;

    cms_env_set_originfo_version(env);

    if (env->version >= 3)
        return;

    for (i = 0; i < sk_CMS_RecipientInfo_num(env->recipientInfos); i++) {
        ri = sk_CMS_RecipientInfo_value(env->recipientInfos, i);
        if (ri->type == CMS_RECIPINFO_PASS || ri->type == CMS_RECIPINFO_OTHER) {
            env->version = 3;
            return;
        } else if (ri->type != CMS_RECIPINFO_TRANS
                   || ri->d.ktri->version != 0) {
            env->version = 2;
        }
    }
    if (env->version == 2)
        return;
    if (env->originatorInfo || env->unprotectedAttrs)
        env->version = 2;
    env->version = 0;
}",0
Detect whether the following code contains vulnerabilities.,"void list_proxy(char *server, void *data __attribute__((unused)), void *rock)
{
    struct enum_rock *erock = (struct enum_rock *) rock;
    struct backend *be;
    int r;
    char *result;

    be = proxy_findserver(server, &nntp_protocol,
			  nntp_userid ? nntp_userid : ""anonymous"",
			  &backend_cached, &backend_current, NULL, nntp_in);
    if (!be) return;

    prot_printf(be->out, ""LIST %s %s\r\n"", erock->cmd, erock->wild);

    r = read_response(be, 0, &result);
    if (!r && !strncmp(result, ""215 "", 4)) {
	while (!(r = read_response(be, 0, &result)) && result[0] != '.') {
	    prot_printf(nntp_out, ""%s"", result);
	}
    }
}",1
Detect whether the following code contains vulnerabilities.,"int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock)
{
# ifdef USE_RWLOCK
    if (pthread_rwlock_wrlock(lock) != 0)
        return 0;
# else
    if (pthread_mutex_lock(lock) != 0)
        return 0;
# endif

    return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static void flush_trace_file(void)

{

    /* If the trace file is not open yet, open it now */

    if (!trace_fp) {

        trace_fp = fopen(trace_file_name, ""w"");

        if (!trace_fp) {

            /* Avoid repeatedly trying to open file on failure */

            trace_file_enabled = false;

            return;

        }

        write_header(trace_fp);

    }



    if (trace_fp) {

        size_t unused; /* for when fwrite(3) is declared warn_unused_result */

        unused = fwrite(trace_buf, trace_idx * sizeof(trace_buf[0]), 1, trace_fp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    {
        xReturn = pdTRUE;
    }
    else
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */",0
Detect whether the following code contains vulnerabilities.,"static inline int copy_kernel_to_xregs_err(struct xregs_state *xstate, u64 mask)
{
	u32 lmask = mask;
	u32 hmask = mask >> 32;
	int err;

	XSTATE_OP(XRSTOR, xstate, lmask, hmask, err);

	return err;
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t virtio_balloon_get_features(VirtIODevice *vdev)

{

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void hci_le_ext_adv_report_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_ext_adv_report *ev = ptr;
		u8 legacy_evt_type;
		u16 evt_type;

		evt_type = __le16_to_cpu(ev->evt_type);
		legacy_evt_type = ext_evt_type_to_legacy(hdev, evt_type);
		if (legacy_evt_type != LE_ADV_INVALID) {
			process_adv_report(hdev, legacy_evt_type, &ev->bdaddr,
					   ev->bdaddr_type, NULL, 0, ev->rssi,
					   ev->data, ev->length);
		}

		ptr += sizeof(*ev) + ev->length;
	}

	hci_dev_unlock(hdev);
}",1
Detect whether the following code contains vulnerabilities.,"static int v9fs_synth_unlinkat(FsContext *ctx, V9fsPath *dir,

                               const char *name, int flags)

{

    errno = EPERM;

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qmp_output_type_null(Visitor *v, const char *name, Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add_obj(qov, name, qnull());

}
",0
Detect whether the following code contains vulnerabilities.,"BalloonInfo *qmp_query_balloon(Error **errp)

{

    BalloonInfo *info;



    if (kvm_enabled() && !kvm_has_sync_mmu()) {

        error_set(errp, QERR_KVM_MISSING_CAP, ""synchronous MMU"", ""balloon"");

        return NULL;

    }



    info = g_malloc0(sizeof(*info));



    if (qemu_balloon_status(info) == 0) {

        error_set(errp, QERR_DEVICE_NOT_ACTIVE, ""balloon"");

        qapi_free_BalloonInfo(info);

        return NULL;

    }



    return info;

}
",0
Detect whether the following code contains vulnerabilities.,"static void readCoord(u8 *p, RtreeCoord *pCoord){
  assert( ((((char*)p) - (char*)0)&3)==0 );  /* p is always 4-byte aligned */
#if SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
  pCoord->u = _byteswap_ulong(*(u32*)p);
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
  pCoord->u = __builtin_bswap32(*(u32*)p);
#elif SQLITE_BYTEORDER==4321
  pCoord->u = *(u32*)p;
#else
  pCoord->u = (
    (((u32)p[0]) << 24) + 
    (((u32)p[1]) << 16) + 
    (((u32)p[2]) <<  8) + 
    (((u32)p[3]) <<  0)
  );
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static void fw_cfg_data_mem_write(void *opaque, target_phys_addr_t addr,

                                  uint64_t value, unsigned size)

{

    fw_cfg_write(opaque, (uint8_t)value);

}
",0
Detect whether the following code contains vulnerabilities.,"void cleanup(void)
{
#if defined(JAS_USE_JAS_INIT)
	jas_cleanup();
#else
	jas_cleanup_thread();
	jas_cleanup_library();
#endif
}",0
Detect whether the following code contains vulnerabilities.,"int qemu_timeout_ns_to_ms(int64_t ns)

{

    int64_t ms;

    if (ns < 0) {

        return -1;

    }



    if (!ns) {

        return 0;

    }



    /* Always round up, because it's better to wait too long than to wait too

     * little and effectively busy-wait

     */

    ms = DIV_ROUND_UP(ns, SCALE_MS);



    /* To avoid overflow problems, limit this to 2^31, i.e. approx 25 days */

    if (ms > (int64_t) INT32_MAX) {

        ms = INT32_MAX;

    }



    return (int) ms;

}
",0
Detect whether the following code contains vulnerabilities.,"    if (ret == WS_SUCCESS) {
        WMEMSET((byte*)&fd, 0, sizeof(HANDLE));
        WMEMCPY((byte*)&fd, data + idx, sz);
        idx += sz;

        /* get offset into file */
        WMEMSET(&offset, 0, sizeof(OVERLAPPED));
        ato32(data + idx, &sz);
        idx += UINT32_SZ;
        offset.OffsetHigh = (DWORD)sz;
        ato32(data + idx, &sz);
        idx += UINT32_SZ;
        offset.Offset = (DWORD)sz;

        /* get length to be written */
        ato32(data + idx, &sz);
        idx += UINT32_SZ;

        if (WriteFile(fd, data + idx, sz, &bytesWritten, &offset) == 0) {
            WLOG(WS_LOG_SFTP, ""Error writing to file"");
            res  = err;
            type = WOLFSSH_FTP_FAILURE;
            ret  = WS_INVALID_STATE_E;
        }
        else {
            ret = WS_SUCCESS;
        }
    }",1
Detect whether the following code contains vulnerabilities.,"  void Compute(OpKernelContext* ctx) override {
    const Tensor& input = ctx->input(0);
    const float input_min_float = ctx->input(1).flat<float>()(0);
    const float input_max_float = ctx->input(2).flat<float>()(0);
    Tensor* output_min = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));
    Tensor* output_max = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));

    qint32 used_min_quantized;
    qint32 used_max_quantized;
    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);

    // We want to make sure that the minimum is no larger than zero, so that the
    // convolution operation can run efficiently.
    const float used_min_float = std::min(
        0.0f,
        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));
    const float used_max_float =
        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);

    output_min->flat<float>().setConstant(used_min_float);
    output_max->flat<float>().setConstant(used_max_float);
  }",1
Detect whether the following code contains vulnerabilities.,"ofputil_uninit_group_mod(struct ofputil_group_mod *gm)
{
    ofputil_bucket_list_destroy(&gm->buckets);
    ofputil_group_properties_destroy(&gm->props);
}",0
Detect whether the following code contains vulnerabilities.,"static int webm_dash_manifest_write_trailer(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    int i;

    for (i = 0; i < w->nb_as; i++) {

        av_freep(&w->as[i].streams);

    }

    av_freep(&w->as);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)
{
  size_t
    extent;

  if (CheckMemoryOverflow(count,quantum) != MagickFalse)
    return((void *) NULL);
  extent=count*quantum;
  return(AcquireMagickMemory(extent));
}",1
Detect whether the following code contains vulnerabilities.,"  Tracing::Reason getTraceReason(const Http::RequestHeaderMap&) override {
    return Tracing::Reason::Sampling;
  }",0
Detect whether the following code contains vulnerabilities.,"void cpu_watchpoint_remove_by_ref(CPUState *env, CPUWatchpoint *watchpoint)

{

    TAILQ_REMOVE(&env->watchpoints, watchpoint, entry);



    tlb_flush_page(env, watchpoint->vaddr);



    qemu_free(watchpoint);

}
",0
Detect whether the following code contains vulnerabilities.,"static int stbi__hdr_test(stbi__context* s)
{
   int r = stbi__hdr_test_core(s, ""#?RADIANCE\n"");
   stbi__rewind(s);
   if(!r) {
       r = stbi__hdr_test_core(s, ""#?RGBE\n"");
       stbi__rewind(s);
   }
   return r;
}",0
Detect whether the following code contains vulnerabilities.,"wait_for_single_pid (pid)
     pid_t pid;
{
  pid_t got_pid;
  WAIT status;
  int pstatus, flags;

  pstatus = find_status_by_pid (pid);

  if (pstatus == PROC_BAD)
    {
      internal_error (_(""wait: pid %ld is not a child of this shell""), (long)pid);
      return (127);
    }

  if (pstatus != PROC_STILL_ALIVE)
    {
      if (pstatus > 128)
	last_command_exit_signal = find_termsig_by_pid (pid);
      return (pstatus);
    }

  siginterrupt (SIGINT, 1);
  while ((got_pid = WAITPID (pid, &status, 0)) != pid)
    {
      CHECK_TERMSIG;
      CHECK_WAIT_INTR;
      if (got_pid < 0)
	{
	  if (errno != EINTR && errno != ECHILD)
	    {
	      siginterrupt (SIGINT, 0);
	      sys_error (""wait"");
	    }
	  break;
	}
      else if (got_pid > 0)
	set_pid_status (got_pid, status);
    }

  if (got_pid > 0)
    {
      set_pid_status (got_pid, status);
      set_pid_flags (got_pid, PROC_NOTIFIED);
    }

  siginterrupt (SIGINT, 0);
  QUIT;

  return (got_pid > 0 ? process_exit_status (status) : -1);
}",1
Detect whether the following code contains vulnerabilities.,"int kvm_irqchip_remove_irqfd(KVMState *s, int fd, int virq)

{

    return -ENOSYS;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qdict_do_flatten(QDict *qdict, QDict *target, const char *prefix)

{

    QObject *value;

    const QDictEntry *entry, *next;

    const char *new_key;

    bool delete;



    entry = qdict_first(qdict);



    while (entry != NULL) {



        next = qdict_next(qdict, entry);

        value = qdict_entry_value(entry);

        new_key = NULL;

        delete = false;



        if (prefix) {

            qobject_incref(value);

            new_key = g_strdup_printf(""%s.%s"", prefix, entry->key);

            qdict_put_obj(target, new_key, value);

            delete = true;

        }



        if (qobject_type(value) == QTYPE_QDICT) {

            qdict_do_flatten(qobject_to_qdict(value), target,

                             new_key ? new_key : entry->key);

            delete = true;

        }



        if (delete) {

            qdict_del(qdict, entry->key);



            /* Restart loop after modifying the iterated QDict */

            entry = qdict_first(qdict);

            continue;

        }



        entry = next;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void destroy_con_cq_qp(struct rtrs_clt_con *con)
{
	struct rtrs_clt_path *clt_path = to_clt_path(con->c.path);

	/*
	 * Be careful here: destroy_con_cq_qp() can be called even
	 * create_con_cq_qp() failed, see comments there.
	 */
	lockdep_assert_held(&con->con_mutex);
	rtrs_cq_qp_destroy(&con->c);
	if (con->rsp_ius) {
		rtrs_iu_free(con->rsp_ius, clt_path->s.dev->ib_dev,
			     con->queue_num);
		con->rsp_ius = NULL;
		con->queue_num = 0;
	}
	if (clt_path->s.dev_ref && !--clt_path->s.dev_ref) {
		rtrs_ib_dev_put(clt_path->s.dev);
		clt_path->s.dev = NULL;
	}
}",0
Detect whether the following code contains vulnerabilities.,"static void vhost_commit(MemoryListener *listener)

{

}
",1
Detect whether the following code contains vulnerabilities.,"void get_xsrf_token(const char *username, const char *pass,
		    const char *formname, time_t xsrf_time, char token_str[33])
{
	MD5_CTX md5_ctx;
	uint8_t token[16];
	int i;

	token_str[0] = '\0';
	ZERO_STRUCT(md5_ctx);
	MD5Init(&md5_ctx);

	MD5Update(&md5_ctx, (uint8_t *)formname, strlen(formname));
	MD5Update(&md5_ctx, (uint8_t *)&xsrf_time, sizeof(time_t));
	if (username != NULL) {
		MD5Update(&md5_ctx, (uint8_t *)username, strlen(username));
	}
	if (pass != NULL) {
		MD5Update(&md5_ctx, (uint8_t *)pass, strlen(pass));
	}

	MD5Final(token, &md5_ctx);

	for(i = 0; i < sizeof(token); i++) {
		char tmp[3];

		snprintf(tmp, sizeof(tmp), ""%02x"", token[i]);
		strlcat(token_str, tmp, sizeof(tmp));
	}
}",1
Detect whether the following code contains vulnerabilities.,"static int uio_mmap_physical(struct vm_area_struct *vma)
{
	struct uio_device *idev = vma->vm_private_data;
	int mi = uio_find_mem_index(vma);
	if (mi < 0)
		return -EINVAL;

	vma->vm_ops = &uio_physical_vm_ops;

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);

	return remap_pfn_range(vma,
			       vma->vm_start,
			       idev->info->mem[mi].addr >> PAGE_SHIFT,
			       vma->vm_end - vma->vm_start,
			       vma->vm_page_prot);
}",1
Detect whether the following code contains vulnerabilities.,"u32reset ()
{
  u32init = 0;
  utf8locale = 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void _db_level_get(struct db_arg_chain_tree *node)
{
	struct db_arg_chain_tree *iter = node;

	while (iter->lvl_prv != NULL)
		iter = iter->lvl_prv;

	while (iter) {
		_db_tree_get(iter);
		iter = iter->lvl_nxt;
	}
}",1
Detect whether the following code contains vulnerabilities.,"QPDF::parse_xrefFirst(std::string const& line,
                      int& obj, int& num, int& bytes)
{
    // is_space and is_digit both return false on '\0', so this will
    // not overrun the null-terminated buffer.
    char const* p = line.c_str();
    char const* start = line.c_str();

    // Skip zero or more spaces
    while (QUtil::is_space(*p))
    {
        ++p;
    }
    // Require digit
    if (! QUtil::is_digit(*p))
    {
        return false;
    }
    // Gather digits
    std::string obj_str;
    while (QUtil::is_digit(*p))
    {
        obj_str.append(1, *p++);
    }
    // Require space
    if (! QUtil::is_space(*p))
    {
        return false;
    }
    // Skip spaces
    while (QUtil::is_space(*p))
    {
        ++p;
    }
    // Require digit
    if (! QUtil::is_digit(*p))
    {
        return false;
    }
    // Gather digits
    std::string num_str;
    while (QUtil::is_digit(*p))
    {
        num_str.append(1, *p++);
    }
    // Skip any space including line terminators
    while (QUtil::is_space(*p))
    {
        ++p;
    }
    bytes = p - start;
    obj = QUtil::string_to_int(obj_str.c_str());
    num = QUtil::string_to_int(num_str.c_str());
    return true;
}",1
Detect whether the following code contains vulnerabilities.,"void migrate_compress_threads_create(void)

{

    int i, thread_count;



    if (!migrate_use_compression()) {

        return;

    }

    quit_comp_thread = false;

    compression_switch = true;

    thread_count = migrate_compress_threads();

    compress_threads = g_new0(QemuThread, thread_count);

    comp_param = g_new0(CompressParam, thread_count);

    comp_done_cond = g_new0(QemuCond, 1);

    comp_done_lock = g_new0(QemuMutex, 1);

    qemu_cond_init(comp_done_cond);

    qemu_mutex_init(comp_done_lock);

    for (i = 0; i < thread_count; i++) {

        /* com_param[i].file is just used as a dummy buffer to save data, set

         * it's ops to empty.

         */

        comp_param[i].file = qemu_fopen_ops(NULL, &empty_ops);

        comp_param[i].done = true;

        qemu_mutex_init(&comp_param[i].mutex);

        qemu_cond_init(&comp_param[i].cond);

        qemu_thread_create(compress_threads + i, ""compress"",

                           do_data_compress, comp_param + i,

                           QEMU_THREAD_JOINABLE);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"const char* RtmpProtocol::handle_S0S1S2(const char *data, size_t len, const function<void()> &func) {
    if (len < 1 + 2 * C1_HANDSHARK_SIZE) {
        //数据不够
        return nullptr;
    }
    if (data[0] != HANDSHAKE_PLAINTEXT) {
        throw std::runtime_error(""only plaintext[0x03] handshake supported"");
    }
    //发送 C2
    const char *pcC2 = data + 1;
    onSendRawData(obtainBuffer(pcC2, C1_HANDSHARK_SIZE));
    //握手结束
    _next_step_func = [this](const char *data, size_t len) {
        //握手结束并且开始进入解析命令模式
        return handle_rtmp(data, len);
    };
    func();
    return data + 1 + 2 * C1_HANDSHARK_SIZE;
}",0
Detect whether the following code contains vulnerabilities.,"static void eepro100_write(void *opaque, target_phys_addr_t addr,

                           uint64_t data, unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1:

        eepro100_write1(s, addr, data);

        break;

    case 2:

        eepro100_write2(s, addr, data);

        break;

    case 4:

        eepro100_write4(s, addr, data);

        break;

    default:

        abort();

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_change(const char *device, const char *target)

{

    if (strcmp(device, ""vnc"") == 0) {

	do_change_vnc(target);

    } else {

	do_change_block(device, target);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void free_input_threads(void)

{

    int i;



    if (nb_input_files == 1)

        return;



    transcoding_finished = 1;



    for (i = 0; i < nb_input_files; i++) {

        InputFile *f = input_files[i];

        AVPacket pkt;



        if (f->joined)

            continue;



        pthread_mutex_lock(&f->fifo_lock);

        while (av_fifo_size(f->fifo)) {

            av_fifo_generic_read(f->fifo, &pkt, sizeof(pkt), NULL);

            av_free_packet(&pkt);

        }

        pthread_cond_signal(&f->fifo_cond);

        pthread_mutex_unlock(&f->fifo_lock);



        pthread_join(f->thread, NULL);

        f->joined = 1;



        while (av_fifo_size(f->fifo)) {

            av_fifo_generic_read(f->fifo, &pkt, sizeof(pkt), NULL);

            av_free_packet(&pkt);

        }

        av_fifo_free(f->fifo);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);
}",1
Detect whether the following code contains vulnerabilities.,"static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,
                                          unsigned char *buf, int idx,
                                          int width)
{
    size_t i, j;

    if (bn_wexpand(b, top) == NULL)
        return 0;

    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {
        ((unsigned char *)b->d)[i] = buf[j];
    }

    b->top = top;
    bn_correct_top(b);
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"apr_byte_t oidc_util_spaced_string_equals(apr_pool_t *pool, const char *a,
		const char *b) {

	/* parse both entries as hash tables */
	apr_hash_t *ht_a = oidc_util_spaced_string_to_hashtable(pool, a);
	apr_hash_t *ht_b = oidc_util_spaced_string_to_hashtable(pool, b);

	/* first compare the length of both response_types */
	if (apr_hash_count(ht_a) != apr_hash_count(ht_b))
		return FALSE;

	/* then loop over all entries */
	apr_hash_index_t *hi;
	for (hi = apr_hash_first(NULL, ht_a); hi; hi = apr_hash_next(hi)) {
		const char *k;
		const char *v;
		apr_hash_this(hi, (const void**) &k, NULL, (void**) &v);
		if (apr_hash_get(ht_b, k, APR_HASH_KEY_STRING) == NULL)
			return FALSE;
	}

	/* if we've made it this far, a an b are equal in length and every element in a is in b */
	return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"dwg_section_wtype (const DWGCHAR *restrict wname)
{
  DWGCHAR *wp;
  char name[24];
  uint16_t c;
  int i = 0;

  if (wname == NULL)
    return SECTION_UNKNOWN; // but could also be INFO or SYSTEM_MAP
  wp = (DWGCHAR *)wname;
  while ((c = *wp++))
    {
      name[i++] = (char)(c & 0xff);
      if (i >= 24)
        return SECTION_UNKNOWN;
    }
  name[i] = '\0';
  return dwg_section_type (name);
}",0
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel16_mc23_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midv_qrt_16w_msa(src - (2 * stride) - 2,

                              stride, dst, stride, 16, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_invoke_set_guest_debug(void *data)

{

    struct kvm_set_guest_debug_data *dbg_data = data;

    CPUState *env = dbg_data->env;



    if (env->kvm_vcpu_dirty) {

        kvm_arch_put_registers(env);

        env->kvm_vcpu_dirty = 0;

    }

    dbg_data->err = kvm_vcpu_ioctl(env, KVM_SET_GUEST_DEBUG, &dbg_data->dbg);

}
",1
Detect whether the following code contains vulnerabilities.,"parsediropres(netdissect_options *ndo,
              const uint32_t *dp)
{
	int er;

	if (!(dp = parsestatus(ndo, dp, &er)))
		return (0);
	if (er)
		return (1);

	dp = parsefh(ndo, dp, 0);
	if (dp == NULL)
		return (0);

	return (parsefattr(ndo, dp, ndo->ndo_vflag, 0) != NULL);
}",0
Detect whether the following code contains vulnerabilities.,"static struct pathelem *add_entry(struct pathelem *root, const char *name,

                                  unsigned type)

{

    struct pathelem **e;



    root->num_entries++;



    root = realloc(root, sizeof(*root)

                   + sizeof(root->entries[0])*root->num_entries);

    e = &root->entries[root->num_entries-1];



    *e = new_entry(root->pathname, root, name);

    if (is_dir_maybe(type)) {

        *e = add_dir_maybe(*e);

    }



    return root;

}
",1
Detect whether the following code contains vulnerabilities.,"static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_comp rpcomp;

	snprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""pcomp"");

	if (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,
		    sizeof(struct crypto_report_comp), &rpcomp))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}",1
Detect whether the following code contains vulnerabilities.,"char* problem_data_save(problem_data_t *pd)
{
    load_abrt_conf();

    struct dump_dir *dd = NULL;

    if (g_settings_privatereports)
        dd = create_dump_dir_from_problem_data_ext(pd, g_settings_dump_location, 0);
    else
        dd = create_dump_dir_from_problem_data(pd, g_settings_dump_location);

    char *problem_id = NULL;
    if (dd)
    {
        problem_id = xstrdup(dd->dd_dirname);
        dd_close(dd);
    }

    log_info(""problem id: '%s'"", problem_id);
    return problem_id;
}",0
Detect whether the following code contains vulnerabilities.,"static int decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t;



    if (total_freq == 0)

        return AVERROR_INVALIDDATA;



    t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"management_client_pf(void *arg,
                     const unsigned long cid,
                     struct buffer_list *pf_config)  /* ownership transferred */
{
    struct multi_context *m = (struct multi_context *) arg;
    struct multi_instance *mi = lookup_by_cid(m, cid);
    bool ret = false;

    if (mi && pf_config)
    {
        ret = pf_load_from_buffer_list(&mi->context, pf_config);
    }

    if (pf_config)
    {
        buffer_list_free(pf_config);
    }
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,

                              GArray *table_data, GArray *linker)

{

    GArray *structures = nvdimm_build_device_structure(device_list);

    void *header;



    acpi_add_table(table_offsets, table_data);



    /* NFIT header. */

    header = acpi_data_push(table_data, sizeof(NvdimmNfitHeader));

    /* NVDIMM device structures. */

    g_array_append_vals(table_data, structures->data, structures->len);



    build_header(linker, table_data, header, ""NFIT"",

                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL);

    g_array_free(structures, true);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t cmd646_data_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (size == 1) {

        return ide_ioport_read(cmd646bar->bus, addr);

    } else if (addr == 0) {

        if (size == 2) {

            return ide_data_readw(cmd646bar->bus, addr);

        } else {

            return ide_data_readl(cmd646bar->bus, addr);

        }

    }

    return ((uint64_t)1 << (size * 8)) - 1;

}
",0
Detect whether the following code contains vulnerabilities.,"int device_links_check_suppliers(struct device *dev)
{
	struct device_link *link;
	int ret = 0;

	/*
	 * Device waiting for supplier to become available is not allowed to
	 * probe.
	 */
	mutex_lock(&wfs_lock);
	if (!list_empty(&dev->links.needs_suppliers) &&
	    dev->links.need_for_probe) {
		mutex_unlock(&wfs_lock);
		return -EPROBE_DEFER;
	}
	mutex_unlock(&wfs_lock);

	device_links_write_lock();

	list_for_each_entry(link, &dev->links.suppliers, c_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		if (link->status != DL_STATE_AVAILABLE &&
		    !(link->flags & DL_FLAG_SYNC_STATE_ONLY)) {
			device_links_missing_supplier(dev);
			ret = -EPROBE_DEFER;
			break;
		}
		WRITE_ONCE(link->status, DL_STATE_CONSUMER_PROBE);
	}
	dev->links.status = DL_DEV_PROBING;

	device_links_write_unlock();
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"PPC_OP(test_ctrz_true)

{

    T0 = (regs->ctr == 0 && (T0 & PARAM(1)) != 0);

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)
{
	int i;
	rdpBitmapCache* bitmapCache;
	bitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));

	if (!bitmapCache)
		return NULL;

	bitmapCache->settings = settings;
	bitmapCache->update = ((freerdp*)settings->instance)->update;
	bitmapCache->context = bitmapCache->update->context;
	bitmapCache->cells =
	    (BITMAP_V2_CELL*)calloc(settings->BitmapCacheV2NumCells, sizeof(BITMAP_V2_CELL));

	if (!bitmapCache->cells)
		goto fail;
	bitmapCache->maxCells = settings->BitmapCacheV2NumCells;

	for (i = 0; i < (int)bitmapCache->maxCells; i++)
	{
		bitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;
		/* allocate an extra entry for BITMAP_CACHE_WAITING_LIST_INDEX */
		bitmapCache->cells[i].entries =
		    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));

		if (!bitmapCache->cells[i].entries)
			goto fail;
	}

	return bitmapCache;
fail:

	if (bitmapCache->cells)
	{
		for (i = 0; i < (int)bitmapCache->maxCells; i++)
			free(bitmapCache->cells[i].entries);
	}

	free(bitmapCache);
	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static int decode_attr_size(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *size)
{
	__be32 *p;
	int ret = 0;

	*size = 0;
	if (unlikely(bitmap[0] & (FATTR4_WORD0_SIZE - 1U)))
		return -EIO;
	if (likely(bitmap[0] & FATTR4_WORD0_SIZE)) {
		p = xdr_inline_decode(xdr, 8);
		if (unlikely(!p))
			return -EIO;
		xdr_decode_hyper(p, size);
		bitmap[0] &= ~FATTR4_WORD0_SIZE;
		ret = NFS_ATTR_FATTR_SIZE;
	}
	dprintk(""%s: file size=%Lu\n"", __func__, (unsigned long long)*size);
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"inline TfLiteIntArray* GetOutputShapeFromTensor(TfLiteContext* context,
                                                TfLiteNode* node) {
  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);

  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(shape->dims->data[0]);
  for (int i = 0; i < output_shape->size; ++i) {
    output_shape->data[i] = shape->data.i32[i];
  }

  return output_shape;
}",1
Detect whether the following code contains vulnerabilities.,"ofputil_encode_port_status(const struct ofputil_port_status *ps,
                           enum ofputil_protocol protocol)
{
    struct ofp_port_status *ops;
    struct ofpbuf *b;
    enum ofp_version version;
    enum ofpraw raw;

    version = ofputil_protocol_to_ofp_version(protocol);
    switch (version) {
    case OFP10_VERSION:
        raw = OFPRAW_OFPT10_PORT_STATUS;
        break;

    case OFP11_VERSION:
    case OFP12_VERSION:
    case OFP13_VERSION:
        raw = OFPRAW_OFPT11_PORT_STATUS;
        break;

    case OFP14_VERSION:
    case OFP15_VERSION:
        raw = OFPRAW_OFPT14_PORT_STATUS;
        break;

    case OFP16_VERSION:
        raw = OFPRAW_OFPT16_PORT_STATUS;
        break;

    default:
        OVS_NOT_REACHED();
    }

    b = ofpraw_alloc_xid(raw, version, htonl(0), 0);
    ops = ofpbuf_put_zeros(b, sizeof *ops);
    ops->reason = ps->reason;
    ofputil_put_phy_port(version, &ps->desc, b);
    ofpmsg_update_length(b);
    return b;
}",0
Detect whether the following code contains vulnerabilities.,"static void mkdir_recursive(char *name)
{
	/* if name has many levels (""dir1/dir2""),
	 * bb_make_directory() will create dir1 according to umask,
	 * not according to its ""mode"" parameter.
	 * Since we run with umask=0, need to temporarily switch it.
	 */
	umask(022); /* ""dir1"" (if any) will be 0755 too */
	bb_make_directory(name, 0755, FILEUTILS_RECUR);
	umask(0);
}",0
Detect whether the following code contains vulnerabilities.,"_archive_write_disk_data_block(struct archive *_a,
    const void *buff, size_t size, int64_t offset)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	ssize_t r;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_DATA, ""archive_write_data_block"");

	a->offset = offset;
	if (a->todo & TODO_HFS_COMPRESSION)
		r = hfs_write_data_block(a, buff, size);
	else
		r = write_data_block(a, buff, size);
	if (r < ARCHIVE_OK)
		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
	return (ARCHIVE_OK);
#else
	return (size);
#endif
}",0
Detect whether the following code contains vulnerabilities.,void Http2Handler::remove_self() { sessions_->remove_handler(this); },0
Detect whether the following code contains vulnerabilities.,"static int64_t guest_file_handle_add(FILE *fh, Error **errp)

{

    GuestFileHandle *gfh;

    int64_t handle;



    handle = ga_get_fd_handle(ga_state, errp);

    if (handle < 0) {

        return -1;

    }



    gfh = g_malloc0(sizeof(GuestFileHandle));

    gfh->id = handle;

    gfh->fh = fh;

    QTAILQ_INSERT_TAIL(&guest_file_state.filehandles, gfh, next);



    return handle;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool insn_crosses_page(CPUARMState *env, DisasContext *s)

{

    /* Return true if the insn at dc->pc might cross a page boundary.

     * (False positives are OK, false negatives are not.)

     */

    uint16_t insn;



    if ((s->pc & 3) == 0) {

        /* At a 4-aligned address we can't be crossing a page */

        return false;

    }



    /* This must be a Thumb insn */

    insn = arm_lduw_code(env, s->pc, s->sctlr_b);



    if ((insn >> 11) >= 0x1d) {

        /* Top five bits 0b11101 / 0b11110 / 0b11111 : this is the

         * First half of a 32-bit Thumb insn. Thumb-1 cores might

         * end up actually treating this as two 16-bit insns (see the

         * code at the start of disas_thumb2_insn()) but we don't bother

         * to check for that as it is unlikely, and false positives here

         * are harmless.

         */

        return true;

    }

    /* Definitely a 16-bit insn, can't be crossing a page. */

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool anal_bb_edge (RCore *core, const char *input) {
	// ""afbe"" switch-bb-addr case-bb-addr
	char *arg = strdup (r_str_trim_ro(input));
	char *sp = strchr (arg, ' ');
	if (sp) {
		*sp++ = 0;
		ut64 sw_at = r_num_math (core->num, arg);
		ut64 cs_at = r_num_math (core->num, sp);
		RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, sw_at, 0);
		if (fcn) {
			RAnalBlock *bb;
			RListIter *iter;
			r_list_foreach (fcn->bbs, iter, bb) {
				if (sw_at >= bb->addr && sw_at < (bb->addr + bb->size)) {
					if (!bb->switch_op) {
						bb->switch_op = r_anal_switch_op_new (
							sw_at, 0, 0);
					}
					r_anal_switch_op_add_case (bb->switch_op, cs_at, 0, cs_at);
				}
			}
			free (arg);
			return true;
		}
	}
	free (arg);
	return false;
}",0
Detect whether the following code contains vulnerabilities.,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MaxTextExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MaxTextExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}",0
Detect whether the following code contains vulnerabilities.,"int hfi1_mmu_rb_register(void *ops_arg, struct mm_struct *mm,
			 struct mmu_rb_ops *ops,
			 struct workqueue_struct *wq,
			 struct mmu_rb_handler **handler)
{
	struct mmu_rb_handler *handlr;
	int ret;

	handlr = kmalloc(sizeof(*handlr), GFP_KERNEL);
	if (!handlr)
		return -ENOMEM;

	handlr->root = RB_ROOT_CACHED;
	handlr->ops = ops;
	handlr->ops_arg = ops_arg;
	INIT_HLIST_NODE(&handlr->mn.hlist);
	spin_lock_init(&handlr->lock);
	handlr->mn.ops = &mn_opts;
	handlr->mm = mm;
	INIT_WORK(&handlr->del_work, handle_remove);
	INIT_LIST_HEAD(&handlr->del_list);
	INIT_LIST_HEAD(&handlr->lru_list);
	handlr->wq = wq;

	ret = mmu_notifier_register(&handlr->mn, handlr->mm);
	if (ret) {
		kfree(handlr);
		return ret;
	}

	*handler = handlr;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void kvm_mce_broadcast_rest(CPUState *env)

{

    CPUState *cenv;

    int family, model, cpuver = env->cpuid_version;



    family = (cpuver >> 8) & 0xf;

    model = ((cpuver >> 12) & 0xf0) + ((cpuver >> 4) & 0xf);



    /* Broadcast MCA signal for processor version 06H_EH and above */

    if ((family == 6 && model >= 14) || family > 6) {

        for (cenv = first_cpu; cenv != NULL; cenv = cenv->next_cpu) {

            if (cenv == env) {

                continue;

            }

            kvm_inject_x86_mce(cenv, 1, MCI_STATUS_VAL | MCI_STATUS_UC,

                               MCG_STATUS_MCIP | MCG_STATUS_RIPV, 0, 0, 1);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void HierarchicalBitmapRequester::PrepareForDecoding(void)
{
#if ACCUSOFT_CODE

  UBYTE i;

  BuildCommon();

  if (m_ppDecodingMCU == NULL) {
    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);
    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);
  }

  if (m_ppUpsampler == NULL) {
    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);
    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);

    for(i = 0;i < m_ucCount;i++) {
      class Component *comp = m_pFrame->ComponentOf(i);
      UBYTE sx = comp->SubXOf();
      UBYTE sy = comp->SubYOf();

      if (sx > 1 || sy > 1) {
        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,
                                                          m_ulPixelWidth,m_ulPixelHeight,
                                                          m_pFrame->TablesOf()->isChromaCentered());
        m_bSubsampling   = true;
      }
    }
  }

  if (m_pLargestScale)
    m_pLargestScale->PrepareForDecoding();
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static void set_flag(struct Mailbox *m, AclFlags aclflag, int flag,
                     const char *str, char *flags, size_t flsize)
{
  if (m->rights & aclflag)
    if (flag && imap_has_flag(&imap_mdata_get(m)->flags, str))
      mutt_str_cat(flags, flsize, str);
}",0
Detect whether the following code contains vulnerabilities.,"inline Item_result Item_case_expr::result_type() const
{
  return this_item()->result_type();
}",0
Detect whether the following code contains vulnerabilities.,"static void dp8393x_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    uint16_t old_val = dp8393x_readw(opaque, addr & ~0x1);



    switch (addr & 3) {

    case 0:

        val = val | (old_val & 0xff00);

        break;

    case 1:

        val = (val << 8) | (old_val & 0x00ff);

        break;

    }

    dp8393x_writew(opaque, addr & ~0x1, val);

}
",0
Detect whether the following code contains vulnerabilities.,"UTI_TimespecNetworkToHost(Timespec *src, struct timespec *dest)
{
  uint32_t sec_low, nsec;
#ifdef HAVE_LONG_TIME_T
  uint32_t sec_high;
#endif

  sec_low = ntohl(src->tv_sec_low);
#ifdef HAVE_LONG_TIME_T
  sec_high = ntohl(src->tv_sec_high);
  if (sec_high == TV_NOHIGHSEC)
    sec_high = 0;

  dest->tv_sec = (uint64_t)sec_high << 32 | sec_low;
#else
  dest->tv_sec = sec_low;
#endif

  nsec = ntohl(src->tv_nsec);
  dest->tv_nsec = MIN(nsec, 999999999U);
}",0
Detect whether the following code contains vulnerabilities.,"void *umm_malloc( size_t size ) {
  void *ret;

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  size += POISON_SIZE(size);

  ret = _umm_malloc( size );

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}",1
Detect whether the following code contains vulnerabilities.,"zsetdevice(i_ctx_t *i_ctx_p)
{
    gx_device *dev = gs_currentdevice(igs);
    os_ptr op = osp;
    int code = 0;

    check_write_type(*op, t_device);
    if (dev->LockSafetyParams) {	  /* do additional checking if locked  */
        if(op->value.pdevice != dev) 	  /* don't allow a different device    */
            return_error(gs_error_invalidaccess);
    }
    dev->ShowpageCount = 0;

    if (op->value.pdevice == 0)
        return gs_note_error(gs_error_undefined);

    code = gs_setdevice_no_erase(igs, op->value.pdevice);
    if (code < 0)
        return code;

    make_bool(op, code != 0);	/* erase page if 1 */
    invalidate_stack_devices(i_ctx_p);
    clear_pagedevice(istate);
    return code;
}",1
Detect whether the following code contains vulnerabilities.,"      pathWithEscapedSlashesAction() const override {
    return envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
        KEEP_UNCHANGED;
  }",0
Detect whether the following code contains vulnerabilities.,"static bool win_credential_has_certificate(win_credential_t *cred)
{
  if (!cred) return false;
  return (cred->cert_context != NULL);
}",0
Detect whether the following code contains vulnerabilities.,"int ssl_cert_add0_chain_cert(SSL *s, SSL_CTX *ctx, X509 *x)
{
    int r;
    CERT_PKEY *cpk = s ? s->cert->key : ctx->cert->key;
    if (!cpk)
        return 0;
    r = ssl_security_cert(s, ctx, x, 0, 0);
    if (r != 1) {
        ERR_raise(ERR_LIB_SSL, r);
        return 0;
    }
    if (!cpk->chain)
        cpk->chain = sk_X509_new_null();
    if (!cpk->chain || !sk_X509_push(cpk->chain, x))
        return 0;
    return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static void get_page_bootmem(unsigned long info,  struct page *page,
			     unsigned long type)
{
	page->lru.next = (struct list_head *) type;
	SetPagePrivate(page);
	set_page_private(page, info);
	atomic_inc(&page->_count);
}",0
Detect whether the following code contains vulnerabilities.,"int get_urecord(udomain_t* _d, str* _aor, struct urecord** _r)
{
	unsigned int sl, i, aorhash;
	urecord_t* r;

	if (db_mode!=DB_ONLY) {
		/* search in cache */
		aorhash = ul_get_aorhash(_aor);
		sl = aorhash&(_d->size-1);
		r = _d->table[sl].first;

		for(i = 0; r!=NULL && i < _d->table[sl].n; i++) {
			if((r->aorhash==aorhash) && (r->aor.len==_aor->len)
						&& !memcmp(r->aor.s,_aor->s,_aor->len)){
				*_r = r;
				return 0;
			}

			r = r->next;
		}
	} else {
		/* search in DB */
		r = db_load_urecord( ul_dbh, _d, _aor);
		if (r) {
			*_r = r;
			return 0;
		}
	}

	return 1;   /* Nothing found */
}",0
Detect whether the following code contains vulnerabilities.,"static inline QuantumAny ScaleQuantumToAny(const Quantum quantum,
  const QuantumAny range)
{
  return((QuantumAny) (((double) range*quantum)/QuantumRange+0.5));
}",1
Detect whether the following code contains vulnerabilities.,"Object *object_dynamic_cast_assert(Object *obj, const char *typename)

{

    Object *inst;



    inst = object_dynamic_cast(obj, typename);



    if (!inst) {

        fprintf(stderr, ""Object %p is not an instance of type %s\n"",

                obj, typename);

        abort();

    }



    return inst;

}
",1
Detect whether the following code contains vulnerabilities.,"vte_sequence_handler_multiple(VteTerminal *terminal,
                              GValueArray *params,
                              VteTerminalSequenceHandler handler)
{
        vte_sequence_handler_multiple_limited(terminal, params, handler, G_MAXLONG);
}",1
Detect whether the following code contains vulnerabilities.,"    return s_path;
  }

  // [internal] Sorting function, used by cimg::files().",0
Detect whether the following code contains vulnerabilities.,"static void audio_capture(void *opaque, void *buf, int size)

{

    VncState *vs = opaque;



    vnc_lock_output(vs);

    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU);

    vnc_write_u8(vs, VNC_MSG_SERVER_QEMU_AUDIO);

    vnc_write_u16(vs, VNC_MSG_SERVER_QEMU_AUDIO_DATA);

    vnc_write_u32(vs, size);

    vnc_write(vs, buf, size);

    vnc_unlock_output(vs);

    vnc_flush(vs);

}
",1
Detect whether the following code contains vulnerabilities.,"  static void  Ins_JMPR( INS_ARG )
  {
    CUR.IP      += (Int)(args[0]);
    CUR.step_ins = FALSE;

    if(CUR.IP > CUR.codeSize ||
       (CUR.code[CUR.IP] != 0x2D && CUR.code[CUR.IP - 1] == 0x2D))
    /* The JPMR is meant to stop at the ENDF instruction to finish
     * the function. However the programmer made a mistake, and ended
     * up one byte too far. I suspect that some TT interpreters handle this
     * by detecting that the IP has gone off the end of the function. We can
     * allow for simple cases here by just checking the preceding byte.
     * Fonts with this problem are not uncommon.
     */
      CUR.IP -= 1;
  }",1
Detect whether the following code contains vulnerabilities.,"static int read_uncompressed_sgi(unsigned char* out_buf, uint8_t* out_end,

                const uint8_t *in_buf, const uint8_t *in_end, SgiState* s)

{

    int x, y, z;

    const uint8_t *ptr;

    unsigned int offset = s->height * s->width * s->bytes_per_channel;



    /* Test buffer size. */

    if (offset * s->depth > in_end - in_buf) {

       return -1;

    }



    for (y = s->height - 1; y >= 0; y--) {

        out_end = out_buf + (y * s->linesize);

        for (x = s->width; x > 0; x--) {

            ptr = in_buf += s->bytes_per_channel;

            for(z = 0; z < s->depth; z ++) {

                memcpy(out_end, ptr, s->bytes_per_channel);

                out_end += s->bytes_per_channel;

                ptr += offset;

            }

        }

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ahci_irq_lower(AHCIState *s, AHCIDevice *dev)

{

    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);



    DPRINTF(0, ""lower irq\n"");



    if (!msi_enabled(PCI_DEVICE(d))) {

        qemu_irq_lower(s->irq);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"DeviceState *sysbus_create_varargs(const char *name,

                                   target_phys_addr_t addr, ...)

{

    DeviceState *dev;

    SysBusDevice *s;

    va_list va;

    qemu_irq irq;

    int n;



    dev = qdev_create(NULL, name);

    s = sysbus_from_qdev(dev);

    qdev_init(dev);

    if (addr != (target_phys_addr_t)-1) {

        sysbus_mmio_map(s, 0, addr);

    }

    va_start(va, addr);

    n = 0;

    while (1) {

        irq = va_arg(va, qemu_irq);

        if (!irq) {

            break;

        }

        sysbus_connect_irq(s, n, irq);

        n++;

    }

    return dev;

}
",1
Detect whether the following code contains vulnerabilities.,"	__releases(nfnl_queue_pernet(seq_file_net(s))->instances_lock)
{
	spin_unlock(&nfnl_queue_pernet(seq_file_net(s))->instances_lock);
}",0
Detect whether the following code contains vulnerabilities.,"static void cleanup_infolist(CommandLineParameterInfoList *head)

{

    CommandLineParameterInfoList *pre_entry, *cur, *del_entry;



    cur = head;

    while (cur->next) {

        pre_entry = head;

        while (pre_entry != cur->next) {

            if (!strcmp(pre_entry->value->name, cur->next->value->name)) {

                del_entry = cur->next;

                cur->next = cur->next->next;

                g_free(del_entry);

                break;

            }

            pre_entry = pre_entry->next;

        }

        cur = cur->next;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,

                             unsigned size)

{

    icp_pit_state *s = (icp_pit_state *)opaque;

    int n;



    /* ??? Don't know the PrimeCell ID for this device.  */

    n = offset >> 8;

    if (n > 2) {

        hw_error(""%s: Bad timer %d\n"", __func__, n);

    }



    return arm_timer_read(s->timer[n], offset & 0xff);

}
",0
Detect whether the following code contains vulnerabilities.,"md_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)
{
    OFF off = beg;

    while(off < ctx->size && CH(off) == CH(beg))
        off++;

    /* Fence must have at least three characters. */
    if(off - beg < 3)
        return FALSE;

    ctx->code_fence_length = off - beg;

    /* Optionally, space(s) can follow. */
    while(off < ctx->size  &&  CH(off) == _T(' '))
        off++;

    /* Optionally, an info string can follow. */
    while(off < ctx->size  &&  !ISNEWLINE(off)) {
        /* Backtick-based fence must not contain '`' in the info string. */
        if(CH(beg) == _T('`')  &&  CH(off) == _T('`'))
            return FALSE;
        off++;
    }

    *p_end = off;
    return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"void scsi_req_dequeue(SCSIRequest *req)

{

    trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);

    if (req->enqueued) {

        QTAILQ_REMOVE(&req->dev->requests, req, next);

        req->enqueued = false;

        scsi_req_unref(req);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int lcc_network_buffer_finalize (lcc_network_buffer_t *nb) /* {{{ */
{
  if (nb == NULL)
    return (EINVAL);

#if HAVE_LIBGCRYPT
  if (nb->seclevel == SIGN)
    nb_add_signature (nb);
  else if (nb->seclevel == ENCRYPT)
    nb_add_encryption (nb);
#endif

  return (0);
} /* }}} int lcc_network_buffer_finalize */",0
Detect whether the following code contains vulnerabilities.,"bool CUser::AddNetwork(CIRCNetwork* pNetwork) {
    if (FindNetwork(pNetwork->GetName())) {
        return false;
    }

    m_vIRCNetworks.push_back(pNetwork);

    return true;
}",0
Detect whether the following code contains vulnerabilities.,"static void ecc_mem_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    printf(""ECC: Unsupported write 0x"" TARGET_FMT_plx "" %02x\n"",

           addr, val & 0xff);

}
",0
Detect whether the following code contains vulnerabilities.,"void *zcalloc(size_t size) {
    void *ptr = calloc(1, size+PREFIX_SIZE);

    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_alloc(zmalloc_size(ptr));
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    return (char*)ptr+PREFIX_SIZE;
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static char *vnc_socket_remote_addr(const char *format, int fd) {

    struct sockaddr_storage sa;

    socklen_t salen;



    salen = sizeof(sa);

    if (getpeername(fd, (struct sockaddr*)&sa, &salen) < 0)

        return NULL;



    return addr_to_string(format, &sa, salen);

}
",1
Detect whether the following code contains vulnerabilities.,"  void release_reserved_pushes(uint64_t pushes) {
    Mutex::Locker l(recovery_lock);
    assert(recovery_ops_reserved >= pushes);
    recovery_ops_reserved -= pushes;
    _maybe_queue_recovery();
  }",0
Detect whether the following code contains vulnerabilities.,"static int tpm_passthrough_unix_write(int fd, const uint8_t *buf, uint32_t len)

{

    int ret, remain;



    remain = len;

    while (len > 0) {

        ret = write(fd, buf, remain);

        if (ret < 0) {

            if (errno != EINTR && errno != EAGAIN) {

                return -1;

            }

        } else if (ret == 0) {

            break;

        } else {

            buf += ret;

            remain -= ret;

        }

    }

    return len - remain;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pc_fw_cfg_guest_info(PcGuestInfo *guest_info)

{

    PcRomPciInfo *info;

    if (!guest_info->has_pci_info) {

        return;

    }



    info = g_malloc(sizeof *info);

    info->w32_min = cpu_to_le64(guest_info->pci_info.w32.begin);

    info->w32_max = cpu_to_le64(guest_info->pci_info.w32.end);

    info->w64_min = cpu_to_le64(guest_info->pci_info.w64.begin);

    info->w64_max = cpu_to_le64(guest_info->pci_info.w64.end);

    /* Pass PCI hole info to guest via a side channel.

     * Required so guest PCI enumeration does the right thing. */

    fw_cfg_add_file(guest_info->fw_cfg, ""etc/pci-info"", info, sizeof *info);

}
",0
Detect whether the following code contains vulnerabilities.,"static void mp_tasklet_action(unsigned long data)
{
	struct sb_uart_state *state = (struct sb_uart_state *)data;
	struct tty_struct *tty;

	printk(""tasklet is called!\n"");
	tty = state->info->tty;
	tty_wakeup(tty);
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t _hostfs_pwrite(
    oe_fd_t* desc,
    const void* buf,
    size_t count,
    oe_off_t offset)
{
    ssize_t ret = -1;
    file_t* file = _cast_file(desc);

    if (!file)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=
        OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)
{
	const char *buf;
	ssize_t len;
	ssize_t count;

	len = udev_device_get_properties_monitor_buf(udev_device, &buf);
	if (len < 32)
		return -1;
	if (udev_monitor->sun.sun_family != 0)
		count = sendto(udev_monitor->sock,
			       buf, len, 0,
			       (struct sockaddr *)&udev_monitor->sun,
			       udev_monitor->addrlen);
	else if (udev_monitor->snl.nl_family != 0)
		/* no destination besides the muticast group, we will always get ECONNREFUSED */
		count = sendto(udev_monitor->sock,
			       buf, len, 0,
			       (struct sockaddr *)&udev_monitor->snl_peer,
			       sizeof(struct sockaddr_nl));
	else
		return -1;

	info(udev_monitor->udev, ""passed %zi bytes to monitor %p, \n"", count, udev_monitor);
	return count;
}",1
Detect whether the following code contains vulnerabilities.,"const Integer& DSA_Verifier::GetS() const
{
    return s_;
}",0
Detect whether the following code contains vulnerabilities.,"static bool riccb_needed(void *opaque)

{

#ifdef CONFIG_KVM

    if (kvm_enabled()) {

        return kvm_s390_get_ri();

    }

#endif

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"regex_match_and_setup(const pcre *re, uschar *subject, int options, int setup)
{
int ovector[3*(EXPAND_MAXN+1)];
int n = pcre_exec(re, NULL, subject, Ustrlen(subject), 0, PCRE_EOPT|options,
  ovector, sizeof(ovector)/sizeof(int));
BOOL yield = n >= 0;
if (n == 0) n = EXPAND_MAXN + 1;
if (yield)
  {
  int nn;
  expand_nmax = (setup < 0)? 0 : setup + 1;
  for (nn = (setup < 0)? 0 : 2; nn < n*2; nn += 2)
    {
    expand_nstring[expand_nmax] = subject + ovector[nn];
    expand_nlength[expand_nmax++] = ovector[nn+1] - ovector[nn];
    }
  expand_nmax--;
  }
return yield;
}",0
Detect whether the following code contains vulnerabilities.,"static int tcp_v6_gso_send_check(struct sk_buff *skb)
{
	const struct ipv6hdr *ipv6h;
	struct tcphdr *th;

	if (!pskb_may_pull(skb, sizeof(*th)))
		return -EINVAL;

	ipv6h = ipv6_hdr(skb);
	th = tcp_hdr(skb);

	th->check = 0;
	skb->ip_summed = CHECKSUM_PARTIAL;
	__tcp_v6_send_check(skb, &ipv6h->saddr, &ipv6h->daddr);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void do_subfeo (void)

{

    T2 = T0;

    T0 = T1 + ~T0 + xer_ca;

    if (likely(!((~T2 ^ T1 ^ (-1)) & (~T2 ^ T0) & (1 << 31)))) {

        xer_ov = 0;

    } else {

        xer_so = 1;

        xer_ov = 1;

    }

    if (likely(T0 >= T1 && (xer_ca == 0 || T0 != T1))) {

        xer_ca = 0;

    } else {

        xer_ca = 1;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,

                                         hwaddr desc_pa, unsigned int max)

{

    unsigned int next;



    /* If this descriptor says it doesn't chain, we're done. */

    if (!(desc->flags & VRING_DESC_F_NEXT)) {

        return max;

    }



    /* Check they're not leading us off end of descriptors. */

    next = desc->next;

    /* Make sure compiler knows to grab that: we don't want it changing! */

    smp_wmb();



    if (next >= max) {

        error_report(""Desc next is %u"", next);

        exit(1);

    }



    vring_desc_read(vdev, desc, desc_pa, next);

    return next;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_uint8_equal(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    uint8_t v2;

    qemu_get_8s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void b43_op_configure_filter(struct ieee80211_hw *hw,
				    unsigned int changed, unsigned int *fflags,
				    u64 multicast)
{
	struct b43_wl *wl = hw_to_b43_wl(hw);
	struct b43_wldev *dev;

	mutex_lock(&wl->mutex);
	dev = wl->current_dev;
	if (!dev) {
		*fflags = 0;
		goto out_unlock;
	}

	*fflags &= FIF_PROMISC_IN_BSS |
		  FIF_ALLMULTI |
		  FIF_FCSFAIL |
		  FIF_PLCPFAIL |
		  FIF_CONTROL |
		  FIF_OTHER_BSS |
		  FIF_BCN_PRBRESP_PROMISC;

	changed &= FIF_PROMISC_IN_BSS |
		   FIF_ALLMULTI |
		   FIF_FCSFAIL |
		   FIF_PLCPFAIL |
		   FIF_CONTROL |
		   FIF_OTHER_BSS |
		   FIF_BCN_PRBRESP_PROMISC;

	wl->filter_flags = *fflags;

	if (changed && b43_status(dev) >= B43_STAT_INITIALIZED)
		b43_adjust_opmode(dev);

out_unlock:
	mutex_unlock(&wl->mutex);
}",0
Detect whether the following code contains vulnerabilities.,"static __always_inline u32 __flow_hash_words(const u32 *words, u32 length,
					     u32 keyval)
{
	return jhash2(words, length, keyval);
}",1
Detect whether the following code contains vulnerabilities.,"static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
				   u16 selector, int seg)
{
	u8 cpl = ctxt->ops->cpl(ctxt);
	return __load_segment_descriptor(ctxt, selector, seg, cpl,
					 X86_TRANSFER_NONE, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"static int em_mov_sreg_rm(struct x86_emulate_ctxt *ctxt)
{
	u16 sel = ctxt->src.val;

	if (ctxt->modrm_reg == VCPU_SREG_CS || ctxt->modrm_reg > VCPU_SREG_GS)
		return emulate_ud(ctxt);

	if (ctxt->modrm_reg == VCPU_SREG_SS)
		ctxt->interruptibility = KVM_X86_SHADOW_INT_MOV_SS;

	/* Disable writeback. */
	ctxt->dst.type = OP_NONE;
	return load_segment_descriptor(ctxt, sel, ctxt->modrm_reg);
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(umask)
{
	long arg1 = 0;
	int oldumask;
	
	oldumask = umask(077);

	if (BG(umask) == -1) {
		BG(umask) = oldumask;
	}
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|l"", &arg1) == FAILURE) {
		RETURN_FALSE;
	}

	if (ZEND_NUM_ARGS() == 0) {
		umask(oldumask);
	} else {
		umask(arg1);
	}

	RETURN_LONG(oldumask);
}",1
Detect whether the following code contains vulnerabilities.,"LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,
              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)
{
    const char *str;
    xkb_mod_index_t ndx;
    const LookupModMaskPriv *arg = priv;
    const struct xkb_mod_set *mods = arg->mods;
    enum mod_type mod_type = arg->mod_type;

    if (type != EXPR_TYPE_INT)
        return false;

    str = xkb_atom_text(ctx, field);

    if (istreq(str, ""all"")) {
        *val_rtrn  = MOD_REAL_MASK_ALL;
        return true;
    }

    if (istreq(str, ""none"")) {
        *val_rtrn = 0;
        return true;
    }

    ndx = XkbModNameToIndex(mods, field, mod_type);
    if (ndx == XKB_MOD_INVALID)
        return false;

    *val_rtrn = (1u << ndx);
    return true;
}",1
Detect whether the following code contains vulnerabilities.,"static int mt_resume(struct hid_device *hdev)
{
	/* Some Elan legacy devices require SET_IDLE to be set on resume.
	 * It should be safe to send it to other devices too.
	 * Tested on 3M, Stantum, Cypress, Zytronic, eGalax, and Elan panels. */

	hid_hw_idle(hdev, 0, 0, HID_REQ_SET_IDLE);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"end_superexec(i_ctx_t *i_ctx_p)
{
    i_ctx_p->in_superexec--;
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"_blackbox_reload(int32_t target)
{
	struct qb_log_target *t = qb_log_target_get(target);

	if (t->instance == NULL) {
		return;
	}
	qb_rb_close(t->instance);
	t->instance = qb_rb_open(t->filename, t->size,
				 QB_RB_FLAG_CREATE | QB_RB_FLAG_OVERWRITE, 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_tlbiel(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void *rndis_queue_response(USBNetState *s, unsigned int length)

{

    struct rndis_response *r =

            qemu_mallocz(sizeof(struct rndis_response) + length);



    TAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);

    r->length = length;



    return &r->buf[0];

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int bmv_aud_decode_init(AVCodecContext *avctx)

{

    BMVAudioDecContext *c = avctx->priv_data;



    if (avctx->channels != 2) {

        av_log(avctx, AV_LOG_INFO, ""invalid number of channels\n"");

        return AVERROR(EINVAL);

    }



    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&c->frame);

    avctx->coded_frame = &c->frame;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_arch_insert_sw_breakpoint(CPUState *env, struct kvm_sw_breakpoint *bp)

{

    static const uint8_t int3 = 0xcc;



    if (cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&bp->saved_insn, 1, 0) ||

        cpu_memory_rw_debug(env, bp->pc, (uint8_t *)&int3, 1, 1))

        return -EINVAL;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_change_vnc(const char *target)

{

    if (strcmp(target, ""passwd"") == 0 ||

	strcmp(target, ""password"") == 0) {

	char password[9];

	monitor_readline(""Password: "", 1, password, sizeof(password));

	if (vnc_display_password(NULL, password) < 0)

	    term_printf(""could not set VNC server password\n"");

    } else {

	if (vnc_display_open(NULL, target) < 0)

	    term_printf(""could not start VNC server on %s\n"", target);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int yr_re_parse(
    const char* re_string,
    RE_AST** re_ast,
    RE_ERROR* error)
{
  return yr_parse_re_string(re_string, re_ast, error);
}",0
Detect whether the following code contains vulnerabilities.,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256]; /* our stringbuffer */
        int buflen=0;
        register u_int rotbit; /* this is the bit we rotate through all bitpositions */
        register u_int tokval;
        const char * sepstr = """";

	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;   /* load our first value */
            rotbit=1;
            while (rotbit != 0) {
                /*
                 * lets AND the rotating bit with our token value
                 * and see if we have got a match
                 */
		if (tokval == (v&rotbit)) {
                    /* ok we have found something */
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1; /* no match - lets shift and try again */
            }
            lp++;
	}

        if (buflen == 0)
            /* bummer - lets print the ""unknown"" message as advised in the fmt string if we got one */
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}",1
Detect whether the following code contains vulnerabilities.,"static void basic_globals_ctor(php_basic_globals *basic_globals_p TSRMLS_DC) /* {{{ */
{
	BG(rand_is_seeded) = 0;
	BG(mt_rand_is_seeded) = 0;
	BG(umask) = -1;
	BG(next) = NULL;
	BG(left) = -1;
	BG(user_tick_functions) = NULL;
	BG(user_filter_map) = NULL;
	BG(serialize_lock) = 0;
	
	memset(&BG(serialize), 0, sizeof(BG(serialize)));
	memset(&BG(unserialize), 0, sizeof(BG(unserialize)));

	memset(&BG(url_adapt_state_ex), 0, sizeof(BG(url_adapt_state_ex)));

#if defined(_REENTRANT) && defined(HAVE_MBRLEN) && defined(HAVE_MBSTATE_T)
	memset(&BG(mblen_state), 0, sizeof(BG(mblen_state)));
#endif

	BG(incomplete_class) = incomplete_class_entry;
	BG(page_uid) = -1;
	BG(page_gid) = -1;
}",1
Detect whether the following code contains vulnerabilities.,"void qxl_log_command(PCIQXLDevice *qxl, const char *ring, QXLCommandExt *ext)

{

    bool compat = ext->flags & QXL_COMMAND_FLAG_COMPAT;

    void *data;



    if (!qxl->cmdlog) {

        return;

    }

    fprintf(stderr, ""%"" PRId64 "" qxl-%d/%s:"", qemu_get_clock_ns(vm_clock),

            qxl->id, ring);

    fprintf(stderr, "" cmd @ 0x%"" PRIx64 "" %s%s"", ext->cmd.data,

            qxl_name(qxl_type, ext->cmd.type),

            compat ? ""(compat)"" : """");



    data = qxl_phys2virt(qxl, ext->cmd.data, ext->group_id);

    switch (ext->cmd.type) {

    case QXL_CMD_DRAW:

        if (!compat) {

            qxl_log_cmd_draw(qxl, data, ext->group_id);

        } else {

            qxl_log_cmd_draw_compat(qxl, data, ext->group_id);

        }

        break;

    case QXL_CMD_SURFACE:

        qxl_log_cmd_surface(qxl, data);

        break;

    case QXL_CMD_CURSOR:

        qxl_log_cmd_cursor(qxl, data, ext->group_id);

        break;

    }

    fprintf(stderr, ""\n"");

}
",0
Detect whether the following code contains vulnerabilities.,"static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;
	struct sock *sk = sock->sk;

	BT_DBG(""sock %p, sk %p"", sock, sk);

	sa->rc_family  = AF_BLUETOOTH;
	sa->rc_channel = rfcomm_pi(sk)->channel;
	if (peer)
		bacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);
	else
		bacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);

	*len = sizeof(struct sockaddr_rc);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static gboolean gd_vc_in(GIOChannel *chan, GIOCondition cond, void *opaque)

{

    VirtualConsole *vc = opaque;

    uint8_t buffer[1024];

    ssize_t len;



    len = read(vc->fd, buffer, sizeof(buffer));

    if (len <= 0) {

        return FALSE;

    }



    qemu_chr_be_write(vc->chr, buffer, len);



    return TRUE;

}
",1
Detect whether the following code contains vulnerabilities.,"static void dummy_event_handler(void *opaque)

{

}
",0
Detect whether the following code contains vulnerabilities.,"static void opt_input_file(void *optctx, const char *arg)

{

    if (input_filename) {

        fprintf(stderr,

                ""Argument '%s' provided as input filename, but '%s' was already specified.\n"",

                arg, input_filename);

        exit(1);

    }

    if (!strcmp(arg, ""-""))

        arg = ""pipe:"";

    input_filename = arg;

}
",1
Detect whether the following code contains vulnerabilities.,"tile_make_weights (PixopsFilterDimension *dim,
		   double                 scale)
{
  int n = ceil (1 / scale + 1);
  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);
  int offset;
  int i;

  dim->n = n;
  dim->offset = 0;
  dim->weights = pixel_weights;

  for (offset = 0; offset < SUBSAMPLE; offset++)
    {
      double x = (double)offset / SUBSAMPLE;
      double a = x + 1 / scale;

      for (i = 0; i < n; i++)
        {
          if (i < x)
            {
              if (i + 1 > x)
                *(pixel_weights++)  = (MIN (i + 1, a) - x) * scale;
              else
                *(pixel_weights++) = 0;
            }
          else
            {
              if (a > i)
                *(pixel_weights++)  = (MIN (i + 1, a) - i) * scale;
              else
                *(pixel_weights++) = 0;
            }
       }
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void sbr_hf_g_filt_c(int (*Y)[2], const int (*X_high)[40][2],

                          const SoftFloat *g_filt, int m_max, intptr_t ixh)

{

    int m;

    int64_t accu;



    for (m = 0; m < m_max; m++) {

        int64_t r = 1LL << (22-g_filt[m].exp);

        accu = (int64_t)X_high[m][ixh][0] * ((g_filt[m].mant + 0x40)>>7);

        Y[m][0] = (int)((accu + r) >> (23-g_filt[m].exp));



        accu = (int64_t)X_high[m][ixh][1] * ((g_filt[m].mant + 0x40)>>7);

        Y[m][1] = (int)((accu + r) >> (23-g_filt[m].exp));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void get_tmp_filename(char *filename, int size)

{

    char temp_dir[MAX_PATH];



    GetTempPath(MAX_PATH, temp_dir);

    GetTempFileName(temp_dir, ""qem"", 0, filename);

}
",1
Detect whether the following code contains vulnerabilities.,"	switch (yych) {
		case 'a': goto yy28;
		default: goto yy27;
	}",1
Detect whether the following code contains vulnerabilities.,"static bool is_pointer_value(struct verifier_env *env, int regno)
{
	if (env->allow_ptr_leaks)
		return false;

	switch (env->cur_state.regs[regno].type) {
	case UNKNOWN_VALUE:
	case CONST_IMM:
		return false;
	default:
		return true;
	}
}",0
Detect whether the following code contains vulnerabilities.,"void sctp_assoc_sync_pmtu(struct sock *sk, struct sctp_association *asoc)
{
	struct sctp_transport *t;
	__u32 pmtu = 0;

	if (!asoc)
		return;

	/* Get the lowest pmtu of all the transports. */
	list_for_each_entry(t, &asoc->peer.transport_addr_list,
				transports) {
		if (t->pmtu_pending && t->dst) {
			sctp_transport_update_pmtu(sk, t, dst_mtu(t->dst));
			t->pmtu_pending = 0;
		}
		if (!pmtu || (t->pathmtu < pmtu))
			pmtu = t->pathmtu;
	}

	if (pmtu) {
		asoc->pathmtu = pmtu;
		asoc->frag_point = sctp_frag_point(asoc, pmtu);
	}

	SCTP_DEBUG_PRINTK(""%s: asoc:%p, pmtu:%d, frag_point:%d\n"",
			  __func__, asoc, asoc->pathmtu, asoc->frag_point);
}",0
Detect whether the following code contains vulnerabilities.,"void tipc_link_set_abort_limit(struct tipc_link *l, u32 limit)
{
	l->abort_limit = limit;
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t omap2_gpio_module_readp(void *opaque, target_phys_addr_t addr)

{

    return omap2_gpio_module_readp(opaque, addr) >> ((addr & 3) << 3);

}
",1
Detect whether the following code contains vulnerabilities.,"static void DefragTrackerInit(DefragTracker *dt, Packet *p)
{
    /* copy address */
    COPY_ADDRESS(&p->src, &dt->src_addr);
    COPY_ADDRESS(&p->dst, &dt->dst_addr);

    if (PKT_IS_IPV4(p)) {
        dt->id = (int32_t)IPV4_GET_IPID(p);
        dt->af = AF_INET;
    } else {
        dt->id = (int32_t)IPV6_EXTHDR_GET_FH_ID(p);
        dt->af = AF_INET6;
    }
    dt->vlan_id[0] = p->vlan_id[0];
    dt->vlan_id[1] = p->vlan_id[1];
    dt->policy = DefragGetOsPolicy(p);
    dt->host_timeout = DefragPolicyGetHostTimeout(p);
    dt->remove = 0;
    dt->seen_last = 0;

    TAILQ_INIT(&dt->frags);
    (void) DefragTrackerIncrUsecnt(dt);
}",1
Detect whether the following code contains vulnerabilities.,"  SSLHandshakeClientNoVerify(
      AsyncSSLSocket::UniquePtr socket,
      bool preverifyResult,
      bool verifyResult)
      : SSLHandshakeBase(std::move(socket), preverifyResult, verifyResult) {
    socket_->sslConn(
        this,
        std::chrono::milliseconds::zero(),
        folly::SSLContext::SSLVerifyPeerEnum::NO_VERIFY);
  }",0
Detect whether the following code contains vulnerabilities.,"static ExitStatus trans_fop_dedd(DisasContext *ctx, uint32_t insn,

                                 const DisasInsn *di)

{

    unsigned rt = extract32(insn, 0, 5);

    unsigned rb = extract32(insn, 16, 5);

    unsigned ra = extract32(insn, 21, 5);

    return do_fop_dedd(ctx, rt, ra, rb, di->f_dedd);

}
",1
Detect whether the following code contains vulnerabilities.,"  const std::string& get_id() const {
    ceph_assert(t != Wildcard && t != Tenant);
    return u.id;
  }",1
Detect whether the following code contains vulnerabilities.,"int ber_write_integer(wStream* s, UINT32 value)
{
	ber_write_universal_tag(s, BER_TAG_INTEGER, FALSE);

	if (value <= 0xFF)
	{
		ber_write_length(s, 1);
		Stream_Write_UINT8(s, value);
		return 2;
	}
	else if (value < 0xFF80)
	{
		ber_write_length(s, 2);
		Stream_Write_UINT16_BE(s, value);
		return 3;
	}
	else if (value < 0xFF8000)
	{
		ber_write_length(s, 3);
		Stream_Write_UINT8(s, (value >> 16));
		Stream_Write_UINT16_BE(s, (value & 0xFFFF));
		return 4;
	}
	else if (value <= 0xFFFFFFFF)
	{
		ber_write_length(s, 4);
		Stream_Write_UINT32_BE(s, value);
		return 5;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"node_new_fail(Node** node, ScanEnv* env)
{
  *node = node_new();
  CHECK_NULL_RETURN_MEMERR(*node);

  NODE_SET_TYPE(*node, NODE_GIMMICK);
  GIMMICK_(*node)->type = GIMMICK_FAIL;
  return ONIG_NORMAL;
}",0
Detect whether the following code contains vulnerabilities.,"static void parse_cmdline(const char *cmdline,

                          int *pnb_args, char **args)

{

    const char *p;

    int nb_args, ret;

    char buf[1024];



    p = cmdline;

    nb_args = 0;

    for (;;) {

        while (qemu_isspace(*p)) {

            p++;

        }

        if (*p == '\0') {

            break;

        }

        if (nb_args >= MAX_ARGS) {

            break;

        }

        ret = get_str(buf, sizeof(buf), &p);

        args[nb_args] = g_strdup(buf);

        nb_args++;

        if (ret < 0) {

            break;

        }

    }

    *pnb_args = nb_args;

}
",1
Detect whether the following code contains vulnerabilities.,"CAMLprim value caml_blit_string(value s1, value ofs1, value s2, value ofs2,
                                value n)
{
  memmove(&Byte(s2, Long_val(ofs2)), &Byte(s1, Long_val(ofs1)), Int_val(n));
  return Val_unit;
}",1
Detect whether the following code contains vulnerabilities.,"static void parse_type_size(Visitor *v, const char *name, uint64_t *obj,

                            Error **errp)

{

    StringInputVisitor *siv = to_siv(v);

    Error *err = NULL;

    uint64_t val;



    if (siv->string) {

        parse_option_size(name, siv->string, &val, &err);

    } else {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""size"");

        return;

    }

    if (err) {

        error_propagate(errp, err);

        return;

    }



    *obj = val;

}
",1
Detect whether the following code contains vulnerabilities.,"TEST_F(EncryptionUtilTest, sm4_test_basic) {
    std::string source_1 = ""hello, doris"";
    do_sm4_test(source_1, _aes_key);
    std::string source_2 = ""doris test"";
    do_sm4_test(source_2, _aes_key);
}",0
Detect whether the following code contains vulnerabilities.,"void HeaderMapImpl::iterate(ConstIterateCb cb, void* context) const {
  for (const HeaderEntryImpl& header : headers_) {
    if (cb(header, context) == HeaderMap::Iterate::Break) {
      break;
    }
  }
}",0
Detect whether the following code contains vulnerabilities.,"static void eject_device(BlockDriverState *bs, int force, Error **errp)

{

    if (bdrv_in_use(bs)) {

        error_set(errp, QERR_DEVICE_IN_USE, bdrv_get_device_name(bs));

        return;

    }

    if (!bdrv_dev_has_removable_media(bs)) {

        error_setg(errp, ""Device '%s' is not removable"",

                   bdrv_get_device_name(bs));

        return;

    }



    if (bdrv_dev_is_medium_locked(bs) && !bdrv_dev_is_tray_open(bs)) {

        bdrv_dev_eject_request(bs, force);

        if (!force) {

            error_setg(errp, ""Device '%s' is locked"",

                       bdrv_get_device_name(bs));

            return;

        }

    }



    bdrv_close(bs);

}
",0
Detect whether the following code contains vulnerabilities.,"void av_aes_crypt(AVAES *a, uint8_t *dst_, const uint8_t *src_,

                  int count, uint8_t *iv_, int decrypt)

{

    av_aes_block       *dst = (av_aes_block *) dst_;

    const av_aes_block *src = (const av_aes_block *) src_;

    av_aes_block        *iv = (av_aes_block *) iv_;



    while (count--) {

        addkey(&a->state[1], src, &a->round_key[a->rounds]);

        if (decrypt) {

            crypt(a, 0, inv_sbox, dec_multbl);

            if (iv) {

                addkey(&a->state[0], &a->state[0], iv);

                memcpy(iv, src, 16);

            }

            addkey(dst, &a->state[0], &a->round_key[0]);

        } else {

            if (iv)

                addkey(&a->state[1], &a->state[1], iv);

            crypt(a, 2, sbox, enc_multbl);

            addkey(dst, &a->state[0], &a->round_key[0]);

            if (iv)

                memcpy(iv, dst, 16);

        }

        src++;

        dst++;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)
{
    char_u	*pnew;

    if (exclude_trailing_space)
	bd->endspaces = 0;
    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))
								      == NULL)
	return FAIL;
    y_current->y_array[y_idx] = pnew;
    vim_memset(pnew, ' ', (size_t)bd->startspaces);
    pnew += bd->startspaces;
    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);
    pnew += bd->textlen;
    vim_memset(pnew, ' ', (size_t)bd->endspaces);
    pnew += bd->endspaces;
    if (exclude_trailing_space)
    {
	int s = bd->textlen + bd->endspaces;

	while (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)
	{
	    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;
	    pnew--;
	}
    }
    *pnew = NUL;
    return OK;
}",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(pcntl_wait)
{
	long options = 0;
	zval *z_status = NULL;
	int status;
	pid_t child_id;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""z|l"", &z_status, &options) == FAILURE)
		return;
	
	convert_to_long_ex(&z_status);

	status = Z_LVAL_P(z_status);
#ifdef HAVE_WAIT3
	if(options) {
		child_id = wait3(&status, options, NULL);
	}
	else {
		child_id = wait(&status);
	}
#else
	child_id = wait(&status);
#endif
	if (child_id < 0) {
		PCNTL_G(last_error) = errno;
	}

	Z_LVAL_P(z_status) = status;

	RETURN_LONG((long) child_id);
}",1
Detect whether the following code contains vulnerabilities.,"v3d_push_job(struct v3d_file_priv *v3d_priv,
	     struct v3d_job *job, enum v3d_queue queue)
{
	int ret;

	ret = drm_sched_job_init(&job->base, &v3d_priv->sched_entity[queue],
				 v3d_priv);
	if (ret)
		return ret;

	job->done_fence = dma_fence_get(&job->base.s_fence->finished);

	/* put by scheduler job completion */
	kref_get(&job->refcount);

	drm_sched_entity_push_job(&job->base, &v3d_priv->sched_entity[queue]);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int fp_reg_offset(int regno, TCGMemOp size)

{

    int offs = offsetof(CPUARMState, vfp.regs[regno * 2]);

#ifdef HOST_WORDS_BIGENDIAN

    offs += (8 - (1 << size));

#endif

    return offs;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ccp_sg_free(struct ccp_sg_workarea *wa)
{
	if (wa->dma_count)
		dma_unmap_sg(wa->dma_dev, wa->dma_sg, wa->nents, wa->dma_dir);

	wa->dma_count = 0;
}",0
Detect whether the following code contains vulnerabilities.,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_ofb)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	
	MCRYPT_GET_CRYPT_ARGS

	convert_to_long_ex(mode);

	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, ""ofb"", iv, iv_len, ZEND_NUM_ARGS(), Z_LVAL_PP(mode), return_value TSRMLS_CC);",1
Detect whether the following code contains vulnerabilities.,"static int find_snapshot_by_id_and_name(BlockDriverState *bs,
                                        const char *id,
                                        const char *name)
{
    BDRVQcowState *s = bs->opaque;
    int i;

    if (id && name) {
        for (i = 0; i < s->nb_snapshots; i++) {
            if (!strcmp(s->snapshots[i].id_str, id) &&
                !strcmp(s->snapshots[i].name, name)) {
                return i;
            }
        }
    } else if (id) {
        for (i = 0; i < s->nb_snapshots; i++) {
            if (!strcmp(s->snapshots[i].id_str, id)) {
                return i;
            }
        }
    } else if (name) {
        for (i = 0; i < s->nb_snapshots; i++) {
            if (!strcmp(s->snapshots[i].name, name)) {
                return i;
            }
        }
    }

    return -1;
}",0
Detect whether the following code contains vulnerabilities.,"xmlRelaxNGIncludePush(xmlRelaxNGParserCtxtPtr ctxt,
                      xmlRelaxNGIncludePtr value)
{
    if (ctxt->incTab == NULL) {
        ctxt->incMax = 4;
        ctxt->incNr = 0;
        ctxt->incTab =
            (xmlRelaxNGIncludePtr *) xmlMalloc(ctxt->incMax *
                                               sizeof(ctxt->incTab[0]));
        if (ctxt->incTab == NULL) {
            xmlRngPErrMemory(ctxt, ""allocating include\n"");
            return (0);
        }
    }
    if (ctxt->incNr >= ctxt->incMax) {
        ctxt->incMax *= 2;
        ctxt->incTab =
            (xmlRelaxNGIncludePtr *) xmlRealloc(ctxt->incTab,
                                                ctxt->incMax *
                                                sizeof(ctxt->incTab[0]));
        if (ctxt->incTab == NULL) {
            xmlRngPErrMemory(ctxt, ""allocating include\n"");
            return (0);
        }
    }
    ctxt->incTab[ctxt->incNr] = value;
    ctxt->inc = value;
    return (ctxt->incNr++);
}",0
Detect whether the following code contains vulnerabilities.,  SystemError() {},0
Detect whether the following code contains vulnerabilities.,"static void FUNCC(pred4x4_dc)(uint8_t *_src, const uint8_t *topright, int _stride){

    pixel *src = (pixel*)_src;

    int stride = _stride/sizeof(pixel);

    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]

                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) >>3;



    ((pixel4*)(src+0*stride))[0]=

    ((pixel4*)(src+1*stride))[0]=

    ((pixel4*)(src+2*stride))[0]=

    ((pixel4*)(src+3*stride))[0]= PIXEL_SPLAT_X4(dc);

}
",1
Detect whether the following code contains vulnerabilities.,"void replay_finish_event(void)

{

    replay_has_unread_data = 0;

    replay_fetch_data_kind();

}
",0
Detect whether the following code contains vulnerabilities.,"asmlinkage long sys_rt_sigreturn(void)
{
	struct rt_sigframe __user *frame =
		(struct rt_sigframe __user *) __frame->sp;
	sigset_t set;
	unsigned long d0;

	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
		goto badframe;
	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
		goto badframe;

	sigdelsetmask(&set, ~_BLOCKABLE);
	spin_lock_irq(&current->sighand->siglock);
	current->blocked = set;
	recalc_sigpending();
	spin_unlock_irq(&current->sighand->siglock);

	if (restore_sigcontext(__frame, &frame->uc.uc_mcontext, &d0))
		goto badframe;

	if (do_sigaltstack(&frame->uc.uc_stack, NULL, __frame->sp) == -EFAULT)
		goto badframe;

	return d0;

badframe:
	force_sig(SIGSEGV, current);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int l3_unscale(int value, int exponent)

{

    unsigned int m;

    int e;



    e  = table_4_3_exp  [4 * value + (exponent & 3)];

    m  = table_4_3_value[4 * value + (exponent & 3)];

    e -= exponent >> 2;

#ifdef DEBUG

    if(e < 1)

        av_log(NULL, AV_LOG_WARNING, ""l3_unscale: e is %d\n"", e);

#endif

    if (e > (SUINT)31)

        return 0;

    m = (m + (1 << (e - 1))) >> e;



    return m;

}
",1
Detect whether the following code contains vulnerabilities.,"uint64_t helper_fres(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN reciprocal */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    farg.d = float64_div(float64_one, farg.d, &env->fp_status);

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"TPMS_PCR_SELECTION_Marshal(TPMS_PCR_SELECTION *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;

    written += TPMI_ALG_HASH_Marshal(&source->hash, buffer, size);
    written += UINT8_Marshal(&source->sizeofSelect, buffer, size);
    written += Array_Marshal(&source->pcrSelect[0], source->sizeofSelect, buffer, size);
    return written;
}",0
Detect whether the following code contains vulnerabilities.,"static void RENAME(vertical_compose53iL0)(uint8_t *_b0, uint8_t *_b1, uint8_t *_b2,

                                          int width)

{

    int i;

    TYPE *b0 = (TYPE *)_b0;

    TYPE *b1 = (TYPE *)_b1;

    TYPE *b2 = (TYPE *)_b2;

    for (i = 0; i < width; i++)

        b1[i] -= (b0[i] + b2[i] + 2) >> 2;

}
",1
Detect whether the following code contains vulnerabilities.,"GF_Box *gen_sample_entry_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_SampleEntryBox, GF_QT_SUBTYPE_C608);//type will be overriten
	gf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);
	return (GF_Box *)tmp;
}",0
Detect whether the following code contains vulnerabilities.,"void ram_handle_compressed(void *host, uint8_t ch, uint64_t size)

{

    if (ch != 0 || !is_zero_range(host, size)) {

        memset(host, ch, size);

#ifndef _WIN32

        if (ch == 0 && (!kvm_enabled() || kvm_has_sync_mmu())) {

            size = size & ~(getpagesize() - 1);

            if (size > 0) {

                qemu_madvise(host, size, QEMU_MADV_DONTNEED);

            }

        }

#endif

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int zslLexValueLteMax(sds value, zlexrangespec *spec) {
    return spec->maxex ?
        (sdscmplex(value,spec->max) < 0) :
        (sdscmplex(value,spec->max) <= 0);
}",0
Detect whether the following code contains vulnerabilities.,"gdm_session_handle_info_query (GdmDBusWorkerManager  *worker_manager_interface,
                               GDBusMethodInvocation *invocation,
                               const char            *service_name,
                               const char            *query,
                               GdmSession            *self)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (self->priv->user_verifier_interface != NULL, FALSE);

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                set_pending_query (conversation, invocation);

                gdm_dbus_user_verifier_emit_info_query (self->priv->user_verifier_interface,
                                                        service_name,
                                                        query);
        }

        return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_net_tx_complete(NetClientState *nc, ssize_t len)

{

    VirtIONet *n = qemu_get_nic_opaque(nc);

    VirtIONetQueue *q = virtio_net_get_subqueue(nc);

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    virtqueue_push(q->tx_vq, &q->async_tx.elem, 0);

    virtio_notify(vdev, q->tx_vq);



    q->async_tx.elem.out_num = 0;



    virtio_queue_set_notification(q->tx_vq, 1);

    virtio_net_flush_tx(q);

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_peer_set_offload(NetClientState *nc, int csum, int tso4, int tso6,

                          int ecn, int ufo)

{

    if (!nc->peer || !nc->peer->info->set_offload) {

        return;

    }



    nc->peer->info->set_offload(nc->peer, csum, tso4, tso6, ecn, ufo);

}
",0
Detect whether the following code contains vulnerabilities.,"static void nvdimm_build_nfit(GSList *device_list, GArray *table_offsets,

                              GArray *table_data, BIOSLinker *linker)

{

    GArray *structures = nvdimm_build_device_structure(device_list);

    unsigned int header;



    acpi_add_table(table_offsets, table_data);



    /* NFIT header. */

    header = table_data->len;

    acpi_data_push(table_data, sizeof(NvdimmNfitHeader));

    /* NVDIMM device structures. */

    g_array_append_vals(table_data, structures->data, structures->len);



    build_header(linker, table_data,

                 (void *)(table_data->data + header), ""NFIT"",

                 sizeof(NvdimmNfitHeader) + structures->len, 1, NULL, NULL);

    g_array_free(structures, true);

}
",1
Detect whether the following code contains vulnerabilities.,"static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
  const char *it = s;
  const char *end = s + len;

  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        mutt_buffer_addch(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        mutt_buffer_addch(&buf, *it);
      }
    }
    mutt_buffer_addch(&buf, '\0');
    return buf.data;
  }
  else if (enc == ENCBASE64)
  {
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
    if (dlen == -1)
    {
      FREE(&out);
      return NULL;
    }
    out[dlen] = '\0';
    return out;
  }

  assert(0); /* The enc parameter has an invalid value */
  return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t sp804_read(void *opaque, target_phys_addr_t offset,

                           unsigned size)

{

    sp804_state *s = (sp804_state *)opaque;



    if (offset < 0x20) {

        return arm_timer_read(s->timer[0], offset);

    }

    if (offset < 0x40) {

        return arm_timer_read(s->timer[1], offset - 0x20);

    }



    /* TimerPeriphID */

    if (offset >= 0xfe0 && offset <= 0xffc) {

        return sp804_ids[(offset - 0xfe0) >> 2];

    }



    switch (offset) {

    /* Integration Test control registers, which we won't support */

    case 0xf00: /* TimerITCR */

    case 0xf04: /* TimerITOP (strictly write only but..) */

        return 0;

    }



    hw_error(""%s: Bad offset %x\n"", __func__, (int)offset);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"  double GetZoomLevel(v8::Isolate* isolate) {
    double result = 0.0;
    content::RenderFrame* render_frame;
    if (!MaybeGetRenderFrame(isolate, ""getZoomLevel"", &render_frame))
      return result;

    mojo::AssociatedRemote<mojom::ElectronBrowser> browser_remote;
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &browser_remote);
    browser_remote->DoGetZoomLevel(&result);
    return result;
  }",1
Detect whether the following code contains vulnerabilities.,"int PDFDoc::saveAs(GooString *name, PDFWriteMode mode) {
  FILE *f;
  OutStream *outStr;
  int res;

  if (!(f = fopen(name->c_str(), ""wb""))) {
    error(errIO, -1, ""Couldn't open file '{0:t}'"", name);
    return errOpenFile;
  }
  outStr = new FileOutStream(f,0);
  res = saveAs(outStr, mode);
  delete outStr;
  fclose(f);
  return res;
}",0
Detect whether the following code contains vulnerabilities.,"RZ_IPI int fcn_cmpaddr(const void *_a, const void *_b) {
	const RzAnalysisFunction *a = _a, *b = _b;
	return (a->addr > b->addr) - (a->addr < b->addr);
}",0
Detect whether the following code contains vulnerabilities.,"static void sig_server_setup_fill_chatnet(IRC_SERVER_CONNECT_REC *conn,
					  IRC_CHATNET_REC *ircnet)
{
	if (!IS_IRC_SERVER_CONNECT(conn))
		return;
	g_return_if_fail(IS_IRCNET(ircnet));

	if (ircnet->nick != NULL) g_free_and_null(conn->alternate_nick);
	if (ircnet->usermode != NULL) {
		g_free_and_null(conn->usermode);
		conn->usermode = g_strdup(ircnet->usermode);
	}

	if (ircnet->max_kicks > 0) conn->max_kicks = ircnet->max_kicks;
	if (ircnet->max_msgs > 0) conn->max_msgs = ircnet->max_msgs;
	if (ircnet->max_modes > 0) conn->max_modes = ircnet->max_modes;
	if (ircnet->max_whois > 0) conn->max_whois = ircnet->max_whois;

	if (ircnet->max_cmds_at_once > 0)
		conn->max_cmds_at_once = ircnet->max_cmds_at_once;
	if (ircnet->cmd_queue_speed > 0)
		conn->cmd_queue_speed = ircnet->cmd_queue_speed;
	if (ircnet->max_query_chans > 0)
		conn->max_query_chans = ircnet->max_query_chans;
}",1
Detect whether the following code contains vulnerabilities.,"virDomainDefPostParseCheckFailure(virDomainDefPtr def,
                                  unsigned int parseFlags,
                                  int ret)
{
    if (ret != 0)
        def->postParseFailed = true;

    if (ret <= 0)
        return ret;

    if (!(parseFlags & VIR_DOMAIN_DEF_PARSE_ALLOW_POST_PARSE_FAIL))
        return -1;

    virResetLastError();
    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int oma_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    OMAContext *oc = s->priv_data;

    int packet_size = s->streams[0]->codec->block_align;

    int ret = av_get_packet(s->pb, pkt, packet_size);



    if (ret <= 0)

        return AVERROR(EIO);



    pkt->stream_index = 0;



    if (oc->encrypted) {

        /* previous unencrypted block saved in IV for

         * the next packet (CBC mode) */

        av_des_crypt(&oc->av_des, pkt->data, pkt->data,

                     (packet_size >> 3), oc->iv, 1);

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pl190_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = pl190_init;

    dc->no_user = 1;

    dc->reset = pl190_reset;

    dc->vmsd = &vmstate_pl190;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline ut32 r_read_ble32(const void *src, bool big_endian) {
	return big_endian? r_read_be32 (src): r_read_le32 (src);
}",0
Detect whether the following code contains vulnerabilities.,"static void backup_duplicate_context(MpegEncContext *bak, MpegEncContext *src){

#define COPY(a) bak->a= src->a

    COPY(allocated_edge_emu_buffer);

    COPY(edge_emu_buffer);

    COPY(me.scratchpad);

    COPY(me.temp);

    COPY(rd_scratchpad);

    COPY(b_scratchpad);

    COPY(obmc_scratchpad);

    COPY(me.map);

    COPY(me.score_map);

    COPY(blocks);

    COPY(block);

    COPY(start_mb_y);

    COPY(end_mb_y);

    COPY(me.map_generation);

    COPY(pb);

    COPY(dct_error_sum);

    COPY(dct_count[0]);

    COPY(dct_count[1]);

    COPY(ac_val_base);

    COPY(ac_val[0]);

    COPY(ac_val[1]);

    COPY(ac_val[2]);

#undef COPY

}
",1
Detect whether the following code contains vulnerabilities.,"static Status ValidateSavedTensors(const GraphDef& graph_def) {
  for (const auto& node : graph_def.node()) {
    const auto node_iterator = node.attr().find(""value"");
    if (node_iterator != node.attr().end()) {
      AttrValue node_value = node_iterator->second;
      if (node_value.has_tensor()) {
        const PartialTensorShape node_shape(node_value.tensor().tensor_shape());
        if (node_shape.num_elements() < 0) {
          return errors::FailedPrecondition(
              ""Saved model contains node \"""", node.name(), ""\"" (op \"""",
              node.op(), ""\"") which initializes from a tensor with "",
              node_shape.num_elements(), "" elements"");
        }
      }
    } else if (node.op() == ""Const"") {
      return errors::FailedPrecondition(
          ""Saved model contains node \"""", node.name(),
          ""\"" which is a constant tensor but no value has been provided"");
    }
  }
  return Status::OK();
}",1
Detect whether the following code contains vulnerabilities.,"static int pxb_bus_num(PCIBus *bus)

{

    PXBDev *pxb = PXB_DEV(bus->parent_dev);



    return pxb->bus_nr;

}
",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(radius_add_server)
{
	char *hostname, *secret;
	int hostname_len, secret_len;
	long  port, timeout, maxtries;
	radius_descriptor *raddesc;
	zval *z_radh;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,
		&hostname, &hostname_len,
		&port,
		&secret, &secret_len,
		&timeout, &maxtries) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);

	if (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}",0
Detect whether the following code contains vulnerabilities.,"void Http2FloodMitigationTest::floodServer(const Http2Frame& frame, const std::string& flood_stat) {
  // pack the as many frames as we can into 16k buffer
  const int FrameCount = (16 * 1024) / frame.size();
  std::vector<char> buf(FrameCount * frame.size());
  for (auto pos = buf.begin(); pos != buf.end();) {
    pos = std::copy(frame.begin(), frame.end(), pos);
  }

  tcp_client_->readDisable(true);
  int64_t total_bytes_sent = 0;
  // If the flood protection is not working this loop will keep going
  // forever until it is killed by blaze timer or run out of memory.
  // Add early stop if we have sent more than 100M of frames, as it this
  // point it is obvious something is wrong.
  while (total_bytes_sent < TransmitThreshold && tcp_client_->connected()) {
    tcp_client_->write({buf.begin(), buf.end()}, false, false);
    total_bytes_sent += buf.size();
  }

  EXPECT_LE(total_bytes_sent, TransmitThreshold) << ""Flood mitigation is broken."";
  EXPECT_EQ(1, test_server_->counter(flood_stat)->value());
  test_server_->waitForCounterGe(""http.config_test.downstream_cx_delayed_close_timeout"", 1);
}",0
Detect whether the following code contains vulnerabilities.,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;

	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	put_files_struct(req->work.files);
	req->work.files = NULL;
}",0
Detect whether the following code contains vulnerabilities.,"void dualminer_init_firstrun(struct cgpu_info *icarus)
{
	struct ICARUS_INFO *info = icarus->device_data;
	int fd = icarus->device_fd;

	dualminer_bootstrap_device(fd);

	if (opt_scrypt)
		gc3355_set_rts_status(fd, RTS_HIGH);

	gc3355_init(fd, opt_dualminer_sha2_gating, !opt_dual_mode);
	applog(LOG_DEBUG, ""%""PRIpreprv"": scrypt: %d, scrypt only: %d; have fan: %d\n"", icarus->proc_repr, opt_scrypt, opt_scrypt, opt_hubfans);

	if (gc3355_get_cts_status(fd) != 1)
	{
		// Scrypt + SHA2 mode
		if (opt_scrypt)
			info->Hs = DUALMINER_SCRYPT_DM_HASH_TIME;
	}

	if (opt_scrypt)
		icarus->min_nonce_diff = 1./0x10000;

	applog(LOG_DEBUG, ""%""PRIpreprv"": dualminer: Init: pll=%d, sha2num=%d"", icarus->proc_repr, opt_pll_freq, opt_sha2_number);
}",0
Detect whether the following code contains vulnerabilities.,"void replay_fetch_data_kind(void)

{

    if (replay_file) {

        if (!replay_has_unread_data) {

            replay_data_kind = replay_get_byte();

            if (replay_data_kind == EVENT_INSTRUCTION) {

                replay_state.instructions_count = replay_get_dword();

            }

            replay_check_error();

            replay_has_unread_data = 1;

            if (replay_data_kind >= EVENT_COUNT) {

                error_report(""Replay: unknown event kind %d"", replay_data_kind);

                exit(1);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,static inline bool is_timers_nohz_active(void) { return false; },0
Detect whether the following code contains vulnerabilities.,"  Item_cache_timestamp(THD *thd)
   :Item_cache(thd, &type_handler_timestamp2) { }",0
Detect whether the following code contains vulnerabilities.,"static unsigned long weighted_cpuload(const int cpu)
{
	return cpu_rq(cpu)->load.weight;
}",0
Detect whether the following code contains vulnerabilities.,"    unsigned int button() const {
      return _button;
    }",0
Detect whether the following code contains vulnerabilities.,"getouraddr(void)

{

	char buff[256];

	struct hostent *he = NULL;



	if (gethostname(buff,256) == 0)

            he = gethostbyname(buff);

        if (he)

            our_addr = *(struct in_addr *)he->h_addr;

        if (our_addr.s_addr == 0)

            our_addr.s_addr = loopback_addr.s_addr;

}
",1
Detect whether the following code contains vulnerabilities.,"static int iccrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int components, i, code = 0;
    ref *tempref, ICCdict, valref;

    code = array_get(imemory, space, 1, &ICCdict);
    if (code < 0)
        return code;
    code = dict_find_string(&ICCdict, ""N"", &tempref);
    if (code < 0)
        return code;
    if (code == 0)
        return gs_note_error(gs_error_undefined);
    components = tempref->value.intval;
    code = dict_find_string(&ICCdict, ""Range"", &tempref);
    if (code > 0 && !r_has_type(tempref, t_null)) {
        for (i=0;i<components * 2;i++) {
            code = array_get(imemory, tempref, i, &valref);
            if (code < 0)
                return code;
            if (r_has_type(&valref, t_integer))
                ptr[i] = (float)valref.value.intval;
            else
                ptr[i] = (float)valref.value.realval;
        }
    } else {
        for (i=0;i<components;i++) {
            ptr[i * 2] = 0;
            ptr[(i * 2) + 1] = 1;
        }
    }
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif,
				    unsigned int nfixedargs,
				    unsigned int ntotalargs)
{
  ffi_status status = ffi_prep_cif_machdep (cif);
  cif->aarch64_nfixedargs = nfixedargs;
  return status;
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_window_check1(DisasContext *dc, unsigned r1)

{

    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {

        return;

    }

    if (option_enabled(dc, XTENSA_OPTION_WINDOWED_REGISTER) &&

            r1 / 4 > dc->used_window) {

        TCGv_i32 pc = tcg_const_i32(dc->pc);

        TCGv_i32 w = tcg_const_i32(r1 / 4);



        dc->used_window = r1 / 4;

        gen_advance_ccount(dc);

        gen_helper_window_check(cpu_env, pc, w);



        tcg_temp_free(w);

        tcg_temp_free(pc);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"init_stack_with_value_at_exception_boundary (VerifyContext *ctx, ILCodeDesc *code, MonoClass *klass)
{
	MonoError error;
	MonoType *type = mono_class_inflate_generic_type_checked (&klass->byval_arg, ctx->generic_context, &error);

	if (!mono_error_ok (&error)) {
		char *name = mono_type_get_full_name (klass);
		ADD_VERIFY_ERROR (ctx, g_strdup_printf (""Invalid class %s used for exception"", name));
		g_free (name);
		mono_error_cleanup (&error);
		return;
	}

	if (!ctx->max_stack) {
		ADD_VERIFY_ERROR (ctx, g_strdup_printf (""Stack overflow at 0x%04x"", ctx->ip_offset));
		return;
	}

	stack_init (ctx, code);
	set_stack_value (ctx, code->stack, type, FALSE);
	ctx->exception_types = g_slist_prepend (ctx->exception_types, type);
	code->size = 1;
	code->flags |= IL_CODE_FLAG_WAS_TARGET;
	if (mono_type_is_generic_argument (type))
		code->stack->stype |= BOXED_MASK;
}",0
Detect whether the following code contains vulnerabilities.,"static always_inline int dv_rl2vlc(int run, int l, uint32_t* vlc)

{

    *vlc = dv_vlc_map[run][((uint16_t)l)&0x1ff].vlc;

    return dv_vlc_map[run][((uint16_t)l)&0x1ff].size;

}
",0
Detect whether the following code contains vulnerabilities.,"void cpu_x86_update_cr0(CPUX86State *env)

{

    int pg_state, pe_state;



#if defined(DEBUG_MMU)

    printf(""CR0 update: CR0=0x%08x\n"", env->cr[0]);

#endif

    pg_state = env->cr[0] & CR0_PG_MASK;

    if (pg_state != last_pg_state) {

        tlb_flush(env);

        last_pg_state = pg_state;

    }

    /* update PE flag in hidden flags */

    pe_state = (env->cr[0] & CR0_PE_MASK);

    env->hflags = (env->hflags & ~HF_PE_MASK) | (pe_state << HF_PE_SHIFT);

    /* ensure that ADDSEG is always set in real mode */

    env->hflags |= ((pe_state ^ 1) << HF_ADDSEG_SHIFT);

}
",0
Detect whether the following code contains vulnerabilities.,"HandShakeState& States::useHandShake()
{
    return handshakeLayer_;
}",0
Detect whether the following code contains vulnerabilities.,"static int sr_read_reg(struct usbnet *dev, u8 reg, u8 *value)
{
	return sr_read(dev, reg, 1, value);
}",0
Detect whether the following code contains vulnerabilities.,"int auth_spa_server(auth_instance *ablock, uschar *data) {return 0;}",1
Detect whether the following code contains vulnerabilities.,"void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint32_t val = data;

    if (addr > (vdev->config_len - sizeof(val)))
        return;

    stl_p(vdev->config + addr, val);

    if (k->set_config) {
        k->set_config(vdev, vdev->config);
    }
}",1
Detect whether the following code contains vulnerabilities.,"f_luaeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];

    str = tv_get_string_buf(&argvars[0], buf);
    do_luaeval(str, argvars + 1, rettv);
}",1
Detect whether the following code contains vulnerabilities.,"uint32_t smbXcli_tcon_get_fs_attributes(struct smbXcli_tcon *tcon)
{
	return tcon->fs_attributes;
}",0
Detect whether the following code contains vulnerabilities.,"int X509_check_trust(X509 *x, int id, int flags)
{
    X509_TRUST *pt;
    int idx;

    /* We get this as a default value */
    if (id == 0) {
        int rv;
        rv = obj_trust(NID_anyExtendedKeyUsage, x, 0);
        if (rv != X509_TRUST_UNTRUSTED)
            return rv;
        return trust_compat(NULL, x, 0);
    }
    idx = X509_TRUST_get_by_id(id);
    if (idx == -1)
        return default_trust(id, x, flags);
    pt = X509_TRUST_get0(idx);
    return pt->check_trust(pt, x, flags);
}",1
Detect whether the following code contains vulnerabilities.,    ~Interruptible_wait() {},0
Detect whether the following code contains vulnerabilities.,"ENTROPY_DEBUG(const char *label, unsigned long entropy) {
  const char *const EXPAT_ENTROPY_DEBUG = getenv(""EXPAT_ENTROPY_DEBUG"");
  if (EXPAT_ENTROPY_DEBUG && ! strcmp(EXPAT_ENTROPY_DEBUG, ""1"")) {
    fprintf(stderr, ""Entropy: %s --> 0x%0*lx (%lu bytes)\n"", label,
            (int)sizeof(entropy) * 2, entropy, (unsigned long)sizeof(entropy));
  }
  return entropy;
}",0
Detect whether the following code contains vulnerabilities.,"bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)
{
	unsigned long current_rip = kvm_rip_read(vcpu) +
		get_segment_base(vcpu, VCPU_SREG_CS);

	return current_rip == linear_rip;
}",0
Detect whether the following code contains vulnerabilities.,"void load_cgroup(const char *fname) {
	if (!fname)
		return;

	FILE *fp = fopen(fname, ""re"");
	if (fp) {
		char buf[MAXBUF];
		if (fgets(buf, MAXBUF, fp)) {
			cfg.cgroup = strdup(buf);
			if (!cfg.cgroup)
				errExit(""strdup"");
		}
		else
			goto errout;

		fclose(fp);
		return;
	}
errout:
	fwarning(""cannot load control group\n"");
	if (fp)
		fclose(fp);
}",1
Detect whether the following code contains vulnerabilities.,"static void framebuffer_update_request(VncState *vs, int incremental,

                                       int x_position, int y_position,

                                       int w, int h)

{

    int i;

    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;

    const size_t height = surface_height(vs->vd->ds);



    if (y_position > height) {

        y_position = height;

    }

    if (y_position + h >= height) {

        h = height - y_position;

    }



    vs->need_update = 1;

    if (!incremental) {

        vs->force_update = 1;

        for (i = 0; i < h; i++) {

            bitmap_set(vs->dirty[y_position + i], 0, width);

            bitmap_clear(vs->dirty[y_position + i], width,

                         VNC_DIRTY_BITS - width);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int rac_get_model256_sym(RangeCoder *c, Model256 *m)

{

    int prob, prob2, helper, val;

    int start, end;

    int ssym;



    prob2      = c->range;

    c->range >>= MODEL_SCALE;



    helper     = c->low / c->range;

    ssym       = helper >> MODEL256_SEC_SCALE;

    val        = m->secondary[ssym];



    end = start = m->secondary[ssym + 1] + 1;

    while (end > val + 1) {

        ssym = (end + val) >> 1;

        if (m->freqs[ssym] <= helper) {

            end = start;

            val = ssym;

        } else {

            end   = (end + val) >> 1;

            start = ssym;

        }

    }

    prob = m->freqs[val] * c->range;

    if (val != 255)

        prob2 = m->freqs[val + 1] * c->range;



    c->low  -= prob;

    c->range = prob2 - prob;

    if (c->range < RAC_BOTTOM)

        rac_normalise(c);



    model256_update(m, val);



    return val;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ath6kl_usb_free_urb_to_pipe(struct ath6kl_usb_pipe *pipe,
					struct ath6kl_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;

	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",1
Detect whether the following code contains vulnerabilities.,"static Picture * remove_short(H264Context *h, int frame_num){

    MpegEncContext * const s = &h->s;

    int i;



    if(s->avctx->debug&FF_DEBUG_MMCO)

        av_log(h->s.avctx, AV_LOG_DEBUG, ""remove short %d count %d\n"", frame_num, h->short_ref_count);



    for(i=0; i<h->short_ref_count; i++){

        Picture *pic= h->short_ref[i];

        if(s->avctx->debug&FF_DEBUG_MMCO)

            av_log(h->s.avctx, AV_LOG_DEBUG, ""%d %d %p\n"", i, pic->frame_num, pic);

        if(pic->frame_num == frame_num){

            h->short_ref[i]= NULL;

            memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count - i - 1)*sizeof(Picture*));

            h->short_ref_count--;

            return pic;

        }

    }

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static int xan_decode_end(AVCodecContext *avctx)

{

    XanContext *s = avctx->priv_data;



    /* release the last frame */

    avctx->release_buffer(avctx, &s->last_frame);



    av_free(s->buffer1);

    av_free(s->buffer2);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"PackLinuxElf32armBe::buildLoader(Filter const *ft)
{
    buildLinuxLoader(
        stub_armeb_v4a_linux_elf_entry, sizeof(stub_armeb_v4a_linux_elf_entry),
        stub_armeb_v4a_linux_elf_fold,  sizeof(stub_armeb_v4a_linux_elf_fold), ft);
}",0
Detect whether the following code contains vulnerabilities.,"void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const
{
    ParaNdis_CheckSumVerifyFlat(IpHeader,
                                EthPayloadLength,
                                pcrIpChecksum | pcrFixIPChecksum,
                                __FUNCTION__);
}",1
Detect whether the following code contains vulnerabilities.,"static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||
	    put_user(kp->type, &up->type) ||
	    copy_to_user(&up->u, &kp->u, sizeof(kp->u)) ||
	    put_user(kp->pending, &up->pending) ||
	    put_user(kp->sequence, &up->sequence) ||
	    put_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||
	    put_user(kp->timestamp.tv_nsec, &up->timestamp.tv_nsec) ||
	    put_user(kp->id, &up->id) ||
	    copy_to_user(up->reserved, kp->reserved, sizeof(kp->reserved)))
		return -EFAULT;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void platform_fixed_ioport_init(PCIXenPlatformState* s)

{

    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 4, platform_fixed_ioport_writel, s);

    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_writew, s);

    register_ioport_write(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_writeb, s);

    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 2, platform_fixed_ioport_readw, s);

    register_ioport_read(XEN_PLATFORM_IOPORT, 16, 1, platform_fixed_ioport_readb, s);

}
",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(SplDoublyLinkedList, pop)
{
	zval *value;
	spl_dllist_object *intern;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, """") == FAILURE) {
		return;
	}

	intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	value = (zval *)spl_ptr_llist_pop(intern->llist TSRMLS_CC);

	if (value == NULL) {
		zend_throw_exception(spl_ce_RuntimeException, ""Can't pop from an empty datastructure"", 0 TSRMLS_CC);
		return;
	}

	RETURN_ZVAL(value, 1, 1);
} ",1
Detect whether the following code contains vulnerabilities.,"g_malloc(size_t n_bytes)

{

    void *mem;

    __coverity_negative_sink__(n_bytes);

    mem = malloc(n_bytes == 0 ? 1 : n_bytes);

    if (!mem) __coverity_panic__();

    return mem;

}
",1
Detect whether the following code contains vulnerabilities.,"static int inet_connect_addr(struct addrinfo *addr, bool block,

                             bool *in_progress)

{

    int sock, rc;



    if (in_progress) {

        *in_progress = false;

    }



    sock = qemu_socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);

    if (sock < 0) {

        fprintf(stderr, ""%s: socket(%s): %s\n"", __func__,

                inet_strfamily(addr->ai_family), strerror(errno));

        return -1;

    }

    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));

    if (!block) {

        socket_set_nonblock(sock);

    }

    /* connect to peer */

    do {

        rc = 0;

        if (connect(sock, addr->ai_addr, addr->ai_addrlen) < 0) {

            rc = -socket_error();

        }

    } while (rc == -EINTR);



    if (!block && QEMU_SOCKET_RC_INPROGRESS(rc)) {

        if (in_progress) {

            *in_progress = true;

        }

    } else if (rc < 0) {

        closesocket(sock);

        return -1;

    }

    return sock;

}
",1
Detect whether the following code contains vulnerabilities.,"static void cirrus_mmio_write(void *opaque, target_phys_addr_t addr,

                              uint64_t val, unsigned size)

{

    CirrusVGAState *s = opaque;



    if (addr >= 0x100) {

	cirrus_mmio_blt_write(s, addr - 0x100, val);

    } else {

        cirrus_vga_ioport_write(s, addr + 0x3c0, val);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void jbd2_journal_wait_updates(journal_t *journal)
{
	transaction_t *commit_transaction = journal->j_running_transaction;

	if (!commit_transaction)
		return;

	spin_lock(&commit_transaction->t_handle_lock);
	while (atomic_read(&commit_transaction->t_updates)) {
		DEFINE_WAIT(wait);

		prepare_to_wait(&journal->j_wait_updates, &wait,
					TASK_UNINTERRUPTIBLE);
		if (atomic_read(&commit_transaction->t_updates)) {
			spin_unlock(&commit_transaction->t_handle_lock);
			write_unlock(&journal->j_state_lock);
			schedule();
			write_lock(&journal->j_state_lock);
			spin_lock(&commit_transaction->t_handle_lock);
		}
		finish_wait(&journal->j_wait_updates, &wait);
	}
	spin_unlock(&commit_transaction->t_handle_lock);
}",1
Detect whether the following code contains vulnerabilities.,"GetLastSegSwitchTime(void)
{
	pg_time_t	result;

	/* Need WALWriteLock, but shared lock is sufficient */
	LWLockAcquire(WALWriteLock, LW_SHARED);
	result = XLogCtl->lastSegSwitchTime;
	LWLockRelease(WALWriteLock);

	return result;
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_rfci(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    /* Restore CPU state */

    gen_helper_rfci(cpu_env);

    gen_sync_exception(ctx);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"int usbredirparser_have_cap(struct usbredirparser *parser_pub, int cap)
{
    struct usbredirparser_priv *parser =
        (struct usbredirparser_priv *)parser_pub;
    return usbredirparser_caps_get_cap(parser, parser->our_caps, cap);
}",0
Detect whether the following code contains vulnerabilities.,"static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {
	int i;
	int chsz = 1;
	// r_socket_block_time (s, 1, 1, 0);
	if (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {
		return 0;
	}
	for (i = 1; i < bufsz; i += chsz) {
		buf[i] =0;
		r_socket_block_time (s, 1, 0, 1000);
		int olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);
		if (olen != chsz) {
			buf[i] = 0;
			break;
		}
	}
	return i;
}",1
Detect whether the following code contains vulnerabilities.,"void qdict_del(QDict *qdict, const char *key)

{

    QDictEntry *entry;



    entry = qdict_find(qdict, key, tdb_hash(key) % QDICT_HASH_SIZE);

    if (entry) {

        LIST_REMOVE(entry, next);

        qentry_destroy(entry);

        qdict->size--;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"BitStream::skipToNextByte()
{
    if (bit_offset != 7)
    {
	unsigned int bits_to_skip = bit_offset + 1;
	if (bits_available < bits_to_skip)
	{
	    throw std::logic_error(
		""INTERNAL ERROR: overflow skipping to next byte in bitstream"");
	}
	bit_offset = 7;
	++p;
	bits_available -= bits_to_skip;
    }
}",1
Detect whether the following code contains vulnerabilities.,"	void testCompareRangeHelper(const char * a, const char * b, int expected, bool avoidNullRange = true) {
		UriTextRangeA ra;
		UriTextRangeA rb;

		if (a) {
			ra.first = a;
			ra.afterLast = a + strlen(a);
		} else {
			ra.first = NULL;
			ra.afterLast = NULL;
		}

		if (b) {
			rb.first = b;
			rb.afterLast = b + strlen(b);
		} else {
			rb.first = NULL;
			rb.afterLast = NULL;
		}

		const int received = uriCompareRangeA(
				((a == NULL) && avoidNullRange) ? NULL : &ra,
				((b == NULL) && avoidNullRange) ? NULL : &rb);
		if (received != expected) {
			printf(""Comparing <%s> to <%s> yields %d, expected %d.\n"",
					a, b, received, expected);
		}
		TEST_ASSERT(received == expected);
	}",0
Detect whether the following code contains vulnerabilities.,"void spapr_drc_detach(sPAPRDRConnector *drc, DeviceState *d, Error **errp)

{

    trace_spapr_drc_detach(spapr_drc_index(drc));



    if (drc->isolation_state != SPAPR_DR_ISOLATION_STATE_ISOLATED) {

        trace_spapr_drc_awaiting_isolated(spapr_drc_index(drc));

        drc->awaiting_release = true;

        return;

    }



    if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&

        drc->allocation_state != SPAPR_DR_ALLOCATION_STATE_UNUSABLE) {

        trace_spapr_drc_awaiting_unusable(spapr_drc_index(drc));

        drc->awaiting_release = true;

        return;

    }



    if (drc->awaiting_allocation) {

        drc->awaiting_release = true;

        trace_spapr_drc_awaiting_allocation(spapr_drc_index(drc));

        return;

    }



    spapr_drc_release(drc);

}
",1
Detect whether the following code contains vulnerabilities.,"    Document getSpec() {
        return DOC(""input"" << DOC_ARRAY(DOC_ARRAY(0)) << ""expected""
                           << DOC(""$allElementsTrue"" << false << ""$anyElementTrue"" << false));
    }",0
Detect whether the following code contains vulnerabilities.,"static void piix4_device_unplug_request_cb(HotplugHandler *hotplug_dev,

                                           DeviceState *dev, Error **errp)

{

    PIIX4PMState *s = PIIX4_PM(hotplug_dev);



    if (s->acpi_memory_hotplug.is_enabled &&

        object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM)) {

        acpi_memory_unplug_request_cb(hotplug_dev, &s->acpi_memory_hotplug,

                                      dev, errp);

    } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {

        acpi_pcihp_device_unplug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev,

                                    errp);

    } else if (object_dynamic_cast(OBJECT(dev), TYPE_CPU) &&

               !s->cpu_hotplug_legacy) {

        acpi_cpu_unplug_request_cb(hotplug_dev, &s->cpuhp_state, dev, errp);

    } else {

        error_setg(errp, ""acpi: device unplug request for not supported device""

                   "" type: %s"", object_get_typename(OBJECT(dev)));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static target_ulong h_random(PowerPCCPU *cpu, sPAPRMachineState *spapr,

                             target_ulong opcode, target_ulong *args)

{

    sPAPRRngState *rngstate;

    HRandomData hrdata;



    rngstate = SPAPR_RNG(object_resolve_path_type("""", TYPE_SPAPR_RNG, NULL));



    if (!rngstate || !rngstate->backend) {

        return H_HARDWARE;

    }



    qemu_sem_init(&hrdata.sem, 0);

    hrdata.val.v64 = 0;

    hrdata.received = 0;



    qemu_mutex_unlock_iothread();

    while (hrdata.received < 8) {

        rng_backend_request_entropy(rngstate->backend, 8 - hrdata.received,

                                    random_recv, &hrdata);

        qemu_sem_wait(&hrdata.sem);

    }

    qemu_mutex_lock_iothread();



    qemu_sem_destroy(&hrdata.sem);

    args[0] = hrdata.val.v64;



    return H_SUCCESS;

}
",1
Detect whether the following code contains vulnerabilities.,"static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)
{
	int err = 0;
	UNIXCB(skb).pid  = get_pid(scm->pid);
	UNIXCB(skb).cred = get_cred(scm->cred);
	UNIXCB(skb).fp = NULL;
	if (scm->fp && send_fds)
		err = unix_attach_fds(scm, skb);

	skb->destructor = unix_destruct_scm;
	return err;
}",1
Detect whether the following code contains vulnerabilities.,"void laio_cleanup(void *s_)
{
    struct qemu_laio_state *s = s_;
    event_notifier_cleanup(&s->e);
    g_free(s);",1
Detect whether the following code contains vulnerabilities.,"static int b43_op_beacon_set_tim(struct ieee80211_hw *hw,
				 struct ieee80211_sta *sta, bool set)
{
	struct b43_wl *wl = hw_to_b43_wl(hw);

	/* FIXME: add locking */
	b43_update_templates(wl);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int main(int argc, char** argv)

{

    FILE *f= fopen(argv[1], ""rb+"");

    int count= atoi(argv[2]);

    int maxburst= atoi(argv[3]);

    int length;



    srand (time (0));



    fseek(f, 0, SEEK_END);

    length= ftell(f);

    fseek(f, 0, SEEK_SET);



    while(count--){

        int burst= 1 + random() * (uint64_t) (abs(maxburst)-1) / RAND_MAX;

        int pos= random() * (uint64_t) length / RAND_MAX;

        fseek(f, pos, SEEK_SET);



        if(maxburst<0) burst= -maxburst;



        if(pos + burst > length)

            continue;



        while(burst--){

            int val= random() * 256ULL / RAND_MAX;



            if(maxburst<0) val=0;



            fwrite(&val, 1, 1, f);

        }

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_cond_signal(QemuCond *cond)

{

    DWORD result;



    /*

     * Signal only when there are waiters.  cond->waiters is

     * incremented by pthread_cond_wait under the external lock,

     * so we are safe about that.

     */

    if (cond->waiters == 0) {

        return;

    }



    /*

     * Waiting threads decrement it outside the external lock, but

     * only if another thread is executing pthread_cond_broadcast and

     * has the mutex.  So, it also cannot be decremented concurrently

     * with this particular access.

     */

    cond->target = cond->waiters - 1;

    result = SignalObjectAndWait(cond->sema, cond->continue_event,

                                 INFINITE, FALSE);

    if (result == WAIT_ABANDONED || result == WAIT_FAILED) {

        error_exit(GetLastError(), __func__);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t block_save_pending(QEMUFile *f, void *opaque, uint64_t max_size)

{

    /* Estimate pending number of bytes to send */

    uint64_t pending;



    qemu_mutex_lock_iothread();

    blk_mig_lock();

    pending = get_remaining_dirty() +

                       block_mig_state.submitted * BLOCK_SIZE +

                       block_mig_state.read_done * BLOCK_SIZE;



    /* Report at least one block pending during bulk phase */

    if (pending == 0 && !block_mig_state.bulk_completed) {

        pending = BLOCK_SIZE;

    }

    blk_mig_unlock();

    qemu_mutex_unlock_iothread();



    DPRINTF(""Enter save live pending  %"" PRIu64 ""\n"", pending);

    return pending;

}
",1
Detect whether the following code contains vulnerabilities.,"static int gset_decode_next_bit(gset_decoder *decoder)
{
    if (++decoder->bit >= 8) {
        if (++decoder->offset >= decoder->datalen) {
            return -1;
        }
        decoder->bit = 0;
    }
    return (decoder->data[decoder->offset] & cbit_mask[decoder->bit])? 1 : 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void alloc_picture(void *opaque)

{

    VideoState *is = opaque;

    VideoPicture *vp;



    vp = &is->pictq[is->pictq_windex];



    if (vp->bmp)

        SDL_FreeYUVOverlay(vp->bmp);



#if CONFIG_AVFILTER

    if (vp->picref)

        avfilter_unref_buffer(vp->picref);

    vp->picref = NULL;



    vp->width   = is->out_video_filter->inputs[0]->w;

    vp->height  = is->out_video_filter->inputs[0]->h;

    vp->pix_fmt = is->out_video_filter->inputs[0]->format;

#else

    vp->width   = is->video_st->codec->width;

    vp->height  = is->video_st->codec->height;

    vp->pix_fmt = is->video_st->codec->pix_fmt;

#endif



    vp->bmp = SDL_CreateYUVOverlay(vp->width, vp->height,

                                   SDL_YV12_OVERLAY,

                                   screen);











    SDL_LockMutex(is->pictq_mutex);

    vp->allocated = 1;

    SDL_CondSignal(is->pictq_cond);

    SDL_UnlockMutex(is->pictq_mutex);
",1
Detect whether the following code contains vulnerabilities.,"static u32 txclk_tx_s_max_pulse_width(struct cx23885_dev *dev, u32 ns,
				      u16 *divider)
{
	u64 pulse_clocks;

	if (ns > IR_MAX_DURATION)
		ns = IR_MAX_DURATION;
	pulse_clocks = ns_to_pulse_clocks(ns);
	*divider = pulse_clocks_to_clock_divider(pulse_clocks);
	cx23888_ir_write4(dev, CX23888_IR_TXCLK_REG, *divider);
	return (u32) pulse_width_count_to_ns(FIFO_RXTX, *divider);
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t online_show(struct device *dev, struct device_attribute *attr,
			   char *buf)
{
	bool val;

	device_lock(dev);
	val = !dev->offline;
	device_unlock(dev);
	return sprintf(buf, ""%u\n"", val);
}",1
Detect whether the following code contains vulnerabilities.,"static int __init skcipher_module_init(void)
{
	skcipher_default_geniv = num_possible_cpus() > 1 ?
				 ""eseqiv"" : ""chainiv"";
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"png_build_grayscale_palette(int bit_depth, png_colorp palette)
{
   int num_palette;
   int color_inc;
   int i;
   int v;

   png_debug(1, ""in png_do_build_grayscale_palette"");

   if (palette == NULL)
      return;

   switch (bit_depth)
   {
      case 1:
         num_palette = 2;
         color_inc = 0xff;
         break;

      case 2:
         num_palette = 4;
         color_inc = 0x55;
         break;

      case 4:
         num_palette = 16;
         color_inc = 0x11;
         break;

      case 8:
         num_palette = 256;
         color_inc = 1;
         break;

      default:
         num_palette = 0;
         color_inc = 0;
         break;
   }

   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
   {
      palette[i].red = (png_byte)(v & 0xff);
      palette[i].green = (png_byte)(v & 0xff);
      palette[i].blue = (png_byte)(v & 0xff);
   }
}",0
Detect whether the following code contains vulnerabilities.,"BitWriter::flush()
{
    if (bit_offset < 7)
    {
	int bits_to_write = bit_offset + 1;
	write_bits(this->ch, this->bit_offset, 0, bits_to_write, this->pl);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int uas_pre_reset(struct usb_interface *intf)
{
	struct Scsi_Host *shost = usb_get_intfdata(intf);
	struct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;
	unsigned long flags;

	if (devinfo->shutdown)
		return 0;

	/* Block new requests */
	spin_lock_irqsave(shost->host_lock, flags);
	scsi_block_requests(shost);
	spin_unlock_irqrestore(shost->host_lock, flags);

	if (uas_wait_for_pending_cmnds(devinfo) != 0) {
		shost_printk(KERN_ERR, shost, ""%s: timed out\n"", __func__);
		scsi_unblock_requests(shost);
		return 1;
	}

	uas_free_streams(devinfo);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int sco_send_frame(struct sock *sk, void *buf, int len,
			  unsigned int msg_flags)
{
	struct sco_conn *conn = sco_pi(sk)->conn;
	struct sk_buff *skb;
	int err;

	/* Check outgoing MTU */
	if (len > conn->mtu)
		return -EINVAL;

	BT_DBG(""sk %p len %d"", sk, len);

	skb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);
	if (!skb)
		return err;

	memcpy(skb_put(skb, len), buf, len);
	hci_send_sco(conn->hcon, skb);

	return len;
}",1
Detect whether the following code contains vulnerabilities.,"static void apply_mid_side_stereo(ChannelElement *cpe)

{

    int w, w2, g, i;

    IndividualChannelStream *ics = &cpe->ch[0].ics;

    if (!cpe->common_window)

        return;

    for (w = 0; w < ics->num_windows; w += ics->group_len[w]) {

        for (w2 =  0; w2 < ics->group_len[w]; w2++) {

            int start = (w+w2) * 128;

            for (g = 0; g < ics->num_swb; g++) {

                if (!cpe->ms_mask[w*16 + g]) {

                    start += ics->swb_sizes[g];

                    continue;

                }

                for (i = 0; i < ics->swb_sizes[g]; i++) {

                    float L = (cpe->ch[0].coeffs[start+i] + cpe->ch[1].coeffs[start+i]) * 0.5f;

                    float R = L - cpe->ch[1].coeffs[start+i];

                    cpe->ch[0].coeffs[start+i] = L;

                    cpe->ch[1].coeffs[start+i] = R;

                }

                start += ics->swb_sizes[g];

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static char *sieve_srs_forward(char *return_path)
{
    const char *srs_domain = config_getstring(IMAPOPT_SRS_DOMAIN);
    char *srs_return_path = NULL;
    int srs_status;

    if (!srs_engine) {
        /* SRS not enabled */
        return NULL;
    }

    srs_status = srs_forward_alloc(srs_engine, &srs_return_path,
                                   return_path, srs_domain);

    if (srs_status != SRS_SUCCESS) {
        syslog(LOG_ERR, ""sieve SRS forward failed (%s, %s): %s"",
               return_path, srs_domain, srs_strerror(srs_status));
        if (srs_return_path) {
            free(srs_return_path);
            srs_return_path = NULL;
        }
    }

    return srs_return_path;
}",0
Detect whether the following code contains vulnerabilities.,"keyval_sort(struct keyval *kv)
{
  struct onekeyval *head;
  struct onekeyval *okv;
  struct onekeyval *sokv;

  if (!kv || !kv->head)
    return;

  head = kv->head;
  for (okv = kv->head; okv; okv = okv->next)
    {
      okv->sort = NULL;
      for (sokv = kv->head; sokv; sokv = sokv->next)
	{
	  // We try to find a name which is greater than okv->name
	  // but less than our current candidate (okv->sort->name)
	  if ( (strcmp(sokv->name, okv->name) > 0) &&
	       ((okv->sort == NULL) || (strcmp(sokv->name, okv->sort->name) < 0)) )
	    okv->sort = sokv;
	}

      // Find smallest name, which will be the new head
      if (strcmp(okv->name, head->name) < 0)
	head = okv;
    }

  while ((okv = kv->head))
    {
      kv->head  = okv->next;
      okv->next = okv->sort;
    }

  kv->head = head;
  for (okv = kv->head; okv; okv = okv->next)
    kv->tail = okv;

  DPRINTF(E_DBG, L_MISC, ""Keyval sorted. New head: %s. New tail: %s.\n"", kv->head->name, kv->tail->name);
}",0
Detect whether the following code contains vulnerabilities.,"static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,
				     int off_pitch, int bytesperline,
				     int lines)
{
    int y;
    int off_cur;
    int off_cur_end;

    for (y = 0; y < lines; y++) {
	off_cur = off_begin;
	off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;
        memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);
	off_begin += off_pitch;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int skcipher_done_slow(struct skcipher_walk *walk, unsigned int bsize)
{
	u8 *addr;

	addr = (u8 *)ALIGN((unsigned long)walk->buffer, walk->alignmask + 1);
	addr = skcipher_get_spot(addr, bsize);
	scatterwalk_copychunks(addr, &walk->out, bsize,
			       (walk->flags & SKCIPHER_WALK_PHYS) ? 2 : 1);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void cmd_test_unit_ready(IDEState *s, uint8_t *buf)

{

    if (bdrv_is_inserted(s->bs)) {

        ide_atapi_cmd_ok(s);

    } else {

        ide_atapi_cmd_error(s, SENSE_NOT_READY, ASC_MEDIUM_NOT_PRESENT);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gdb_vm_stopped(void *opaque, int reason)

{

    GDBState *s = opaque;

    char buf[256];

    const char *type;

    int ret;



    if (s->state == RS_SYSCALL)

        return;



    /* disable single step if it was enable */

    cpu_single_step(s->env, 0);



    if (reason == EXCP_DEBUG) {

        if (s->env->watchpoint_hit) {

            switch (s->env->watchpoint_hit->flags & BP_MEM_ACCESS) {

            case BP_MEM_READ:

                type = ""r"";

                break;

            case BP_MEM_ACCESS:

                type = ""a"";

                break;

            default:

                type = """";

                break;

            }

            snprintf(buf, sizeof(buf), ""T%02x%swatch:"" TARGET_FMT_lx "";"",

                     SIGTRAP, type, s->env->watchpoint_hit->vaddr);

            put_packet(s, buf);

            s->env->watchpoint_hit = NULL;

            return;

        }

	tb_flush(s->env);

        ret = SIGTRAP;

    } else if (reason == EXCP_INTERRUPT) {

        ret = SIGINT;

    } else {

        ret = 0;

    }

    snprintf(buf, sizeof(buf), ""S%02x"", ret);

    put_packet(s, buf);

}
",0
Detect whether the following code contains vulnerabilities.,"olsr_print_neighbor(netdissect_options *ndo,
                    const u_char *msg_data, u_int hello_len)
{
    int neighbor;

    ND_PRINT((ndo, ""\n\t      neighbor\n\t\t""));
    neighbor = 1;

    while (hello_len >= sizeof(struct in_addr)) {

        if (!ND_TTEST2(*msg_data, sizeof(struct in_addr)))
            return (-1);
        /* print 4 neighbors per line */

        ND_PRINT((ndo, ""%s%s"", ipaddr_string(ndo, msg_data),
               neighbor % 4 == 0 ? ""\n\t\t"" : "" ""));

        msg_data += sizeof(struct in_addr);
        hello_len -= sizeof(struct in_addr);
    }
    return (0);
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_blk_dma_restart_cb(void *opaque, int running, int reason)

{

    VirtIOBlock *s = opaque;

    VirtIOBlockReq *req = s->rq;



    if (!running)

        return;



    s->rq = NULL;



    while (req) {

        virtio_blk_handle_write(req);

        req = req->next;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_cpu_is_self(void *env)

{

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_sysexit(void)

{

    int cpl;



    cpl = env->hflags & HF_CPL_MASK;

    if (env->sysenter_cs == 0 || cpl != 0) {

        raise_exception_err(EXCP0D_GPF, 0);

    }

    cpu_x86_set_cpl(env, 3);

    cpu_x86_load_seg_cache(env, R_CS, ((env->sysenter_cs + 16) & 0xfffc) | 3,

                           0, 0xffffffff,

                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |

                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |

                           DESC_CS_MASK | DESC_R_MASK | DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_SS, ((env->sysenter_cs + 24) & 0xfffc) | 3,

                           0, 0xffffffff,

                           DESC_G_MASK | DESC_B_MASK | DESC_P_MASK |

                           DESC_S_MASK | (3 << DESC_DPL_SHIFT) |

                           DESC_W_MASK | DESC_A_MASK);

    ESP = ECX;

    EIP = EDX;

#ifdef USE_KQEMU

    if (kqemu_is_ok(env)) {

        env->exception_index = -1;

        cpu_loop_exit();

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"njs_vm_add_path(njs_vm_t *vm, const njs_str_t *path)
{
    njs_str_t  *item;

    if (vm->paths == NULL) {
        vm->paths = njs_arr_create(vm->mem_pool, 4, sizeof(njs_str_t));
        if (njs_slow_path(vm->paths == NULL)) {
            return NJS_ERROR;
        }
    }

    item = njs_arr_add(vm->paths);
    if (njs_slow_path(item == NULL)) {
        return NJS_ERROR;
    }

    *item = *path;

    return NJS_OK;
}",0
Detect whether the following code contains vulnerabilities.,"static int add_metadata(int count, int type,

                        const char *name, const char *sep, TiffContext *s)

{

    switch(type) {

    case TIFF_DOUBLE: return add_doubles_metadata(count, name, sep, s);

    case TIFF_SHORT : return add_shorts_metadata(count, name, sep, s);

    case TIFF_STRING: return add_string_metadata(count, name, s);

    default         : return AVERROR_INVALIDDATA;

    };

}
",1
Detect whether the following code contains vulnerabilities.,"static void ptirq_free_irte(const struct ptirq_remapping_info *entry)
{
	struct intr_source intr_src;

	if (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {
		if (entry->intr_type == PTDEV_INTR_MSI) {
			intr_src.is_msi = true;
			intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		} else {
			intr_src.is_msi = false;
			intr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);
		}
		dmar_free_irte(&intr_src, entry->irte_idx);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static void test_validate_list(TestInputVisitorData *data,

                                const void *unused)

{

    UserDefOneList *head = NULL;

    Visitor *v;



    v = validate_test_init(data, ""[ { 'string': 'string0', 'integer': 42 }, { 'string': 'string1', 'integer': 43 }, { 'string': 'string2', 'integer': 44 } ]"");



    visit_type_UserDefOneList(v, NULL, &head, &error_abort);

    qapi_free_UserDefOneList(head);

}
",0
Detect whether the following code contains vulnerabilities.,"VTermState *vterm_obtain_state(VTerm *vt)
{
  VTermState *state;
  if(vt->state)
    return vt->state;

  state = vterm_state_new(vt);
  vt->state = state;

  state->combine_chars_size = 16;
  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));

  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);

  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));

  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');
  if(*state->encoding_utf8.enc->init != NULL)
    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);

  vterm_parser_set_callbacks(vt, &parser_callbacks, state);

  return state;
}",1
Detect whether the following code contains vulnerabilities.,"void kvm_init_cpu_signals(CPUState *cpu)

{

    int r;

    sigset_t set;

    struct sigaction sigact;



    memset(&sigact, 0, sizeof(sigact));

    sigact.sa_handler = dummy_signal;

    sigaction(SIG_IPI, &sigact, NULL);



    pthread_sigmask(SIG_BLOCK, NULL, &set);

#if defined KVM_HAVE_MCE_INJECTION

    sigdelset(&set, SIGBUS);

    pthread_sigmask(SIG_SETMASK, &set, NULL);

#endif

    sigdelset(&set, SIG_IPI);

    r = kvm_set_signal_mask(cpu, &set);

    if (r) {

        fprintf(stderr, ""kvm_set_signal_mask: %s\n"", strerror(-r));

        exit(1);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void ax25_kill_by_device(struct net_device *dev)
{
	ax25_dev *ax25_dev;
	ax25_cb *s;

	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
		return;

	spin_lock_bh(&ax25_list_lock);
again:
	ax25_for_each(s, &ax25_list) {
		if (s->ax25_dev == ax25_dev) {
			spin_unlock_bh(&ax25_list_lock);
			lock_sock(s->sk);
			s->ax25_dev = NULL;
			release_sock(s->sk);
			ax25_disconnect(s, ENETUNREACH);
			spin_lock_bh(&ax25_list_lock);

			/* The entry could have been deleted from the
			 * list meanwhile and thus the next pointer is
			 * no longer valid.  Play it safe and restart
			 * the scan.  Forward progress is ensured
			 * because we set s->ax25_dev to NULL and we
			 * are never passed a NULL 'dev' argument.
			 */
			goto again;
		}
	}
	spin_unlock_bh(&ax25_list_lock);
}",1
Detect whether the following code contains vulnerabilities.,"static void adb_kbd_put_keycode(void *opaque, int keycode)

{

    KBDState *s = opaque;



    if (s->count < sizeof(s->data)) {

        s->data[s->wptr] = keycode;

        if (++s->wptr == sizeof(s->data))

            s->wptr = 0;

        s->count++;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t tstats_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *offs)
{
	char ctl[2];

	if (count != 2 || *offs)
		return -EINVAL;

	if (copy_from_user(ctl, buf, count))
		return -EFAULT;

	mutex_lock(&show_mutex);
	switch (ctl[0]) {
	case '0':
		if (timer_stats_active) {
			timer_stats_active = 0;
			time_stop = ktime_get();
			sync_access();
		}
		break;
	case '1':
		if (!timer_stats_active) {
			reset_entries();
			time_start = ktime_get();
			smp_mb();
			timer_stats_active = 1;
		}
		break;
	default:
		count = -EINVAL;
	}
	mutex_unlock(&show_mutex);

	return count;
}",1
Detect whether the following code contains vulnerabilities.,"get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
/* This version is for reading raw-word-format PPM files with any maxval */
{
  ppm_source_ptr source = (ppm_source_ptr)sinfo;
  register JSAMPROW ptr;
  register U_CHAR *bufferptr;
  register JSAMPLE *rescale = source->rescale;
  JDIMENSION col;
  unsigned int maxval = source->maxval;

  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
    ERREXIT(cinfo, JERR_INPUT_EOF);
  ptr = source->pub.buffer[0];
  bufferptr = source->iobuffer;
  for (col = cinfo->image_width; col > 0; col--) {
    register unsigned int temp;
    temp  = UCH(*bufferptr++) << 8;
    temp |= UCH(*bufferptr++);
    if (temp > maxval)
      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
    *ptr++ = rescale[temp];
    temp  = UCH(*bufferptr++) << 8;
    temp |= UCH(*bufferptr++);
    if (temp > maxval)
      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
    *ptr++ = rescale[temp];
    temp  = UCH(*bufferptr++) << 8;
    temp |= UCH(*bufferptr++);
    if (temp > maxval)
      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);
    *ptr++ = rescale[temp];
  }
  return 1;
}",1
Detect whether the following code contains vulnerabilities.,"static void perf_event_init_cpu(int cpu)
{
	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);

	mutex_lock(&swhash->hlist_mutex);
	swhash->online = true;
	if (swhash->hlist_refcount > 0) {
		struct swevent_hlist *hlist;

		hlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));
		WARN_ON(!hlist);
		rcu_assign_pointer(swhash->swevent_hlist, hlist);
	}
	mutex_unlock(&swhash->hlist_mutex);
}",1
Detect whether the following code contains vulnerabilities.,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_cipher rcipher;

	strlcpy(rcipher.type, ""cipher"", sizeof(rcipher.type));

	rcipher.blocksize = alg->cra_blocksize;
	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}",1
Detect whether the following code contains vulnerabilities.,"static void tpm_tis_receive_cb(TPMState *s, uint8_t locty)

{

    TPMTISEmuState *tis = &s->s.tis;



    assert(s->locty_number == locty);



    qemu_bh_schedule(tis->bh);

}
",0
Detect whether the following code contains vulnerabilities.,"ISADevice *isa_create_simple(const char *name)

{

    ISADevice *dev;



    dev = isa_create(name);

    if (qdev_init(&dev->qdev) != 0) {

        return NULL;

    }

    return dev;

}
",1
Detect whether the following code contains vulnerabilities.,"static target_long monitor_get_tbl (const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return cpu_ppc_load_tbl(env);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtconsole_realize(DeviceState *dev, Error **errp)

{

    VirtIOSerialPort *port = VIRTIO_SERIAL_PORT(dev);

    VirtConsole *vcon = VIRTIO_CONSOLE(dev);

    VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(dev);



    if (port->id == 0 && !k->is_console) {

        error_setg(errp, ""Port number 0 on virtio-serial devices reserved ""

                   ""for virtconsole devices for backward compatibility."");

        return;

    }



    if (vcon->chr) {

        vcon->chr->explicit_fe_open = 1;

        qemu_chr_add_handlers(vcon->chr, chr_can_read, chr_read, chr_event,

                              vcon);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int annotation_set_pop3showafter(annotate_state_t *state,
                                        struct annotate_entry_list *entry,
                                        int maywrite)
{
    struct mailbox *mailbox = state->mailbox;
    int r = 0;
    time_t date;

    assert(mailbox);

    if (entry->shared.s == NULL) {
        /* Effectively removes the annotation */
        date = 0;
    }
    else {
        r = time_from_rfc5322(buf_cstring(&entry->shared), &date, DATETIME_FULL);
        if (r < 0)
            return IMAP_PROTOCOL_BAD_PARAMETERS;
    }

    if (date != mailbox->i.pop3_show_after) {
        if (!maywrite) return IMAP_PERMISSION_DENIED;
        mailbox_index_dirty(mailbox);
        mailbox_modseq_dirty(mailbox);
        mailbox->i.pop3_show_after = date;
        mboxlist_update_foldermodseq(mailbox->name, mailbox->i.highestmodseq);
    }

    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int cJSON_GetArraySize( cJSON *array )
{
	cJSON *c = array->child;
	int i = 0;
	while ( c ) {
		++i;
		c = c->next;
	}
	return i;
}",1
Detect whether the following code contains vulnerabilities.,"static size_t handle_aiocb_rw_vector(struct qemu_paiocb *aiocb)

{

    size_t offset = 0;

    ssize_t len;



    do {

        if (aiocb->aio_type == QEMU_PAIO_WRITE)

            len = qemu_pwritev(aiocb->aio_fildes,

                               aiocb->aio_iov,

                               aiocb->aio_niov,

                               aiocb->aio_offset + offset);

         else

            len = qemu_preadv(aiocb->aio_fildes,

                              aiocb->aio_iov,

                              aiocb->aio_niov,

                              aiocb->aio_offset + offset);

    } while (len == -1 && errno == EINTR);



    if (len == -1)

        return -errno;

    return len;

}
",0
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(mul32)(CPUOpenRISCState *env,

                       uint32_t ra, uint32_t rb)

{

    uint64_t result;

    uint32_t high, cy;



    OpenRISCCPU *cpu = openrisc_env_get_cpu(env);



    result = (uint64_t)ra * rb;

    /* regisiers in or32 is 32bit, so 32 is NOT a magic number.

       or64 is not handled in this function, and not implement yet,

       TARGET_LONG_BITS for or64 is 64, it will break this function,

       so, we didn't use TARGET_LONG_BITS here.  */

    high = result >> 32;

    cy = result >> (32 - 1);



    if ((cy & 0x1) == 0x0) {

        if (high == 0x0) {

            return result;

        }

    }



    if ((cy & 0x1) == 0x1) {

        if (high == 0xffffffff) {

            return result;

        }

    }



    cpu->env.sr |= (SR_OV | SR_CY);

    if (cpu->env.sr & SR_OVE) {

        raise_exception(cpu, EXCP_RANGE);

    }



    return result;

}
",1
Detect whether the following code contains vulnerabilities.,"static void noop_conv (st_sample_t *dst, const void *src,

                       int samples, volume_t *vol)

{

    (void) src;

    (void) dst;

    (void) samples;

    (void) vol;

}
",0
Detect whether the following code contains vulnerabilities.,"struct xt_table_info *xt_alloc_table_info(unsigned int size)
{
	struct xt_table_info *info = NULL;
	size_t sz = sizeof(*info) + size;

	/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR */
	if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)
		return NULL;

	if (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))
		info = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
	if (!info) {
		info = vmalloc(sz);
		if (!info)
			return NULL;
	}
	memset(info, 0, sizeof(*info));
	info->size = size;
	return info;
}",1
Detect whether the following code contains vulnerabilities.,"static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)

{

    bool print16 = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_SHORT);

    bool printall = !!trace_event_get_state(TRACE_USB_OHCI_TD_PKT_FULL);

    const int width = 16;

    int i;

    char tmp[3 * width + 1];

    char *p = tmp;



    if (!printall && !print16) {

        return;

    }



    for (i = 0; ; i++) {

        if (i && (!(i % width) || (i == len))) {

            if (!printall) {

                trace_usb_ohci_td_pkt_short(msg, tmp);

                break;

            }

            trace_usb_ohci_td_pkt_full(msg, tmp);

            p = tmp;

            *p = 0;

        }

        if (i == len) {

            break;

        }



        p += sprintf(p, "" %.2x"", buf[i]);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int cavs_find_frame_end(ParseContext *pc, const uint8_t *buf,

                               int buf_size) {

    int pic_found, i;

    uint32_t state;



    pic_found= pc->frame_start_found;

    state= pc->state;



    i=0;

    if(!pic_found){

        for(i=0; i<buf_size; i++){

            state= (state<<8) | buf[i];

            if(state == PIC_I_START_CODE || state == PIC_PB_START_CODE){

                i++;

                pic_found=1;

                break;

            }

        }

    }



    if(pic_found){

        /* EOF considered as end of frame */

        if (buf_size == 0)

            return 0;

        for(; i<buf_size; i++){

            state= (state<<8) | buf[i];

            if((state&0xFFFFFF00) == 0x100){

                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){

                    pc->frame_start_found=0;

                    pc->state=-1;

                    return i-3;

                }

            }

        }

    }

    pc->frame_start_found= pic_found;

    pc->state= state;

    return END_NOT_FOUND;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_stf_asi(DisasContext *dc, TCGv addr,

                        int insn, int size, int rd)

{

    TCGv_i32 r_asi, r_size, r_rd;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_rd = tcg_const_i32(rd);

    gen_helper_stf_asi(cpu_env, addr, r_asi, r_size, r_rd);

    tcg_temp_free_i32(r_rd);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
",0
Detect whether the following code contains vulnerabilities.,"ftp_type(ftpbuf_t *ftp, ftptype_t type)
{
	char typechar[2] = ""?"";

	if (ftp == NULL) {
		return 0;
	}
	if (type == ftp->type) { 
		return 1;
	}
	if (type == FTPTYPE_ASCII) {
		typechar[0] = 'A';
	} else if (type == FTPTYPE_IMAGE) {
		typechar[0] = 'I';
	} else {
		return 0;
	}
	if (!ftp_putcmd(ftp, ""TYPE"", typechar)) {
		return 0;
	}
	if (!ftp_getresp(ftp) || ftp->resp != 200) {
		return 0;
	}
	ftp->type = type;

	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"int Field_temporal_with_date::store(const char *from, size_t len, CHARSET_INFO *cs)
{
  MYSQL_TIME ltime;
  MYSQL_TIME_STATUS status;
  THD *thd= get_thd();
  ErrConvString str(from, len, cs);
  bool func_res= !str_to_datetime(cs, from, len, &ltime,
                                  sql_mode_for_dates(thd),
                                  &status);
  return store_TIME_with_warning(&ltime, &str, status.warnings, func_res);
}",0
Detect whether the following code contains vulnerabilities.,"throttle_job (GSWindow  *window,
              GSJob     *job,
              GSManager *manager)
{
        if (manager->priv->throttled) {
                gs_job_stop (job);
        } else {
                manager_maybe_start_job_for_window (manager, window);
        }
}",0
Detect whether the following code contains vulnerabilities.,"void numa_set_mem_node_id(ram_addr_t addr, uint64_t size, uint32_t node)

{

    struct numa_addr_range *range = g_malloc0(sizeof(*range));



    /*

     * Memory-less nodes can come here with 0 size in which case,

     * there is nothing to do.

     */

    if (!size) {

        return;

    }



    range->mem_start = addr;

    range->mem_end = addr + size - 1;

    QLIST_INSERT_HEAD(&numa_info[node].addr, range, entry);

}
",1
Detect whether the following code contains vulnerabilities.,"bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {
  ecc_25519_work_t s2, work;
  ecc_int256_t w, tmp;

  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);
  ecc_25519_add(&work, &ctx->s1, &s2);
  ecc_25519_store_xy_legacy(&w, NULL, &work);
  ecc_25519_gf_sub(&tmp, &ctx->r, &w);

  return ecc_25519_gf_is_zero(&tmp);
}",1
Detect whether the following code contains vulnerabilities.,"void h2_beam_abort(h2_bucket_beam *beam)
{
    h2_beam_lock bl;
    
    if (beam && enter_yellow(beam, &bl) == APR_SUCCESS) {
        if (!beam->aborted) {
            beam->aborted = 1;
            r_purge_sent(beam);
            h2_blist_cleanup(&beam->send_list);
            report_consumption(beam, &bl);
        }
        apr_thread_cond_broadcast(beam->change);
        leave_yellow(beam, &bl);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int calculate_password(String *str, char *buffer)
{
  DBUG_ASSERT(str);
  if (str->length() == 0) // PASSWORD('') returns ''
    return 0;
  
  int buffer_len= 0;
  THD *thd= current_thd;
  int old_passwords= 0;
  if (thd)
    old_passwords= thd->variables.old_passwords;
  
#if defined(HAVE_OPENSSL)
  if (old_passwords == 2)
  {
    my_make_scrambled_password(buffer, str->ptr(),
                               str->length());
    buffer_len= (int) strlen(buffer) + 1;
  }
  else
#endif
  if (old_passwords == 0)
  {
    my_make_scrambled_password_sha1(buffer, str->ptr(),
                                    str->length());
    buffer_len= SCRAMBLED_PASSWORD_CHAR_LENGTH;
  }
  else
  if (old_passwords == 1)
  {
    my_make_scrambled_password_323(buffer, str->ptr(),
                                   str->length());
    buffer_len= SCRAMBLED_PASSWORD_CHAR_LENGTH_323;
  }
  return buffer_len;
}",1
Detect whether the following code contains vulnerabilities.,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	u32 hash[MD5_DIGEST_WORDS];

	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = net_secret[15];

	md5_transform(hash, net_secret);

	return seq_scale(hash[0]);
}",0
Detect whether the following code contains vulnerabilities.,"static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)
{
	unsigned int u = 0;
	LineContribType *res;
	int overflow_error = 0;

	res = (LineContribType *) gdMalloc(sizeof(LineContribType));
	if (!res) {
		return NULL;
	}
	res->WindowSize = windows_size;
	res->LineLength = line_length;
	if (overflow2(line_length, sizeof(ContributionType))) {
		gdFree(res);
		return NULL;
	}
	res->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));
	if (res->ContribRow == NULL) {
		gdFree(res);
		return NULL;
	}
	for (u = 0 ; u < line_length ; u++) {
		if (overflow2(windows_size, sizeof(double))) {
			overflow_error = 1;
		} else {
			res->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));
		}
		if (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {
			u--;
			while (u >= 0) {
				gdFree(res->ContribRow[u].Weights);
				u--;
			}
			return NULL;
		}
	}
	return res;
}",1
Detect whether the following code contains vulnerabilities.,"static void sco_chan_del(struct sock *sk, int err)
{
	struct sco_conn *conn;

	conn = sco_pi(sk)->conn;

	BT_DBG(""sk %p, conn %p, err %d"", sk, conn, err);

	if (conn) {
		sco_conn_lock(conn);
		conn->sk = NULL;
		sco_pi(sk)->conn = NULL;
		sco_conn_unlock(conn);

		if (conn->hcon)
			hci_conn_drop(conn->hcon);
	}

	sk->sk_state = BT_CLOSED;
	sk->sk_err   = err;
	sk->sk_state_change(sk);

	sock_set_flag(sk, SOCK_ZAPPED);
}",0
Detect whether the following code contains vulnerabilities.,"void __init raw_proc_exit(void)
{
	unregister_pernet_subsys(&raw_net_ops);
}",0
Detect whether the following code contains vulnerabilities.,"timespec_cmp(struct timespec time1, struct timespec time2)
{
  /* Less than. */
  if (time1.tv_sec < time2.tv_sec)
    return -1;
  /* Greater than. */
  else if (time1.tv_sec > time2.tv_sec)
    return 1;
  /* Less than. */
  else if (time1.tv_nsec < time2.tv_nsec)
    return -1;
  /* Greater than. */
  else if (time1.tv_nsec > time2.tv_nsec)
    return 1;
  /* Equal. */
  else
    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void kvmclock_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = kvmclock_realize;

    dc->vmsd = &kvmclock_vmsd;

    dc->props = kvmclock_properties;






}",1
Detect whether the following code contains vulnerabilities.,"static int usb_device_init(USBDevice *dev)

{

    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);

    if (klass->init) {

        return klass->init(dev);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,
    size_t num_sg, int is_write)
{
    unsigned int i;
    hwaddr len;
    for (i = 0; i < num_sg; i++) {
        len = sg[i].iov_len;
        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);
        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {
            error_report(""virtio: trying to map MMIO memory"");",1
Detect whether the following code contains vulnerabilities.,"static void ipv6_mc_rejoin_groups(struct inet6_dev *idev)
{
	struct ifmcaddr6 *pmc;

	ASSERT_RTNL();

	mutex_lock(&idev->mc_lock);
	if (mld_in_v1_mode(idev)) {
		for_each_mc_mclock(idev, pmc)
			igmp6_join_group(pmc);
	} else {
		mld_send_report(idev, NULL);
	}
	mutex_unlock(&idev->mc_lock);
}",0
Detect whether the following code contains vulnerabilities.,"struct block_device *f2fs_target_device(struct f2fs_sb_info *sbi,
				block_t blk_addr, struct bio *bio)
{
	struct block_device *bdev = sbi->sb->s_bdev;
	int i;

	for (i = 0; i < sbi->s_ndevs; i++) {
		if (FDEV(i).start_blk <= blk_addr &&
					FDEV(i).end_blk >= blk_addr) {
			blk_addr -= FDEV(i).start_blk;
			bdev = FDEV(i).bdev;
			break;
		}
	}
	if (bio) {
		bio->bi_bdev = bdev;
		bio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(blk_addr);
	}
	return bdev;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int verify_replay(struct xfrm_usersa_info *p,
				struct nlattr **attrs)
{
	struct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];

	if ((p->flags & XFRM_STATE_ESN) && !rt)
		return -EINVAL;

	if (!rt)
		return 0;

	if (p->id.proto != IPPROTO_ESP)
		return -EINVAL;

	if (p->replay_window != 0)
		return -EINVAL;

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int mmap_start(AVFormatContext *ctx)

{

    struct video_data *s = ctx->priv_data;

    enum v4l2_buf_type type;

    int i, res;



    for (i = 0; i < s->buffers; i++) {

        struct v4l2_buffer buf;



        memset(&buf, 0, sizeof(struct v4l2_buffer));

        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

        buf.memory = V4L2_MEMORY_MMAP;

        buf.index  = i;



        res = ioctl(s->fd, VIDIOC_QBUF, &buf);

        if (res < 0) {

            av_log(ctx, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

                   strerror(errno));



            return AVERROR(errno);

        }

    }



    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    res = ioctl(s->fd, VIDIOC_STREAMON, &type);

    if (res < 0) {

        av_log(ctx, AV_LOG_ERROR, ""ioctl(VIDIOC_STREAMON): %s\n"",

               strerror(errno));



        return AVERROR(errno);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"build_gtdt(GArray *table_data, GArray *linker)

{

    int gtdt_start = table_data->len;

    AcpiGenericTimerTable *gtdt;



    gtdt = acpi_data_push(table_data, sizeof *gtdt);

    /* The interrupt values are the same with the device tree when adding 16 */

    gtdt->secure_el1_interrupt = ARCH_TIMER_S_EL1_IRQ + 16;

    gtdt->secure_el1_flags = ACPI_EDGE_SENSITIVE;



    gtdt->non_secure_el1_interrupt = ARCH_TIMER_NS_EL1_IRQ + 16;

    gtdt->non_secure_el1_flags = ACPI_EDGE_SENSITIVE;



    gtdt->virtual_timer_interrupt = ARCH_TIMER_VIRT_IRQ + 16;

    gtdt->virtual_timer_flags = ACPI_EDGE_SENSITIVE;



    gtdt->non_secure_el2_interrupt = ARCH_TIMER_NS_EL2_IRQ + 16;

    gtdt->non_secure_el2_flags = ACPI_EDGE_SENSITIVE;



    build_header(linker, table_data,

                 (void *)(table_data->data + gtdt_start), ""GTDT"",

                 table_data->len - gtdt_start, 2, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,

                                   const char *filename)

{

    int score_max = 0, score;

    BlockDriver *drv = NULL, *d;



    QLIST_FOREACH(d, &bdrv_drivers, list) {

        if (d->bdrv_probe) {

            score = d->bdrv_probe(buf, buf_size, filename);

            if (score > score_max) {

                score_max = score;

                drv = d;

            }

        }

    }



    return drv;

}
",1
Detect whether the following code contains vulnerabilities.,"static KeyValue *copy_key_value(KeyValue *src)

{

    KeyValue *dst = g_new(KeyValue, 1);

    memcpy(dst, src, sizeof(*src));






    return dst;
",1
Detect whether the following code contains vulnerabilities.,"static void write_response(ESPState *s)
{
    uint32_t n;

    trace_esp_write_response(s->status);

    fifo8_reset(&s->fifo);
    esp_fifo_push(s, s->status);
    esp_fifo_push(s, 0);

    if (s->dma) {
        if (s->dma_memory_write) {
            s->dma_memory_write(s->dma_opaque,
                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);
            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;
            s->rregs[ESP_RSEQ] = SEQ_CD;
        } else {
            s->pdma_cb = write_response_pdma_cb;
            esp_raise_drq(s);
            return;
        }
    } else {
        s->ti_size = 2;
        s->rregs[ESP_RFLAGS] = 2;
    }
    esp_raise_irq(s);
}",1
Detect whether the following code contains vulnerabilities.,"parse_create_repinfo(struct msg_parse* msg, struct reply_info** rep,
	struct regional* region)
{
	*rep = construct_reply_info_base(region, msg->flags, msg->qdcount, 0, 
		0, 0, msg->an_rrsets, msg->ns_rrsets, msg->ar_rrsets, 
		msg->rrset_count, sec_status_unchecked);
	if(!*rep)
		return 0;
	return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static void test_pxe_virtio_pci(void)

{

    test_pxe_one(""-device virtio-net-pci,netdev="" NETNAME, false);

}
",0
Detect whether the following code contains vulnerabilities.,"static int rv30_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)

{

    int i, j, k;



    for(i = 0; i < 4; i++, dst += r->intra_types_stride - 4){

        for(j = 0; j < 4; j+= 2){

            int code = svq3_get_ue_golomb(gb) << 1;

            if(code >= 81*2){

                av_log(r->s.avctx, AV_LOG_ERROR, ""Incorrect intra prediction code\n"");

                return -1;

            }

            for(k = 0; k < 2; k++){

                int A = dst[-r->intra_types_stride] + 1;

                int B = dst[-1] + 1;

                *dst++ = rv30_itype_from_context[A * 90 + B * 9 + rv30_itype_code[code + k]];

                if(dst[-1] == 9){

                    av_log(r->s.avctx, AV_LOG_ERROR, ""Incorrect intra prediction mode\n"");

                    return -1;

                }

            }

        }

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){

    AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));

    double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);

    int phase_count= 1<<phase_shift;

    

    c->phase_shift= phase_shift;

    c->phase_mask= phase_count-1;

    c->linear= linear;



    c->filter_length= FFMAX(ceil(filter_size/factor), 1);

    c->filter_bank= av_mallocz(c->filter_length*(phase_count+1)*sizeof(FELEM));

    av_build_filter(c->filter_bank, factor, c->filter_length, phase_count, 1<<FILTER_SHIFT, 1);

    memcpy(&c->filter_bank[c->filter_length*phase_count+1], c->filter_bank, (c->filter_length-1)*sizeof(FELEM));

    c->filter_bank[c->filter_length*phase_count]= c->filter_bank[c->filter_length - 1];



    c->src_incr= out_rate;

    c->ideal_dst_incr= c->dst_incr= in_rate * phase_count;

    c->index= -phase_count*((c->filter_length-1)/2);



    return c;

}
",0
Detect whether the following code contains vulnerabilities.,"static void hci_le_phy_update_evt(struct hci_dev *hdev, struct sk_buff *skb)
{
	struct hci_ev_le_phy_update_complete *ev = (void *) skb->data;
	struct hci_conn *conn;

	BT_DBG(""%s status 0x%2.2x"", hdev->name, ev->status);

	if (ev->status)
		return;

	hci_dev_lock(hdev);

	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
	if (!conn)
		goto unlock;

	conn->le_tx_phy = ev->tx_phy;
	conn->le_rx_phy = ev->rx_phy;

unlock:
	hci_dev_unlock(hdev);
}",0
Detect whether the following code contains vulnerabilities.,"static int mailimf_minus_parse(const char * message, size_t length,
			       size_t * indx)
{
  return mailimf_unstrict_char_parse(message, length, indx, '-');
}",0
Detect whether the following code contains vulnerabilities.,"static void bmdma_addr_write(void *opaque, target_phys_addr_t addr,

                             uint64_t data, unsigned width)

{

    BMDMAState *bm = opaque;

    int shift = addr * 8;

    uint32_t mask = (1ULL << (width * 8)) - 1;



#ifdef DEBUG_IDE

    printf(""%s: 0x%08x\n"", __func__, (unsigned)data);

#endif

    bm->addr &= ~(mask << shift);

    bm->addr |= ((data & mask) << shift) & ~3;

}
",0
Detect whether the following code contains vulnerabilities.,"bool vmx_interrupt_blocked(struct kvm_vcpu *vcpu)
{
	if (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))
		return false;

	return !(vmx_get_rflags(vcpu) & X86_EFLAGS_IF) ||
	       (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &
		(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));
}",0
Detect whether the following code contains vulnerabilities.,"static u64 sched_slice(struct cfs_rq *cfs_rq, struct sched_entity *se)
{
	u64 slice = __sched_period(cfs_rq->nr_running);

	for_each_sched_entity(se) {
		cfs_rq = cfs_rq_of(se);

		slice *= se->load.weight;
		do_div(slice, cfs_rq->load.weight);
	}


	return slice;
}",1
Detect whether the following code contains vulnerabilities.,"enumerator_next_async (GSocketClientAsyncConnectData *data)
{
  /* We need to cleanup the state */
  g_clear_object (&data->socket);
  g_clear_object (&data->proxy_addr);
  g_clear_object (&data->connection);

  g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_RESOLVING, data->connectable, NULL);
  g_socket_address_enumerator_next_async (data->enumerator,
					  g_task_get_cancellable (data->task),
					  g_socket_client_enumerator_callback,
					  data);
}",1
Detect whether the following code contains vulnerabilities.,"string_strncasecmp_range (const char *string1, const char *string2, int max,
                          int range)
{
    int count, diff;

    if (!string1 || !string2)
        return (string1) ? 1 : ((string2) ? -1 : 0);

    count = 0;
    while ((count < max) && string1[0] && string2[0])
    {
        diff = utf8_charcasecmp_range (string1, string2, range);
        if (diff != 0)
            return diff;

        string1 = utf8_next_char (string1);
        string2 = utf8_next_char (string2);
        count++;
    }

    if (count >= max)
        return 0;
    else
        return (string1[0]) ? 1 : ((string2[0]) ? -1 : 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void filter_mirror_setup(NetFilterState *nf, Error **errp)
{
    MirrorState *s = FILTER_MIRROR(nf);
    Chardev *chr;
    chr = qemu_chr_find(s->outdev);
    if (chr == NULL) {
        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,
                  ""Device '%s' not found"", s->outdev);
    qemu_chr_fe_init(&s->chr_out, chr, errp);",1
Detect whether the following code contains vulnerabilities.,"TEST_F(SingleAllowMissingInOrListTest, MissingIssToken) {
  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));
  auto headers = Http::TestRequestHeaderMapImpl{{kExampleHeader, ES256WithoutIssToken}};
  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);
  verifier_->verify(context_);
  EXPECT_THAT(headers, JwtOutputFailedOrIgnore(kExampleHeader));
}",1
Detect whether the following code contains vulnerabilities.,"static bool nvic_user_access_ok(NVICState *s, hwaddr offset)

{

    /* Return true if unprivileged access to this register is permitted. */

    switch (offset) {

    case 0xf00: /* STIR: accessible only if CCR.USERSETMPEND permits */

        return s->cpu->env.v7m.ccr & R_V7M_CCR_USERSETMPEND_MASK;

    default:

        /* All other user accesses cause a BusFault unconditionally */

        return false;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(realpath)
{
	char *filename;
	int filename_len;
	char resolved_path_buff[MAXPATHLEN];

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &filename, &filename_len) == FAILURE) {
		return;
	}

	if (VCWD_REALPATH(filename, resolved_path_buff)) {
		if (PG(safe_mode) && (!php_checkuid(resolved_path_buff, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
			RETURN_FALSE;
		}

		if (php_check_open_basedir(resolved_path_buff TSRMLS_CC)) {
			RETURN_FALSE;
		}

#ifdef ZTS
		if (VCWD_ACCESS(resolved_path_buff, F_OK)) {
			RETURN_FALSE;
		}
#endif
		RETURN_STRING(resolved_path_buff, 1);
	} else {
		RETURN_FALSE;
	}
}",1
Detect whether the following code contains vulnerabilities.,"void __set_breakpoint(struct arch_hw_breakpoint *brk)
{
	memcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));

	if (cpu_has_feature(CPU_FTR_DAWR))
		set_dawr(brk);
	else
		set_dabr(brk);
}",0
Detect whether the following code contains vulnerabilities.,"init_pair(NCURSES_COLOR_T pair, NCURSES_COLOR_T f, NCURSES_COLOR_T b)
{
    return NCURSES_SP_NAME(init_pair) (CURRENT_SCREEN, pair, f, b);
}",0
Detect whether the following code contains vulnerabilities.,"shutdown_mib(void)
{
    unload_all_mibs();
    if (tree_top) {
        if (tree_top->label)
            SNMP_FREE(tree_top->label);
        SNMP_FREE(tree_top);
    }
    tree_head = NULL;
    Mib = NULL;
    if (_mibindexes) {
        int i;
        for (i = 0; i < _mibindex; ++i)
            SNMP_FREE(_mibindexes[i]);
        free(_mibindexes);
        _mibindex = 0;
        _mibindex_max = 0;
        _mibindexes = NULL;
    }
    if (Prefix != NULL && Prefix != &Standard_Prefix[0])
        SNMP_FREE(Prefix);
    if (Prefix)
        Prefix = NULL;
    SNMP_FREE(confmibs);
    SNMP_FREE(confmibdir);
}",1
Detect whether the following code contains vulnerabilities.,"static void php_cli_server_poller_add(php_cli_server_poller *poller, int mode, int fd) /* {{{ */
{
	if (mode & POLLIN) {
		PHP_SAFE_FD_SET(fd, &poller->rfds);
	}
	if (mode & POLLOUT) {
		PHP_SAFE_FD_SET(fd, &poller->wfds);
	}
	if (fd > poller->max_fd) {
		poller->max_fd = fd;
	}
} /* }}} */",0
Detect whether the following code contains vulnerabilities.,"void hostap_setup_dev(struct net_device *dev, local_info_t *local,
		      int type)
{
	struct hostap_interface *iface;

	iface = netdev_priv(dev);
	ether_setup(dev);

	/* kernel callbacks */
	if (iface) {
		/* Currently, we point to the proper spy_data only on
		 * the main_dev. This could be fixed. Jean II */
		iface->wireless_data.spy_data = &iface->spy_data;
		dev->wireless_data = &iface->wireless_data;
	}
	dev->wireless_handlers = &hostap_iw_handler_def;
	dev->watchdog_timeo = TX_TIMEOUT;

	switch(type) {
	case HOSTAP_INTERFACE_AP:
		dev->tx_queue_len = 0;	/* use main radio device queue */
		dev->netdev_ops = &hostap_mgmt_netdev_ops;
		dev->type = ARPHRD_IEEE80211;
		dev->header_ops = &hostap_80211_ops;
		break;
	case HOSTAP_INTERFACE_MASTER:
		dev->netdev_ops = &hostap_master_ops;
		break;
	default:
		dev->tx_queue_len = 0;	/* use main radio device queue */
		dev->netdev_ops = &hostap_netdev_ops;
	}

	dev->mtu = local->mtu;


	SET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);

}",1
Detect whether the following code contains vulnerabilities.,"static void cunary(JF, js_Ast *exp, int opcode)
{
	cexp(J, F, exp->a);
	emitline(J, F, exp);
	emit(J, F, opcode);
}",0
Detect whether the following code contains vulnerabilities.,"static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)
{
	pmd_t pmdval = pmd_read_atomic(pmd);
	/*
	 * The barrier will stabilize the pmdval in a register or on
	 * the stack so that it will stop changing under the code.
	 *
	 * When CONFIG_TRANSPARENT_HUGEPAGE=y on x86 32bit PAE,
	 * pmd_read_atomic is allowed to return a not atomic pmdval
	 * (for example pointing to an hugepage that has never been
	 * mapped in the pmd). The below checks will only care about
	 * the low part of the pmd with 32bit PAE x86 anyway, with the
	 * exception of pmd_none(). So the important thing is that if
	 * the low part of the pmd is found null, the high part will
	 * be also null or the pmd_none() check below would be
	 * confused.
	 */
#ifdef CONFIG_TRANSPARENT_HUGEPAGE
	barrier();
#endif
	if (pmd_none(pmdval) || pmd_trans_huge(pmdval))
		return 1;
	if (unlikely(pmd_bad(pmdval))) {
		pmd_clear_bad(pmd);
		return 1;
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_rm_free_rmstream (RMStream *rms)

{

    av_free(rms->videobuf);

    av_free(rms->audiobuf);

}
",1
Detect whether the following code contains vulnerabilities.,"CompositeDeepScanLine::setCompositing(DeepCompositing* c)
{
  _Data->_comp=c;
}",0
Detect whether the following code contains vulnerabilities.,"asmlinkage void do_notify_resume(struct pt_regs *regs, struct thread_info *ti)
{
	int syscall = 0;

	if ((sysreg_read(SR) & MODE_MASK) == MODE_SUPERVISOR)
		syscall = 1;

	if (ti->flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs, &current->blocked, syscall);

	if (ti->flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(regs);
	}
}",1
Detect whether the following code contains vulnerabilities.,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}",0
Detect whether the following code contains vulnerabilities.,"static void xilinx_enet_init(Object *obj)

{

    XilinxAXIEnet *s = XILINX_AXI_ENET(obj);

    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);

    Error *errp = NULL;



    object_property_add_link(obj, ""axistream-connected"", TYPE_STREAM_SLAVE,

                             (Object **) &s->tx_dev, &errp);

    assert_no_error(errp);



    object_initialize(&s->rx_data_dev, TYPE_XILINX_AXI_ENET_DATA_STREAM);

    object_property_add_child(OBJECT(s), ""axistream-connected-target"",

                              (Object *)&s->rx_data_dev, &errp);

    assert_no_error(errp);



    sysbus_init_irq(sbd, &s->irq);



    memory_region_init_io(&s->iomem, &enet_ops, s, ""enet"", 0x40000);

    sysbus_init_mmio(sbd, &s->iomem);

}
",0
Detect whether the following code contains vulnerabilities.,"cursor_sleep(void)
{
    cursor_is_asleep = TRUE;
    cursor_off();
}",0
Detect whether the following code contains vulnerabilities.,"extern ""C"" void free_wrapper(struct _reent *r, void *ptr, void *caller)
{
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_lock();
#endif
#ifdef MBED_HEAP_STATS_ENABLED
    malloc_stats_mutex->lock();
    alloc_info_t *alloc_info = NULL;
    if (ptr != NULL) {
        alloc_info = ((alloc_info_t *)ptr) - 1;
        if (MBED_HEAP_STATS_SIGNATURE == alloc_info->signature) {
            size_t user_size = alloc_info->size;
            size_t alloc_size = MALLOC_HEAP_TOTAL_SIZE(MALLOC_HEADER_PTR(alloc_info));
            alloc_info->signature = 0x0;
            heap_stats.current_size -= user_size;
            heap_stats.alloc_cnt -= 1;
            heap_stats.overhead_size -= (alloc_size - user_size);
            __real__free_r(r, (void *)alloc_info);
        } else {
            __real__free_r(r, ptr);
        }
    }

    malloc_stats_mutex->unlock();
#else // #ifdef MBED_HEAP_STATS_ENABLED
    __real__free_r(r, ptr);
#endif // #ifdef MBED_HEAP_STATS_ENABLED
#ifdef MBED_MEM_TRACING_ENABLED
    mbed_mem_trace_free(ptr, caller);
    mbed_mem_trace_unlock();
#endif // #ifdef MBED_MEM_TRACING_ENABLED
}",0
Detect whether the following code contains vulnerabilities.,"static bool bdrv_drain_recurse(BlockDriverState *bs, bool begin)

{

    BdrvChild *child, *tmp;

    bool waited;



    /* Ensure any pending metadata writes are submitted to bs->file.  */

    bdrv_drain_invoke(bs, begin);



    /* Wait for drained requests to finish */

    waited = BDRV_POLL_WHILE(bs, atomic_read(&bs->in_flight) > 0);



    QLIST_FOREACH_SAFE(child, &bs->children, next, tmp) {

        BlockDriverState *bs = child->bs;

        bool in_main_loop =

            qemu_get_current_aio_context() == qemu_get_aio_context();

        assert(bs->refcnt > 0);

        if (in_main_loop) {

            /* In case the recursive bdrv_drain_recurse processes a

             * block_job_defer_to_main_loop BH and modifies the graph,

             * let's hold a reference to bs until we are done.

             *

             * IOThread doesn't have such a BH, and it is not safe to call

             * bdrv_unref without BQL, so skip doing it there.

             */

            bdrv_ref(bs);

        }

        waited |= bdrv_drain_recurse(bs, begin);

        if (in_main_loop) {

            bdrv_unref(bs);

        }

    }



    return waited;

}
",1
Detect whether the following code contains vulnerabilities.,"static void atusb_disconnect(struct usb_interface *interface)
{
	struct atusb *atusb = usb_get_intfdata(interface);

	dev_dbg(&atusb->usb_dev->dev, ""%s\n"", __func__);

	atusb->shutdown = 1;
	cancel_delayed_work_sync(&atusb->work);

	usb_kill_anchored_urbs(&atusb->rx_urbs);
	atusb_free_urbs(atusb);
	usb_kill_urb(atusb->tx_urb);
	usb_free_urb(atusb->tx_urb);

	ieee802154_unregister_hw(atusb->hw);

	ieee802154_free_hw(atusb->hw);

	usb_set_intfdata(interface, NULL);
	usb_put_dev(atusb->usb_dev);

	pr_debug(""%s done\n"", __func__);
}",1
Detect whether the following code contains vulnerabilities.,"static int __init nfs4flexfilelayout_init(void)
{
	printk(KERN_INFO ""%s: NFSv4 Flexfile Layout Driver Registering...\n"",
	       __func__);
	return pnfs_register_layoutdriver(&flexfilelayout_type);
}",0
Detect whether the following code contains vulnerabilities.,"static int clone_submodule(const char *path, const char *gitdir, const char *url,
			   const char *depth, struct string_list *reference,
			   int quiet, int progress)
{
	struct child_process cp = CHILD_PROCESS_INIT;

	argv_array_push(&cp.args, ""clone"");
	argv_array_push(&cp.args, ""--no-checkout"");
	if (quiet)
		argv_array_push(&cp.args, ""--quiet"");
	if (progress)
		argv_array_push(&cp.args, ""--progress"");
	if (depth && *depth)
		argv_array_pushl(&cp.args, ""--depth"", depth, NULL);
	if (reference->nr) {
		struct string_list_item *item;
		for_each_string_list_item(item, reference)
			argv_array_pushl(&cp.args, ""--reference"",
					 item->string, NULL);
	}
	if (gitdir && *gitdir)
		argv_array_pushl(&cp.args, ""--separate-git-dir"", gitdir, NULL);

	argv_array_push(&cp.args, url);
	argv_array_push(&cp.args, path);

	cp.git_cmd = 1;
	prepare_submodule_repo_env(&cp.env_array);
	cp.no_stdin = 1;

	return run_command(&cp);
}",1
Detect whether the following code contains vulnerabilities.,"uint32_t lm4549_write_samples(lm4549_state *s, uint32_t left, uint32_t right)

{

    /* The left and right samples are in 20-bit resolution.

       The LM4549 has 18-bit resolution and only uses the bits [19:2].

       This model supports 16-bit playback.

    */



    if (s->buffer_level >= LM4549_BUFFER_SIZE) {

        DPRINTF(""write_sample Buffer full\n"");

        return 0;

    }



    /* Store 16-bit samples in the buffer */

    s->buffer[s->buffer_level++] = (left >> 4);

    s->buffer[s->buffer_level++] = (right >> 4);



    if (s->buffer_level == LM4549_BUFFER_SIZE) {

        /* Trigger the transfer of the buffer to the audio host */

        lm4549_audio_transfer(s);

    }



    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"
      static double mp_avg(_cimg_math_parser& mp) {
        const unsigned int i_end = (unsigned int)mp.opcode[2];
        double val = _mp_arg(3);
        for (unsigned int i = 4; i<i_end; ++i) val+=_mp_arg(i);
        return val/(i_end - 3);",0
Detect whether the following code contains vulnerabilities.,"static int sg_build_iovec(sg_io_hdr_t __user *sgio, void __user *dxferp, u16 iovec_count)
{
	sg_iovec_t __user *iov = (sg_iovec_t __user *) (sgio + 1);
	sg_iovec32_t __user *iov32 = dxferp;
	int i;

	for (i = 0; i < iovec_count; i++) {
		u32 base, len;

		if (get_user(base, &iov32[i].iov_base) ||
		    get_user(len, &iov32[i].iov_len) ||
		    put_user(compat_ptr(base), &iov[i].iov_base) ||
		    put_user(len, &iov[i].iov_len))
			return -EFAULT;
	}

	if (put_user(iov, &sgio->dxferp))
		return -EFAULT;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void apic_reset_irq_delivered(void)

{

    trace_apic_reset_irq_delivered(apic_irq_delivered);



    apic_irq_delivered = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"X509::X509(const char* i, size_t iSz, const char* s, size_t sSz,
           const char* b, int bSz, const char* a, int aSz)
    : issuer_(i, iSz), subject_(s, sSz),
      beforeDate_(b, bSz), afterDate_(a, aSz)
{}",1
Detect whether the following code contains vulnerabilities.,"flatpak_dir_lookup_cached_summary (FlatpakDir *self,
                                   GBytes    **bytes_out,
                                   GBytes    **bytes_sig_out,
                                   const char *name,
                                   const char *url)
{
  CachedSummary *summary;
  gboolean res = FALSE;

  G_LOCK (cache);

  if (self->summary_cache == NULL)
    self->summary_cache = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, (GDestroyNotify) cached_summary_free);

  summary = g_hash_table_lookup (self->summary_cache, name);
  if (summary)
    {
      guint64 now = g_get_monotonic_time ();
      if ((now - summary->time) < (1000 * 1000 * (SUMMARY_CACHE_TIMEOUT_SEC)) &&
          strcmp (url, summary->url) == 0)
        {
          /* g_debug (""Using cached summary for remote %s"", name); */
          *bytes_out = g_bytes_ref (summary->bytes);
          if (bytes_sig_out)
            {
              if (summary->bytes_sig)
                *bytes_sig_out = g_bytes_ref (summary->bytes_sig);
              else
                *bytes_sig_out = NULL;
            }
          res = TRUE;
        }
    }

  G_UNLOCK (cache);

  return res;
}",0
Detect whether the following code contains vulnerabilities.,"make_url (char **url, const char *dn, const char *filter)
{
  gpg_error_t err;
  char *u_dn, *u_filter;
  char const attrs[] = (USERCERTIFICATE "",""
/*                         USERSMIMECERTIFICATE "","" */
                        CACERTIFICATE "",""
                        X509CACERT );

  *url = NULL;

  u_dn = escape4url (dn);
  if (!u_dn)
      return gpg_error_from_errno (errno);

  u_filter = escape4url (filter);
  if (!u_filter)
    {
      err = gpg_error_from_errno (errno);
      xfree (u_dn);
      return err;
    }
  *url = malloc ( 8 + strlen (u_dn)
                 + 1 + strlen (attrs)
                 + 5 + strlen (u_filter) + 1 );
  if (!*url)
    {
      err = gpg_error_from_errno (errno);
      xfree (u_dn);
      xfree (u_filter);
      return err;
    }

  stpcpy (stpcpy (stpcpy (stpcpy (stpcpy (stpcpy (*url, ""ldap:///""),
                                          u_dn),
                                  ""?""),
                          attrs),
                  ""?sub?""),
          u_filter);
  xfree (u_dn);
  xfree (u_filter);
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int qemu_peek_buffer(QEMUFile *f, uint8_t *buf, int size, size_t offset)

{

    int pending;

    int index;



    assert(!qemu_file_is_writable(f));



    index = f->buf_index + offset;

    pending = f->buf_size - index;

    if (pending < size) {

        qemu_fill_buffer(f);

        index = f->buf_index + offset;

        pending = f->buf_size - index;

    }



    if (pending <= 0) {

        return 0;

    }

    if (size > pending) {

        size = pending;

    }



    memcpy(buf, f->buf + index, size);

    return size;

}
",1
Detect whether the following code contains vulnerabilities.,"static int htab_save_setup(QEMUFile *f, void *opaque)

{

    sPAPRMachineState *spapr = opaque;



    /* ""Iteration"" header */

    qemu_put_be32(f, spapr->htab_shift);



    if (spapr->htab) {

        spapr->htab_save_index = 0;

        spapr->htab_first_pass = true;

    } else {

        assert(kvm_enabled());



        spapr->htab_fd = kvmppc_get_htab_fd(false);

        spapr->htab_fd_stale = false;

        if (spapr->htab_fd < 0) {

            fprintf(stderr, ""Unable to open fd for reading hash table from KVM: %s\n"",

                    strerror(errno));

            return -1;

        }

    }





    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"ossl_asn1_class2sym(int tc)
{
    if((tc & V_ASN1_PRIVATE) == V_ASN1_PRIVATE)
	return sym_PRIVATE;
    else if((tc & V_ASN1_CONTEXT_SPECIFIC) == V_ASN1_CONTEXT_SPECIFIC)
	return sym_CONTEXT_SPECIFIC;
    else if((tc & V_ASN1_APPLICATION) == V_ASN1_APPLICATION)
	return sym_APPLICATION;
    else
	return sym_UNIVERSAL;
}",0
Detect whether the following code contains vulnerabilities.,"static void dec_store(DisasContext *dc)

{

    TCGv t, *addr;

    unsigned int size;



    size = 1 << (dc->opcode & 3);



    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)

          && !(dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {

        tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

        t_gen_raise_exception(dc, EXCP_HW_EXCP);

        return;

    }



    LOG_DIS(""s%d%s\n"", size, dc->type_b ? ""i"" : """");

    t_sync_flags(dc);

    /* If we get a fault on a dslot, the jmpstate better be in sync.  */

    sync_jmpstate(dc);

    addr = compute_ldst_addr(dc, &t);



    /* Verify alignment if needed.  */

    if ((dc->env->pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {

        gen_helper_memalign(*addr, tcg_const_tl(dc->rd),

                            tcg_const_tl(1), tcg_const_tl(size - 1));

    }



    gen_store(dc, *addr, cpu_R[dc->rd], size);

    if (addr == &t)

        tcg_temp_free(t);

}
",0
Detect whether the following code contains vulnerabilities.,"ast_for_arg(struct compiling *c, const node *n)
{
    identifier name;
    expr_ty annotation = NULL;
    node *ch;
    arg_ty ret;

    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);
    ch = CHILD(n, 0);
    name = NEW_IDENTIFIER(ch);
    if (!name)
        return NULL;
    if (forbidden_name(c, name, ch, 0))
        return NULL;

    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {
        annotation = ast_for_expr(c, CHILD(n, 2));
        if (!annotation)
            return NULL;
    }

    ret = arg(name, annotation, LINENO(n), n->n_col_offset,
              n->n_end_lineno, n->n_end_col_offset, c->c_arena);
    if (!ret)
        return NULL;
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void check_no_speaker_on_headset(struct snd_kcontrol *kctl,
					struct snd_card *card)
{
	const char *names_to_check[] = {
		""Headset"", ""headset"", ""Headphone"", ""headphone"", NULL};
	const char **s;
	bool found = false;

	if (strcmp(""Speaker"", kctl->id.name))
		return;

	for (s = names_to_check; *s; s++)
		if (strstr(card->shortname, *s)) {
			found = true;
			break;
		}

	if (!found)
		return;

	strlcpy(kctl->id.name, ""Headphone"", sizeof(kctl->id.name));
}",0
Detect whether the following code contains vulnerabilities.,"static int vhost_kernel_memslots_limit(struct vhost_dev *dev)

{

    int limit = 64;

    char *s;



    if (g_file_get_contents(""/sys/module/vhost/parameters/max_mem_regions"",

                            &s, NULL, NULL)) {

        uint64_t val = g_ascii_strtoull(s, NULL, 10);

        if (!((val == G_MAXUINT64 || !val) && errno)) {


            return val;

        }

        error_report(""ignoring invalid max_mem_regions value in vhost module:""

                     "" %s"", s);

    }


    return limit;

}",1
Detect whether the following code contains vulnerabilities.,"ga_init2(garray_T *gap, int itemsize, int growsize)
{
    ga_init(gap);
    gap->ga_itemsize = itemsize;
    gap->ga_growsize = growsize;
}",1
Detect whether the following code contains vulnerabilities.,"e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)

{

    return core->mac[r->dh] == core->mac[r->dt];

}
",1
Detect whether the following code contains vulnerabilities.,"struct dst_entry *inet6_csk_route_req(const struct sock *sk,
				      struct flowi6 *fl6,
				      const struct request_sock *req,
				      u8 proto)
{
	struct inet_request_sock *ireq = inet_rsk(req);
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct in6_addr *final_p, final;
	struct dst_entry *dst;

	memset(fl6, 0, sizeof(*fl6));
	fl6->flowi6_proto = proto;
	fl6->daddr = ireq->ir_v6_rmt_addr;
	rcu_read_lock();
	final_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);
	rcu_read_unlock();
	fl6->saddr = ireq->ir_v6_loc_addr;
	fl6->flowi6_oif = ireq->ir_iif;
	fl6->flowi6_mark = ireq->ir_mark;
	fl6->fl6_dport = ireq->ir_rmt_port;
	fl6->fl6_sport = htons(ireq->ir_num);
	security_req_classify_flow(req, flowi6_to_flowi(fl6));

	dst = ip6_dst_lookup_flow(sk, fl6, final_p);
	if (IS_ERR(dst))
		return NULL;

	return dst;
}",0
Detect whether the following code contains vulnerabilities.,"napi_status napi_set_named_property(napi_env env,
                                    napi_value object,
                                    const char* utf8name,
                                    napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",0
Detect whether the following code contains vulnerabilities.,"static int resize_runtime_buffer(struct snd_rawmidi_runtime *runtime,
				 struct snd_rawmidi_params *params,
				 bool is_input)
{
	char *newbuf, *oldbuf;

	if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L)
		return -EINVAL;
	if (params->avail_min < 1 || params->avail_min > params->buffer_size)
		return -EINVAL;
	if (params->buffer_size != runtime->buffer_size) {
		newbuf = kvzalloc(params->buffer_size, GFP_KERNEL);
		if (!newbuf)
			return -ENOMEM;
		spin_lock_irq(&runtime->lock);
		oldbuf = runtime->buffer;
		runtime->buffer = newbuf;
		runtime->buffer_size = params->buffer_size;
		__reset_runtime_ptrs(runtime, is_input);
		spin_unlock_irq(&runtime->lock);
		kvfree(oldbuf);
	}
	runtime->avail_min = params->avail_min;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void block_job_completed(BlockJob *job, int ret)

{

    BlockDriverState *bs = job->bs;



    assert(bs->job == job);

    job->cb(job->opaque, ret);

    bs->job = NULL;

    g_free(job);

    bdrv_set_in_use(bs, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"int net_slirp_redir(const char *redir_str)

{

    struct slirp_config_str *config;



    if (QTAILQ_EMPTY(&slirp_stacks)) {

        config = g_malloc(sizeof(*config));

        pstrcpy(config->str, sizeof(config->str), redir_str);

        config->flags = SLIRP_CFG_HOSTFWD | SLIRP_CFG_LEGACY;

        config->next = slirp_configs;

        slirp_configs = config;

        return 0;

    }



    return slirp_hostfwd(QTAILQ_FIRST(&slirp_stacks), redir_str, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
				    struct kvm_lapic_state *s)
{
	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);

	return kvm_apic_get_state(vcpu, s);
}",0
Detect whether the following code contains vulnerabilities.,"static int init_pitch_v1(struct snd_usb_audio *chip, int iface,
			 struct usb_host_interface *alts,
			 struct audioformat *fmt)
{
	struct usb_device *dev = chip->dev;
	unsigned int ep;
	unsigned char data[1];
	int err;

	ep = get_endpoint(alts, 0)->bEndpointAddress;

	data[0] = 1;
	if ((err = snd_usb_ctl_msg(dev, usb_sndctrlpipe(dev, 0), UAC_SET_CUR,
				   USB_TYPE_CLASS|USB_RECIP_ENDPOINT|USB_DIR_OUT,
				   UAC_EP_CS_ATTR_PITCH_CONTROL << 8, ep,
				   data, sizeof(data))) < 0) {
		usb_audio_err(chip, ""%d:%d: cannot set enable PITCH\n"",
			      iface, ep);
		return err;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(SplFileInfo, getFileInfo)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	zend_class_entry *ce = intern->info_class;
	zend_error_handling error_handling;
	
	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
		spl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);
	}

	zend_restore_error_handling(&error_handling TSRMLS_CC);
}",1
Detect whether the following code contains vulnerabilities.,"static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)
{
	struct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);
	if (!IS_ERR(new_ns)) {
		struct mount *mnt = real_mount(m);
		mnt->mnt_ns = new_ns;
		new_ns->root = mnt;
		list_add(&mnt->mnt_list, &new_ns->list);
	} else {
		mntput(m);
	}
	return new_ns;
}",1
Detect whether the following code contains vulnerabilities.,"static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)

{

    int i, csize = 1;

    void *src[3];



    for (i = 1; i < 3; i++)

        if (tile->codsty[0].transform != tile->codsty[i].transform) {

            av_log(s->avctx, AV_LOG_ERROR, ""Transforms mismatch, MCT not supported\n"");

            return;

        }



    for (i = 0; i < 3; i++)

        if (tile->codsty[0].transform == FF_DWT97)

            src[i] = tile->comp[i].f_data;

        else

            src[i] = tile->comp[i].i_data;



    for (i = 0; i < 2; i++)

        csize *= tile->comp[0].coord[i][1] - tile->comp[0].coord[i][0];



    s->dsp.mct_decode[tile->codsty[0].transform](src[0], src[1], src[2], csize);

}
",0
Detect whether the following code contains vulnerabilities.,"static TS_RESP *read_PKCS7(BIO *in_bio)
	{
	int ret = 0;
	PKCS7 *token = NULL;
	TS_TST_INFO *tst_info = NULL;
	TS_RESP *resp = NULL;
	TS_STATUS_INFO *si = NULL;

	/* Read PKCS7 object and extract the signed time stamp info. */
	if (!(token = d2i_PKCS7_bio(in_bio, NULL))) goto end;
	if (!(tst_info = PKCS7_to_TS_TST_INFO(token))) goto end;

	/* Creating response object. */
	if (!(resp = TS_RESP_new())) goto end;

	/* Create granted status info. */
	if (!(si = TS_STATUS_INFO_new())) goto end;
	if (!(ASN1_INTEGER_set(si->status, TS_STATUS_GRANTED))) goto end;
	if (!TS_RESP_set_status_info(resp, si)) goto end;

	/* Setting encapsulated token. */
	TS_RESP_set_tst_info(resp, token, tst_info);
	token = NULL;		/* Ownership is lost. */
	tst_info = NULL;	/* Ownership is lost. */

	ret = 1;
 end:
	PKCS7_free(token);
	TS_TST_INFO_free(tst_info);
	if (!ret)
		{
		TS_RESP_free(resp);
		resp = NULL;
		}
	TS_STATUS_INFO_free(si);
	return resp;
	}",0
Detect whether the following code contains vulnerabilities.,"int hashtable_init(hashtable_t *hashtable)
{
    size_t i;

    hashtable->size = 0;
    hashtable->num_buckets = 0;  /* index to primes[] */
    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));
    if(!hashtable->buckets)
        return -1;

    list_init(&hashtable->list);

    for(i = 0; i < num_buckets(hashtable); i++)
    {
        hashtable->buckets[i].first = hashtable->buckets[i].last =
            &hashtable->list;
    }

    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"internal_write_rsa_key(struct sc_card *card, unsigned short fid, struct sc_pkcs15_prkey_rsa *rsa)
{
	int r;

	LOG_FUNC_CALLED(card->ctx);

	r = internal_write_rsa_key_factor(card, fid, 0x02, rsa->modulus);
	LOG_TEST_RET(card->ctx, r, ""write n failed"");
	r = internal_write_rsa_key_factor(card, fid, 0x03, rsa->d);
	LOG_TEST_RET(card->ctx, r, ""write d failed"");

	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}",0
Detect whether the following code contains vulnerabilities.,    virtual UBool appendCodeUnit(UChar c) { str.append(c); return TRUE; },0
Detect whether the following code contains vulnerabilities.,"int basic_authentication(zval* this_ptr, smart_str* soap_headers TSRMLS_DC)
{
	zval **login, **password;

	if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_login"", sizeof(""_login""), (void **)&login) == SUCCESS &&
			!zend_hash_exists(Z_OBJPROP_P(this_ptr), ""_digest"", sizeof(""_digest""))) {
		unsigned char* buf;
		int len;
		smart_str auth = {0};

		smart_str_appendl(&auth, Z_STRVAL_PP(login), Z_STRLEN_PP(login));
		smart_str_appendc(&auth, ':');
		if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_password"", sizeof(""_password""), (void **)&password) == SUCCESS) {
			smart_str_appendl(&auth, Z_STRVAL_PP(password), Z_STRLEN_PP(password));
		}
		smart_str_0(&auth);
		buf = php_base64_encode((unsigned char*)auth.c, auth.len, &len);
		smart_str_append_const(soap_headers, ""Authorization: Basic "");
		smart_str_appendl(soap_headers, (char*)buf, len);
		smart_str_append_const(soap_headers, ""\r\n"");
		efree(buf);
		smart_str_free(&auth);
		return 1;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void ShutdownWrap::OnDone(int status) {
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",0
Detect whether the following code contains vulnerabilities.,"cmsBool CMSEXPORT cmsIT8SetPropertyDbl(cmsHANDLE hIT8, const char* cProp, cmsFloat64Number Val)
{
    cmsIT8* it8 = (cmsIT8*) hIT8;
    char Buffer[1024];

    sprintf(Buffer, it8->DoubleFormatter, Val);

    return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_UNCOOKED) != NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold void uninit(AVFilterContext *ctx)
{
    VignetteContext *s = ctx->priv;
    av_freep(&s->fmap);
    av_expr_free(s->angle_pexpr);
    av_expr_free(s->x0_pexpr);
    av_expr_free(s->y0_pexpr);
}",0
Detect whether the following code contains vulnerabilities.,"vmxnet3_pop_rxc_descr(VMXNET3State *s, int qidx, uint32_t *descr_gen)

{

    uint8_t ring_gen;

    struct Vmxnet3_RxCompDesc rxcd;



    hwaddr daddr =

        vmxnet3_ring_curr_cell_pa(&s->rxq_descr[qidx].comp_ring);



    pci_dma_read(PCI_DEVICE(s), daddr,

                 &rxcd, sizeof(struct Vmxnet3_RxCompDesc));



    ring_gen = vmxnet3_ring_curr_gen(&s->rxq_descr[qidx].comp_ring);



    if (rxcd.gen != ring_gen) {

        *descr_gen = ring_gen;

        vmxnet3_inc_rx_completion_counter(s, qidx);

        return daddr;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int f2fs_set_data_page_dirty(struct page *page)
{
	struct address_space *mapping = page->mapping;
	struct inode *inode = mapping->host;

	trace_f2fs_set_page_dirty(page, DATA);

	if (!PageUptodate(page))
		SetPageUptodate(page);

	if (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {
		if (!IS_ATOMIC_WRITTEN_PAGE(page)) {
			f2fs_register_inmem_page(inode, page);
			return 1;
		}
		/*
		 * Previously, this page has been registered, we just
		 * return here.
		 */
		return 0;
	}

	if (!PageDirty(page)) {
		__set_page_dirty_nobuffers(page);
		f2fs_update_dirty_page(inode, page);
		return 1;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"Pl_ASCII85Decoder::flush()
{
    if (this->pos == 0)
    {
	QTC::TC(""libtests"", ""Pl_ASCII85Decoder no-op flush"");
	return;
    }
    unsigned long lval = 0;
    for (int i = 0; i < 5; ++i)
    {
	lval *= 85;
	lval += (this->inbuf[i] - 33U);
    }

    unsigned char outbuf[4];
    memset(outbuf, 0, 4);
    for (int i = 3; i >= 0; --i)
    {
	outbuf[i] = lval & 0xff;
	lval >>= 8;
    }

    QTC::TC(""libtests"", ""Pl_ASCII85Decoder partial flush"",
	    (this->pos == 5) ? 0 : 1);
    getNext()->write(outbuf, this->pos - 1);

    this->pos = 0;
    memset(this->inbuf, 117, 5);
}",1
Detect whether the following code contains vulnerabilities.,"pad_or_truncate_password_V4(std::string const& password)
{
    char k1[key_bytes];
    pad_or_truncate_password_V4(password, k1);
    return std::string(k1, key_bytes);
}",1
Detect whether the following code contains vulnerabilities.,"VideoTrack::VideoTrack(unsigned int* seed)
    : Track(seed),
      display_height_(0),
      display_width_(0),
      pixel_height_(0),
      pixel_width_(0),
      crop_left_(0),
      crop_right_(0),
      crop_top_(0),
      crop_bottom_(0),
      frame_rate_(0.0),
      height_(0),
      stereo_mode_(0),
      alpha_mode_(0),
      width_(0),
      colour_(NULL),
      projection_(NULL) {}",1
Detect whether the following code contains vulnerabilities.,"int putpwent_sane(const struct passwd *pw, FILE *stream) {
        assert(pw);
        assert(stream);

        errno = 0;
        if (putpwent(pw, stream) != 0)
                return errno_or_else(EIO);

        return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int16_t decodeSample(ms_adpcm_state &state,
	uint8_t code, const int16_t *coefficient)
{
	int linearSample = (state.sample1 * coefficient[0] +
		state.sample2 * coefficient[1]) >> 8;

	linearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;

	linearSample = clamp(linearSample, MIN_INT16, MAX_INT16);

	int delta = (state.delta * adaptationTable[code]) >> 8;
	if (delta < 16)
		delta = 16;

	state.delta = delta;
	state.sample2 = state.sample1;
	state.sample1 = linearSample;

	return static_cast<int16_t>(linearSample);
}",1
Detect whether the following code contains vulnerabilities.,"QStringList PostgreSqlStorage::setupKeys() const
{
    QStringList keys;
    keys << ""Username""
         << ""Password""
         << ""Hostname""
         << ""Port""
         << ""Database"";
    return keys;
}",0
Detect whether the following code contains vulnerabilities.,"static void dead_tmp(TCGv tmp)

{

    tcg_temp_free(tmp);

    num_temps--;

}
",1
Detect whether the following code contains vulnerabilities.,"Panic(const char *fmtstr,
      va_list args)
{
   /* Ignored */
   sLog(log_warning, ""Panic call back invoked. \n"");
}",1
Detect whether the following code contains vulnerabilities.,"static int scsi_event_status_media(SCSIDiskState *s, uint8_t *outbuf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->qdev.conf.bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->media_event) {

            event_code = MEC_NEW_MEDIA;

            s->media_event = false;

        } else if (s->eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->eject_request = false;

        }

    }



    outbuf[0] = event_code;

    outbuf[1] = media_status;



    /* These fields are reserved, just clear them. */

    outbuf[2] = 0;

    outbuf[3] = 0;

    return 4;

}
",0
Detect whether the following code contains vulnerabilities.,"static void l2x0_class_init(ObjectClass *klass, void *data)

{

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = l2x0_priv_init;

    dc->vmsd = &vmstate_l2x0;

    dc->no_user = 1;

    dc->props = l2x0_properties;

    dc->reset = l2x0_priv_reset;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void glue(rop_32_,ROP_NAME)(uint32_t *dst, uint32_t src)
{
    *dst = ROP_FN(*dst, src);
}",1
Detect whether the following code contains vulnerabilities.,"EXPORTED void mailbox_make_uniqueid(struct mailbox *mailbox)
{
    free(mailbox->h.uniqueid);
    mailbox->h.uniqueid = xstrdup(makeuuid());
    mailbox->header_dirty = 1;
}",1
Detect whether the following code contains vulnerabilities.,"static QObject *qmp_output_pop(QmpOutputVisitor *qov, void *qapi)

{

    QStackEntry *e = QSLIST_FIRST(&qov->stack);

    QObject *value;



    assert(e);

    assert(e->qapi == qapi);

    QSLIST_REMOVE_HEAD(&qov->stack, node);

    value = e->value;

    assert(value);

    g_free(e);

    return value;

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_output_visitor_cleanup(QmpOutputVisitor *v)

{

    QStackEntry *e, *tmp;



    QTAILQ_FOREACH_SAFE(e, &v->stack, node, tmp) {

        QTAILQ_REMOVE(&v->stack, e, node);

        if (e->value) {

            qobject_decref(e->value);

        }

        g_free(e);

    }



    g_free(v);

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_error_internal(const char *file, int linenr, const char *func,

                         const char *fmt, ...)

{

    va_list va;

    QError *qerror;



    assert(qemu_error_sink != NULL);



    va_start(va, fmt);

    qerror = qerror_from_info(file, linenr, func, fmt, &va);

    va_end(va);



    switch (qemu_error_sink->dest) {

    case ERR_SINK_FILE:

        qerror_print(qerror);

        QDECREF(qerror);

        break;

    case ERR_SINK_MONITOR:

        assert(qemu_error_sink->mon->error == NULL);

        qemu_error_sink->mon->error = qerror;

        break;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void exif_error_docref(const char *docref EXIFERR_DC, const image_info_type *ImageInfo, int type, const char *format, ...)
{
	va_list args;
	
	va_start(args, format);
#ifdef EXIF_DEBUG
	{
		char *buf;

		spprintf(&buf, 0, ""%s(%d): %s"", _file, _line, format);
		php_verror(docref, ImageInfo->FileName?ImageInfo->FileName:"""", type, buf, args TSRMLS_CC);
		efree(buf);
	}
#else
	php_verror(docref, ImageInfo->FileName?ImageInfo->FileName:"""", type, format, args TSRMLS_CC);
#endif
	va_end(args);
}",1
Detect whether the following code contains vulnerabilities.,"int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    NBDRequest request = {

        .type = NBD_CMD_TRIM,

        .from = offset,

        .len = bytes,

    };




    if (!(client->info.flags & NBD_FLAG_SEND_TRIM)) {

        return 0;

    }



    return nbd_co_request(bs, &request, NULL);

}",1
Detect whether the following code contains vulnerabilities.,"void ring_buffer_reset_cpu(struct trace_buffer *buffer, int cpu)
{
	struct ring_buffer_per_cpu *cpu_buffer = buffer->buffers[cpu];

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return;

	atomic_inc(&cpu_buffer->resize_disabled);
	atomic_inc(&cpu_buffer->record_disabled);

	/* Make sure all commits have finished */
	synchronize_rcu();

	reset_disabled_cpu_buffer(cpu_buffer);

	atomic_dec(&cpu_buffer->record_disabled);
	atomic_dec(&cpu_buffer->resize_disabled);
}",1
Detect whether the following code contains vulnerabilities.,"static void omap_mpui_io_write(void *opaque, target_phys_addr_t addr,

                               uint64_t value, unsigned size)

{

    /* FIXME: infinite loop */

    omap_badwidth_write16(opaque, addr, value);

}
",0
Detect whether the following code contains vulnerabilities.,"static VirtIOSCSIReq *virtio_scsi_pop_req(VirtIOSCSI *s, VirtQueue *vq)

{

    VirtIOSCSIReq *req;

    req = g_malloc(sizeof(*req));

    if (!virtqueue_pop(vq, &req->elem)) {

        g_free(req);

        return NULL;

    }



    virtio_scsi_parse_req(s, vq, req);

    return req;

}
",0
Detect whether the following code contains vulnerabilities.,"val_inq_ctx_args(
    OM_uint32 *minor_status,
    gss_ctx_id_t context_handle,
    gss_name_t *src_name,
    gss_name_t *targ_name,
    OM_uint32 *lifetime_rec,
    gss_OID *mech_type,
    OM_uint32 *ctx_flags,
    int *locally_initiated,
    int *opened)
{

    /* Initialize outputs. */

    if (minor_status != NULL)
	*minor_status = 0;

    if (src_name != NULL)
	*src_name = GSS_C_NO_NAME;

    if (targ_name != NULL)
	*targ_name = GSS_C_NO_NAME;

    if (mech_type != NULL)
	*mech_type = GSS_C_NO_OID;

    /* Validate arguments. */

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    return (GSS_S_COMPLETE);
}",0
Detect whether the following code contains vulnerabilities.,"static void set_pixel_format(VncState *vs,
                             int bits_per_pixel, int depth,
                             int big_endian_flag, int true_color_flag,
                             int red_max, int green_max, int blue_max,
                             int red_shift, int green_shift, int blue_shift)
{
    if (!true_color_flag) {
    vs->client_pf.rmax = red_max;
    vs->client_pf.rbits = hweight_long(red_max);
    vs->client_pf.rshift = red_shift;
    vs->client_pf.rmask = red_max << red_shift;
    vs->client_pf.gmax = green_max;
    vs->client_pf.gbits = hweight_long(green_max);
    vs->client_pf.gshift = green_shift;
    vs->client_pf.gmask = green_max << green_shift;
    vs->client_pf.bmax = blue_max;
    vs->client_pf.bbits = hweight_long(blue_max);
    vs->client_pf.bshift = blue_shift;
    vs->client_pf.bmask = blue_max << blue_shift;
    vs->client_pf.bits_per_pixel = bits_per_pixel;
    vs->client_pf.bytes_per_pixel = bits_per_pixel / 8;
    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;
    vs->client_be = big_endian_flag;
    set_pixel_conversion(vs);
    graphic_hw_invalidate(NULL);
    graphic_hw_update(NULL);",1
Detect whether the following code contains vulnerabilities.,"bool Krecipes::queryClose()
{
	if ( !m_view->inputPanel->everythingSaved() ) {
		switch ( KMessageBox::questionYesNoCancel( this,
		         i18n( ""A recipe contains unsaved changes.\n""
		               ""Do you want to save the changes before exiting?"" ),
		         i18n( ""Unsaved Changes"" ) ) ) {
		case KMessageBox::Yes:
			return m_view->save();
		case KMessageBox::No:
			return true;
		case KMessageBox::Cancel:
			return false;
		default:
			return true;
		}
	}
	else
		return true;
}",0
Detect whether the following code contains vulnerabilities.,"datetime_s_jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__jisx0301(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int handle_pause(struct kvm_vcpu *vcpu)
{
	if (!kvm_pause_in_guest(vcpu->kvm))
		grow_ple_window(vcpu);

	/*
	 * Intel sdm vol3 ch-25.1.3 says: The ""PAUSE-loop exiting""
	 * VM-execution control is ignored if CPL > 0. OTOH, KVM
	 * never set PAUSE_EXITING and just set PLE if supported,
	 * so the vcpu must be CPL=0 if it gets a PAUSE exit.
	 */
	kvm_vcpu_on_spin(vcpu, true);
	return kvm_skip_emulated_instruction(vcpu);
}",0
Detect whether the following code contains vulnerabilities.,"void Mounter::startTimer()
{
    if (!timer) {
        timer=new QTimer(this);
        connect(timer, SIGNAL(timeout()), SLOT(timeout()));
    }
    timer->start(30000);
}",1
Detect whether the following code contains vulnerabilities.,"    bool Image::isPrintICC(uint16_t type, Exiv2::PrintStructureOption option)
    {
        return type == 0x8773 && option == kpsIccProfile;
    }",0
Detect whether the following code contains vulnerabilities.,"struct sctp_chunk *sctp_assoc_lookup_asconf_ack(
					const struct sctp_association *asoc,
					__be32 serial)
{
	struct sctp_chunk *ack;

	/* Walk through the list of cached ASCONF-ACKs and find the
	 * ack chunk whose serial number matches that of the request.
	 */
	list_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {
		if (ack->subh.addip_hdr->serial == serial) {
			sctp_chunk_hold(ack);
			return ack;
		}
	}

	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"int hashtable_del(hashtable_t *hashtable, const char *key)
{
    size_t hash = hash_str(key);
    return hashtable_do_del(hashtable, key, hash);
}",0
Detect whether the following code contains vulnerabilities.,"MONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {
    return bson_append_string_base( b, name, value, len, BSON_STRING );
}",1
Detect whether the following code contains vulnerabilities.,"entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
  if (! rst)
    return 1; // No restriction?  No problem.

  // Only one kind of restriction exists right now
  return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
}",1
Detect whether the following code contains vulnerabilities.,"SwapCreateRegister(ClientPtr client, xRecordRegisterClientsReq * stuff)
{
    int i;
    XID *pClientID;

    swapl(&stuff->context);
    swapl(&stuff->nClients);
    swapl(&stuff->nRanges);
    pClientID = (XID *) &stuff[1];
    if (stuff->nClients >
        client->req_len - bytes_to_int32(sz_xRecordRegisterClientsReq))
        return BadLength;
    for (i = 0; i < stuff->nClients; i++, pClientID++) {
        swapl(pClientID);
    }
    if (stuff->nRanges >
        client->req_len - bytes_to_int32(sz_xRecordRegisterClientsReq)
        - stuff->nClients)
        return BadLength;
    RecordSwapRanges((xRecordRange *) pClientID, stuff->nRanges);
    return Success;
}                               /* SwapCreateRegister */",1
Detect whether the following code contains vulnerabilities.,"static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)
{
	int i;
	int c;
	for (i = n; i > 0; --i) {
		c = (val >> (8 * (i - 1))) & 0xff;
		if (jas_stream_putc(out, c) == EOF)
			return -1;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,
                                         const unsigned char *buf,
                                         size_t len )
{
    if( len != 0 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad client hello message"" ) );
        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    }

    ((void) buf);

    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
        ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;

    return( 0 );
}",0
Detect whether the following code contains vulnerabilities.,"void dma_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie,

                    QEMUSGList *sg, enum BlockAcctType type)

{

    block_acct_start(bdrv_get_stats(bs), cookie, sg->size, type);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_add(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv t0 = tcg_const_tl(0);

    TCGv res = tcg_temp_new();

    TCGv sr_cy = tcg_temp_new();

    TCGv sr_ov = tcg_temp_new();



    tcg_gen_add2_tl(res, sr_cy, srca, t0, srcb, t0);

    tcg_gen_xor_tl(sr_ov, srca, srcb);

    tcg_gen_xor_tl(t0, res, srcb);

    tcg_gen_andc_tl(sr_ov, t0, sr_ov);

    tcg_temp_free(t0);



    tcg_gen_mov_tl(dest, res);

    tcg_temp_free(res);



    tcg_gen_shri_tl(sr_ov, sr_ov, TARGET_LONG_BITS - 1);

    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);

    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);



    gen_ove_cyov(dc, sr_ov, sr_cy);

    tcg_temp_free(sr_ov);

    tcg_temp_free(sr_cy);

}
",1
Detect whether the following code contains vulnerabilities.,"evdev_log_msg(struct evdev_device *device,
	      enum libinput_log_priority priority,
	      const char *format,
	      ...)
{
	va_list args;
	char buf[1024];

	if (!is_logged(evdev_libinput_context(device), priority))
		return;

	/* Anything info and above is user-visible, use the device name */
	snprintf(buf,
		 sizeof(buf),
		 ""%-7s - %s%s%s"",
		 evdev_device_get_sysname(device),
		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  device->devname : """",
		 (priority > LIBINPUT_LOG_PRIORITY_DEBUG) ?  "": "" : """",
		 format);

	va_start(args, format);
	log_msg_va(evdev_libinput_context(device), priority, buf, args);
	va_end(args);

}",1
Detect whether the following code contains vulnerabilities.,"static void flush_buffer(ByteIOContext *s)

{

    if (s->buf_ptr > s->buffer) {

        if (s->write_packet)

            s->write_packet(s->opaque, s->buffer, s->buf_ptr - s->buffer);

        if(s->checksum_ptr){

            s->checksum= s->update_checksum(s->checksum, s->checksum_ptr, s->buf_ptr - s->checksum_ptr);

            s->checksum_ptr= s->buffer;

        }

        s->pos += s->buf_ptr - s->buffer;

    }

    s->buf_ptr = s->buffer;

}
",0
Detect whether the following code contains vulnerabilities.,"mrb_mruby_fiber_gem_init(mrb_state* mrb)
{
  struct RClass *c;

  c = mrb_define_class(mrb, ""Fiber"", mrb->object_class);
  MRB_SET_INSTANCE_TT(c, MRB_TT_FIBER);

  mrb_define_method(mrb, c, ""initialize"", fiber_init,    MRB_ARGS_NONE());
  mrb_define_method(mrb, c, ""resume"",     fiber_resume,  MRB_ARGS_ANY());
  mrb_define_method(mrb, c, ""transfer"",   fiber_transfer, MRB_ARGS_ANY());
  mrb_define_method(mrb, c, ""alive?"",     fiber_alive_p, MRB_ARGS_NONE());
  mrb_define_method(mrb, c, ""=="",         fiber_eq,      MRB_ARGS_REQ(1));

  mrb_define_class_method(mrb, c, ""yield"", fiber_yield, MRB_ARGS_ANY());
  mrb_define_class_method(mrb, c, ""current"", fiber_current, MRB_ARGS_NONE());

  mrb_define_class(mrb, ""FiberError"", mrb->eStandardError_class);
}",0
Detect whether the following code contains vulnerabilities.,"}

static char *format_date(u64 time, char *szTime)
{
	time_t now;
	if (!time) {
		strcpy(szTime, ""UNKNOWN DATE"");
	} else {
		time -= 2082844800;
		now = (u32) time;
		sprintf(szTime, ""GMT %s"", asctime(gf_gmtime(&now)) );
	}",0
Detect whether the following code contains vulnerabilities.,"static int rtcp_parse_packet(RTPDemuxContext *s, const unsigned char *buf, int len)

{

    int payload_len;

    while (len >= 2) {

        switch (buf[1]) {

        case RTCP_SR:

            if (len < 16) {

                av_log(NULL, AV_LOG_ERROR, ""Invalid length for RTCP SR packet\n"");

                return AVERROR_INVALIDDATA;

            }

            payload_len = (AV_RB16(buf + 2) + 1) * 4;



            s->last_rtcp_ntp_time = AV_RB64(buf + 8);

            s->last_rtcp_timestamp = AV_RB32(buf + 16);

            if (s->first_rtcp_ntp_time == AV_NOPTS_VALUE) {

                s->first_rtcp_ntp_time = s->last_rtcp_ntp_time;

                if (!s->base_timestamp)

                    s->base_timestamp = s->last_rtcp_timestamp;

                s->rtcp_ts_offset = s->last_rtcp_timestamp - s->base_timestamp;

            }



            buf += payload_len;

            len -= payload_len;

            break;

        case RTCP_BYE:

            return -RTCP_BYE;

        default:

            return -1;

        }

    }

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"bool StringMatching::matchString(const char* str1, const char* str2)
{
	if(fnmatch(str1,str2,FNM_NOESCAPE)==0)
		return true;
	if(fnmatch(str2,str1,FNM_NOESCAPE)==0)
		return true;
	return false;
}",1
Detect whether the following code contains vulnerabilities.,"PPC_OP(divwu)

{

    if (T1 == 0) {

        T0 = 0;

    } else {

        T0 /= T1;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"int register_savevm(DeviceState *dev,

                    const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveVMHandlers *ops = g_malloc0(sizeof(SaveVMHandlers));

    ops->save_state = save_state;

    ops->load_state = load_state;

    return register_savevm_live(dev, idstr, instance_id, version_id,

                                ops, opaque);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void cris_fidx_i(unsigned int x)

{

	register unsigned int v asm(""$r10"") = x;

	asm (""fidxi\t[%0]\n"" : : ""r"" (v) );

}
",1
Detect whether the following code contains vulnerabilities.,"static int mxf_write_header_metadata_sets(AVFormatContext *s)

{

    AVStream *st;

    MXFStreamContext *sc = NULL;

    int i;



    mxf_write_preface(s);

    mxf_write_identification(s);

    mxf_write_content_storage(s);



    for (i = 0; i < s->nb_streams; i++) {

        st = s->streams[i];

        sc = av_mallocz(sizeof(MXFStreamContext));

        if (!sc)

            return AVERROR(ENOMEM);

        st->priv_data = sc;

        // set pts information

        if (st->codec->codec_type == CODEC_TYPE_VIDEO)

            av_set_pts_info(st, 64, 1, st->codec->time_base.den);

        else if (st->codec->codec_type == CODEC_TYPE_AUDIO)

            av_set_pts_info(st, 64, 1, st->codec->sample_rate);

    }



    mxf_build_structural_metadata(s, MaterialPackage);

    mxf_build_structural_metadata(s, SourcePackage);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vmci_transport_send_invalid_bh(struct sockaddr_vm *dst,
					  struct sockaddr_vm *src)
{
	return vmci_transport_send_control_pkt_bh(
					dst, src,
					VMCI_TRANSPORT_PACKET_TYPE_INVALID,
					0, 0, NULL, VMCI_INVALID_HANDLE);
}",0
Detect whether the following code contains vulnerabilities.,"static int module_enforce_rwx_sections(Elf_Ehdr *hdr, Elf_Shdr *sechdrs,
				       char *secstrings, struct module *mod)
{
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int asf_probe(AVProbeData *pd)

{

    /* check file header */

    if (pd->buf_size <= 32)

        return 0;



    if (!memcmp(pd->buf, &asf_header, sizeof(GUID)))

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,
		unsigned int, flags, struct sockaddr __user *, addr,
		int __user *, addr_len)
{
	struct socket *sock;
	struct iovec iov;
	struct msghdr msg;
	struct sockaddr_storage address;
	int err, err2;
	int fput_needed;

	if (size > INT_MAX)
		size = INT_MAX;
	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (!sock)
		goto out;

	msg.msg_control = NULL;
	msg.msg_controllen = 0;
	msg.msg_iovlen = 1;
	msg.msg_iov = &iov;
	iov.iov_len = size;
	iov.iov_base = ubuf;
	msg.msg_name = (struct sockaddr *)&address;
	msg.msg_namelen = sizeof(address);
	if (sock->file->f_flags & O_NONBLOCK)
		flags |= MSG_DONTWAIT;
	err = sock_recvmsg(sock, &msg, size, flags);

	if (err >= 0 && addr != NULL) {
		err2 = move_addr_to_user(&address,
					 msg.msg_namelen, addr, addr_len);
		if (err2 < 0)
			err = err2;
	}

	fput_light(sock->file, fput_needed);
out:
	return err;
}",1
Detect whether the following code contains vulnerabilities.,"int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)

{

    int dom, pci_bus;

    unsigned slot;

    PCIDevice *dev;

    const char *pci_addr = qdict_get_str(qdict, ""pci_addr"");



    switch (dinfo->type) {

    case IF_SCSI:

        if (pci_read_devaddr(mon, pci_addr, &dom, &pci_bus, &slot)) {

            goto err;

        }

        dev = pci_find_device(pci_find_root_bus(dom), pci_bus,

                              PCI_DEVFN(slot, 0));

        if (!dev) {

            monitor_printf(mon, ""no pci device with address %s\n"", pci_addr);

            goto err;

        }

        if (scsi_hot_add(mon, &dev->qdev, dinfo, 1) != 0) {

            goto err;

        }

        break;

    default:

        monitor_printf(mon, ""Can't hot-add drive to type %d\n"", dinfo->type);

        goto err;

    }



    return 0;

err:

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void bdrv_drain_recurse(BlockDriverState *bs)

{

    BdrvChild *child;



    if (bs->drv && bs->drv->bdrv_drain) {

        bs->drv->bdrv_drain(bs);

    }

    QLIST_FOREACH(child, &bs->children, next) {

        bdrv_drain_recurse(child->bs);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int fread_targphys_ok(target_phys_addr_t dst_addr, size_t nbytes, FILE *f)

{

    return fread_targphys(dst_addr, nbytes, f) == nbytes;

}
",0
Detect whether the following code contains vulnerabilities.,"static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)
{
   if ( input[3] != 0 ) {
      float f1;
      // Exponent
      f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));
      if (req_comp <= 2)
         output[0] = (input[0] + input[1] + input[2]) * f1 / 3;
      else {
         output[0] = input[0] * f1;
         output[1] = input[1] * f1;
         output[2] = input[2] * f1;
      }
      if (req_comp == 2) output[1] = 1;
      if (req_comp == 4) output[3] = 1;
   } else {
      switch (req_comp) {
         case 4: output[3] = 1; /* fallthrough */
         case 3: output[0] = output[1] = output[2] = 0;
                 break;
         case 2: output[1] = 1; /* fallthrough */
         case 1: output[0] = 0;
                 break;
      }
   }
}",0
Detect whether the following code contains vulnerabilities.,"PublicKey::PublicKey(const byte* k, word32 s) : key_(0), sz_(0)
{
    if (s) {
        SetSize(s);
        SetKey(k);
    }
}",0
Detect whether the following code contains vulnerabilities.,"push_symbol(Str str, char symbol, int width, int n)
{
    char buf[2], *p;
    int i;

#ifdef USE_M17N
    if (width == 2)
	p = alt2_symbol[(int)symbol];
    else
#endif
	p = alt_symbol[(int)symbol];
    for (i = 0; i < 2 && *p; i++, p++)
	buf[i] = (*p == ' ') ? NBSP_CODE : *p;

    Strcat(str, Sprintf(""<_SYMBOL TYPE=%d>"", symbol));
    for (; n > 0; n--)
	Strcat_charp_n(str, buf, i);
    Strcat_charp(str, ""</_SYMBOL>"");
}",1
Detect whether the following code contains vulnerabilities.,"static const char *parse_value( cJSON *item, const char *value )
{
	if ( ! value )
		return 0;	/* Fail on null. */
	if ( ! strncmp( value, ""null"", 4 ) ) {
		item->type = cJSON_NULL;
		return value + 4;
	}
	if ( ! strncmp( value, ""false"", 5 ) ) {
		item->type = cJSON_False;
		return value + 5;
	}
	if ( ! strncmp( value, ""true"", 4 ) ) {
		item->type = cJSON_True;
		item->valueint = 1;
		return value + 4;
	}
	if ( *value == '\""' )
		return parse_string( item, value );
	if ( *value == '-' || ( *value >= '0' && *value <= '9' ) )
		return parse_number( item, value );
	if ( *value == '[' )
		return parse_array( item, value );
	if ( *value == '{' )
		return parse_object( item, value );

	/* Fail. */
	ep = value;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"asmlinkage long sys_mkdirat(int dfd, const char __user *pathname, int mode)
{
	int error = 0;
	char * tmp;
	struct dentry *dentry;
	struct nameidata nd;

	tmp = getname(pathname);
	error = PTR_ERR(tmp);
	if (IS_ERR(tmp))
		goto out_err;

	error = do_path_lookup(dfd, tmp, LOOKUP_PARENT, &nd);
	if (error)
		goto out;
	dentry = lookup_create(&nd, 1);
	error = PTR_ERR(dentry);
	if (IS_ERR(dentry))
		goto out_unlock;

	if (!IS_POSIXACL(nd.path.dentry->d_inode))
		mode &= ~current->fs->umask;
	error = mnt_want_write(nd.path.mnt);
	if (error)
		goto out_dput;
	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
	mnt_drop_write(nd.path.mnt);
out_dput:
	dput(dentry);
out_unlock:
	mutex_unlock(&nd.path.dentry->d_inode->i_mutex);
	path_put(&nd.path);
out:
	putname(tmp);
out_err:
	return error;
}",0
Detect whether the following code contains vulnerabilities.,"static void clear_all_pkt_pointers(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = env->cur_state;
	struct bpf_reg_state *regs = state->regs, *reg;
	int i;

	for (i = 0; i < MAX_BPF_REG; i++)
		if (reg_is_pkt_pointer_any(&regs[i]))
			mark_reg_unknown(env, regs, i);

	for (i = 0; i < state->allocated_stack / BPF_REG_SIZE; i++) {
		if (state->stack[i].slot_type[0] != STACK_SPILL)
			continue;
		reg = &state->stack[i].spilled_ptr;
		if (reg_is_pkt_pointer_any(reg))
			__mark_reg_unknown(reg);
	}
}",0
Detect whether the following code contains vulnerabilities.,"void do_addmeo_64 (void)

{

    T1 = T0;

    T0 += xer_ca + (-1);

    if (likely(!((uint64_t)T1 &

                 ((uint64_t)T1 ^ (uint64_t)T0) & (1ULL << 63)))) {

        xer_ov = 0;

    } else {

        xer_so = 1;

        xer_ov = 1;

    }

    if (likely(T1 != 0))

        xer_ca = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler->opaque;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
				      ""unknown subtype""));
		return TRUE;
	}
	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
	g_bus_unwatch_name(info->watcher_id);
	g_free(info);
	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"opts_end_list(Visitor *v, Error **errp)

{

    OptsVisitor *ov = DO_UPCAST(OptsVisitor, visitor, v);



    assert(ov->list_mode == LM_STARTED || ov->list_mode == LM_IN_PROGRESS);

    ov->repeated_opts = NULL;

    ov->list_mode = LM_NONE;

}
",0
Detect whether the following code contains vulnerabilities.,"void dvb_usb_device_exit(struct usb_interface *intf)
{
	struct dvb_usb_device *d = usb_get_intfdata(intf);
	const char *name = ""generic DVB-USB module"";

	usb_set_intfdata(intf, NULL);
	if (d != NULL && d->desc != NULL) {
		name = d->desc->name;
		dvb_usb_exit(d);
	}
	info(""%s successfully deinitialized and disconnected."", name);

}",1
Detect whether the following code contains vulnerabilities.,"QEMUFile *qemu_fdopen(int fd, const char *mode)

{

    QEMUFileSocket *s;



    if (mode == NULL ||

        (mode[0] != 'r' && mode[0] != 'w') ||

        mode[1] != 'b' || mode[2] != 0) {

        fprintf(stderr, ""qemu_fdopen: Argument validity check failed\n"");

        return NULL;

    }



    s = g_malloc0(sizeof(QEMUFileSocket));

    s->fd = fd;



    if (mode[0] == 'r') {

        s->file = qemu_fopen_ops(s, &unix_read_ops);

    } else {

        s->file = qemu_fopen_ops(s, &unix_write_ops);

    }

    return s->file;

}
",1
Detect whether the following code contains vulnerabilities.,"pdf_filter_fstar(fz_context *ctx, pdf_processor *proc)
{
	pdf_filter_processor *p = (pdf_filter_processor*)proc;
	filter_flush(ctx, p, FLUSH_FILL);
	if (p->chain->op_fstar)
		p->chain->op_fstar(ctx, p->chain);
}",0
Detect whether the following code contains vulnerabilities.,"ptaaCreate(l_int32  n)
{
PTAA  *ptaa;

    PROCNAME(""ptaaCreate"");

    if (n <= 0)
        n = INITIAL_PTR_ARRAYSIZE;

    if ((ptaa = (PTAA *)LEPT_CALLOC(1, sizeof(PTAA))) == NULL)
        return (PTAA *)ERROR_PTR(""ptaa not made"", procName, NULL);
    ptaa->n = 0;
    ptaa->nalloc = n;
    if ((ptaa->pta = (PTA **)LEPT_CALLOC(n, sizeof(PTA *))) == NULL) {
        ptaaDestroy(&ptaa);
        return (PTAA *)ERROR_PTR(""pta ptrs not made"", procName, NULL);
    }
    return ptaa;
}",0
Detect whether the following code contains vulnerabilities.,"static int serial_link_irq_chain(struct mp_port *mtpt)
{
	struct irq_info *i = irq_lists + mtpt->port.irq;
	int ret, irq_flags = mtpt->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
	spin_lock_irq(&i->lock);

	if (i->head) {
		list_add(&mtpt->list, i->head);
		spin_unlock_irq(&i->lock);

		ret = 0;
	} else {
		INIT_LIST_HEAD(&mtpt->list);
		i->head = &mtpt->list;
		spin_unlock_irq(&i->lock);

		ret = request_irq(mtpt->port.irq, multi_interrupt,
				irq_flags, ""serial"", i);
		if (ret < 0)
			serial_do_unlink(i, mtpt);
	}

	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"void qvirtio_pci_foreach(QPCIBus *bus, uint16_t device_type,

                void (*func)(QVirtioDevice *d, void *data), void *data)

{

    QVirtioPCIForeachData d = { .func = func,

                                .device_type = device_type,

                                .user_data = data };



    qpci_device_foreach(bus, PCI_VENDOR_ID_REDHAT_QUMRANET, -1,

                                qvirtio_pci_foreach_callback, &d);

}
",1
Detect whether the following code contains vulnerabilities.,"static struct io_buffer_list *io_buffer_get_list(struct io_ring_ctx *ctx,
						 unsigned int bgid)
{
	if (ctx->io_bl && bgid < BGID_ARRAY)
		return &ctx->io_bl[bgid];

	return xa_load(&ctx->io_bl_xa, bgid);
}",0
Detect whether the following code contains vulnerabilities.,"static int webm_dash_manifest_write_header(AVFormatContext *s)

{

    int i;

    double start = 0.0;

    WebMDashMuxContext *w = s->priv_data;

    parse_adaptation_sets(s);

    write_header(s);

    avio_printf(s->pb, ""<Period id=\""0\"""");

    avio_printf(s->pb, "" start=\""PT%gS\"""", start);

    if (!w->is_live) {

        avio_printf(s->pb, "" duration=\""PT%gS\"""", get_duration(s));

    }

    avio_printf(s->pb, "" >\n"");



    for (i = 0; i < w->nb_as; i++) {

        if (write_adaptation_set(s, i) < 0) return -1;

    }



    avio_printf(s->pb, ""</Period>\n"");

    write_footer(s);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool bdrv_is_valid_name(const char *name)

{

    return qemu_opts_id_wellformed(name);

}
",0
Detect whether the following code contains vulnerabilities.,"static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,
  const char *magick_unused(encoding),const PointInfo *offset,
  TypeMetric *metrics)
{
  (void) ThrowMagickException(&image->exception,GetMagickModule(),
    MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"",""`%s' (Freetype)"",
    draw_info->font != (char *) NULL ? draw_info->font : ""none"");
  return(RenderPostscript(image,draw_info,offset,metrics));
}",0
Detect whether the following code contains vulnerabilities.,"static void etsec_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = etsec_realize;

    dc->reset = etsec_reset;

    dc->props = etsec_properties;



}",1
Detect whether the following code contains vulnerabilities.,"int DMA_write_memory (int nchan, void *buf, int pos, int len)

{

    struct dma_regs *r = &dma_controllers[nchan > 3].regs[nchan & 3];

    target_phys_addr_t addr = ((r->pageh & 0x7f) << 24) | (r->page << 16) | r->now[ADDR];



    if (r->mode & 0x20) {

        int i;

        uint8_t *p = buf;



        cpu_physical_memory_write (addr - pos - len, buf, len);

        /* What about 16bit transfers? */

        for (i = 0; i < len; i++) {

            uint8_t b = p[len - i - 1];

            p[i] = b;

        }

    }

    else

        cpu_physical_memory_write (addr + pos, buf, len);



    return len;

}
",0
Detect whether the following code contains vulnerabilities.,"static BOOL update_send_pointer_new(rdpContext* context,
                                    const POINTER_NEW_UPDATE* pointer_new)
{
	wStream* s;
	rdpRdp* rdp = context->rdp;
	BOOL ret = FALSE;
	s = fastpath_update_pdu_init(rdp->fastpath);

	if (!s)
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 16))
		goto out_fail;

	Stream_Write_UINT16(s, pointer_new->xorBpp); /* xorBpp (2 bytes) */
	update_write_pointer_color(s, &pointer_new->colorPtrAttr);
	ret = fastpath_send_update_pdu(rdp->fastpath, FASTPATH_UPDATETYPE_POINTER, s,
	                               FALSE);
out_fail:
	Stream_Release(s);
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"int ff_get_cpu_flags_arm(void)
{
    int flags = CORE_CPU_FLAGS;
    uint32_t hwcap;
    if (get_hwcap(&hwcap) < 0)
        if (get_cpuinfo(&hwcap) < 0)
            return flags;
#define check_cap(cap, flag) do {               \
        if (hwcap & HWCAP_ ## cap)              \
            flags |= AV_CPU_FLAG_ ## flag;      \
    } while (0)
    /* No flags explicitly indicate v6 or v6T2 so check others which
       imply support. */
    check_cap(EDSP,    ARMV5TE);
    check_cap(TLS,     ARMV6);
    check_cap(THUMBEE, ARMV6T2);
    check_cap(VFP,     VFP);
    check_cap(VFPv3,   VFPV3);
    check_cap(NEON,    NEON);
    /* The v6 checks above are not reliable so let higher flags
       trickle down. */
    if (flags & (AV_CPU_FLAG_VFPV3 | AV_CPU_FLAG_NEON))
        flags |= AV_CPU_FLAG_ARMV6T2;
    if (flags & AV_CPU_FLAG_ARMV6T2)
        flags |= AV_CPU_FLAG_ARMV6;
    return flags;
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)

{

    int l;



    if (f->last_error) {

        return;

    }



    while (size > 0) {

        l = IO_BUF_SIZE - f->buf_index;

        if (l > size) {

            l = size;

        }

        memcpy(f->buf + f->buf_index, buf, l);

        f->bytes_xfer += l;

        if (f->ops->writev_buffer) {

            add_to_iovec(f, f->buf + f->buf_index, l);

        }

        f->buf_index += l;

        if (f->buf_index == IO_BUF_SIZE) {

            qemu_fflush(f);

        }

        if (qemu_file_get_error(f)) {

            break;

        }

        buf += l;

        size -= l;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void vfio_vga_quirk_teardown(VFIOPCIDevice *vdev)

{

    int i;



    for (i = 0; i < ARRAY_SIZE(vdev->vga.region); i++) {

        while (!QLIST_EMPTY(&vdev->vga.region[i].quirks)) {

            VFIOQuirk *quirk = QLIST_FIRST(&vdev->vga.region[i].quirks);

            memory_region_del_subregion(&vdev->vga.region[i].mem, &quirk->mem);

            object_unparent(OBJECT(&quirk->mem));

            QLIST_REMOVE(quirk, next);

            g_free(quirk);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"rdp_out_ts_cache_definition(STREAM s, uint16 entries, uint16 maxcellsize)
{
	out_uint16_le(s, entries);
	out_uint16_le(s, maxcellsize);
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t pci_default_read_config(PCIDevice *d,

                                 uint32_t address, int len)

{

    uint32_t val;



    switch(len) {

    default:

    case 4:

	if (address <= 0xfc) {

            val = pci_get_long(d->config + address);

	    break;

	}

	/* fall through */

    case 2:

        if (address <= 0xfe) {

            val = pci_get_word(d->config + address);

	    break;

	}

	/* fall through */

    case 1:

        val = pci_get_byte(d->config + address);

        break;

    }

    return val;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ati_vga_register_types(void)
{
    type_register_static(&ati_vga_info);
}",0
Detect whether the following code contains vulnerabilities.,"static void pc_dimm_realize(DeviceState *dev, Error **errp)

{

    PCDIMMDevice *dimm = PC_DIMM(dev);



    if (!dimm->hostmem) {

        error_setg(errp, ""'"" PC_DIMM_MEMDEV_PROP ""' property is not set"");

        return;

    }

    if ((nb_numa_nodes > 0) && (dimm->node >= nb_numa_nodes)) {

        error_setg(errp, ""'DIMM property "" PC_DIMM_NODE_PROP "" has value %""

                   PRIu32 ""' which exceeds the number of numa nodes: %d"",

                   dimm->node, nb_numa_nodes);

        return;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int state_putws (const wchar_t *ws, STATE *s)
{
  const wchar_t *p = ws;

  while (p && *p != L'\0')
  {
    if (state_putwc (*p, s) < 0)
      return -1;
    p++;
  }
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void adb_mouse_realizefn(DeviceState *dev, Error **errp)

{

    MouseState *s = ADB_MOUSE(dev);

    ADBMouseClass *amc = ADB_MOUSE_GET_CLASS(dev);



    amc->parent_realize(dev, errp);



    qemu_add_mouse_event_handler(adb_mouse_event, s, 0, ""QEMU ADB Mouse"");

}
",1
Detect whether the following code contains vulnerabilities.,"nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)
{
	struct path path = {
		.mnt = nd->path.mnt,
		.dentry = dentry,
	};
	struct rpc_cred *cred;
	struct nfs4_state *state;

	cred = rpc_lookup_cred();
	if (IS_ERR(cred))
		return PTR_ERR(cred);
	state = nfs4_do_open(dir, &path, openflags, NULL, cred);
	put_rpccred(cred);
	if (IS_ERR(state)) {
		switch (PTR_ERR(state)) {
			case -EPERM:
			case -EACCES:
			case -EDQUOT:
			case -ENOSPC:
			case -EROFS:
				lookup_instantiate_filp(nd, (struct dentry *)state, NULL);
				return 1;
			default:
				goto out_drop;
		}
	}
	if (state->inode == dentry->d_inode) {
		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
		nfs4_intent_set_file(nd, &path, state);
		return 1;
	}
	nfs4_close_sync(&path, state, openflags);
out_drop:
	d_drop(dentry);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static inline unsigned long get_desc_base(const struct desc_struct *desc)
{
	return desc->base0 | ((desc->base1) << 16) | ((desc->base2) << 24);
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t gadget_dev_desc_max_speed_show(struct config_item *item,
					      char *page)
{
	enum usb_device_speed speed = to_gadget_info(item)->composite.max_speed;

	return sprintf(page, ""%s\n"", usb_speed_string(speed));
}",0
Detect whether the following code contains vulnerabilities.,"Interval IndexBoundsBuilder::makeRangeInterval(const BSONObj& obj, BoundInclusion boundInclusion) {
    Interval ret;
    ret._intervalData = obj;
    ret.startInclusive = IndexBounds::isStartIncludedInBound(boundInclusion);
    ret.endInclusive = IndexBounds::isEndIncludedInBound(boundInclusion);
    BSONObjIterator it(obj);
    verify(it.more());
    ret.start = it.next();
    verify(it.more());
    ret.end = it.next();
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"date_s_new_bang(int argc, VALUE *argv, VALUE klass)
{
    VALUE ajd, of, sg, nth, sf;
    int jd, df, rof;
    double rsg;

    rb_scan_args(argc, argv, ""03"", &ajd, &of, &sg);

    switch (argc) {
      case 0:
	ajd = INT2FIX(0);
      case 1:
	of = INT2FIX(0);
      case 2:
	sg = INT2FIX(DEFAULT_SG);
    }

    old_to_new(ajd, of, sg,
	       &nth, &jd, &df, &sf, &rof, &rsg);

    if (!df && f_zero_p(sf) && !rof)
	return d_simple_new_internal(klass,
				     nth, jd,
				     rsg,
				     0, 0, 0,
				     HAVE_JD);
    else
	return d_complex_new_internal(klass,
				      nth, jd,
				      df, sf,
				      rof, rsg,
				      0, 0, 0,
				      0, 0, 0,
				      HAVE_JD | HAVE_DF);
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_window_check3(DisasContext *dc, unsigned r1, unsigned r2,

        unsigned r3)

{

    gen_window_check2(dc, r1, r2 > r3 ? r2 : r3);

}
",1
Detect whether the following code contains vulnerabilities.,"pnprintf(char *string, int size, const char *f, ...)
{
    int rc;
    va_list args;

    va_start(args, f);
    rc = vpnprintf(string, size, f, args);
    va_end(args);

    return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static void qdev_print_devinfo(DeviceClass *dc)

{

    error_printf(""name \""%s\"""", object_class_get_name(OBJECT_CLASS(dc)));

    if (dc->bus_type) {

        error_printf("", bus %s"", dc->bus_type);

    }

    if (qdev_class_has_alias(dc)) {

        error_printf("", alias \""%s\"""", qdev_class_get_alias(dc));

    }

    if (dc->desc) {

        error_printf("", desc \""%s\"""", dc->desc);

    }

    if (dc->no_user) {

        error_printf("", no-user"");

    }

    error_printf(""\n"");

}
",1
Detect whether the following code contains vulnerabilities.,"static int cache_space_refresh(Server *s, JournalStorage *storage) {
        JournalStorageSpace *space;
        JournalMetrics *metrics;
        uint64_t vfs_used, vfs_avail, avail;
        usec_t ts;
        int r;

        assert(s);

        metrics = &storage->metrics;
        space = &storage->space;

        ts = now(CLOCK_MONOTONIC);

        if (space->timestamp + RECHECK_SPACE_USEC > ts)
                return 0;

        r = determine_path_usage(s, storage->path, &vfs_used, &vfs_avail);
        if (r < 0)
                return r;

        space->vfs_used = vfs_used;
        space->vfs_available = vfs_avail;

        avail = LESS_BY(vfs_avail, metrics->keep_free);

        space->limit = MIN(MAX(vfs_used + avail, metrics->min_use), metrics->max_use);
        space->available = LESS_BY(space->limit, vfs_used);
        space->timestamp = ts;
        return 1;
}",0
Detect whether the following code contains vulnerabilities.,"int register_reboot_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&reboot_notifier_list, nb);
}",0
Detect whether the following code contains vulnerabilities.,"static inline void vmacache_invalidate(struct mm_struct *mm)
{
	mm->vmacache_seqnum++;

	/* deal with overflows */
	if (unlikely(mm->vmacache_seqnum == 0))
		vmacache_flush_all(mm);
}",1
Detect whether the following code contains vulnerabilities.,"static void prepare_cmd(struct argv_array *out, const struct child_process *cmd)
{
	if (!cmd->argv[0])
		die(""BUG: command is empty"");

	/*
	 * Add SHELL_PATH so in the event exec fails with ENOEXEC we can
	 * attempt to interpret the command with 'sh'.
	 */
	argv_array_push(out, SHELL_PATH);

	if (cmd->git_cmd) {
		argv_array_push(out, ""git"");
		argv_array_pushv(out, cmd->argv);
	} else if (cmd->use_shell) {
		prepare_shell_cmd(out, cmd->argv);
	} else {
		argv_array_pushv(out, cmd->argv);
	}

	/*
	 * If there are no '/' characters in the command then perform a path
	 * lookup and use the resolved path as the command to exec.  If there
	 * are no '/' characters or if the command wasn't found in the path,
	 * have exec attempt to invoke the command directly.
	 */
	if (!strchr(out->argv[1], '/')) {
		char *program = locate_in_PATH(out->argv[1]);
		if (program) {
			free((char *)out->argv[1]);
			out->argv[1] = program;
		}
	}
}",1
Detect whether the following code contains vulnerabilities.,"greeter_display_started (GdmManager *manager,
                         GdmDisplay *display)
{
        if (manager->priv->ran_once) {
                return;
        }

        maybe_start_pending_initial_login (manager, display);

        manager->priv->ran_once = TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	int err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(t->sas_ss_flags, &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
	if (err)
		return err;
	if (t->sas_ss_flags & SS_AUTODISARM)
		sas_ss_reset(t);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"struct inotify_handle *inotify_init(const struct inotify_operations *ops)
{
	struct inotify_handle *ih;

	ih = kmalloc(sizeof(struct inotify_handle), GFP_KERNEL);
	if (unlikely(!ih))
		return ERR_PTR(-ENOMEM);

	idr_init(&ih->idr);
	INIT_LIST_HEAD(&ih->watches);
	mutex_init(&ih->mutex);
	ih->last_wd = 0;
	ih->in_ops = ops;
	atomic_set(&ih->count, 0);
	get_inotify_handle(ih);

	return ih;
}",0
Detect whether the following code contains vulnerabilities.,"int iommu_dma_memory_rw(DMAContext *dma, dma_addr_t addr,

                        void *buf, dma_addr_t len, DMADirection dir)

{

    target_phys_addr_t paddr, plen;

    int err;



#ifdef DEBUG_IOMMU

    fprintf(stderr, ""dma_memory_rw context=%p addr=0x"" DMA_ADDR_FMT "" len=0x""

            DMA_ADDR_FMT "" dir=%d\n"", dma, addr, len, dir);

#endif



    while (len) {

        err = dma->translate(dma, addr, &paddr, &plen, dir);

        if (err) {

	    /*

             * In case of failure on reads from the guest, we clean the

             * destination buffer so that a device that doesn't test

             * for errors will not expose qemu internal memory.

	     */

	    memset(buf, 0, len);

            return -1;

        }



        /* The translation might be valid for larger regions. */

        if (plen > len) {

            plen = len;

        }



        address_space_rw(dma->as, paddr, buf, plen, dir == DMA_DIRECTION_FROM_DEVICE);



        len -= plen;

        addr += plen;

        buf += plen;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void mirror_read_complete(void *opaque, int ret)

{

    MirrorOp *op = opaque;

    MirrorBlockJob *s = op->s;

    if (ret < 0) {

        BlockDriverState *source = s->common.bs;

        BlockErrorAction action;



        bdrv_set_dirty(source, op->sector_num, op->nb_sectors);

        action = mirror_error_action(s, true, -ret);

        if (action == BLOCK_ERROR_ACTION_REPORT && s->ret >= 0) {

            s->ret = ret;

        }



        mirror_iteration_done(op, ret);

        return;

    }

    bdrv_aio_writev(s->target, op->sector_num, &op->qiov, op->nb_sectors,

                    mirror_write_complete, op);

}
",1
Detect whether the following code contains vulnerabilities.,"static int ftp_features(FTPContext *s)

{

    static const char *feat_command        = ""FEAT\r\n"";

    static const char *enable_utf8_command = ""OPTS UTF8 ON\r\n"";

    static const int feat_codes[] = {211, 0};

    static const int opts_codes[] = {200, 451};

    char *feat;



    if (ftp_send_command(s, feat_command, feat_codes, &feat) == 211) {

        if (av_stristr(feat, ""UTF8""))

            ftp_send_command(s, enable_utf8_command, opts_codes, NULL);

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,    ConfigProtoVector getConfigProtos() const override { return {}; },0
Detect whether the following code contains vulnerabilities.,"static void tgen_ext8u(TCGContext *s, TCGType type, TCGReg dest, TCGReg src)

{

    if (facilities & FACILITY_EXT_IMM) {

        tcg_out_insn(s, RRE, LLGCR, dest, src);

        return;

    }



    if (dest == src) {

        tcg_out_movi(s, type, TCG_TMP0, 0xff);

        src = TCG_TMP0;

    } else {

        tcg_out_movi(s, type, dest, 0xff);

    }

    if (type == TCG_TYPE_I32) {

        tcg_out_insn(s, RR, NR, dest, src);

    } else {

        tcg_out_insn(s, RRE, NGR, dest, src);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void RGWCORSRule::format_exp_headers(string& s) {
  s = """";
  for(list<string>::iterator it = exposable_hdrs.begin();
      it != exposable_hdrs.end(); ++it) {
      if (s.length() > 0)
        s.append("","");
      s.append((*it));
  }
}",1
Detect whether the following code contains vulnerabilities.,"static void ima_adpcm_reset2 (_AFmoduleinst *i)
{
	ima_adpcm_data	*d = (ima_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}",1
Detect whether the following code contains vulnerabilities.,"static void unterminated_literal(void)

{

    QObject *obj = qobject_from_json(""nul"", NULL);

    g_assert(obj == NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static void desc_read_cb(struct gatt_db_attribute *attrib,
					unsigned int id, uint16_t offset,
					uint8_t opcode, struct bt_att *att,
					void *user_data)
{
	struct external_desc *desc = user_data;
	struct btd_device *device;

	if (desc->attrib != attrib) {
		error(""Read callback called with incorrect attribute"");
		goto fail;
	}

	device = att_get_device(att);
	if (!device) {
		error(""Unable to find device object"");
		goto fail;
	}

	if (send_read(device, attrib, desc->proxy, desc->pending_reads, id,
					offset, bt_att_get_link_type(att)))
		return;

fail:
	gatt_db_attribute_read_result(attrib, id, BT_ATT_ERROR_UNLIKELY,
								NULL, 0);
}",1
Detect whether the following code contains vulnerabilities.,"symbol_location_as_lhs_set (symbol *sym, location loc)
{
  if (!sym->location_of_lhs)
    {
      sym->location = loc;
      sym->location_of_lhs = true;
    }
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t GPMF_RawDataSize(GPMF_stream *ms)
{
	if (ms && ms->pos+1 < ms->buffer_size_longs)
	{
		uint32_t size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);
		if (GPMF_OK != IsValidSize(ms, size >> 2)) return 0;

		return size;
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_isync(DisasContext *ctx)

{

    /*

     * We need to check for a pending TLB flush. This can only happen in

     * kernel mode however so check MSR_PR

     */

    if (!ctx->pr) {

        gen_check_tlb_flush(ctx);

    }

    gen_stop_exception(ctx);

}
",1
Detect whether the following code contains vulnerabilities.,"static int tcp_close(MigrationState *s)

{

    DPRINTF(""tcp_close\n"");

    if (s->fd != -1) {

        close(s->fd);

        s->fd = -1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"AVBufferRef *av_buffer_pool_get(AVBufferPool *pool)

{

    AVBufferRef *ret;

    BufferPoolEntry *buf;



    /* check whether the pool is empty */

    buf = get_pool(pool);

    if (!buf)

        return pool_alloc_buffer(pool);



    /* keep the first entry, return the rest of the list to the pool */

    add_to_pool(buf->next);

    buf->next = NULL;



    ret = av_buffer_create(buf->data, pool->size, pool_release_buffer,

                           buf, 0);

    if (!ret) {

        add_to_pool(buf);

        return NULL;

    }

    avpriv_atomic_int_add_and_fetch(&pool->refcount, 1);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,
				     int event,
				     struct timespec *tstamp,
				     unsigned long resolution)
{
	struct snd_timer_user *tu = timeri->callback_data;
	struct snd_timer_tread r1;
	unsigned long flags;

	if (event >= SNDRV_TIMER_EVENT_START &&
	    event <= SNDRV_TIMER_EVENT_PAUSE)
		tu->tstamp = *tstamp;
	if ((tu->filter & (1 << event)) == 0 || !tu->tread)
		return;
	r1.event = event;
	r1.tstamp = *tstamp;
	r1.val = resolution;
	spin_lock_irqsave(&tu->qlock, flags);
	snd_timer_user_append_to_tqueue(tu, &r1);
	spin_unlock_irqrestore(&tu->qlock, flags);
	kill_fasync(&tu->fasync, SIGIO, POLL_IN);
	wake_up(&tu->qchange_sleep);
}",1
Detect whether the following code contains vulnerabilities.,"static void free_ioctx_users(struct percpu_ref *ref)
{
	struct kioctx *ctx = container_of(ref, struct kioctx, users);
	struct aio_kiocb *req;

	spin_lock_irq(&ctx->ctx_lock);

	while (!list_empty(&ctx->active_reqs)) {
		req = list_first_entry(&ctx->active_reqs,
				       struct aio_kiocb, ki_list);
		req->ki_cancel(&req->rw);
		list_del_init(&req->ki_list);
	}

	spin_unlock_irq(&ctx->ctx_lock);

	percpu_ref_kill(&ctx->reqs);
	percpu_ref_put(&ctx->reqs);
}",0
Detect whether the following code contains vulnerabilities.,"    TestCheckedArrayByteSink(char* outbuf, int32_t capacity)
            : CheckedArrayByteSink(outbuf, capacity), calledFlush(FALSE) {}",0
Detect whether the following code contains vulnerabilities.,"static void timerlist_rearm(QEMUTimerList *timer_list)

{

    /* Interrupt execution to force deadline recalculation.  */

    if (timer_list->clock->type == QEMU_CLOCK_VIRTUAL) {

        qemu_start_warp_timer();

    }

    timerlist_notify(timer_list);

}
",0
Detect whether the following code contains vulnerabilities.,"xt_request_find_match(uint8_t nfproto, const char *name, uint8_t revision)
{
	struct xt_match *match;

	match = xt_find_match(nfproto, name, revision);
	if (IS_ERR(match)) {
		request_module(""%st_%s"", xt_prefix[nfproto], name);
		match = xt_find_match(nfproto, name, revision);
	}

	return match;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_af_queue_log_state(AudioFrameQueue *afq)

{

    AudioFrame *f;

    av_log(afq->avctx, AV_LOG_DEBUG, ""remaining delay   = %d\n"",

           afq->remaining_delay);

    av_log(afq->avctx, AV_LOG_DEBUG, ""remaining samples = %d\n"",

           afq->remaining_samples);

    av_log(afq->avctx, AV_LOG_DEBUG, ""frames:\n"");

    f = afq->frame_queue;

    while (f) {

        av_log(afq->avctx, AV_LOG_DEBUG, ""  [ pts=%9""PRId64"" duration=%d ]\n"",

               f->pts, f->duration);

        f = f->next;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_change_vnc(const char *target, const char *arg)

{

    if (strcmp(target, ""passwd"") == 0 ||

	strcmp(target, ""password"") == 0) {

	char password[9];

	if (arg) {

	    strncpy(password, arg, sizeof(password));

	    password[sizeof(password) - 1] = '\0';

	} else

	    monitor_readline(""Password: "", 1, password, sizeof(password));

	if (vnc_display_password(NULL, password) < 0)

	    term_printf(""could not set VNC server password\n"");

    } else {

	if (vnc_display_open(NULL, target) < 0)

	    term_printf(""could not start VNC server on %s\n"", target);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"    GC_API int GC_CALL GC_get_stack_base(struct GC_stack_base *sb)
    {
#     ifdef X86_64
        sb -> mem_base = ((NT_TIB*)NtCurrentTeb())->StackBase;
#     else
        void * _tlsbase;

        __asm__ (""movl %%fs:4, %0""
                 : ""=r"" (_tlsbase));
        sb -> mem_base = _tlsbase;
#     endif
      return GC_SUCCESS;
    }",0
Detect whether the following code contains vulnerabilities.,"void *rom_add_blob(const char *name, const void *blob, size_t len,

                   hwaddr addr, const char *fw_file_name,

                   FWCfgReadCallback fw_callback, void *callback_opaque)

{

    Rom *rom;

    void *data = NULL;



    rom           = g_malloc0(sizeof(*rom));

    rom->name     = g_strdup(name);

    rom->addr     = addr;

    rom->romsize  = len;

    rom->datasize = len;

    rom->data     = g_malloc0(rom->datasize);

    memcpy(rom->data, blob, len);

    rom_insert(rom);

    if (fw_file_name && fw_cfg) {

        char devpath[100];



        snprintf(devpath, sizeof(devpath), ""/rom@%s"", fw_file_name);



        if (rom_file_has_mr) {

            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath);

        } else {

            data = rom->data;

        }



        fw_cfg_add_file_callback(fw_cfg, fw_file_name,

                                 fw_callback, callback_opaque,

                                 data, rom->romsize);

    }

    return data;

}
",1
Detect whether the following code contains vulnerabilities.,"static int proxy_mkdir(FsContext *fs_ctx, V9fsPath *dir_path,

                       const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname;



    v9fs_string_init(&fullname);

    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);



    retval = v9fs_request(fs_ctx->private, T_MKDIR, NULL, &fullname,

                          credp->fc_mode, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    v9fs_string_free(&fullname);

    return retval;

}
",1
Detect whether the following code contains vulnerabilities.,"int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,
		 pgpDigParams * ret)
{
    const uint8_t *p = pkts;
    const uint8_t *pend = pkts + pktlen;
    pgpDigParams digp = NULL;
    struct pgpPkt pkt;
    int rc = -1; /* assume failure */

    while (p < pend) {
	if (decodePkt(p, (pend - p), &pkt))
	    break;

	if (digp == NULL) {
	    if (pkttype && pkt.tag != pkttype) {
		break;
	    } else {
		digp = pgpDigParamsNew(pkt.tag);
	    }
	}

	if (pgpPrtPkt(&pkt, digp))
	    break;

	p += (pkt.body - pkt.head) + pkt.blen;
	if (pkttype == PGPTAG_SIGNATURE)
	    break;
    }

    rc = (digp && (p == pend)) ? 0 : -1;

    if (ret && rc == 0) {
	*ret = digp;
    } else {
	pgpDigParamsFree(digp);
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,
                          const TfLiteTensor* axis, TfLiteTensor* output) {
  int axis_value;
  // Retrive all 8 bytes when axis type is kTfLiteInt64 to avoid data loss.
  if (axis->type == kTfLiteInt64) {
    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));
  } else {
    axis_value = *GetTensorData<int>(axis);
  }
  if (axis_value < 0) {
    axis_value += NumDimensions(input);
  }

  // Copy the input dimensions to output except the axis dimension.
  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);
  int j = 0;
  for (int i = 0; i < NumDimensions(input); ++i) {
    if (i != axis_value) {
      output_dims->data[j] = SizeOfDimension(input, i);
      ++j;
    }
  }
  return context->ResizeTensor(context, output, output_dims);
}",1
Detect whether the following code contains vulnerabilities.,"static int dxva2_vc1_end_frame(AVCodecContext *avctx)

{

    VC1Context *v = avctx->priv_data;

    struct dxva2_picture_context *ctx_pic = v->s.current_picture_ptr->hwaccel_picture_private;

    int ret;



    if (ctx_pic->bitstream_size <= 0)

        return -1;



    ret = ff_dxva2_common_end_frame(avctx, &v->s.current_picture_ptr->f,

                                    &ctx_pic->pp, sizeof(ctx_pic->pp),

                                    NULL, 0,

                                    commit_bitstream_and_slice_buffer);

    if (!ret)

        ff_mpeg_draw_horiz_band(&v->s, 0, avctx->height);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"void HELPER(ucf64_set_fpscr)(CPUUniCore32State *env, uint32_t val)

{

    int i;

    uint32_t changed;



    changed = env->ucf64.xregs[UC32_UCF64_FPSCR];

    env->ucf64.xregs[UC32_UCF64_FPSCR] = (val & UCF64_FPSCR_MASK);



    changed ^= val;

    if (changed & (UCF64_FPSCR_RND_MASK)) {

        i = UCF64_FPSCR_RND(val);

        switch (i) {

        case 0:

            i = float_round_nearest_even;

            break;

        case 1:

            i = float_round_to_zero;

            break;

        case 2:

            i = float_round_up;

            break;

        case 3:

            i = float_round_down;

            break;

        default: /* 100 and 101 not implement */

            cpu_abort(env, ""Unsupported UniCore-F64 round mode"");

        }

        set_float_rounding_mode(i, &env->ucf64.fp_status);

    }



    i = ucf64_exceptbits_to_host(UCF64_FPSCR_TRAPEN(val));

    set_float_exception_flags(i, &env->ucf64.fp_status);

}
",0
Detect whether the following code contains vulnerabilities.,"void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)

{

    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);



    /* virtio-1 compliant devices cannot change the alignment */

    if (virtio_vdev_has_feature(vdev, VIRTIO_F_VERSION_1)) {

        error_report(""tried to modify queue alignment for virtio-1 device"");

        return;

    }

    /* Check that the transport told us it was going to do this

     * (so a buggy transport will immediately assert rather than

     * silently failing to migrate this state)

     */

    assert(k->has_variable_vring_alignment);



    vdev->vq[n].vring.align = align;

    virtio_queue_update_rings(vdev, n);

}
",1
Detect whether the following code contains vulnerabilities.,"LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    const char *path[] = { key, NULL };
    MMDB_aget_value(start, &entry_data, path);
    return mmdb_strndup((char *)entry_data.utf8_string, entry_data.data_size);
}",1
Detect whether the following code contains vulnerabilities.,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_decrypt)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;

	MCRYPT_GET_CRYPT_ARGS
	
	convert_to_string_ex(mode);

	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_DECRYPT, return_value TSRMLS_CC);",1
Detect whether the following code contains vulnerabilities.,"static void check_reference(struct quota_handle *h, unsigned int blk)
{
	if (blk >= h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks)
		log_err(""Illegal reference (%u >= %u) in %s quota file. ""
			""Quota file is probably corrupted.\n""
			""Please run e2fsck (8) to fix it."",
			blk,
			h->qh_info.u.v2_mdqi.dqi_qtree.dqi_blocks,
			quota_type2name(h->qh_type));
}",1
Detect whether the following code contains vulnerabilities.,"static int udf_read_extent_cache(struct inode *inode, loff_t bcount,
				 loff_t *lbcount, struct extent_position *pos)
{
	struct udf_inode_info *iinfo = UDF_I(inode);
	int ret = 0;

	spin_lock(&iinfo->i_extent_cache_lock);
	if ((iinfo->cached_extent.lstart <= bcount) &&
	    (iinfo->cached_extent.lstart != -1)) {
		/* Cache hit */
		*lbcount = iinfo->cached_extent.lstart;
		memcpy(pos, &iinfo->cached_extent.epos,
		       sizeof(struct extent_position));
		if (pos->bh)
			get_bh(pos->bh);
		ret = 1;
	}
	spin_unlock(&iinfo->i_extent_cache_lock);
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static void unrealize(DeviceState *d, Error **errp)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    Object *root_container;

    char name[256];

    Error *err = NULL;



    trace_spapr_drc_unrealize(spapr_drc_index(drc));

    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);

    snprintf(name, sizeof(name), ""%x"", spapr_drc_index(drc));

    object_property_del(root_container, name, &err);

    if (err) {

        error_report_err(err);

        object_unref(OBJECT(drc));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"slap_controls_init( void )
{
	int i, rc;

	rc = LDAP_SUCCESS;

	for ( i = 0; control_defs[i].sc_oid != NULL; i++ ) {
		int *cid = (int *)(((char *)&slap_cids) + control_defs[i].sc_cid );
		rc = register_supported_control( control_defs[i].sc_oid,
			control_defs[i].sc_mask, control_defs[i].sc_extendedops,
			control_defs[i].sc_parse, cid );
		if ( rc != LDAP_SUCCESS ) break;
	}

	return rc;
}",0
Detect whether the following code contains vulnerabilities.,  QUInt8() {},1
Detect whether the following code contains vulnerabilities.,"ram_addr_t ppc4xx_sdram_adjust(ram_addr_t ram_size, int nr_banks,

                               target_phys_addr_t ram_bases[],

                               target_phys_addr_t ram_sizes[],

                               const unsigned int sdram_bank_sizes[])

{

    ram_addr_t size_left = ram_size;

    int i;

    int j;



    for (i = 0; i < nr_banks; i++) {

        for (j = 0; sdram_bank_sizes[j] != 0; j++) {

            unsigned int bank_size = sdram_bank_sizes[j];



            if (bank_size <= size_left) {

                char name[32];

                snprintf(name, sizeof(name), ""ppc4xx.sdram%d"", i);

                ram_bases[i] = qemu_ram_alloc(NULL, name, bank_size);

                ram_sizes[i] = bank_size;

                size_left -= bank_size;

                break;

            }

        }



        if (!size_left) {

            /* No need to use the remaining banks. */

            break;

        }

    }



    ram_size -= size_left;

    if (size_left)

        printf(""Truncating memory to %d MiB to fit SDRAM controller limits.\n"",

               (int)(ram_size >> 20));



    return ram_size;

}
",0
Detect whether the following code contains vulnerabilities.,"static void perf_nesting(void)

{

    unsigned int i, maxcycles, maxnesting;

    double duration;



    maxcycles = 10000;

    maxnesting = 1000;

    Coroutine *root;



    g_test_timer_start();

    for (i = 0; i < maxcycles; i++) {

        NestData nd = {

            .n_enter  = 0,

            .n_return = 0,

            .max      = maxnesting,

        };

        root = qemu_coroutine_create(nest);

        qemu_coroutine_enter(root, &nd);

    }

    duration = g_test_timer_elapsed();



    g_test_message(""Nesting %u iterations of %u depth each: %f s\n"",

        maxcycles, maxnesting, duration);

}
",1
Detect whether the following code contains vulnerabilities.,"R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {
	return -1;
}",1
Detect whether the following code contains vulnerabilities.,"void pointZZ_pDouble(PointZZ_p * rop, const PointZZ_p * op, const CurveZZ_p * curve) {
    mpz_t numer, denom, lambda;
    mpz_inits(numer, denom, lambda, NULL);

    // calculate lambda
    mpz_mul(numer, op->x, op->x);
    mpz_mul_ui(numer, numer, 3);
    mpz_add(numer, numer, curve->a);
    mpz_mul_ui(denom, op->y, 2);
    mpz_invert(denom, denom, curve->p);  // TODO check status
    mpz_mul(lambda, numer, denom);
    mpz_mod(lambda, lambda, curve->p);

    // calculate resulting x coord
    mpz_mul(rop->x, lambda, lambda);
    mpz_sub(rop->x, rop->x, op->x);
    mpz_sub(rop->x, rop->x, op->x);
    mpz_mod(rop->x, rop->x, curve->p);

    //calculate resulting y coord
    mpz_sub(rop->y, op->x, rop->x);
    mpz_mul(rop->y, lambda, rop->y);
    mpz_sub(rop->y, rop->y, op->y);
    mpz_mod(rop->y, rop->y, curve->p);

    mpz_clears(numer, denom, lambda, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"atol8(const char *p, size_t char_cnt)
{
	int64_t l;
	int digit;
        
	l = 0;
	while (char_cnt-- > 0) {
		if (*p >= '0' && *p <= '7')
			digit = *p - '0';
		else
			break;
		p++;
		l <<= 3;
		l |= digit;
	}
	return (l);
}",1
Detect whether the following code contains vulnerabilities.,"get_credentials_generation (GoaProvider *provider)
{
  return 3;
}",0
Detect whether the following code contains vulnerabilities.,"int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
{
	ax25_dev *ax25_dev, *fwd_dev;

	if ((ax25_dev = ax25_addr_ax25dev(&fwd->port_from)) == NULL)
		return -EINVAL;

	switch (cmd) {
	case SIOCAX25ADDFWD:
		if ((fwd_dev = ax25_addr_ax25dev(&fwd->port_to)) == NULL)
			return -EINVAL;
		if (ax25_dev->forward != NULL)
			return -EINVAL;
		ax25_dev->forward = fwd_dev->dev;
		break;

	case SIOCAX25DELFWD:
		if (ax25_dev->forward == NULL)
			return -EINVAL;
		ax25_dev->forward = NULL;
		break;

	default:
		return -EINVAL;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"int bdrv_has_zero_init(BlockDriverState *bs)

{

    assert(bs->drv);



    if (bs->drv->bdrv_has_zero_init) {

        return bs->drv->bdrv_has_zero_init(bs);

    }



    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline QEMUClock *qemu_clock_ptr(QEMUClockType type)

{

    return &qemu_clocks[type];

}
",0
Detect whether the following code contains vulnerabilities.,"on_screen_monitors_changed (GdkScreen *screen,
                            GSManager *manager)
{
        GSList *l;
        int     n_monitors;
        int     n_windows;
        int     i;

        n_monitors = gdk_screen_get_n_monitors (screen);
        n_windows = g_slist_length (manager->priv->windows);

        gs_debug (""Monitors changed for screen %d: num=%d"",
                  gdk_screen_get_number (screen),
                  n_monitors);

        if (n_monitors > n_windows) {
                /* add more windows */
                for (i = n_windows; i < n_monitors; i++) {
                        gs_manager_create_window_for_monitor (manager, screen, i - 1);
                }
        } else {
                /* remove the extra windows */
                for (l = manager->priv->windows; l != NULL; l = l->next) {
                        GdkScreen *this_screen;
                        int        this_monitor;

                        this_screen = gs_window_get_screen (GS_WINDOW (l->data));
                        this_monitor = gs_window_get_monitor (GS_WINDOW (l->data));
                        if (this_screen == screen && this_monitor >= n_monitors) {
                                manager_maybe_stop_job_for_window (manager, GS_WINDOW (l->data));
                                gs_window_destroy (GS_WINDOW (l->data));
                                manager->priv->windows = g_slist_delete_link (manager->priv->windows, l);
                        }
                }
        }
}",1
Detect whether the following code contains vulnerabilities.,"usage(void)
{
#define KEEP(s) s ""\n""
    static const char msg[] =
    {
	KEEP("""")
	KEEP(""Options:"")
	KEEP(""  -S <<       read commands from standard input"")
	KEEP(""  -T TERM     use this instead of $TERM"")
	KEEP(""  -V          print curses-version"")
	KEEP(""  -x          do not try to clear scrollback"")
	KEEP("""")
	KEEP(""Commands:"")
	KEEP(""  clear       clear the screen"")
	KEEP(""  init        initialize the terminal"")
	KEEP(""  reset       reinitialize the terminal"")
	KEEP(""  capname     unlike clear/init/reset, print value for capability \""capname\"""")
    };
#undef KEEP
    (void) fprintf(stderr, ""Usage: %s [options] [command]\n"", prg_name);
    fputs(msg, stderr);
    ExitProgram(ErrUsage);
}",0
Detect whether the following code contains vulnerabilities.,"static UINT rdpei_touch_update(RdpeiClientContext* context, int externalId, int x, int y,
                               int* contactId)
{
	unsigned int i;
	int contactIdlocal = -1;
	RDPINPUT_CONTACT_DATA contact;
	RDPINPUT_CONTACT_POINT* contactPoint = NULL;
	RDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*)context->handle;
	UINT error = CHANNEL_RC_OK;

	for (i = 0; i < rdpei->maxTouchContacts; i++)
	{
		contactPoint = (RDPINPUT_CONTACT_POINT*)&rdpei->contactPoints[i];

		if (!contactPoint->active)
			continue;

		if (contactPoint->externalId == externalId)
		{
			contactIdlocal = contactPoint->contactId;
			break;
		}
	}

	if (contactIdlocal >= 0)
	{
		ZeroMemory(&contact, sizeof(RDPINPUT_CONTACT_DATA));
		contactPoint->lastX = x;
		contactPoint->lastY = y;
		contact.x = x;
		contact.y = y;
		contact.contactId = (UINT32)contactIdlocal;
		contact.contactFlags |= CONTACT_FLAG_UPDATE;
		contact.contactFlags |= CONTACT_FLAG_INRANGE;
		contact.contactFlags |= CONTACT_FLAG_INCONTACT;
		error = context->AddContact(context, &contact);
	}

	*contactId = contactIdlocal;
	return error;
}",0
Detect whether the following code contains vulnerabilities.,"static inline uint32_t vmsvga_fifo_read_raw(struct vmsvga_state_s *s)

{

    uint32_t cmd = s->fifo[CMD(stop) >> 2];



    s->cmd->stop = cpu_to_le32(CMD(stop) + 4);

    if (CMD(stop) >= CMD(max)) {

        s->cmd->stop = s->cmd->min;

    }

    return cmd;

}
",1
Detect whether the following code contains vulnerabilities.,"static int check_opcodes(MMCO *mmco1, MMCO *mmco2, int n_mmcos)

{

    int i;



    for (i = 0; i < n_mmcos; i++) {

        if (mmco1[i].opcode != mmco2[i].opcode)

            return -1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void check_cmd(AHCIState *s, int port)

{

    AHCIPortRegs *pr = &s->dev[port].port_regs;

    int slot;



    if ((pr->cmd & PORT_CMD_START) && pr->cmd_issue) {

        for (slot = 0; (slot < 32) && pr->cmd_issue; slot++) {

            if ((pr->cmd_issue & (1 << slot)) &&

                !handle_cmd(s, port, slot)) {

                pr->cmd_issue &= ~(1 << slot);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xB(IpvideoContext *s)

{

    int y;



    /* 64-color encoding (each pixel in block is a different color) */

    CHECK_STREAM_PTR(64);



    for (y = 0; y < 8; y++) {

        memcpy(s->pixel_ptr, s->stream_ptr, 8);

        s->stream_ptr += 8;

        s->pixel_ptr  += s->stride;

    }



    /* report success */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void smack_netlbl_delete(struct sock *sk)
{
	struct socket_smack *ssp = sk->sk_security;

	/*
	 * Take the label off the socket if one is set.
	 */
	if (ssp->smk_state != SMK_NETLBL_LABELED)
		return;

	local_bh_disable();
	bh_lock_sock_nested(sk);
	netlbl_sock_delattr(sk);
	bh_unlock_sock(sk);
	local_bh_enable();
	ssp->smk_state = SMK_NETLBL_UNLABELED;
}",0
Detect whether the following code contains vulnerabilities.,"int blk_mig_active(void)

{

    return !QSIMPLEQ_EMPTY(&block_mig_state.bmds_list);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int writer_print_string(WriterContext *wctx,

                                      const char *key, const char *val, int opt)

{

    const struct section *section = wctx->section[wctx->level];

    int ret = 0;



    if (opt && !(wctx->writer->flags & WRITER_FLAG_DISPLAY_OPTIONAL_FIELDS))

        return 0;



    if (section->show_all_entries || av_dict_get(section->entries_to_show, key, NULL, 0)) {

        wctx->writer->print_string(wctx, key, val);

        wctx->nb_item[wctx->level]++;

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int ber_write_length(wStream* s, int length)
{
	if (length > 0x7F)
	{
		Stream_Write_UINT8(s, 0x82);
		Stream_Write_UINT16_BE(s, length);
		return 3;
	}
	else
	{
		Stream_Write_UINT8(s, length);
		return 1;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static void window_resize(IMAGE *img)
{
    gtk_drawing_area_size(GTK_DRAWING_AREA (img->darea),
        img->width, img->height);
    if (!(GTK_WIDGET_FLAGS(img->window) & GTK_VISIBLE)) {
        /* We haven't yet shown the window, so set a default size
         * which is smaller than the desktop to allow room for
         * desktop toolbars, and if possible a little larger than
         * the image to allow room for the scroll bars.
         * We don't know the width of the scroll bars, so just guess. */
        gtk_window_set_default_size(GTK_WINDOW(img->window),
            min(gdk_screen_width()-96, img->width+24),
            min(gdk_screen_height()-96, img->height+24));
    }
}",1
Detect whether the following code contains vulnerabilities.,"static const CPUArchIdList *pc_possible_cpu_arch_ids(MachineState *machine)

{

    assert(machine->possible_cpus);

    return machine->possible_cpus;

}
",0
Detect whether the following code contains vulnerabilities.,"void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {
  if (data.empty()) {
    return;
  }
  if (!header.empty()) {
    header.append("","", 1);
  }
  header.append(data.data(), data.size());
}",1
Detect whether the following code contains vulnerabilities.,"LOG_OpenFileLog(const char *log_file)
{
  FILE *f;

  if (log_file) {
    f = fopen(log_file, ""a"");
    if (!f)
      LOG_FATAL(""Could not open log file %s"", log_file);
  } else {
    f = stderr;
  }

  /* Enable line buffering */
  setvbuf(f, NULL, _IOLBF, BUFSIZ);

  if (file_log && file_log != stderr)
    fclose(file_log);

  file_log = f;
}",1
Detect whether the following code contains vulnerabilities.,"int64_t ga_get_fd_handle(GAState *s, Error **errp)

{

    int64_t handle;



    g_assert(s->pstate_filepath);

    /* we blacklist commands and avoid operations that potentially require

     * writing to disk when we're in a frozen state. this includes opening

     * new files, so we should never get here in that situation

     */

    g_assert(!ga_is_frozen(s));



    handle = s->pstate.fd_counter++;

    if (s->pstate.fd_counter < 0) {

        s->pstate.fd_counter = 0;

    }

    if (!write_persistent_state(&s->pstate, s->pstate_filepath)) {

        error_setg(errp, ""failed to commit persistent state to disk"");

    }



    return handle;

}
",1
Detect whether the following code contains vulnerabilities.,"INLINE bits64 extractFloat64Frac( float64 a )

{



    return a & LIT64( 0x000FFFFFFFFFFFFF );



}
",0
Detect whether the following code contains vulnerabilities.,"static void do_cpu_reset(void *opaque)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    const struct arm_boot_info *info = env->boot_info;



    cpu_reset(CPU(cpu));

    if (info) {

        if (!info->is_linux) {

            /* Jump to the entry point.  */

            env->regs[15] = info->entry & 0xfffffffe;

            env->thumb = info->entry & 1;

        } else {

            if (CPU(cpu) == first_cpu) {

                env->regs[15] = info->loader_start;

                if (!info->dtb_filename) {

                    if (old_param) {

                        set_kernel_args_old(info);

                    } else {

                        set_kernel_args(info);

                    }

                }

            } else {

                info->secondary_cpu_reset_hook(cpu, info);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int cris_addc_m(int a, const int *b)

{

	asm volatile (""addc [%1], %0\n"" : ""+r"" (a) : ""r"" (b));

	return a;

}
",1
Detect whether the following code contains vulnerabilities.,"static int sp_add_point_to_mbr(uchar *(*wkb), uchar *end, uint n_dims, 
			       uchar byte_order __attribute__((unused)),
			       double *mbr)
{
  double ord;
  double *mbr_end = mbr + n_dims * 2;

  while (mbr < mbr_end)
  {
    if ((*wkb) > end - 8)
      return -1;
    float8get(ord, (*wkb));
    (*wkb) += 8;
    if (ord < *mbr)
      *mbr = ord;
    mbr++;
    if (ord > *mbr)
      *mbr = ord;
    mbr++;
  }
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_vring_teardown(VirtIOSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);

    int i;



    if (s->ctrl_vring) {

        vring_teardown(&s->ctrl_vring->vring, vdev, 0);



    }

    if (s->event_vring) {

        vring_teardown(&s->event_vring->vring, vdev, 1);



    }

    if (s->cmd_vrings) {

        for (i = 0; i < vs->conf.num_queues && s->cmd_vrings[i]; i++) {

            vring_teardown(&s->cmd_vrings[i]->vring, vdev, 2 + i);



        }

        free(s->cmd_vrings);

        s->cmd_vrings = NULL;

    }

}",1
Detect whether the following code contains vulnerabilities.,"static void dec_user(DisasContext *dc)

{

    LOG_DIS(""user"");



    cpu_abort(dc->env, ""user insn undefined\n"");

}
",1
Detect whether the following code contains vulnerabilities.,"static void term_update(void)

{

    int i, delta;



    if (term_cmd_buf_size != term_last_cmd_buf_size ||

        memcmp(term_cmd_buf, term_last_cmd_buf, term_cmd_buf_size) != 0) {

        for(i = 0; i < term_last_cmd_buf_index; i++) {

            term_printf(""\033[D"");

        }

        term_cmd_buf[term_cmd_buf_size] = '\0';

        term_printf(""%s"", term_cmd_buf);

        term_printf(""\033[K"");

        memcpy(term_last_cmd_buf, term_cmd_buf, term_cmd_buf_size);

        term_last_cmd_buf_size = term_cmd_buf_size;

        term_last_cmd_buf_index = term_cmd_buf_size;

    }

    if (term_cmd_buf_index != term_last_cmd_buf_index) {

        delta = term_cmd_buf_index - term_last_cmd_buf_index;

        if (delta > 0) {

            for(i = 0;i < delta; i++) {

                term_printf(""\033[C"");

            }

        } else {

            delta = -delta;

            for(i = 0;i < delta; i++) {

                term_printf(""\033[D"");

            }

        }

        term_last_cmd_buf_index = term_cmd_buf_index;

    }

    term_flush();

}
",0
Detect whether the following code contains vulnerabilities.,"bool ha_rollback_to_savepoint_can_release_mdl(THD *thd)
{
  Ha_trx_info *ha_info;
  THD_TRANS *trans= (thd->in_sub_stmt ? &thd->transaction.stmt :
                                        &thd->transaction.all);

  DBUG_ENTER(""ha_rollback_to_savepoint_can_release_mdl"");

  /**
    Checking whether it is safe to release metadata locks after rollback to
    savepoint in all the storage engines that are part of the transaction.
  */
  for (ha_info= trans->ha_list; ha_info; ha_info= ha_info->next())
  {
    handlerton *ht= ha_info->ht();
    DBUG_ASSERT(ht);

    if (ht->savepoint_rollback_can_release_mdl == 0 ||
        ht->savepoint_rollback_can_release_mdl(ht, thd) == false)
      DBUG_RETURN(false);
  }

  DBUG_RETURN(true);
}",0
Detect whether the following code contains vulnerabilities.,"int hugetlb_overcommit_handler(struct ctl_table *table, int write,
		void *buffer, size_t *length, loff_t *ppos)
{
	struct hstate *h = &default_hstate;
	unsigned long tmp;
	int ret;

	if (!hugepages_supported())
		return -EOPNOTSUPP;

	tmp = h->nr_overcommit_huge_pages;

	if (write && hstate_is_gigantic(h))
		return -EINVAL;

	table->data = &tmp;
	table->maxlen = sizeof(unsigned long);
	ret = proc_doulongvec_minmax(table, write, buffer, length, ppos);
	if (ret)
		goto out;

	if (write) {
		spin_lock(&hugetlb_lock);
		h->nr_overcommit_huge_pages = tmp;
		spin_unlock(&hugetlb_lock);
	}
out:
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)
{
	int rc;

	ctxt->dst.type = OP_REG;
	ctxt->dst.addr.reg = &ctxt->_eip;
	ctxt->dst.bytes = ctxt->op_bytes;
	rc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);
	if (rc != X86EMUL_CONTINUE)
		return rc;
	rsp_increment(ctxt, ctxt->src.val);
	return X86EMUL_CONTINUE;
}",1
Detect whether the following code contains vulnerabilities.,"static void spin_reset(void *opaque)

{

    SpinState *s = opaque;

    int i;



    for (i = 0; i < MAX_CPUS; i++) {

        SpinInfo *info = &s->spin[i];



        info->pir = i;

        info->r3 = i;

        info->addr = 1;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int source_config_props(AVFilterLink *outlink)

{

    AVFilterContext *ctx = outlink->src;

    Frei0rContext *s = ctx->priv;



    if (av_image_check_size(s->w, s->h, 0, ctx) < 0)

        return AVERROR(EINVAL);

    outlink->w = s->w;

    outlink->h = s->h;

    outlink->time_base = s->time_base;





    if (!(s->instance = s->construct(outlink->w, outlink->h))) {

        av_log(ctx, AV_LOG_ERROR, ""Impossible to load frei0r instance"");

        return AVERROR(EINVAL);

    }



    return set_params(ctx, s->params);

}",1
Detect whether the following code contains vulnerabilities.,"    CImg<T> get_fill(const T& val0, const T& val1, const T& val2, const T& val3, const T& val4, const T& val5,
                     const T& val6, const T& val7, const T& val8) const {
      return CImg<T>(_width,_height,_depth,_spectrum).fill(val0,val1,val2,val3,val4,val5,val6,val7,val8);
    }",0
Detect whether the following code contains vulnerabilities.,"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {
	if (!buf || !sz || sz == UT64_MAX) {
		return NULL;
	}
	RBuffer *tbuf = r_buf_new ();
	r_buf_set_bytes (tbuf, buf, sz);
	struct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);
	r_buf_free (tbuf);
	return res ? res : NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static ext4_io_end_t *ext4_init_io_end (struct inode *inode)
{
	ext4_io_end_t *io = NULL;

	io = kmalloc(sizeof(*io), GFP_NOFS);

	if (io) {
		igrab(inode);
		io->inode = inode;
		io->flag = 0;
		io->offset = 0;
		io->size = 0;
		io->error = 0;
		INIT_WORK(&io->work, ext4_end_io_work);
		INIT_LIST_HEAD(&io->list);
	}

	return io;
}",1
Detect whether the following code contains vulnerabilities.,"TEST_F(ServerSelectorTestFixture, ShouldReturnNoneIfTopologyUnknown) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    ASSERT_EQ(TopologyType::kUnknown, topologyDescription->getType());
    ASSERT_EQ(boost::none, selector.selectServers(topologyDescription, ReadPreferenceSetting()));
}",1
Detect whether the following code contains vulnerabilities.,"static void spapr_cpu_core_realize_child(Object *child, Error **errp)

{

    Error *local_err = NULL;

    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());

    CPUState *cs = CPU(child);

    PowerPCCPU *cpu = POWERPC_CPU(cs);

    Object *obj;



    obj = object_new(spapr->icp_type);

    object_property_add_child(OBJECT(cpu), ""icp"", obj, NULL);

    object_property_add_const_link(obj, ""xics"", OBJECT(spapr), &error_abort);

    object_property_set_bool(obj, true, ""realized"", &local_err);

    if (local_err) {

        goto error;

    }



    object_property_set_bool(child, true, ""realized"", &local_err);

    if (local_err) {

        goto error;

    }



    spapr_cpu_init(spapr, cpu, &local_err);

    if (local_err) {

        goto error;

    }



    xics_cpu_setup(XICS_FABRIC(spapr), cpu, ICP(obj));

    return;



error:

    object_unparent(obj);

    error_propagate(errp, local_err);

}
",1
Detect whether the following code contains vulnerabilities.,"ActivationPtr createActivation(const StreamInfo::StreamInfo& info,
                               const Http::RequestHeaderMap* request_headers,
                               const Http::ResponseHeaderMap* response_headers,
                               const Http::ResponseTrailerMap* response_trailers) {
  auto activation = std::make_unique<Activation>();
  activation->InsertValueProducer(Request, std::make_unique<RequestWrapper>(request_headers, info));
  activation->InsertValueProducer(
      Response, std::make_unique<ResponseWrapper>(response_headers, response_trailers, info));
  activation->InsertValueProducer(Connection, std::make_unique<ConnectionWrapper>(info));
  activation->InsertValueProducer(Upstream, std::make_unique<UpstreamWrapper>(info));
  activation->InsertValueProducer(Source, std::make_unique<PeerWrapper>(info, false));
  activation->InsertValueProducer(Destination, std::make_unique<PeerWrapper>(info, true));
  activation->InsertValueProducer(Metadata,
                                  std::make_unique<MetadataProducer>(info.dynamicMetadata()));
  activation->InsertValueProducer(FilterState,
                                  std::make_unique<FilterStateWrapper>(info.filterState()));
  return activation;
}",1
Detect whether the following code contains vulnerabilities.,"int qcow2_mark_dirty(BlockDriverState *bs)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t val;
    int ret;

    assert(s->qcow_version >= 3);

    if (s->incompatible_features & QCOW2_INCOMPAT_DIRTY) {
        return 0; /* already dirty */
    }

    val = cpu_to_be64(s->incompatible_features | QCOW2_INCOMPAT_DIRTY);
    ret = bdrv_pwrite(bs->file, offsetof(QCowHeader, incompatible_features),
                      &val, sizeof(val));
    if (ret < 0) {
        return ret;
    }
    ret = bdrv_flush(bs->file);
    if (ret < 0) {
        return ret;
    }

    /* Only treat image as dirty if the header was updated successfully */
    s->incompatible_features |= QCOW2_INCOMPAT_DIRTY;
    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int qemu_devtree_setprop(void *fdt, const char *node_path,

                         const char *property, void *val_array, int size)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop(fdt, offset, property, val_array, size);

}
",1
Detect whether the following code contains vulnerabilities.,"void jas_matrix_clip(jas_matrix_t *matrix, jas_seqent_t minval,
  jas_seqent_t maxval)
{
	int i;
	int j;
	jas_seqent_t v;
	jas_seqent_t *rowstart;
	jas_seqent_t *data;
	int rowstep;

	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);
		rowstep = jas_matrix_rowstep(matrix);
		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
		  rowstart += rowstep) {
			data = rowstart;
			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
			  ++data) {
				v = *data;
				if (v < minval) {
					*data = minval;
				} else if (v > maxval) {
					*data = maxval;
				}
			}
		}
	}
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t block_crypto_init_func(QCryptoBlock *block,

                                      void *opaque,

                                      size_t headerlen,

                                      Error **errp)

{

    struct BlockCryptoCreateData *data = opaque;

    int ret;



    /* User provided size should reflect amount of space made

     * available to the guest, so we must take account of that

     * which will be used by the crypto header

     */

    data->size += headerlen;



    qemu_opt_set_number(data->opts, BLOCK_OPT_SIZE, data->size, &error_abort);

    ret = bdrv_create_file(data->filename, data->opts, errp);

    if (ret < 0) {

        return -1;

    }



    data->blk = blk_new_open(data->filename, NULL, NULL,

                             BDRV_O_RDWR | BDRV_O_PROTOCOL, errp);

    if (!data->blk) {

        return -1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"TPMI_RH_ENABLES_Unmarshal(TPMI_RH_ENABLES *target, BYTE **buffer, INT32 *size, BOOL allowNull)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_RH_OWNER:
	  case TPM_RH_PLATFORM:
	  case TPM_RH_ENDORSEMENT:
	  case TPM_RH_PLATFORM_NV:
	    break;
	  case TPM_RH_NULL:
	    if (allowNull) {
		break;
	    }
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"rsvg_new_polyline (void)
{
    return rsvg_new_any_poly (TRUE);
}",1
Detect whether the following code contains vulnerabilities.,"print_values(int byte_offset, unsigned int bit_offset,
	     unsigned int bits_available)
{
    std::cout << ""byte offset = "" << byte_offset << "", ""
	      << ""bit offset = "" << bit_offset << "", ""
	      << ""bits available = "" << bits_available << std::endl;
}",1
Detect whether the following code contains vulnerabilities.,"static inline bool IS_CLOSER(float x, float y, float z) { return fabs((x)-(y)) < fabs((x)-(z)); }",0
Detect whether the following code contains vulnerabilities.,"static void xen_log_stop(MemoryListener *listener, MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    state->log_for_dirtybit = NULL;

    /* Disable dirty bit tracking */

    xc_hvm_track_dirty_vram(xen_xc, xen_domid, 0, 0, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static double get_video_clock(VideoState *is)

{

    double delta;

    if (is->paused) { //FIXME timing gets messed after pause

        delta = 0;

    } else {

        delta = (av_gettime() - is->video_current_pts_time) / 1000000.0;

    }

    return is->video_current_pts + delta;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_wsr_windowbase(DisasContext *dc, uint32_t sr, TCGv_i32 v)

{

    gen_helper_wsr_windowbase(cpu_env, v);

    reset_used_window(dc);

}
",1
Detect whether the following code contains vulnerabilities.,"compile_string_node(Node* node, regex_t* reg)
{
  int r, len, prev_len, slen, ambig;
  UChar *p, *prev, *end;
  StrNode* sn;
  OnigEncoding enc = reg->enc;

  sn = STR_(node);
  if (sn->end <= sn->s)
    return 0;

  end = sn->end;
  ambig = NODE_STRING_IS_AMBIG(node);

  p = prev = sn->s;
  prev_len = enclen(enc, p);
  p += prev_len;
  slen = 1;

  for (; p < end; ) {
    len = enclen(enc, p);
    if (len == prev_len) {
      slen++;
    }
    else {
      r = add_compile_string(prev, prev_len, slen, reg, ambig);
      if (r != 0) return r;

      prev  = p;
      slen  = 1;
      prev_len = len;
    }

    p += len;
  }

  return add_compile_string(prev, prev_len, slen, reg, ambig);
}",0
Detect whether the following code contains vulnerabilities.,"static target_long monitor_get_psr (const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return GET_PSR(env);

}
",1
Detect whether the following code contains vulnerabilities.,"fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
{
	tmsize_t stride = PredictorState(tif)->stride;
	uint32 bps = tif->tif_dir.td_bitspersample / 8;
	tmsize_t wc = cc / bps;
	tmsize_t count = cc;
	uint8 *cp = (uint8 *) cp0;
	uint8 *tmp = (uint8 *)_TIFFmalloc(cc);

	assert((cc%(bps*stride))==0);

	if (!tmp)
		return;

	while (count > stride) {
		REPEAT4(stride, cp[stride] =
                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)
		count -= stride;
	}

	_TIFFmemcpy(tmp, cp0, cc);
	cp = (uint8 *) cp0;
	for (count = 0; count < wc; count++) {
		uint32 byte;
		for (byte = 0; byte < bps; byte++) {
			#if WORDS_BIGENDIAN
			cp[bps * count + byte] = tmp[byte * wc + count];
			#else
			cp[bps * count + byte] =
				tmp[(bps - byte - 1) * wc + count];
			#endif
		}
	}
	_TIFFfree(tmp);
}",1
Detect whether the following code contains vulnerabilities.,"static void remove_translation_table(FlowSource_t *fs, exporter_ipfix_domain_t *exporter, uint16_t id) {
input_translation_t *table, *parent;

	syslog(LOG_INFO, ""Process_ipfix: [%u] Withdraw template id: %i"", 
			exporter->info.id, id);

	parent = NULL;
	table = exporter->input_translation_table;
	while ( table && ( table->id != id ) ) {
		parent = table;
		table = table->next;
	}

	if ( table == NULL ) {
		syslog(LOG_ERR, ""Process_ipfix: [%u] Withdraw template id: %i. translation table not found"", 
				exporter->info.id, id);
		return;
	}

	dbg_printf(""\n[%u] Withdraw template ID: %u\n"", exporter->info.id, table->id);

	// clear table cache, if this is the table to delete
	if (exporter->current_table == table)
		exporter->current_table = NULL;

	if ( parent ) {
		// remove table from list
		parent->next = table->next;
	} else {
		// last table removed
		exporter->input_translation_table = NULL;
	}

	RemoveExtensionMap(fs, table->extension_info.map);
	free(table->sequence);
	free(table->extension_info.map);
	free(table);

} // End of remove_translation_table",1
Detect whether the following code contains vulnerabilities.,"void ram_control_load_hook(QEMUFile *f, uint64_t flags)

{

    int ret = -EINVAL;



    if (f->ops->hook_ram_load) {

        ret = f->ops->hook_ram_load(f, f->opaque, flags);

        if (ret < 0) {

            qemu_file_set_error(f, ret);

        }

    } else {

        qemu_file_set_error(f, ret);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int mm_start_timer(struct qemu_alarm_timer *t)

{

    TIMECAPS tc;



    memset(&tc, 0, sizeof(tc));

    timeGetDevCaps(&tc, sizeof(tc));



    mm_period = tc.wPeriodMin;

    timeBeginPeriod(mm_period);



    mm_timer = timeSetEvent(1,                  /* interval (ms) */

                            mm_period,          /* resolution */

                            mm_alarm_handler,   /* function */

                            (DWORD_PTR)t,       /* parameter */

                            TIME_ONESHOT | TIME_CALLBACK_FUNCTION);



    if (!mm_timer) {

        fprintf(stderr, ""Failed to initialize win32 alarm timer: %ld\n"",

                GetLastError());

        timeEndPeriod(mm_period);

        return -1;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"process_button(struct parsed_tag *tag)
{
    Str tmp = NULL;
    char *p, *q, *r, *qq = """";
    int qlen, v;

    if (cur_form_id < 0) {
       char *s = ""<form_int method=internal action=none>"";
       tmp = process_form(parse_tag(&s, TRUE));
    }
    if (tmp == NULL)
       tmp = Strnew();

    p = ""submit"";
    parsedtag_get_value(tag, ATTR_TYPE, &p);
    q = NULL;
    parsedtag_get_value(tag, ATTR_VALUE, &q);
    r = """";
    parsedtag_get_value(tag, ATTR_NAME, &r);

    v = formtype(p);
    if (v == FORM_UNKNOWN)
       return NULL;

    if (!q) {
       switch (v) {
       case FORM_INPUT_SUBMIT:
       case FORM_INPUT_BUTTON:
           q = ""SUBMIT"";
           break;
       case FORM_INPUT_RESET:
           q = ""RESET"";
           break;
       }
    }
    if (q) {
       qq = html_quote(q);
       qlen = strlen(q);
    }

    /*    Strcat_charp(tmp, ""<pre_int>""); */
    Strcat(tmp, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=%s ""
                       ""name=\""%s\"" value=\""%s\"">"",
                       cur_hseq++, cur_form_id, p, html_quote(r), qq));
    return tmp;
}",1
Detect whether the following code contains vulnerabilities.,"dp_packet_has_flow_mark(struct dp_packet *p OVS_UNUSED,
                        uint32_t *mark OVS_UNUSED)
{
#ifdef DPDK_NETDEV
    if (p->mbuf.ol_flags & PKT_RX_FDIR_ID) {
        *mark = p->mbuf.hash.fdir.hi;
        return true;
    }
#endif
    return false;
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t msix_bar_size(PCIDevice *dev)

{

    return (dev->cap_present & QEMU_PCI_CAP_MSIX) ?

        dev->msix_bar_size : 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_chr(DeviceState *dev, Property *prop, const char *str)

{

    CharDriverState **ptr = qdev_get_prop_ptr(dev, prop);



    *ptr = qemu_chr_find(str);

    if (*ptr == NULL) {

        return -ENOENT;

    }

    if ((*ptr)->assigned) {

        return -EEXIST;

    }

    (*ptr)->assigned = 1;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"decrypt (gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )
{
  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );

  mpi_normalize (a);
  mpi_normalize (b);

  /* output = b/(a^x) mod p */
  mpi_powm( t1, a, skey->x, skey->p );
  mpi_invm( t1, t1, skey->p );
  mpi_mulm( output, b, t1, skey->p );
#if 0
  if( DBG_CIPHER )
    {
      log_mpidump (""elg decrypted x"", skey->x);
      log_mpidump (""elg decrypted p"", skey->p);
      log_mpidump (""elg decrypted a"", a);
      log_mpidump (""elg decrypted b"", b);
      log_mpidump (""elg decrypted M"", output);
    }
#endif
  mpi_free(t1);
}",1
Detect whether the following code contains vulnerabilities.,"void ff_msmpeg4_encode_init(MpegEncContext *s)

{

    static int init_done=0;

    int i;



    common_init(s);

    if(s->msmpeg4_version>=4){

        s->min_qcoeff= -255;

        s->max_qcoeff=  255;

    }



    if (!init_done) {

        /* init various encoding tables */

        init_done = 1;

        init_mv_table(&mv_tables[0]);

        init_mv_table(&mv_tables[1]);

        for(i=0;i<NB_RL_TABLES;i++)

            init_rl(&rl_table[i]);



        for(i=0; i<NB_RL_TABLES; i++){

            int level;

            for(level=0; level<=MAX_LEVEL; level++){

                int run;

                for(run=0; run<=MAX_RUN; run++){

                    int last;

                    for(last=0; last<2; last++){

                        rl_length[i][level][run][last]= get_size_of_code(s, &rl_table[  i], last, run, level, 0);

                    }

                }

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"MONGO_EXPORT bson_oid_t *bson_iterator_oid( const bson_iterator *i ) {
    return ( bson_oid_t * )bson_iterator_value( i );
}",0
Detect whether the following code contains vulnerabilities.,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf = NULL; /* leave initialized to NULL or getline segfaults */
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		fflush(stdout);
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}",1
Detect whether the following code contains vulnerabilities.,"int sqlite3CheckObjectName(
  Parse *pParse,            /* Parsing context */
  const char *zName,        /* Name of the object to check */
  const char *zType,        /* Type of this object */
  const char *zTblName      /* Parent table name for triggers and indexes */
){
  sqlite3 *db = pParse->db;
  if( sqlite3WritableSchema(db) || db->init.imposterTable ){
    /* Skip these error checks for writable_schema=ON */
    return SQLITE_OK;
  }
  if( db->init.busy ){
    if( sqlite3_stricmp(zType, db->init.azInit[0])
     || sqlite3_stricmp(zName, db->init.azInit[1])
     || sqlite3_stricmp(zTblName, db->init.azInit[2])
    ){
      if( sqlite3Config.bExtraSchemaChecks ){
        sqlite3ErrorMsg(pParse, """"); /* corruptSchema() will supply the error */
        return SQLITE_ERROR;
      }
    }
  }else{
    if( pParse->nested==0 
     && 0==sqlite3StrNICmp(zName, ""sqlite_"", 7)
    ){
      sqlite3ErrorMsg(pParse, ""object name reserved for internal use: %s"",
                      zName);
      return SQLITE_ERROR;
    }
  }
  return SQLITE_OK;
}",1
Detect whether the following code contains vulnerabilities.,"static bool is_zero(BlockDriverState *bs, int64_t offset, int64_t bytes)

{

    int nr;

    int64_t res;

    int64_t start;



    /* TODO: Widening to sector boundaries should only be needed as

     * long as we can't query finer granularity. */

    start = QEMU_ALIGN_DOWN(offset, BDRV_SECTOR_SIZE);

    bytes = QEMU_ALIGN_UP(offset + bytes, BDRV_SECTOR_SIZE) - start;



    /* Clamp to image length, before checking status of underlying sectors */

    if (start + bytes > bs->total_sectors * BDRV_SECTOR_SIZE) {

        bytes = bs->total_sectors * BDRV_SECTOR_SIZE - start;

    }



    if (!bytes) {

        return true;

    }

    res = bdrv_get_block_status_above(bs, NULL, start >> BDRV_SECTOR_BITS,

                                      bytes >> BDRV_SECTOR_BITS, &nr, NULL);

    return res >= 0 && (res & BDRV_BLOCK_ZERO) &&

        nr * BDRV_SECTOR_SIZE == bytes;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int name_to_handle(int dirfd, const char *name,

                                 struct file_handle *fh, int *mnt_id, int flags)

{

    return syscall(__NR_name_to_handle_at, dirfd, name, fh, mnt_id, flags);

}
",0
Detect whether the following code contains vulnerabilities.,"        WritingTaskData(int partNumber, int tx, int ty, int lx, int ly):
            partNumber(partNumber),
            tx(tx),
            ty(ty),
            lx(lx),
            ly(ly)
        {}",0
Detect whether the following code contains vulnerabilities.,"void acpi_memory_plug_cb(ACPIREGS *ar, qemu_irq irq, MemHotplugState *mem_st,

                         DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    mdev->dimm = dev;

    mdev->is_enabled = true;

    mdev->is_inserting = true;



    /* do ACPI magic */

    acpi_send_gpe_event(ar, irq, ACPI_MEMORY_HOTPLUG_STATUS);

    return;

}
",0
Detect whether the following code contains vulnerabilities.,"void *qemu_memalign(size_t alignment, size_t size)

{

    if (!size) {

        abort();

    }

    return oom_check(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE));

}
",1
Detect whether the following code contains vulnerabilities.,"void __put_task_struct(struct task_struct *tsk)
{
	WARN_ON(!tsk->exit_state);
	WARN_ON(refcount_read(&tsk->usage));
	WARN_ON(tsk == current);

	cgroup_free(tsk);
	task_numa_free(tsk, true);
	security_task_free(tsk);
	exit_creds(tsk);
	delayacct_tsk_free(tsk);
	put_signal_struct(tsk->signal);

	if (!profile_handoff_task(tsk))
		free_task(tsk);
}",1
Detect whether the following code contains vulnerabilities.,"static void decode_sublayer_hrd(HEVCContext *s, int nb_cpb,

                                int subpic_params_present)

{

    GetBitContext *gb = &s->HEVClc.gb;

    int i;



    for (i = 0; i < nb_cpb; i++) {

        get_ue_golomb_long(gb); // bit_rate_value_minus1

        get_ue_golomb_long(gb); // cpb_size_value_minus1



        if (subpic_params_present) {

            get_ue_golomb_long(gb); // cpb_size_du_value_minus1

            get_ue_golomb_long(gb); // bit_rate_du_value_minus1

        }

        skip_bits1(gb); // cbr_flag

    }

}
",1
Detect whether the following code contains vulnerabilities.,"md_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)
{
    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };
    OFF off = beg;

    while(n_align > 0) {
        int index = 0;  /* index into align_map[] */

        while(CH(off) != _T('-'))
            off++;
        if(off > beg  &&  CH(off-1) == _T(':'))
            index |= 1;
        while(off < end  &&  CH(off) == _T('-'))
            off++;
        if(off < end  &&  CH(off) == _T(':'))
            index |= 2;

        *align = align_map[index];
        align++;
        n_align--;
    }

}",0
Detect whether the following code contains vulnerabilities.,"NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,

                          off_t size, uint32_t nbdflags)

{

    NBDExport *exp = g_malloc0(sizeof(NBDExport));

    QSIMPLEQ_INIT(&exp->requests);

    exp->refcount = 1;

    QTAILQ_INIT(&exp->clients);

    exp->bs = bs;

    exp->dev_offset = dev_offset;

    exp->nbdflags = nbdflags;

    exp->size = size == -1 ? bdrv_getlength(bs) : size;

    return exp;

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int pcd_check_events(struct cdrom_device_info *cdi,
				     unsigned int clearing, int slot_nr)
{
	struct pcd_unit *cd = cdi->handle;
	int res = cd->changed;
	if (res)
		cd->changed = 0;
	return res ? DISK_EVENT_MEDIA_CHANGE : 0;
}",0
Detect whether the following code contains vulnerabilities.,"stat_location_finish (SoupMessage *msg,
                      GFileType   *target_type,
                      guint       *num_children)
{
  Multistatus  ms;
  xmlNodeIter  iter;
  gboolean     res;
  GError      *error;
  guint        child_count;
  GFileType    file_type;

  if (msg->status_code != 207)
    return FALSE;

  res = multistatus_parse (msg, &ms, &error);

  if (res == FALSE)
    return FALSE;

  res = FALSE;
  child_count = 0;
  file_type = G_FILE_TYPE_UNKNOWN;

  multistatus_get_response_iter (&ms, &iter);
  while (xml_node_iter_next (&iter))
    {
      MsResponse response;

      if (! multistatus_get_response (&iter, &response))
        continue;

      if (response.is_target)
        {
          file_type = ms_response_to_file_type (&response);
          res = TRUE;
        }
      else
        child_count++;

      ms_response_clear (&response);
    }

  if (res)
    {
      if (target_type)
        *target_type = file_type;

      if (num_children)
        *num_children = child_count;
    }

  multistatus_free (&ms);
  return res;
}",0
Detect whether the following code contains vulnerabilities.,"static void iscsi_nop_timed_event(void *opaque)

{

    IscsiLun *iscsilun = opaque;



    if (iscsi_get_nops_in_flight(iscsilun->iscsi) > MAX_NOP_FAILURES) {

        error_report(""iSCSI: NOP timeout. Reconnecting..."");

        iscsi_reconnect(iscsilun->iscsi);

    }



    if (iscsi_nop_out_async(iscsilun->iscsi, NULL, NULL, 0, NULL) != 0) {

        error_report(""iSCSI: failed to sent NOP-Out. Disabling NOP messages."");

        return;

    }



    timer_mod(iscsilun->nop_timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + NOP_INTERVAL);

    iscsi_set_events(iscsilun);

}
",1
Detect whether the following code contains vulnerabilities.,"static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)
{
	if (clone_flags & CLONE_FS) {
		atomic_inc(&current->fs->count);
		return 0;
	}
	tsk->fs = __copy_fs_struct(current->fs);
	if (!tsk->fs)
		return -ENOMEM;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void sd_reset(SDState *sd, BlockBackend *blk)

{

    uint64_t size;

    uint64_t sect;



    if (blk) {

        blk_get_geometry(blk, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = sd_addr_to_wpnum(size) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->blk = blk;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = blk ? blk_is_read_only(blk) : false;

    sd->wpgrps_size = sect;

    sd->wp_groups = bitmap_new(sd->wpgrps_size);

    memset(sd->function_group, 0, sizeof(sd->function_group));

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = false;

}
",0
Detect whether the following code contains vulnerabilities.,"duint32 dwgCompressor::litLength21(duint8 *cbuf, duint8 oc, duint32 *si){

    duint32 srcIndex=*si;

    duint32 length = oc + 8;
    if (length == 0x17) {
        duint32 n = cbuf[srcIndex++];
        length += n;
        if (n == 0xff) {
            do {
                n = cbuf[srcIndex++];
                n |= static_cast<duint32>(cbuf[srcIndex++] << 8);
                length += n;
            } while (n == 0xffff);
        }
    }

    *si = srcIndex;
    return length;
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_savevm_send_postcopy_advise(QEMUFile *f)

{

    uint64_t tmp[2];

    tmp[0] = cpu_to_be64(getpagesize());

    tmp[1] = cpu_to_be64(1ul << qemu_target_page_bits());



    trace_qemu_savevm_send_postcopy_advise();

    qemu_savevm_command_send(f, MIG_CMD_POSTCOPY_ADVISE, 16, (uint8_t *)tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"std::string Box_irot::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);

  sstr << indent << ""rotation: "" << m_rotation << "" degrees (CCW)\n"";

  return sstr.str();
}",0
Detect whether the following code contains vulnerabilities.,"static BlkverifyAIOCB *blkverify_aio_get(BlockDriverState *bs, bool is_write,

                                         int64_t sector_num, QEMUIOVector *qiov,

                                         int nb_sectors,

                                         BlockCompletionFunc *cb,

                                         void *opaque)

{

    BlkverifyAIOCB *acb = qemu_aio_get(&blkverify_aiocb_info, bs, cb, opaque);



    acb->is_write = is_write;

    acb->sector_num = sector_num;

    acb->nb_sectors = nb_sectors;

    acb->ret = -EINPROGRESS;

    acb->done = 0;

    acb->qiov = qiov;

    acb->buf = NULL;

    acb->verify = NULL;

    return acb;

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_device_free_virtqueues(VirtIODevice *vdev)

{

    int i;

    if (!vdev->vq) {

        return;

    }



    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {

        VRingMemoryRegionCaches *caches;

        if (vdev->vq[i].vring.num == 0) {

            break;

        }

        caches = atomic_read(&vdev->vq[i].vring.caches);

        atomic_set(&vdev->vq[i].vring.caches, NULL);

        virtio_free_region_cache(caches);

    }

    g_free(vdev->vq);

}
",1
Detect whether the following code contains vulnerabilities.,"Pl_ASCIIHexDecoder::write(unsigned char* buf, size_t len)
{
    if (this->eod)
    {
	return;
    }
    for (size_t i = 0; i < len; ++i)
    {
	char ch = toupper(buf[i]);
	switch (ch)
	{
	  case ' ':
	  case '\f':
	  case '\v':
	  case '\t':
	  case '\r':
	  case '\n':
	    QTC::TC(""libtests"", ""Pl_ASCIIHexDecoder ignore space"");
	    // ignore whitespace
	    break;

	  case '>':
	    this->eod = true;
	    flush();
	    break;

	  default:
	    if (((ch >= '0') && (ch <= '9')) ||
		((ch >= 'A') && (ch <= 'F')))
	    {
		this->inbuf[this->pos++] = ch;
		if (this->pos == 2)
		{
		    flush();
		}
	    }
	    else
	    {
		char t[2];
		t[0] = ch;
		t[1] = 0;
		throw std::runtime_error(
		    std::string(""character out of range""
				"" during base Hex decode: "") + t);
	    }
	    break;
	}
	if (this->eod)
	{
	    break;
	}
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void on_vcpu(CPUState *env, void (*func)(void *data), void *data)

{

    if (env == cpu_single_env) {

        func(data);

        return;

    }

    abort();

}
",1
Detect whether the following code contains vulnerabilities.,"static void kvm_client_set_memory(struct CPUPhysMemoryClient *client,

				  target_phys_addr_t start_addr,

				  ram_addr_t size,

				  ram_addr_t phys_offset)

{

	kvm_set_phys_mem(start_addr, size, phys_offset);

}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err gf_seng_dump_rap_on(GF_SceneEngine *seng, Bool dump_rap)
{
	seng->dump_rap = dump_rap;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,

                                                     int nb_samples)

{

    AVFilterBufferRef *samplesref = NULL;

    int linesize[8];

    uint8_t *data[8];

    int nb_channels = av_get_channel_layout_nb_channels(link->channel_layout);



    /* Calculate total buffer size, round to multiple of 16 to be SIMD friendly */

    if (av_samples_alloc(data, linesize,

                         nb_channels, nb_samples, link->format,

                         16) < 0)

        return NULL;



    samplesref =

        avfilter_get_audio_buffer_ref_from_arrays(data, linesize, perms,

                                                  nb_samples, link->format,

                                                  link->channel_layout, link->planar);

    if (!samplesref) {

        av_free(data[0]);

        return NULL;

    }



    return samplesref;

}
",1
Detect whether the following code contains vulnerabilities.,"static int hevc_init(AVCodecParserContext *s)

{

    HEVCContext  *h  = &((HEVCParseContext *)s->priv_data)->h;

    h->HEVClc = av_mallocz(sizeof(HEVCLocalContext));



    h->skipped_bytes_pos_size = INT_MAX;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static gboolean io_watch_poll_check(GSource *source)

{

    IOWatchPoll *iwp = io_watch_poll_from_source(source);



    if (iwp->max_size == 0) {

        return FALSE;

    }



    return g_io_watch_funcs.check(source);

}
",0
Detect whether the following code contains vulnerabilities.,"void vty_putchars(VIOsPAPRDevice *sdev, uint8_t *buf, int len)

{

    VIOsPAPRVTYDevice *dev = VIO_SPAPR_VTY_DEVICE(sdev);



    /* FIXME: should check the qemu_chr_fe_write() return value */

    qemu_chr_fe_write(dev->chardev, buf, len);

}
",1
Detect whether the following code contains vulnerabilities.,"rb_glob_caller(const char *path, VALUE a, void *enc)
{
    int status;
    struct glob_args *args = (struct glob_args *)a;

    args->path = path;
    rb_protect(glob_func_caller, a, &status);
    return status;
}",0
Detect whether the following code contains vulnerabilities.,"int rom_add_blob(const char *name, const void *blob, size_t len,

                 target_phys_addr_t addr)

{

    Rom *rom;



    rom = g_malloc0(sizeof(*rom));

    rom->name    = g_strdup(name);

    rom->addr    = addr;

    rom->romsize = len;

    rom->data    = g_malloc0(rom->romsize);

    memcpy(rom->data, blob, len);

    rom_insert(rom);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"    template<typename t>
    bool contains(const T& pixel, t& x, t& y, t& z) const {
      const ulongT wh = (ulongT)_width*_height, whd = wh*_depth, siz = whd*_spectrum;
      const T *const ppixel = &pixel;
      if (is_empty() || ppixel<_data || ppixel>=_data + siz) return false;
      ulongT off = ((ulongT)(ppixel - _data))%whd;
      const ulongT nz = off/wh;
      off%=wh;
      const ulongT ny = off/_width, nx = off%_width;
      x = (t)nx; y = (t)ny; z = (t)nz;
      return true;",0
Detect whether the following code contains vulnerabilities.,"  unsigned find_file(const StringList & sl, String & filename)
  {
    StringListEnumeration els = sl.elements_obj();
    const char * dir;
    String path;
    while ( (dir = els.next()) != 0 ) 
    {
      path = dir;
      if (path.back() != '/') path += '/';
      unsigned dir_len = path.size();
      path += filename;
      if (file_exists(path)) {
        filename.swap(path);
        return dir_len;
      }
    }
    return 0;
  }",1
Detect whether the following code contains vulnerabilities.,"monitor_key_compare (gconstpointer a,
		     gconstpointer data)
{
	const Monitor *monitor;
	const Monitor *compare_monitor;

	monitor = a;
	compare_monitor = data;
	
	if (monitor->client < compare_monitor->client) {
		return -1;
	}
	if (monitor->client > compare_monitor->client) {
		return +1;
	}

	if (monitor->file < compare_monitor->file) {
		return -1;
	}
	if (monitor->file > compare_monitor->file) {
		return +1;
	}
	
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_net_set_config(VirtIODevice *vdev, const uint8_t *config)

{

    VirtIONet *n = VIRTIO_NET(vdev);

    struct virtio_net_config netcfg = {};



    memcpy(&netcfg, config, n->config_size);



    if (!(vdev->guest_features >> VIRTIO_NET_F_CTRL_MAC_ADDR & 1) &&

        memcmp(netcfg.mac, n->mac, ETH_ALEN)) {

        memcpy(n->mac, netcfg.mac, ETH_ALEN);

        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"  explicit MaxPooling3dGradGradOp(OpKernelConstruction* context)
      : OpKernel(context) {
    string data_format;
    OP_REQUIRES_OK(context, context->GetAttr(""data_format"", &data_format));
    OP_REQUIRES(context, FormatFromString(data_format, &data_format_),
                errors::InvalidArgument(""Invalid data format""));
    OP_REQUIRES_OK(context, context->GetAttr(""ksize"", &ksize_));
    OP_REQUIRES(context, ksize_.size() == 5,
                errors::InvalidArgument(""Sliding window ksize field must ""
                                        ""specify 5 dimensions""));
    OP_REQUIRES_OK(context, context->GetAttr(""strides"", &stride_));
    OP_REQUIRES(context, stride_.size() == 5,
                errors::InvalidArgument(""Sliding window strides field must ""
                                        ""specify 5 dimensions""));
    OP_REQUIRES_OK(context, context->GetAttr(""padding"", &padding_));
    OP_REQUIRES(context, ksize_[0] == 1 && stride_[0] == 1,
                errors::Unimplemented(
                    ""Pooling is not yet supported on the batch dimension.""));
    const int32 ksize_c = GetTensorDim(ksize_, data_format_, 'C');
    const int32 stride_c = GetTensorDim(stride_, data_format_, 'C');
    OP_REQUIRES(context, ksize_c == 1 && stride_c == 1,
                errors::Unimplemented(""MaxPooling3dGradGrad is not yet ""
                                      ""supported on the depth dimension.""));
  }",0
Detect whether the following code contains vulnerabilities.,"input_print(struct input_ctx *ictx)
{
	int	set;

	set = ictx->cell.set == 0 ? ictx->cell.g0set : ictx->cell.g1set;
	if (set == 1)
		ictx->cell.cell.attr |= GRID_ATTR_CHARSET;
	else
		ictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;

	grid_cell_one(&ictx->cell.cell, ictx->ch);
	screen_write_cell(&ictx->ctx, &ictx->cell.cell);

	ictx->cell.cell.attr &= ~GRID_ATTR_CHARSET;

	return (0);
}",0
Detect whether the following code contains vulnerabilities.,"static int film_probe(AVProbeData *p)
{
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
    return AVPROBE_SCORE_MAX;
}",1
Detect whether the following code contains vulnerabilities.,"static void strongarm_gpio_write(void *opaque, hwaddr offset,

                                 uint64_t value, unsigned size)

{

    StrongARMGPIOInfo *s = opaque;



    switch (offset) {

    case GPDR:        /* GPIO Pin-Direction registers */

        s->dir = value;

        strongarm_gpio_handler_update(s);

        break;



    case GPSR:        /* GPIO Pin-Output Set registers */

        s->olevel |= value;

        strongarm_gpio_handler_update(s);

        s->gpsr = value;

        break;



    case GPCR:        /* GPIO Pin-Output Clear registers */

        s->olevel &= ~value;

        strongarm_gpio_handler_update(s);

        break;



    case GRER:        /* GPIO Rising-Edge Detect Enable registers */

        s->rising = value;

        break;



    case GFER:        /* GPIO Falling-Edge Detect Enable registers */

        s->falling = value;

        break;



    case GAFR:        /* GPIO Alternate Function registers */

        s->gafr = value;

        break;



    case GEDR:        /* GPIO Edge Detect Status registers */

        s->status &= ~value;

        strongarm_gpio_irq_update(s);

        break;



    default:

        printf(""%s: Bad offset 0x"" TARGET_FMT_plx ""\n"", __func__, offset);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int cris_bound_d(int v, int b)

{

	int r = v;

	asm (""bound.d\t%1, %0\n"" : ""+r"" (r) : ""ri"" (b));

	return r;

}
",1
Detect whether the following code contains vulnerabilities.,"static gint compare_expire(gconstpointer a, gconstpointer b)
{
	const struct dhcp_lease *lease1 = a;
	const struct dhcp_lease *lease2 = b;

	return lease2->expire - lease1->expire;
}",0
Detect whether the following code contains vulnerabilities.,"static uint64_t zynq_slcr_compute_pll(uint64_t input, uint32_t ctrl_reg)
{
    uint32_t mult = ((ctrl_reg & R_xxx_PLL_CTRL_PLL_FPDIV_MASK) >>
            R_xxx_PLL_CTRL_PLL_FPDIV_SHIFT);

    /* first, check if pll is bypassed */
    if (ctrl_reg & R_xxx_PLL_CTRL_PLL_BYPASS_FORCE_MASK) {
        return input;
    }

    /* is pll disabled ? */
    if (ctrl_reg & (R_xxx_PLL_CTRL_PLL_RESET_MASK |
                    R_xxx_PLL_CTRL_PLL_PWRDWN_MASK)) {
        return 0;
    }

    /* frequency multiplier -> period division */
    return input / mult;
}",1
Detect whether the following code contains vulnerabilities.,"com_nopager(String *buffer __attribute__((unused)),
	    char *line __attribute__((unused)))
{
  strmov(pager, ""stdout"");
  opt_nopager=1;
  PAGER= stdout;
  tee_fprintf(stdout, ""PAGER set to stdout\n"");
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)

{

    struct vmsvga_rect_s *rect;

    if (s->invalidated) {

        s->redraw_fifo_first = s->redraw_fifo_last;

        return;

    }

    /* Overlapping region updates can be optimised out here - if someone

     * knows a smart algorithm to do that, please share.  */

    while (s->redraw_fifo_first != s->redraw_fifo_last) {

        rect = &s->redraw_fifo[s->redraw_fifo_first ++];

        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;

        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void Curl_detach_connnection(struct Curl_easy *data)
{
  struct connectdata *conn = data->conn;
  if(conn)
    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);
  data->conn = NULL;
}",1
Detect whether the following code contains vulnerabilities.,"int ZEXPORT inflatePrime(strm, bits, value)
z_streamp strm;
int bits;
int value;
{
    struct inflate_state FAR *state;

    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (bits < 0) {
        state->hold = 0;
        state->bits = 0;
        return Z_OK;
    }
    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
    value &= (1L << bits) - 1;
    state->hold += (unsigned)value << state->bits;
    state->bits += (uInt)bits;
    return Z_OK;
}",0
Detect whether the following code contains vulnerabilities.,"static int pf_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)
{
	struct pf_unit *pf = bdev->bd_disk->private_data;

	if (cmd != CDROMEJECT)
		return -EINVAL;

	if (pf->access != 1)
		return -EBUSY;
	mutex_lock(&pf_mutex);
	pf_eject(pf);
	mutex_unlock(&pf_mutex);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static u8 __from_ib_qp_type(enum ib_qp_type type)
{
	switch (type) {
	case IB_QPT_GSI:
		return CMDQ_CREATE_QP1_TYPE_GSI;
	case IB_QPT_RC:
		return CMDQ_CREATE_QP_TYPE_RC;
	case IB_QPT_UD:
		return CMDQ_CREATE_QP_TYPE_UD;
	default:
		return IB_QPT_MAX;
	}
}",0
Detect whether the following code contains vulnerabilities.,"struct sctp_chunk *sctp_make_abort(const struct sctp_association *asoc,
			      const struct sctp_chunk *chunk,
			      const size_t hint)
{
	struct sctp_chunk *retval;
	__u8 flags = 0;

	/* Set the T-bit if we have no association and 'chunk' is not
	 * an INIT (vtag will be reflected).
	 */
	if (!asoc) {
		if (chunk && chunk->chunk_hdr &&
		    chunk->chunk_hdr->type == SCTP_CID_INIT)
			flags = 0;
		else
			flags = SCTP_CHUNK_FLAG_T;
	}

	retval = sctp_make_control(asoc, SCTP_CID_ABORT, flags, hint);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ABORT back to where the offender came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}",0
Detect whether the following code contains vulnerabilities.,"int bdrv_debug_resume(BlockDriverState *bs, const char *tag)

{

    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {

        bs = bs->file;

    }



    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {

        return bs->drv->bdrv_debug_resume(bs, tag);

    }



    return -ENOTSUP;

}
",0
Detect whether the following code contains vulnerabilities.,"TPMA_ALGORITHM_Unmarshal(TPMA_ALGORITHM *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;
    TPMA_ALGORITHM orig_target = *target; // libtpms added

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed */
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target & TPMA_ALGORITHM_reserved) {
	    rc = TPM_RC_RESERVED_BITS;
	    *target = orig_target; // libtpms added
	}
    }
    return rc;
}",0
Detect whether the following code contains vulnerabilities.,"void tracing_snapshot_alloc(void)
{
	/* Give warning */
	tracing_snapshot();
}",0
Detect whether the following code contains vulnerabilities.,"static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,

                                            int64_t sector_num,

                                            QEMUIOVector *qiov,

                                            int nb_sectors,

                                            BlockDriverCompletionFunc *cb,

                                            void *opaque,

                                            int is_write)



{

    BlockDriverAIOCBSync *acb;



    acb = qemu_aio_get(&bdrv_em_aiocb_info, bs, cb, opaque);

    acb->is_write = is_write;

    acb->qiov = qiov;

    acb->bounce = qemu_blockalign(bs, qiov->size);

    acb->bh = qemu_bh_new(bdrv_aio_bh_cb, acb);



    if (is_write) {

        qemu_iovec_to_buf(acb->qiov, 0, acb->bounce, qiov->size);

        acb->ret = bs->drv->bdrv_write(bs, sector_num, acb->bounce, nb_sectors);

    } else {

        acb->ret = bs->drv->bdrv_read(bs, sector_num, acb->bounce, nb_sectors);

    }



    qemu_bh_schedule(acb->bh);



    return &acb->common;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ljpeg_encode_yuv(AVCodecContext *avctx, PutBitContext *pb,

                            const AVFrame *frame)

{

    const int predictor = avctx->prediction_method + 1;

    LJpegEncContext *s  = avctx->priv_data;

    const int mb_width  = (avctx->width  + s->hsample[0] - 1) / s->hsample[0];

    const int mb_height = (avctx->height + s->vsample[0] - 1) / s->vsample[0];

    int mb_x, mb_y;



    for (mb_y = 0; mb_y < mb_height; mb_y++) {

        if (pb->buf_end - pb->buf - (put_bits_count(pb) >> 3) <

            mb_width * 4 * 3 * s->hsample[0] * s->vsample[0]) {

            av_log(avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

            return -1;

        }



        for (mb_x = 0; mb_x < mb_width; mb_x++)

            ljpeg_encode_yuv_mb(s, pb, frame, predictor, mb_x, mb_y);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_always_inline void decode_dc_coeffs(GetBitContext *gb, int16_t *out,

                                              int blocks_per_slice)

{

    int16_t prev_dc;

    int code, i, sign;



    OPEN_READER(re, gb);



    DECODE_CODEWORD(code, FIRST_DC_CB);

    prev_dc = TOSIGNED(code);

    out[0] = prev_dc;



    out += 64; // dc coeff for the next block



    code = 5;

    sign = 0;

    for (i = 1; i < blocks_per_slice; i++, out += 64) {

        DECODE_CODEWORD(code, dc_codebook[FFMIN(code, 6U)]);

        if(code) sign ^= -(code & 1);

        else     sign  = 0;

        prev_dc += (((code + 1) >> 1) ^ sign) - sign;

        out[0] = prev_dc;

    }

    CLOSE_READER(re, gb);

}
",1
Detect whether the following code contains vulnerabilities.,"static int svm_nmi_allowed(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb *vmcb = svm->vmcb;
	int ret;
	ret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&
	      !(svm->vcpu.arch.hflags & HF_NMI_MASK);
	ret = ret && gif_set(svm) && nested_svm_nmi(svm);

	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static bool allow_auth_to_host(struct Curl_easy *data)
{
  struct connectdata *conn = data->conn;
  return (!data->state.this_is_a_follow ||
          data->set.allow_auth_to_other_hosts ||
          (data->state.first_host &&
           strcasecompare(data->state.first_host, conn->host.name) &&
           (data->state.first_remote_port == conn->remote_port) &&
           (data->state.first_remote_protocol == conn->handler->protocol)));
}",1
Detect whether the following code contains vulnerabilities.,"void tls1_clear(SSL *s)
{
    ssl3_clear(s);
    if (s->method->version == TLS_ANY_VERSION)
        s->version = TLS_MAX_VERSION;
    else
        s->version = s->method->version;
}",0
Detect whether the following code contains vulnerabilities.,"void error_queue::add_warning(de265_error warning, bool once)
{
  // check if warning was already shown
  bool add=true;
  if (once) {
    for (int i=0;i<nWarningsShown;i++) {
      if (warnings_shown[i] == warning) {
        add=false;
        break;
      }
    }
  }

  if (!add) {
    return;
  }


  // if this is a one-time warning, remember that it was shown

  if (once) {
    if (nWarningsShown < MAX_WARNINGS) {
      warnings_shown[nWarningsShown++] = warning;
    }
  }


  // add warning to output queue

  if (nWarnings == MAX_WARNINGS) {
    warnings[MAX_WARNINGS-1] = DE265_WARNING_WARNING_BUFFER_FULL;
    return;
  }

  warnings[nWarnings++] = warning;
}",0
Detect whether the following code contains vulnerabilities.,"static void get_id3_tag(AVFormatContext *s, int len)

{

    ID3v2ExtraMeta *id3v2_extra_meta = NULL;



    ff_id3v2_read(s, ID3v2_DEFAULT_MAGIC, &id3v2_extra_meta);

    if (id3v2_extra_meta)

        ff_id3v2_parse_apic(s, &id3v2_extra_meta);

    ff_id3v2_free_extra_meta(&id3v2_extra_meta);

}
",0
Detect whether the following code contains vulnerabilities.,"void do_subfco (void)

{

    T2 = T0;

    T0 = T1 - T0;

    if (likely(T0 > T1)) {

        xer_ca = 0;

    } else {

        xer_ca = 1;

    }

    if (likely(!(((~T2) ^ T1 ^ (-1)) & ((~T2) ^ T0) & (1 << 31)))) {

        xer_ov = 0;

    } else {

        xer_so = 1;

        xer_ov = 1;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,

                        void *opaque)

{

    VMStateField *field = vmsd->fields;



    if (vmsd->pre_save) {

        vmsd->pre_save(opaque);


    while (field->name) {

        if (!field->field_exists ||

            field->field_exists(opaque, vmsd->version_id)) {

            void *base_addr = vmstate_base_addr(opaque, field);

            int i, n_elems = vmstate_n_elems(opaque, field);

            int size = vmstate_size(opaque, field);



            for (i = 0; i < n_elems; i++) {

                void *addr = base_addr + size * i;



                if (field->flags & VMS_ARRAY_OF_POINTER) {

                    addr = *(void **)addr;


                if (field->flags & VMS_STRUCT) {

                    vmstate_save_state(f, field->vmsd, addr);


                    field->info->put(f, addr, size);










        field++;


    vmstate_subsection_save(f, vmsd, opaque);
",1
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_stdio(const char *id,

                                            ChardevBackend *backend,

                                            ChardevReturn *ret,

                                            Error **errp)

{

    ChardevStdio *opts = backend->u.stdio.data;

    CharDriverState *chr;

    struct sigaction act;

    ChardevCommon *common = qapi_ChardevStdio_base(opts);



    if (is_daemonized()) {

        error_setg(errp, ""cannot use stdio with -daemonize"");





    if (stdio_in_use) {

        error_setg(errp, ""cannot use stdio by multiple character devices"");





    stdio_in_use = true;

    old_fd0_flags = fcntl(0, F_GETFL);

    tcgetattr(0, &oldtty);

    qemu_set_nonblock(0);

    atexit(term_exit);



    memset(&act, 0, sizeof(act));

    act.sa_handler = term_stdio_handler;

    sigaction(SIGCONT, &act, NULL);



    chr = qemu_chr_open_fd(0, 1, common, errp);




    chr->chr_close = qemu_chr_close_stdio;

    chr->chr_set_echo = qemu_chr_set_echo_stdio;

    if (opts->has_signal) {

        stdio_allow_signal = opts->signal;


    qemu_chr_fe_set_echo(chr, false);



    return chr;
",1
Detect whether the following code contains vulnerabilities.,"static int addr_doit(struct sk_buff *skb, struct nlmsghdr *nlh)
{
	struct net *net = sock_net(skb->sk);
	struct nlattr *tb[IFA_MAX+1];
	struct net_device *dev;
	struct ifaddrmsg *ifm;
	int err;
	u8 pnaddr;

	if (!capable(CAP_NET_ADMIN))
		return -EPERM;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	ASSERT_RTNL();

	err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, ifa_phonet_policy);
	if (err < 0)
		return err;

	ifm = nlmsg_data(nlh);
	if (tb[IFA_LOCAL] == NULL)
		return -EINVAL;
	pnaddr = nla_get_u8(tb[IFA_LOCAL]);
	if (pnaddr & 3)
		/* Phonet addresses only have 6 high-order bits */
		return -EINVAL;

	dev = __dev_get_by_index(net, ifm->ifa_index);
	if (dev == NULL)
		return -ENODEV;

	if (nlh->nlmsg_type == RTM_NEWADDR)
		err = phonet_address_add(dev, pnaddr);
	else
		err = phonet_address_del(dev, pnaddr);
	if (!err)
		phonet_address_notify(nlh->nlmsg_type, dev, pnaddr);
	return err;
}",1
Detect whether the following code contains vulnerabilities.,"parsecolorchar(zattr arg, int is_fg)
{
    if (bv->fm[1] == '{') {
	char *ep;
	bv->fm += 2; /* skip over F{ */
	if ((ep = strchr(bv->fm, '}'))) {
	    char oc = *ep, *col, *coll;
	    *ep = '\0';
	    /* expand the contents of the argument so you can use
	     * %v for example */
	    coll = col = promptexpand(bv->fm, 0, NULL, NULL, NULL);
	    *ep = oc;
	    arg = match_colour((const char **)&coll, is_fg, 0);
	    free(col);
	    bv->fm = ep;
	} else {
	    arg = match_colour((const char **)&bv->fm, is_fg, 0);
	    if (*bv->fm != '}')
		bv->fm--;
	}
    } else
	arg = match_colour(NULL, 1, arg);
    return arg;
}",1
Detect whether the following code contains vulnerabilities.,"static int pkey_sm2_decrypt(EVP_PKEY_CTX *ctx,
                            unsigned char *out, size_t *outlen,
                            const unsigned char *in, size_t inlen)
{
    EC_KEY *ec = ctx->pkey->pkey.ec;
    SM2_PKEY_CTX *dctx = ctx->data;
    const EVP_MD *md = (dctx->md == NULL) ? EVP_sm3() : dctx->md;

    if (out == NULL) {
        if (!sm2_plaintext_size(ec, md, inlen, outlen))
            return -1;
        else
            return 1;
    }

    return sm2_decrypt(ec, md, in, inlen, out, outlen);
}",1
Detect whether the following code contains vulnerabilities.,"static av_cold int msrle_decode_init(AVCodecContext *avctx)

{

    MsrleContext *s = avctx->priv_data;

    int i;



    s->avctx = avctx;



    switch (avctx->bits_per_coded_sample) {

    case 1:

        avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;

        break;

    case 4:

    case 8:

        avctx->pix_fmt = AV_PIX_FMT_PAL8;

        break;

    case 24:

        avctx->pix_fmt = AV_PIX_FMT_BGR24;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""unsupported bits per sample\n"");

        return -1;

    }



    avcodec_get_frame_defaults(&s->frame);

    s->frame.data[0] = NULL;



    if (avctx->extradata_size >= AVPALETTE_SIZE)

        for (i = 0; i < AVPALETTE_SIZE/4; i++)

            s->pal[i] = 0xFF<<24 | AV_RL32(avctx->extradata+4*i);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void portio_list_init(PortioList *piolist,

                      const MemoryRegionPortio *callbacks,

                      void *opaque, const char *name)

{

    unsigned n = 0;



    while (callbacks[n].size) {

        ++n;

    }



    piolist->ports = callbacks;

    piolist->nr = 0;

    piolist->regions = g_new0(MemoryRegion *, n);

    piolist->aliases = g_new0(MemoryRegion *, n);

    piolist->address_space = NULL;

    piolist->opaque = opaque;

    piolist->name = name;

}
",0
Detect whether the following code contains vulnerabilities.,"static GSList *nvdimm_get_plugged_device_list(void)

{

    GSList *list = NULL;



    object_child_foreach(qdev_get_machine(), nvdimm_plugged_device_list,

                         &list);

    return list;

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_ccw_hcall_notify(const uint64_t *args)

{

    uint64_t subch_id = args[0];

    uint64_t queue = args[1];

    SubchDev *sch;

    int cssid, ssid, schid, m;



    if (ioinst_disassemble_sch_ident(subch_id, &m, &cssid, &ssid, &schid)) {

        return -EINVAL;

    }

    sch = css_find_subch(m, cssid, ssid, schid);

    if (!sch || !css_subch_visible(sch)) {

        return -EINVAL;

    }

    if (queue >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }

    virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);

    return 0;



}
",0
Detect whether the following code contains vulnerabilities.,"static int vhost_user_migration_done(struct vhost_dev *dev, char* mac_addr)

{

    VhostUserMsg msg = { 0 };

    int err;



    assert(dev->vhost_ops->backend_type == VHOST_BACKEND_TYPE_USER);



    /* If guest supports GUEST_ANNOUNCE do nothing */

    if (virtio_has_feature(dev->acked_features, VIRTIO_NET_F_GUEST_ANNOUNCE)) {

        return 0;

    }



    /* if backend supports VHOST_USER_PROTOCOL_F_RARP ask it to send the RARP */

    if (virtio_has_feature(dev->protocol_features,

                           VHOST_USER_PROTOCOL_F_RARP)) {

        msg.request = VHOST_USER_SEND_RARP;

        msg.flags = VHOST_USER_VERSION;

        memcpy((char *)&msg.u64, mac_addr, 6);

        msg.size = sizeof(m.u64);



        err = vhost_user_write(dev, &msg, NULL, 0);

        return err;

    }

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"BOOL ber_read_sequence_tag(wStream* s, int* length)
{
	BYTE byte;

	if(Stream_GetRemainingLength(s) < 1)
		return FALSE;
	Stream_Read_UINT8(s, byte);

	if (byte != ((BER_CLASS_UNIV | BER_CONSTRUCT) | (BER_TAG_SEQUENCE_OF)))
		return FALSE;

	return ber_read_length(s, length);
}",1
Detect whether the following code contains vulnerabilities.,"int fw_cfg_add_i64(FWCfgState *s, uint16_t key, uint64_t value)

{

    uint64_t *copy;



    copy = g_malloc(sizeof(value));

    *copy = cpu_to_le64(value);

    return fw_cfg_add_bytes(s, key, (uint8_t *)copy, sizeof(value));

}
",1
Detect whether the following code contains vulnerabilities.,"static void sp_setup(struct net_device *dev)
{
	/* Finish setting up the DEVICE info. */
	dev->netdev_ops		= &sp_netdev_ops;
	dev->needs_free_netdev	= true;
	dev->mtu		= SIXP_MTU;
	dev->hard_header_len	= AX25_MAX_HEADER_LEN;
	dev->header_ops 	= &ax25_header_ops;

	dev->addr_len		= AX25_ADDR_LEN;
	dev->type		= ARPHRD_AX25;
	dev->tx_queue_len	= 10;

	/* Only activated in AX.25 mode */
	memcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);
	dev_addr_set(dev, (u8 *)&ax25_defaddr);

	dev->flags		= 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int ds1338_recv(I2CSlave *i2c)

{

    DS1338State *s = FROM_I2C_SLAVE(DS1338State, i2c);

    uint8_t res;



    res  = s->nvram[s->ptr];

    s->ptr = (s->ptr + 1) & 0xff;

    return res;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool io_poll_disarm(struct io_kiocb *req)
	__must_hold(&ctx->completion_lock)
{
	if (!io_poll_get_ownership(req))
		return false;
	io_poll_remove_entries(req);
	hash_del(&req->hash_node);
	return true;",1
Detect whether the following code contains vulnerabilities.,"static int query_codec(enum CodecID id, int std_compliance)

{

    CodecMime *cm= ff_id3v2_mime_tags;

    while(cm->id != CODEC_ID_NONE) {

        if(id == cm->id)

            return MKTAG('A', 'P', 'I', 'C');

        cm++;

    }

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn raw_co_write_zeroes(

    BlockDriverState *bs, int64_t sector_num,

    int nb_sectors, BdrvRequestFlags flags)

{

    BDRVRawState *s = bs->opaque;



    if (!(flags & BDRV_REQ_MAY_UNMAP)) {

        return -ENOTSUP;

    }

    if (!s->discard_zeroes) {

        return -ENOTSUP;

    }

    return paio_submit_co(bs, s->fd, sector_num, NULL, nb_sectors,

                          QEMU_AIO_DISCARD);

}
",1
Detect whether the following code contains vulnerabilities.,"ExprCreateMultiKeysymList(ExprDef *expr)
{
    unsigned nLevels = darray_size(expr->keysym_list.symsMapIndex);

    darray_resize(expr->keysym_list.symsMapIndex, 1);
    darray_resize(expr->keysym_list.symsNumEntries, 1);
    darray_item(expr->keysym_list.symsMapIndex, 0) = 0;
    darray_item(expr->keysym_list.symsNumEntries, 0) = nLevels;

    return expr;
}",0
Detect whether the following code contains vulnerabilities.,"int Arg_comparator::compare_e_time()
{
  THD *thd= current_thd;
  longlong val1= (*a)->val_time_packed(thd);
  longlong val2= (*b)->val_time_packed(thd);
  if ((*a)->null_value || (*b)->null_value)
    return MY_TEST((*a)->null_value && (*b)->null_value);
  return MY_TEST(val1 == val2);
}",0
Detect whether the following code contains vulnerabilities.,"    inline T pow3(const T& val) {
      return val*val*val;
    }",0
Detect whether the following code contains vulnerabilities.,"int ldb_vlv_init(const char *version)
{
	LDB_MODULE_CHECK_VERSION(version);
	return ldb_register_module(&ldb_vlv_module_ops);
}",0
Detect whether the following code contains vulnerabilities.,"static inline void ss_del(struct msg_sender *mss)
{
	if (mss->list.next != NULL)
		list_del(&mss->list);
}",0
Detect whether the following code contains vulnerabilities.,"bool format_go_output(const string& file_path) {
  const string command = ""gofmt -w "" + file_path;

  if (system(command.c_str()) == 0) {
    return true;
  }

  fprintf(stderr, ""WARNING - Running '%s' failed.\n"", command.c_str());
  return false;
}",1
Detect whether the following code contains vulnerabilities.,"static umode_t platform_dev_attrs_visible(struct kobject *kobj, struct attribute *a,
		int n)
{
	struct device *dev = container_of(kobj, typeof(*dev), kobj);

	if (a == &dev_attr_numa_node.attr &&
			dev_to_node(dev) == NUMA_NO_NODE)
		return 0;

	return a->mode;
}",0
Detect whether the following code contains vulnerabilities.,"static int mpegts_read_packet(AVFormatContext *s,

                              AVPacket *pkt)

{

    MpegTSContext *ts = s->priv_data;



    if (!ts->mpeg2ts_raw) {

        ts->pkt = pkt;

        return handle_packets(ts, 0);

    } else {

        return mpegts_raw_read_packet(s, pkt);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ide_flush_cache(IDEState *s)

{

    if (s->bs == NULL) {

        ide_flush_cb(s, 0);

        return;

    }




    bdrv_acct_start(s->bs, &s->acct, 0, BDRV_ACCT_FLUSH);

    bdrv_aio_flush(s->bs, ide_flush_cb, s);

}",1
Detect whether the following code contains vulnerabilities.,"static void term_bol(void)

{

    term_cmd_buf_index = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"    **/
    CImg<T>& operator^=(const char *const expression) {
      return *this^=(+*this)._fill(expression,true,true,0,0,""operator^="",this);",0
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,

                                      uint64_t bytes, QEMUIOVector *qiov,

                                      int flags)

{

    BDRVRawState *s = bs->opaque;



    if (offset > UINT64_MAX - s->offset) {

        return -EINVAL;

    }

    offset += s->offset;



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);

}
",0
Detect whether the following code contains vulnerabilities.,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",1
Detect whether the following code contains vulnerabilities.,"int nfc_register_device(struct nfc_dev *dev)
{
	int rc;

	pr_debug(""dev_name=%s\n"", dev_name(&dev->dev));

	mutex_lock(&nfc_devlist_mutex);
	nfc_devlist_generation++;
	rc = device_add(&dev->dev);
	mutex_unlock(&nfc_devlist_mutex);

	if (rc < 0)
		return rc;

	rc = nfc_llcp_register_device(dev);
	if (rc)
		pr_err(""Could not register llcp device\n"");

	rc = nfc_genl_device_added(dev);
	if (rc)
		pr_debug(""The userspace won't be notified that the device %s was added\n"",
			 dev_name(&dev->dev));

	dev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,
				   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);
	if (dev->rfkill) {
		if (rfkill_register(dev->rfkill) < 0) {
			rfkill_destroy(dev->rfkill);
			dev->rfkill = NULL;
		}
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"compile_get_env(char_u **arg, cctx_T *cctx)
{
    char_u	*start = *arg;
    int		len;
    int		ret;
    char_u	*name;

    ++*arg;
    len = get_env_len(arg);
    if (len == 0)
    {
	semsg(_(e_syntax_error_at_str), start - 1);
	return FAIL;
    }

    // include the '$' in the name, eval_env_var() expects it.
    name = vim_strnsave(start, len + 1);
    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);
    vim_free(name);
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void stream_joined(h2_mplx *m, h2_stream *stream)
{
    ap_assert(!stream->task || stream->task->worker_done);
    
    h2_ihash_remove(m->shold, stream->id);
    h2_ihash_add(m->spurge, stream);
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t sock_sendpage(struct file *file, struct page *page,
			     int offset, size_t size, loff_t *ppos, int more)
{
	struct socket *sock;
	int flags;

	sock = file->private_data;

	flags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;
	if (more)
		flags |= MSG_MORE;

	return sock->ops->sendpage(sock, page, offset, size, flags);
}",1
Detect whether the following code contains vulnerabilities.,"_hb_buffer_swap( HB_Buffer buffer )
{
  HB_GlyphItem tmp_string;
  int tmp_length;
  int tmp_pos;

  if ( buffer->separate_out )
    {
      tmp_string = buffer->in_string;
      buffer->in_string = buffer->out_string;
      buffer->out_string = tmp_string;
      buffer->alt_string = buffer->out_string;
    }

  tmp_length = buffer->in_length;
  buffer->in_length = buffer->out_length;
  buffer->out_length = tmp_length;

  tmp_pos = buffer->in_pos;
  buffer->in_pos = buffer->out_pos;
  buffer->out_pos = tmp_pos;
}",1
Detect whether the following code contains vulnerabilities.,"void ff_biweight_h264_pixels16_8_msa(uint8_t *dst, uint8_t *src,

                                     int stride, int height,

                                     int log2_denom, int weight_dst,

                                     int weight_src, int offset)

{

    avc_biwgt_16width_msa(src, stride,

                          dst, stride,

                          height, log2_denom,

                          weight_src, weight_dst, offset);

}
",0
Detect whether the following code contains vulnerabilities.,"static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx)

{

    USBPort *uport;

    char path[32];

    int i, pos, port;



    port = (slot_ctx[1]>>16) & 0xFF;




    port = xhci->ports[port-1].uport->index+1;

    pos = snprintf(path, sizeof(path), ""%d"", port);

    for (i = 0; i < 5; i++) {

        port = (slot_ctx[0] >> 4*i) & 0x0f;

        if (!port) {

            break;


        pos += snprintf(path + pos, sizeof(path) - pos, "".%d"", port);




    QTAILQ_FOREACH(uport, &xhci->bus.used, next) {

        if (strcmp(uport->path, path) == 0) {

            return uport;



",1
Detect whether the following code contains vulnerabilities.,"int ovl_want_write(struct dentry *dentry)
{
	struct ovl_fs *ofs = dentry->d_sb->s_fs_info;
	return mnt_want_write(ofs->upper_mnt);
}",0
Detect whether the following code contains vulnerabilities.,"get_ownertrust_with_min (PKT_public_key *pk)
{
#ifdef NO_TRUST_MODELS
  (void)pk;
  return TRUST_UNKNOWN;
#else
  unsigned int otrust, otrust_min;

  otrust = (tdb_get_ownertrust (pk) & TRUST_MASK);
  otrust_min = tdb_get_min_ownertrust (pk);
  if (otrust < otrust_min)
    {
      /* If the trust that the user has set is less than the trust
	 that was calculated from a trust signature chain, use the
	 higher of the two.  We do this here and not in
	 get_ownertrust since the underlying ownertrust should not
	 really be set - just the appearance of the ownertrust. */

      otrust = otrust_min;
    }

  return otrust;
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t taihu_cpld_readb (void *opaque, hwaddr addr)

{

    taihu_cpld_t *cpld;

    uint32_t ret;



    cpld = opaque;

    switch (addr) {

    case 0x0:

        ret = cpld->reg0;

        break;

    case 0x1:

        ret = cpld->reg1;

        break;

    default:

        ret = 0;

        break;

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int iov_iter_npages(const struct iov_iter *i, int maxpages)
{
	if (unlikely(!i->count))
		return 0;
	/* iovec and kvec have identical layouts */
	if (likely(iter_is_iovec(i) || iov_iter_is_kvec(i)))
		return iov_npages(i, maxpages);
	if (iov_iter_is_bvec(i))
		return bvec_npages(i, maxpages);
	if (iov_iter_is_pipe(i)) {
		unsigned int iter_head;
		int npages;
		size_t off;

		if (!sanity(i))
			return 0;

		data_start(i, &iter_head, &off);
		/* some of this one + all after this one */
		npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
		return min(npages, maxpages);
	}
	if (iov_iter_is_xarray(i)) {
		unsigned offset = (i->xarray_start + i->iov_offset) % PAGE_SIZE;
		int npages = DIV_ROUND_UP(offset + i->count, PAGE_SIZE);
		return min(npages, maxpages);
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)
	{
	long l;

	if (p != NULL)
		{
		l=c->id;
		if ((l & 0xff000000) != 0x02000000) return(0);
		p[0]=((unsigned char)(l>>16L))&0xFF;
		p[1]=((unsigned char)(l>> 8L))&0xFF;
		p[2]=((unsigned char)(l     ))&0xFF;
		}
	return(3);
	}",1
Detect whether the following code contains vulnerabilities.,"static void loop_remove(struct loop_device *lo)
{
	blk_cleanup_queue(lo->lo_queue);
	del_gendisk(lo->lo_disk);
	blk_mq_free_tag_set(&lo->tag_set);
	put_disk(lo->lo_disk);
	kfree(lo);
}",0
Detect whether the following code contains vulnerabilities.,"irc_server_set_host (struct t_irc_server *server, const char *host)
{
    struct t_irc_channel *ptr_channel;

    /* if host is the same, just return */
    if ((!server->host && !host)
        || (server->host && host && strcmp (server->host, host) == 0))
    {
        return;
    }

    /* update the nick host in server */
    if (server->host)
        free (server->host);
    server->host = (host) ? strdup (host) : NULL;

    /* set local variable ""host"" for server and all channels/pv */
    weechat_buffer_set (server->buffer, ""localvar_set_host"", host);
    for (ptr_channel = server->channels; ptr_channel;
         ptr_channel = ptr_channel->next_channel)
    {
        weechat_buffer_set (ptr_channel->buffer,
                            ""localvar_set_host"", host);
    }

    weechat_bar_item_update (""irc_host"");
    weechat_bar_item_update (""irc_nick_host"");
}",0
Detect whether the following code contains vulnerabilities.,"static void vc1_inv_trans_4x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (17 * dc +  4) >> 3;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest += linesize;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void emulated_push_error(EmulatedState *card, uint64_t code)

{

    EmulEvent *event = (EmulEvent *)g_malloc(sizeof(EmulEvent));



    assert(event);

    event->p.error.type = EMUL_ERROR;

    event->p.error.code = code;

    emulated_push_event(card, event);

}
",1
Detect whether the following code contains vulnerabilities.,"static void term_up_char(void)

{

    int idx;



    if (term_hist_entry == 0)

	return;

    if (term_hist_entry == -1) {

	/* Find latest entry */

	for (idx = 0; idx < TERM_MAX_CMDS; idx++) {

	    if (term_history[idx] == NULL)

		break;

	}

	term_hist_entry = idx;

    }

    term_hist_entry--;

    if (term_hist_entry >= 0) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf), 

                term_history[term_hist_entry]);

	term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static u32 read_32(cdk_stream_t s)
{
	byte buf[4];
	size_t nread;

	assert(s != NULL);

	stream_read(s, buf, 4, &nread);
	if (nread != 4)
		return (u32) - 1;
	return buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];
}",1
Detect whether the following code contains vulnerabilities.,"tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma)
{
	/*
	 * flush_tlb_range() implementations that look at VM_HUGETLB (tile,
	 * mips-4k) flush only large pages.
	 *
	 * flush_tlb_range() implementations that flush I-TLB also flush D-TLB
	 * (tile, xtensa, arm), so it's ok to just add VM_EXEC to an existing
	 * range.
	 *
	 * We rely on tlb_end_vma() to issue a flush, such that when we reset
	 * these values the batch is empty.
	 */
	tlb->vma_huge = is_vm_hugetlb_page(vma);
	tlb->vma_exec = !!(vma->vm_flags & VM_EXEC);
}",1
Detect whether the following code contains vulnerabilities.,"static int em_loop(struct x86_emulate_ctxt *ctxt)
{
	register_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);
	if ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&
	    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))
		jmp_rel(ctxt, ctxt->src.val);

	return X86EMUL_CONTINUE;
}",1
Detect whether the following code contains vulnerabilities.,"PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"RefreshXtermOSC()
{
  int i;
  struct win *p;

  p = Layer2Window(D_forecv->c_layer);
  for (i = 3; i >=0; i--)
    SetXtermOSC(i, p ? p->w_xtermosc[i] : 0);
}",1
Detect whether the following code contains vulnerabilities.,"    void Close()
    {
        if ( m_file )
        {
            fclose(m_file);
            m_file = NULL;
        }
    }",0
Detect whether the following code contains vulnerabilities.,"static uint16_t phys_section_add(MemoryRegionSection *section)

{

    /* The physical section number is ORed with a page-aligned

     * pointer to produce the iotlb entries.  Thus it should

     * never overflow into the page-aligned value.

     */

    assert(next_map.sections_nb < TARGET_PAGE_SIZE);



    if (next_map.sections_nb == next_map.sections_nb_alloc) {

        next_map.sections_nb_alloc = MAX(next_map.sections_nb_alloc * 2,

                                         16);

        next_map.sections = g_renew(MemoryRegionSection, next_map.sections,

                                    next_map.sections_nb_alloc);

    }

    next_map.sections[next_map.sections_nb] = *section;

    memory_region_ref(section->mr);

    return next_map.sections_nb++;

}
",0
Detect whether the following code contains vulnerabilities.,"CharDriverState *qemu_chr_find(const char *name)

{

    CharDriverState *chr;



    TAILQ_FOREACH(chr, &chardevs, next) {

        if (strcmp(chr->label, name) != 0)

            continue;

        return chr;

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"void AES128GCM_OnWireRxHandler::reset_rx_handler()
{
  if(1 != EVP_DecryptInit_ex(ectx.get(), nullptr, nullptr, nullptr,
	reinterpret_cast<const unsigned char*>(&nonce))) {
    throw std::runtime_error(""EVP_DecryptInit_ex failed"");
  }
  ++nonce.random_seq;
}",1
Detect whether the following code contains vulnerabilities.,"static void cpu_ioreq_move(ioreq_t *req)

{

    int i;



    if (!req->data_is_ptr) {

        if (req->dir == IOREQ_READ) {

            for (i = 0; i < req->count; i++) {

                read_phys_req_item(req->addr, req, i, &req->data);

            }

        } else if (req->dir == IOREQ_WRITE) {

            for (i = 0; i < req->count; i++) {

                write_phys_req_item(req->addr, req, i, &req->data);

            }

        }

    } else {

        uint64_t tmp;



        if (req->dir == IOREQ_READ) {

            for (i = 0; i < req->count; i++) {

                read_phys_req_item(req->addr, req, i, &tmp);

                write_phys_req_item(req->data, req, i, &tmp);

            }

        } else if (req->dir == IOREQ_WRITE) {

            for (i = 0; i < req->count; i++) {

                read_phys_req_item(req->data, req, i, &tmp);

                write_phys_req_item(req->addr, req, i, &tmp);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)
{
	return pte_write(pte) ||
		((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));
}",1
Detect whether the following code contains vulnerabilities.,"static void v9fs_synth_direntry(V9fsSynthNode *node,

                                struct dirent *entry, off_t off)

{

    strcpy(entry->d_name, node->name);

    entry->d_ino = node->attr->inode;

    entry->d_off = off + 1;

}
",0
Detect whether the following code contains vulnerabilities.,"void monitor_init(CharDriverState *chr, int show_banner)

{

    int i;



    if (is_first_init) {

        key_timer = qemu_new_timer(vm_clock, release_keys, NULL);

        if (!key_timer)

            return;

        for (i = 0; i < MAX_MON; i++) {

            monitor_hd[i] = NULL;

        }

        is_first_init = 0;

    }

    for (i = 0; i < MAX_MON; i++) {

        if (monitor_hd[i] == NULL) {

            monitor_hd[i] = chr;

            break;

        }

    }



    hide_banner = !show_banner;



    qemu_chr_add_handlers(chr, term_can_read, term_read, term_event, cur_mon);



    readline_start("""", 0, monitor_command_cb, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)

{

    assert(len >= 14);

    if (!req->sense_len) {

        return 0;

    }

    return scsi_build_sense(req->sense, req->sense_len, buf, len, true);

}
",0
Detect whether the following code contains vulnerabilities.,"static void vt82c686b_write_config(PCIDevice * d, uint32_t address,

                                   uint32_t val, int len)

{

    VT82C686BState *vt686 = DO_UPCAST(VT82C686BState, dev, d);



    DPRINTF(""vt82c686b_write_config  address 0x%x  val 0x%x len 0x%x \n"",

           address, val, len);



    pci_default_write_config(d, address, val, len);

    if (address == 0x85) {  /* enable or disable super IO configure */

        if (val & 0x2) {

            /* floppy also uses 0x3f0 and 0x3f1.

             * But we do not emulate flopy,so just set it here. */

            isa_unassign_ioport(0x3f0, 2);

            register_ioport_read(0x3f0, 2, 1, superio_ioport_readb,

                                 &vt686->superio_conf);

            register_ioport_write(0x3f0, 2, 1, superio_ioport_writeb,

                                  &vt686->superio_conf);

        } else {

            isa_unassign_ioport(0x3f0, 2);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                              gss_buffer_t output_token)
{
    OM_uint32 major_status = GSS_S_COMPLETE;

    if (output_token != GSS_C_NO_BUFFER) {
        output_token->length = 0;
        output_token->value = NULL;
    }

    *minor_status = 0;

    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;

        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);

            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }

    return major_status;
}",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(SplFileInfo, __construct)
{
	spl_filesystem_object *intern;
	char *path;
	int len;
	zend_error_handling error_handling;

	zend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &path, &len) == FAILURE) {
		zend_restore_error_handling(&error_handling TSRMLS_CC);
		return;
	}

	intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	spl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);

	zend_restore_error_handling(&error_handling TSRMLS_CC);
	
	/* intern->type = SPL_FS_INFO; already set */
}",1
Detect whether the following code contains vulnerabilities.,"void options_apply() { /* apply default/validated configuration */
    unsigned num=0;
    SERVICE_OPTIONS *section;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);

    memcpy(&global_options, &new_global_options, sizeof(GLOBAL_OPTIONS));
    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));

    /* service_options are used for inetd mode and to enumerate services */
    for(section=new_service_options.next; section; section=section->next)
        section->section_number=num++;
    memcpy(&service_options, &new_service_options, sizeof(SERVICE_OPTIONS));
    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));
    number_of_sections=num;

    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",0
Detect whether the following code contains vulnerabilities.,"Network::FilterStatus Context::onNetworkNewConnection() {
  onCreate(root_context_id_);
  if (!wasm_->onNewConnection_) {
    return Network::FilterStatus::Continue;
  }
  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {
    return Network::FilterStatus::Continue;
  }
  return Network::FilterStatus::StopIteration;
}",1
Detect whether the following code contains vulnerabilities.,"void vnc_client_write(void *opaque)

{

    long ret;

    VncState *vs = opaque;



#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

	ret = gnutls_write(vs->tls.session, vs->output.buffer, vs->output.offset);

	if (ret < 0) {

	    if (ret == GNUTLS_E_AGAIN)

		errno = EAGAIN;

	    else

		errno = EIO;

	    ret = -1;

	}

    } else

#endif /* CONFIG_VNC_TLS */

	ret = send(vs->csock, vs->output.buffer, vs->output.offset, 0);

    ret = vnc_client_io_error(vs, ret, socket_error());

    if (!ret)

	return;



    memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));

    vs->output.offset -= ret;



    if (vs->output.offset == 0) {

	qemu_set_fd_handler2(vs->csock, NULL, vnc_client_read, NULL, vs);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void spapr_phb_hot_unplug_child(HotplugHandler *plug_handler,

                                       DeviceState *plugged_dev, Error **errp)

{

    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));

    PCIDevice *pdev = PCI_DEVICE(plugged_dev);

    sPAPRDRConnectorClass *drck;

    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);

    Error *local_err = NULL;



    if (!phb->dr_enabled) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG,

                   object_get_typename(OBJECT(phb)));

        return;

    }



    g_assert(drc);



    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    if (!drck->release_pending(drc)) {

        spapr_phb_remove_pci_device(drc, phb, pdev, &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

        spapr_hotplug_req_remove_by_index(drc);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"long __sys_recvmsg_sock(struct socket *sock, struct user_msghdr __user *msg,
			unsigned int flags)
{
	struct msghdr msg_sys;

	return ___sys_recvmsg(sock, msg, &msg_sys, flags, 0);
}",1
Detect whether the following code contains vulnerabilities.,"  const std::string& get_tenant() const {
    ceph_assert(t != Wildcard);
    return u.tenant;
  }",1
Detect whether the following code contains vulnerabilities.,"static void mcf_intc_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    int offset;

    mcf_intc_state *s = (mcf_intc_state *)opaque;

    offset = addr & 0xff;

    if (offset >= 0x40 && offset < 0x80) {

        int n = offset - 0x40;

        s->icr[n] = val;

        if (val == 0)

            s->enabled &= ~(1ull << n);

        else

            s->enabled |= (1ull << n);

        mcf_intc_update(s);

        return;

    }

    switch (offset) {

    case 0x00: case 0x04:

        /* Ignore IPR writes.  */

        return;

    case 0x08:

        s->imr = (s->imr & 0xffffffff) | ((uint64_t)val << 32);

        break;

    case 0x0c:

        s->imr = (s->imr & 0xffffffff00000000ull) | (uint32_t)val;

        break;

    default:

        hw_error(""mcf_intc_write: Bad write offset %d\n"", offset);

        break;

    }

    mcf_intc_update(s);

}
",0
Detect whether the following code contains vulnerabilities.,"make_weights (PixopsFilter     *filter,
	      PixopsInterpType  interp_type,	      
	      double            scale_x,
	      double            scale_y)
{
  switch (interp_type)
    {
    case PIXOPS_INTERP_NEAREST:
      g_assert_not_reached ();
      break;

    case PIXOPS_INTERP_TILES:
      tile_make_weights (&filter->x, scale_x);
      tile_make_weights (&filter->y, scale_y);
      break;
      
    case PIXOPS_INTERP_BILINEAR:
      bilinear_magnify_make_weights (&filter->x, scale_x);
      bilinear_magnify_make_weights (&filter->y, scale_y);
      break;
      
    case PIXOPS_INTERP_HYPER:
      bilinear_box_make_weights (&filter->x, scale_x);
      bilinear_box_make_weights (&filter->y, scale_y);
      break;
    }
}",1
Detect whether the following code contains vulnerabilities.,"int bdrv_load_vmstate(BlockDriverState *bs, uint8_t *buf,

                      int64_t pos, int size)

{

    BlockDriver *drv = bs->drv;

    if (!drv)

        return -ENOMEDIUM;

    if (drv->bdrv_load_vmstate)

        return drv->bdrv_load_vmstate(bs, buf, pos, size);

    if (bs->file)

        return bdrv_load_vmstate(bs->file, buf, pos, size);

    return -ENOTSUP;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline abi_long host_to_target_timespec(abi_ulong target_addr,

                                               struct timespec *host_ts)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_WRITE, target_ts, target_addr, 0))

        return -TARGET_EFAULT;

    target_ts->tv_sec = tswapal(host_ts->tv_sec);

    target_ts->tv_nsec = tswapal(host_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 1);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *
        p_code_block)
{
    OPJ_UINT32 l_data_size;

    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));

    if (l_data_size > p_code_block->data_size) {
        if (p_code_block->data) {
            /* We refer to data - 1 since below we incremented it */
            opj_free(p_code_block->data - 1);
        }
        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);
        if (! p_code_block->data) {
            p_code_block->data_size = 0U;
            return OPJ_FALSE;
        }
        p_code_block->data_size = l_data_size;

        /* We reserve the initial byte as a fake byte to a non-FF value */
        /* and increment the data pointer, so that opj_mqc_init_enc() */
        /* can do bp = data - 1, and opj_mqc_byteout() can safely dereference */
        /* it. */
        p_code_block->data[0] = 0;
        p_code_block->data += 1; /*why +1 ?*/
    }
    return OPJ_TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"static int cmpfcncc(const void *_a, const void *_b) {
	RAnalFunction *a = (RAnalFunction *)_a;
	RAnalFunction *b = (RAnalFunction *)_b;
	ut64 as = r_anal_function_complexity (a);
	ut64 bs = r_anal_function_complexity (b);
	return (as > bs)? 1: (as < bs)? -1: 0;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t block_crypto_read_func(QCryptoBlock *block,

                                      size_t offset,

                                      uint8_t *buf,

                                      size_t buflen,

                                      Error **errp,

                                      void *opaque)

{

    BlockDriverState *bs = opaque;

    ssize_t ret;



    ret = bdrv_pread(bs->file, offset, buf, buflen);

    if (ret < 0) {

        error_setg_errno(errp, -ret, ""Could not read encryption header"");

        return ret;

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static target_long monitor_get_decr (const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return cpu_ppc_load_decr(env);

}
",1
Detect whether the following code contains vulnerabilities.,"evdns_base_set_option(struct evdns_base *base,
    const char *option, const char *val)
{
	int res;
	EVDNS_LOCK(base);
	res = evdns_base_set_option_impl(base, option, val, DNS_OPTIONS_ALL);
	EVDNS_UNLOCK(base);
	return res;
}",0
Detect whether the following code contains vulnerabilities.,"void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val, int l)

{

    int i, was_irq_disabled = pci_irq_disabled(d);

    uint32_t config_size = pci_config_size(d);



    for (i = 0; i < l && addr + i < config_size; val >>= 8, ++i) {

        uint8_t wmask = d->wmask[addr + i];

        uint8_t w1cmask = d->w1cmask[addr + i];

        assert(!(wmask & w1cmask));

        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);

        d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */

    }

    if (ranges_overlap(addr, l, PCI_BASE_ADDRESS_0, 24) ||

        ranges_overlap(addr, l, PCI_ROM_ADDRESS, 4) ||

        ranges_overlap(addr, l, PCI_ROM_ADDRESS1, 4) ||

        range_covers_byte(addr, l, PCI_COMMAND))

        pci_update_mappings(d);



    if (range_covers_byte(addr, l, PCI_COMMAND))

        pci_update_irq_disabled(d, was_irq_disabled);

}
",1
Detect whether the following code contains vulnerabilities.,"void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)
{
	size_t cbAvPair = cbAvPairList;
	NTLM_AV_PAIR* pAvPair = pAvPairList;

	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
		return;

	WLog_INFO(TAG, ""AV_PAIRs ="");

	while (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)
	{
		WLog_INFO(TAG, ""\t%s AvId: %"" PRIu16 "" AvLen: %"" PRIu16 """",
		          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),
		          ntlm_av_pair_get_len(pAvPair));
		winpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),
		              ntlm_av_pair_get_len(pAvPair));

		pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);
	}
}",1
Detect whether the following code contains vulnerabilities.,"void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {
  headers_.remove_if([&](const HeaderEntryImpl& entry) {
    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());
    if (to_remove) {
      // If this header should be removed, make sure any references in the
      // static lookup table are cleared as well.
      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());
      if (cb) {
        StaticLookupResponse ref_lookup_response = cb(*this);
        if (ref_lookup_response.entry_) {
          *ref_lookup_response.entry_ = nullptr;
        }
      }
    }
    return to_remove;
  });
}",1
Detect whether the following code contains vulnerabilities.,"static PHP_FUNCTION(session_id)
{
	zend_string *name = NULL;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""|S"", &name) == FAILURE) {
		return;
	}

	if (name && PS(use_cookies) && SG(headers_sent)) {
		php_error_docref(NULL, E_WARNING, ""Cannot change session id when headers already sent"");
		RETURN_FALSE;
	}

	if (PS(id)) {
		/* keep compatibility for ""\0"" characters ???
		 * see: ext/session/tests/session_id_error3.phpt */
		size_t len = strlen(ZSTR_VAL(PS(id)));
		if (UNEXPECTED(len != ZSTR_LEN(PS(id)))) {
			RETVAL_NEW_STR(zend_string_init(ZSTR_VAL(PS(id)), len, 0));
		} else {
			RETVAL_STR_COPY(PS(id));
		}
	} else {
		RETVAL_EMPTY_STRING();
	}

	if (name) {
		if (PS(id)) {
			zend_string_release(PS(id));
		}
		PS(id) = zend_string_copy(name);
	}
}",0
Detect whether the following code contains vulnerabilities.,"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)

{

    int32_t datalen;

    int lun;



    DPRINTF(""do_busid_cmd: busid 0x%x\n"", busid);

    lun = busid & 7;

    s->current_req = scsi_req_new(s->current_dev, 0, lun, NULL);

    datalen = scsi_req_enqueue(s->current_req, buf);

    s->ti_size = datalen;

    if (datalen != 0) {

        s->rregs[ESP_RSTAT] = STAT_TC;

        s->dma_left = 0;

        s->dma_counter = 0;

        if (datalen > 0) {

            s->rregs[ESP_RSTAT] |= STAT_DI;

        } else {

            s->rregs[ESP_RSTAT] |= STAT_DO;

        }

        scsi_req_continue(s->current_req);

    }

    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;

    s->rregs[ESP_RSEQ] = SEQ_CD;

    esp_raise_irq(s);

}
",0
Detect whether the following code contains vulnerabilities.,"read_rle_pixel(tga_source_ptr sinfo)
/* Read one Targa pixel from the input file, expanding RLE data as needed */
{
  register FILE *infile = sinfo->pub.input_file;
  register int i;

  /* Duplicate previously read pixel? */
  if (sinfo->dup_pixel_count > 0) {
    sinfo->dup_pixel_count--;
    return;
  }

  /* Time to read RLE block header? */
  if (--sinfo->block_count < 0) { /* decrement pixels remaining in block */
    i = read_byte(sinfo);
    if (i & 0x80) {             /* Start of duplicate-pixel block? */
      sinfo->dup_pixel_count = i & 0x7F; /* number of dups after this one */
      sinfo->block_count = 0;   /* then read new block header */
    } else {
      sinfo->block_count = i & 0x7F; /* number of pixels after this one */
    }
  }

  /* Read next pixel */
  for (i = 0; i < sinfo->pixel_size; i++) {
    sinfo->tga_pixel[i] = (U_CHAR)getc(infile);
  }
}",1
Detect whether the following code contains vulnerabilities.,"static void free_todo_entries(TodoEntry **todos) {
        for (TodoEntry *x = *todos; x && x->dir; x++) {
                closedir(x->dir);
                free(x->dirname);
        }

        freep(todos);
}",0
Detect whether the following code contains vulnerabilities.,"static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,
						  __be16 sport, __be16 dport   )
{
	return secure_tcpv6_sequence_number(saddr, daddr, sport, dport);
}",1
Detect whether the following code contains vulnerabilities.,"static void remove_port(VirtIOSerial *vser, uint32_t port_id)

{

    VirtIOSerialPort *port;

    unsigned int i;



    i = port_id / 32;

    vser->ports_map[i] &= ~(1U << (port_id % 32));



    port = find_port_by_id(vser, port_id);

    /*

     * This function is only called from qdev's unplug callback; if we

     * get a NULL port here, we're in trouble.

     */

    assert(port);



    /* Flush out any unconsumed buffers first */

    discard_vq_data(port->ovq, VIRTIO_DEVICE(port->vser));



    send_control_event(vser, port->id, VIRTIO_CONSOLE_PORT_REMOVE, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */
{
	spl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);
	
	if (fsobj->u.dir.entry.d_name[0] == '\0' && fsobj->orig_path == NULL) {
		method = ""_bad_state_ex"";
		method_len = sizeof(""_bad_state_ex"") - 1;
		key = NULL;
	}
	
	return zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);
}",1
Detect whether the following code contains vulnerabilities.,"_outParamRef(StringInfo str, const ParamRef *node)
{
	WRITE_NODE_TYPE(""PARAMREF"");

	WRITE_INT_FIELD(number);
	WRITE_LOCATION_FIELD(location);
}",0
Detect whether the following code contains vulnerabilities.,"static double get_time (void) {
#ifdef DO_TIME_DAY
    struct timeval tv;

    gettimeofday(&tv, NULL);

    return tv.tv_sec + 1e-6 * tv.tv_usec;
#else
    struct timeb tb;

    ftime(&tb);

    return tb.time + 1e-3 * tb.millitm;
#endif
}",0
Detect whether the following code contains vulnerabilities.,"void kvm_arch_commit_memory_region(struct kvm *kvm,
				   struct kvm_userspace_memory_region *mem,
				   const struct kvm_memory_slot *old,
				   enum kvm_mr_change change)
{
}",0
Detect whether the following code contains vulnerabilities.,"const char *swscale_configuration(void)

{

    return FFMPEG_CONFIGURATION;

}
",0
Detect whether the following code contains vulnerabilities.,"static void unlink_queue(struct sem_array *sma, struct sem_queue *q)
{
	list_del(&q->list);
	if (q->nsops > 1)
		sma->complex_count--;
}",0
Detect whether the following code contains vulnerabilities.,"ssize_t enc_untrusted_write(int fd, const void *buf, size_t count) {
  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(
      asylo::system_call::kSYS_write, fd, buf, count));
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold int smc_decode_init(AVCodecContext *avctx)

{

    SmcContext *s = avctx->priv_data;



    s->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_PAL8;



    s->frame.data[0] = NULL;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, target_phys_addr_t index)

{

    PhysPageEntry lp = d->phys_map;

    PhysPageEntry *p;

    int i;

    uint16_t s_index = phys_section_unassigned;



    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {

        if (lp.ptr == PHYS_MAP_NODE_NIL) {

            goto not_found;

        }

        p = phys_map_nodes[lp.ptr];

        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];

    }



    s_index = lp.ptr;

not_found:

    return &phys_sections[s_index];

}
",0
Detect whether the following code contains vulnerabilities.,"bool lockdep_rtnl_is_held(void)
{
	return lockdep_is_held(&rtnl_mutex);
}",0
Detect whether the following code contains vulnerabilities.,"QEMUOptionParameter *append_option_parameters(QEMUOptionParameter *dest,

    QEMUOptionParameter *list)

{

    size_t num_options, num_dest_options;



    num_options = count_option_parameters(dest);

    num_dest_options = num_options;



    num_options += count_option_parameters(list);



    dest = qemu_realloc(dest, (num_options + 1) * sizeof(QEMUOptionParameter));




    while (list && list->name) {

        if (get_option_parameter(dest, list->name) == NULL) {

            dest[num_dest_options++] = *list;


        }

        list++;

    }



    return dest;

}",1
Detect whether the following code contains vulnerabilities.,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
	else if (len < ds)
		msg->msg_flags |= MSG_TRUNC;

	msg->msg_namelen = 0;

	lock_sock(sk);
	if (ctx->more) {
		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}",1
Detect whether the following code contains vulnerabilities.,"static void reset_packet_state(AVFormatContext *s)

{

    ASFContext *asf        = s->priv_data;

    int i;



    asf->state             = PARSE_PACKET_HEADER;

    asf->offset            = 0;

    asf->return_subpayload = 0;

    asf->sub_left          = 0;

    asf->sub_header_offset = 0;

    asf->packet_offset     = asf->first_packet_offset;

    asf->pad_len           = 0;

    asf->rep_data_len      = 0;

    asf->dts_delta         = 0;

    asf->mult_sub_len      = 0;

    asf->nb_mult_left      = 0;

    asf->nb_sub            = 0;

    asf->prop_flags        = 0;

    asf->sub_dts           = 0;

    asf->dts               = 0;

    for (i = 0; i < asf->nb_streams; i++) {

        ASFPacket *pkt = &asf->asf_st[i]->pkt;

        pkt->size_left = 0;

        pkt->data_size = 0;

        pkt->duration  = 0;

        pkt->flags     = 0;

        pkt->dts       = 0;

        pkt->duration  = 0;

        av_free_packet(&pkt->avpkt);

        av_init_packet(&pkt->avpkt);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"dissect_NOTIFY_OPTIONS_ARRAY_CTR(tvbuff_t *tvb, int offset,
				 packet_info *pinfo, proto_tree *tree,
				 dcerpc_info *di, guint8 *drep)
{
	if (di->conformant_run)
		return offset;

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_notify_options_version, NULL);

	offset = dissect_notify_options_flags(tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_notify_options_count, NULL);

	offset = dissect_ndr_pointer(
		tvb, offset, pinfo, tree, di, drep,
		dissect_NOTIFY_OPTIONS_ARRAY, NDR_POINTER_UNIQUE,
		""Notify Options Array"", -1);

	return offset;
}",0
Detect whether the following code contains vulnerabilities.,"static void test_validate_fail_union_native_list(TestInputVisitorData *data,

                                                 const void *unused)

{

    UserDefNativeListUnion *tmp = NULL;

    Error *err = NULL;

    Visitor *v;



    v = validate_test_init(data,

                           ""{ 'type': 'integer', 'data' : [ 'string' ] }"");



    visit_type_UserDefNativeListUnion(v, &tmp, NULL, &err);

    g_assert(err);


    qapi_free_UserDefNativeListUnion(tmp);

}",1
Detect whether the following code contains vulnerabilities.,"static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,

                                 struct tftp_t *tp)

{

  struct tftp_session *spt;

  int k;



  for (k = 0; k < TFTP_SESSIONS_MAX; k++) {

    spt = &slirp->tftp_sessions[k];



    if (!tftp_session_in_use(spt))

        goto found;



    /* sessions time out after 5 inactive seconds */

    if ((int)(curtime - spt->timestamp) > 5000) {

        tftp_session_terminate(spt);

        goto found;

    }

  }



  return -1;



 found:

  memset(spt, 0, sizeof(*spt));

  spt->client_addr = *srcsas;

  spt->fd = -1;

  spt->block_size = 512;

  spt->client_port = tp->udp.uh_sport;

  spt->slirp = slirp;



  tftp_session_update(spt);



  return k;

}
",1
Detect whether the following code contains vulnerabilities.,"mlx5_queue_state_modify(struct rte_eth_dev *dev,
			struct mlx5_mp_arg_queue_state_modify *sm)
{
	struct mlx5_priv *priv = dev->data->dev_private;
	int ret = 0;

	switch (rte_eal_process_type()) {
	case RTE_PROC_PRIMARY:
		ret = mlx5_queue_state_modify_primary(dev, sm);
		break;
	case RTE_PROC_SECONDARY:
		ret = mlx5_mp_req_queue_state_modify(&priv->mp_id, sm);
		break;
	default:
		break;
	}
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static double get_video_clock(VideoState *is)

{

    if (is->paused) {

        return is->video_current_pts;

    } else {

        return is->video_current_pts + (av_gettime() - is->video_current_pts_time) / 1000000.0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t timerslack_ns_write(struct file *file, const char __user *buf,
					size_t count, loff_t *offset)
{
	struct inode *inode = file_inode(file);
	struct task_struct *p;
	u64 slack_ns;
	int err;

	err = kstrtoull_from_user(buf, count, 10, &slack_ns);
	if (err < 0)
		return err;

	p = get_proc_task(inode);
	if (!p)
		return -ESRCH;

	if (p != current) {
		if (!capable(CAP_SYS_NICE)) {
			count = -EPERM;
			goto out;
		}

		err = security_task_setscheduler(p);
		if (err) {
			count = err;
			goto out;
		}
	}

	task_lock(p);
	if (slack_ns == 0)
		p->timer_slack_ns = p->default_timer_slack_ns;
	else
		p->timer_slack_ns = slack_ns;
	task_unlock(p);

out:
	put_task_struct(p);

	return count;
}",0
Detect whether the following code contains vulnerabilities.,"int floatx80_unordered(floatx80 a, floatx80 b, float_status *status)

{

    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 1;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)
{
  struct ImapMbox mx;
  struct Url url;
  char cachepath[PATH_MAX];
  char mbox[PATH_MAX];

  if (path)
    imap_cachepath(idata, path, mbox, sizeof(mbox));
  else
  {
    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)
      return NULL;

    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));
    FREE(&mx.mbox);
  }

  mutt_account_tourl(&idata->conn->account, &url);
  url.path = mbox;
  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);

  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);
}",1
Detect whether the following code contains vulnerabilities.,"static int newgroup(message_data_t *msg)
{
    int r;
    char *group;
    char mailboxname[MAX_MAILBOX_BUFFER];

    /* isolate newsgroup */
    group = msg->control + 8; /* skip ""newgroup"" */
    while (Uisspace(*group)) group++;

    snprintf(mailboxname, sizeof(mailboxname), ""%s%.*s"",
	     newsprefix, (int) strcspn(group, "" \t\r\n""), group);

    r = mboxlist_createmailbox(mailboxname, 0, NULL, 0,
			       newsmaster, newsmaster_authstate, 0, 0, 0);

    /* XXX check body of message for useful MIME parts */

    return r;
}",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState* create_eventfd_chr_device(void * opaque, EventNotifier *n,

                                                  int vector)

{

    /* create a event character device based on the passed eventfd */

    IVShmemState *s = opaque;

    CharDriverState * chr;

    int eventfd = event_notifier_get_fd(n);



    chr = qemu_chr_open_eventfd(eventfd);



    if (chr == NULL) {

        fprintf(stderr, ""creating eventfd for eventfd %d failed\n"", eventfd);

        exit(-1);

    }




    /* if MSI is supported we need multiple interrupts */

    if (ivshmem_has_feature(s, IVSHMEM_MSI)) {

        s->eventfd_table[vector].pdev = &s->dev;

        s->eventfd_table[vector].vector = vector;



        qemu_chr_add_handlers(chr, ivshmem_can_receive, fake_irqfd,

                      ivshmem_event, &s->eventfd_table[vector]);

    } else {

        qemu_chr_add_handlers(chr, ivshmem_can_receive, ivshmem_receive,

                      ivshmem_event, s);

    }



    return chr;



}",1
Detect whether the following code contains vulnerabilities.,"void net_slirp_redir(Monitor *mon, const char *redir_str, const char *redir_opt2)

{

    struct slirp_config_str *config;



    if (!slirp_inited) {

        if (mon) {

            monitor_printf(mon, ""user mode network stack not in use\n"");

        } else {

            config = qemu_malloc(sizeof(*config));

            config->str = redir_str;

            config->next = slirp_redirs;

            slirp_redirs = config;

        }

        return;

    }



    if (!strcmp(redir_str, ""remove"")) {

        net_slirp_redir_rm(mon, redir_opt2);

        return;

    }



    slirp_redirection(mon, redir_str);

}
",0
Detect whether the following code contains vulnerabilities.,"static void quit_handler(int sig)
{
    /* if we're frozen, don't exit unless we're absolutely forced to,
     * because it's basically impossible for graceful exit to complete
     * unless all log/pid files are on unfreezable filesystems. there's
     * also a very likely chance killing the agent before unfreezing
     * the filesystems is a mistake (or will be viewed as one later).
     */
    if (ga_is_frozen(ga_state)) {
        return;
    g_debug(""received signal num %d, quitting"", sig);
    if (g_main_loop_is_running(ga_state->main_loop)) {
        g_main_loop_quit(ga_state->main_loop);",1
Detect whether the following code contains vulnerabilities.,"static void mlx5_fpga_conn_free_recv_bufs(struct mlx5_fpga_conn *conn)
{
	int ix;

	for (ix = 0; ix < conn->qp.rq.size; ix++) {
		if (!conn->qp.rq.bufs[ix])
			continue;
		mlx5_fpga_conn_unmap_buf(conn, conn->qp.rq.bufs[ix]);
		kfree(conn->qp.rq.bufs[ix]);
		conn->qp.rq.bufs[ix] = NULL;
	}
}",0
Detect whether the following code contains vulnerabilities.,"TRIO_PRIVATE int TrioScan TRIO_ARGS8(
    (source, sourceSize, InStream, UndoStream, format, arglist, argfunc, argarray),
    trio_pointer_t source, size_t sourceSize, void(*InStream) TRIO_PROTO((trio_class_t*, int*)),
    void(*UndoStream) TRIO_PROTO((trio_class_t*)), TRIO_CONST char* format, va_list arglist,
    trio_argfunc_t argfunc, trio_pointer_t* argarray)
{
	int status;
	trio_parameter_t parameters[MAX_PARAMETERS];
	trio_class_t data;

	assert(VALID(InStream));
	assert(VALID(format));

	memset(&data, 0, sizeof(data));
	data.InStream = InStream;
	data.UndoStream = UndoStream;
	data.location = (trio_pointer_t)source;
	data.max = sourceSize;
	data.error = 0;

#if defined(USE_LOCALE)
	if (NULL == internalLocaleValues)
	{
		TrioSetLocale();
	}
#endif

	status = TrioParse(TYPE_SCAN, format, parameters, arglist, argfunc, argarray);
	if (status < 0)
		return status;

	status = TrioScanProcess(&data, format, parameters);
	if (data.error != 0)
	{
		status = data.error;
	}
	return status;
}",0
Detect whether the following code contains vulnerabilities.,"GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)
{
	GIOChannel *handle, *ssl_handle;

	handle = net_connect_ip(ip, port, my_ip);
	if (handle == NULL)
		return NULL;
	ssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);
	if (ssl_handle == NULL)
		g_io_channel_unref(handle);
	return ssl_handle;
}",0
Detect whether the following code contains vulnerabilities.,"static void tftp_udp_output(struct tftp_session *spt, struct mbuf *m,
                            struct tftp_t *recv_tp)
{
    if (spt->client_addr.ss_family == AF_INET6) {
        struct sockaddr_in6 sa6, da6;

        sa6.sin6_addr = spt->slirp->vhost_addr6;
        sa6.sin6_port = recv_tp->udp.uh_dport;
        da6.sin6_addr = ((struct sockaddr_in6 *)&spt->client_addr)->sin6_addr;
        da6.sin6_port = spt->client_port;

        udp6_output(NULL, m, &sa6, &da6);
    } else {
        struct sockaddr_in sa4, da4;

        sa4.sin_addr = spt->slirp->vhost_addr;
        sa4.sin_port = recv_tp->udp.uh_dport;
        da4.sin_addr = ((struct sockaddr_in *)&spt->client_addr)->sin_addr;
        da4.sin_port = spt->client_port;

        udp_output(NULL, m, &sa4, &da4, IPTOS_LOWDELAY);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void tcp_chr_disconnect(CharDriverState *chr)

{

    TCPCharDriver *s = chr->opaque;



    if (!s->connected) {

        return;

    }



    s->connected = 0;

    if (s->listen_ioc) {

        s->listen_tag = qio_channel_add_watch(

            QIO_CHANNEL(s->listen_ioc), G_IO_IN, tcp_chr_accept, chr, NULL);

    }

    tcp_set_msgfds(chr, NULL, 0);

    remove_fd_in_watch(chr);

    object_unref(OBJECT(s->sioc));

    s->sioc = NULL;

    object_unref(OBJECT(s->ioc));

    s->ioc = NULL;

    g_free(chr->filename);

    chr->filename = SocketAddress_to_str(""disconnected:"", s->addr,

                                         s->is_listen, s->is_telnet);

    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);

    if (s->reconnect_time) {

        qemu_chr_socket_restart_timer(chr);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int SetDatesFromDcert(Cert* cert, DecodedCert* decoded)
{
    int ret = 0;

    if (decoded->beforeDate == NULL || decoded->afterDate == NULL) {
        WOLFSSL_MSG(""Couldn't extract dates"");
        ret = -1;
    }
    else if (decoded->beforeDateLen > MAX_DATE_SIZE ||
                                        decoded->afterDateLen > MAX_DATE_SIZE) {
        WOLFSSL_MSG(""Bad date size"");
        ret = -1;
    }
    else {
        XMEMCPY(cert->beforeDate, decoded->beforeDate, decoded->beforeDateLen);
        XMEMCPY(cert->afterDate,  decoded->afterDate,  decoded->afterDateLen);

        cert->beforeDateSz = decoded->beforeDateLen;
        cert->afterDateSz  = decoded->afterDateLen;
    }

    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,
				      struct ndpi_flow_struct *flow) {
  u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;

  if(flow->packet.iph) {
    struct in_addr addr;
    u_int16_t sport, dport;

    addr.s_addr = flow->packet.iph->saddr;

    if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)
      sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;
    else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)
      sport = flow->packet.udp->source, dport = flow->packet.udp->dest;
    else
      sport = dport = 0;

    /* guess host protocol */
    ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);

    if(ret == NDPI_PROTOCOL_UNKNOWN) {
      addr.s_addr = flow->packet.iph->daddr;
      ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);
    }
  }

  return(ret);
}",0
Detect whether the following code contains vulnerabilities.,"static CURLcode imap_connect(struct connectdata *conn, bool *done)
{
  CURLcode result = CURLE_OK;
  struct imap_conn *imapc = &conn->proto.imapc;
  struct pingpong *pp = &imapc->pp;

  *done = FALSE; /* default to not done yet */

  /* We always support persistent connections in IMAP */
  connkeep(conn, ""IMAP default"");

  /* Set the default response time-out */
  pp->response_time = RESP_TIMEOUT;
  pp->statemach_act = imap_statemach_act;
  pp->endofresp = imap_endofresp;
  pp->conn = conn;

  /* Set the default preferred authentication type and mechanism */
  imapc->preftype = IMAP_TYPE_ANY;
  Curl_sasl_init(&imapc->sasl, &saslimap);

  /* Initialise the pingpong layer */
  Curl_pp_init(pp);

  /* Parse the URL options */
  result = imap_parse_url_options(conn);
  if(result)
    return result;

  /* Start off waiting for the server greeting response */
  state(conn, IMAP_SERVERGREET);

  /* Start off with an response id of '*' */
  strcpy(imapc->resptag, ""*"");

  result = imap_multi_statemach(conn, done);

  return result;
}",0
Detect whether the following code contains vulnerabilities.,"process_cmd_cmdallow(CMD_Request *msg, char *line)
{
  int status;
  msg->command = htons(REQ_CMDALLOW);
  status = parse_allow_deny(msg, line);
  return status;
}",0
Detect whether the following code contains vulnerabilities.,"static void term_handle_command(char *cmdline)

{

    char *p, *pstart;

    int argc;

    const char *args[MAX_ARGS + 1];

    term_cmd_t *cmd;



#ifdef DEBUG

    term_printf(""command='%s'\n"", cmdline);

#endif

    

    /* split command in words */

    argc = 0;

    p = cmdline;

    for(;;) {

        while (isspace(*p))

            p++;

        if (*p == '\0')

            break;

        pstart = p;

        while (*p != '\0' && !isspace(*p))

            p++;

        args[argc] = pstart;

        argc++;

        if (argc >= MAX_ARGS)

            break;

        if (*p == '\0')

            break;

        *p++ = '\0';

    }

    args[argc] = NULL;

#ifdef DEBUG

    for(i=0;i<argc;i++) {

        term_printf("" '%s'"", args[i]);

    }

    term_printf(""\n"");

#endif

    if (argc <= 0)

        return;

    for(cmd = term_cmds; cmd->name != NULL; cmd++) {

        if (compare_cmd(args[0], cmd->name)) 

            goto found;

    }

    term_printf(""unknown command: '%s'\n"", args[0]);

    return;

 found:

    cmd->handler(argc, args);

}
",0
Detect whether the following code contains vulnerabilities.,"static void udp_chr_update_read_handler(CharDriverState *chr)

{

    NetCharDriver *s = chr->opaque;



    if (s->tag) {

        g_source_remove(s->tag);

        s->tag = 0;

    }



    if (s->chan) {

        s->tag = io_add_watch_poll(s->chan, udp_chr_read_poll, udp_chr_read, chr);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {
	if (!s) {
		return -1;
	}
#if HAVE_LIB_SSL
	if (s->is_ssl) {
		if (s->bio) {
			return BIO_read (s->bio, buf, len);
		}
		return SSL_read (s->sfd, buf, len);
	}
#endif
#if __WINDOWS__
rep:
	{
	int ret = recv (s->fd, (void *)buf, len, 0);
	if (ret == -1) {
		goto rep;
	}
	return ret;
	}
#else
	// int r = read (s->fd, buf, len);
	int r = recv (s->fd, buf, len, 0);
	D { eprintf (""READ ""); int i; for (i = 0; i<len; i++) { eprintf (""%02x "", buf[i]); } eprintf (""\n""); }
	return r;
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static int bdrv_prwv_co(BdrvChild *child, int64_t offset,

                        QEMUIOVector *qiov, bool is_write,

                        BdrvRequestFlags flags)

{

    Coroutine *co;

    RwCo rwco = {

        .child = child,

        .offset = offset,

        .qiov = qiov,

        .is_write = is_write,

        .ret = NOT_DONE,

        .flags = flags,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_rw_co_entry(&rwco);

    } else {

        AioContext *aio_context = bdrv_get_aio_context(child->bs);



        co = qemu_coroutine_create(bdrv_rw_co_entry, &rwco);

        qemu_coroutine_enter(co);

        while (rwco.ret == NOT_DONE) {

            aio_poll(aio_context, true);

        }

    }

    return rwco.ret;

}
",0
Detect whether the following code contains vulnerabilities.,"bgp_connect_check (struct peer *peer)
{
  int status;
  socklen_t slen;
  int ret;

  /* Anyway I have to reset read and write thread. */
  BGP_READ_OFF (peer->t_read);
  BGP_WRITE_OFF (peer->t_write);

  /* Check file descriptor. */
  slen = sizeof (status);
  ret = getsockopt(peer->fd, SOL_SOCKET, SO_ERROR, (void *) &status, &slen);

  /* If getsockopt is fail, this is fatal error. */
  if (ret < 0)
    {
      zlog (peer->log, LOG_INFO, ""can't get sockopt for nonblocking connect"");
      BGP_EVENT_ADD (peer, TCP_fatal_error);
      return;
    }      

  /* When status is 0 then TCP connection is established. */
  if (status == 0)
    {
      BGP_EVENT_ADD (peer, TCP_connection_open);
    }
  else
    {
      if (BGP_DEBUG (events, EVENTS))
	  plog_debug (peer->log, ""%s [Event] Connect failed (%s)"",
		     peer->host, safe_strerror (errno));
      BGP_EVENT_ADD (peer, TCP_connection_open_failed);
    }
}",0
Detect whether the following code contains vulnerabilities.,"void bdrv_flush(BlockDriverState *bs)
{
    if (bs->drv && bs->drv->bdrv_flush)
        bs->drv->bdrv_flush(bs);",1
Detect whether the following code contains vulnerabilities.,"int mp_pack(lua_State *L) {
    int nargs = lua_gettop(L);
    int i;
    mp_buf *buf;

    if (nargs == 0)
        return luaL_argerror(L, 0, ""MessagePack pack needs input."");

    buf = mp_buf_new(L);
    for(i = 1; i <= nargs; i++) {
        /* Copy argument i to top of stack for _encode processing;
         * the encode function pops it from the stack when complete. */
        lua_pushvalue(L, i);

        mp_encode_lua_type(L,buf,0);

        lua_pushlstring(L,(char*)buf->b,buf->len);

        /* Reuse the buffer for the next operation by
         * setting its free count to the total buffer size
         * and the current position to zero. */
        buf->free += buf->len;
        buf->len = 0;
    }
    mp_buf_free(L, buf);

    /* Concatenate all nargs buffers together */
    lua_concat(L, nargs);
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"static void i40e_map_vector_to_qp(struct i40e_vsi *vsi, int v_idx, int qp_idx)
{
	struct i40e_q_vector *q_vector = vsi->q_vectors[v_idx];
	struct i40e_ring *tx_ring = vsi->tx_rings[qp_idx];
	struct i40e_ring *rx_ring = vsi->rx_rings[qp_idx];

	tx_ring->q_vector = q_vector;
	tx_ring->next = q_vector->tx.ring;
	q_vector->tx.ring = tx_ring;
	q_vector->tx.count++;

	/* Place XDP Tx ring in the same q_vector ring list as regular Tx */
	if (i40e_enabled_xdp_vsi(vsi)) {
		struct i40e_ring *xdp_ring = vsi->xdp_rings[qp_idx];

		xdp_ring->q_vector = q_vector;
		xdp_ring->next = q_vector->tx.ring;
		q_vector->tx.ring = xdp_ring;
		q_vector->tx.count++;
	}

	rx_ring->q_vector = q_vector;
	rx_ring->next = q_vector->rx.ring;
	q_vector->rx.ring = rx_ring;
	q_vector->rx.count++;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void __init check_numabalancing_enable(void)
{
}",0
Detect whether the following code contains vulnerabilities.,"av_cold void rgb2rgb_init_x86(void)

{

#if HAVE_INLINE_ASM

    int cpu_flags = av_get_cpu_flags();



    if (cpu_flags & AV_CPU_FLAG_MMX)

        rgb2rgb_init_MMX();

    if (HAVE_AMD3DNOW && cpu_flags & AV_CPU_FLAG_3DNOW)

        rgb2rgb_init_3DNOW();

    if (HAVE_MMXEXT   && cpu_flags & AV_CPU_FLAG_MMXEXT)

        rgb2rgb_init_MMX2();

    if (HAVE_SSE      && cpu_flags & AV_CPU_FLAG_SSE2)

        rgb2rgb_init_SSE2();

#endif /* HAVE_INLINE_ASM */

}
",0
Detect whether the following code contains vulnerabilities.,"    DRW_TableEntry() {
        tType = DRW::UNKNOWNT;
        flags = 0;
        numReactors = xDictFlag = 0;
        parentHandle = 0;
        curr = NULL;
    }",1
Detect whether the following code contains vulnerabilities.,"static int get_S2prot(CPUARMState *env, int s2ap, int xn)

{

    int prot = 0;



    if (s2ap & 1) {

        prot |= PAGE_READ;

    }

    if (s2ap & 2) {

        prot |= PAGE_WRITE;

    }

    if (!xn) {

        prot |= PAGE_EXEC;

    }

    return prot;

}
",1
Detect whether the following code contains vulnerabilities.,"static int filter_frame(AVFilterLink *inlink, AVFrame *inbuf)

{

    AudioPhaserContext *s = inlink->dst->priv;

    AVFilterLink *outlink = inlink->dst->outputs[0];

    AVFrame *outbuf;



    if (av_frame_is_writable(inbuf)) {

        outbuf = inbuf;

    } else {

        outbuf = ff_get_audio_buffer(inlink, inbuf->nb_samples);

        if (!outbuf)

            return AVERROR(ENOMEM);

        av_frame_copy_props(outbuf, inbuf);

    }



    s->phaser(s, inbuf->extended_data, outbuf->extended_data,

              outbuf->nb_samples, outbuf->channels);



    if (inbuf != outbuf)

        av_frame_free(&inbuf);



    return ff_filter_frame(outlink, outbuf);

}
",1
Detect whether the following code contains vulnerabilities.,"static void icp_realize(DeviceState *dev, Error **errp)

{

    ICPState *icp = ICP(dev);

    ICPStateClass *icpc = ICP_GET_CLASS(dev);

    Object *obj;

    Error *err = NULL;



    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, &err);

    if (!obj) {

        error_setg(errp, ""%s: required link '"" ICP_PROP_XICS ""' not found: %s"",

                   __func__, error_get_pretty(err));

        return;

    }



    icp->xics = XICS_FABRIC(obj);



    if (icpc->realize) {

        icpc->realize(dev, errp);

    }



    qemu_register_reset(icp_reset, dev);

}
",0
Detect whether the following code contains vulnerabilities.,"Context* Wasm::start() {
  auto root_id = plugin_->root_id_;
  auto it = root_contexts_.find(root_id);
  if (it != root_contexts_.end()) {
    it->second->onStart(root_id, vm_configuration());
    return it->second.get();
  }
  auto context = std::make_unique<Context>(this, root_id, plugin_);
  auto context_ptr = context.get();
  root_contexts_[root_id] = std::move(context);
  context_ptr->onStart(root_id, vm_configuration());
  return context_ptr;
};",0
Detect whether the following code contains vulnerabilities.,"BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)
{
	_noLibzError();
	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static uint16_t nvme_dma_read_prp(NvmeCtrl *n, uint8_t *ptr, uint32_t len,

    uint64_t prp1, uint64_t prp2)

{

    QEMUSGList qsg;

    QEMUIOVector iov;

    uint16_t status = NVME_SUCCESS;



    if (nvme_map_prp(&qsg, &iov, prp1, prp2, len, n)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    if (qsg.nsg > 0) {

        if (dma_buf_read(ptr, len, &qsg)) {

            status = NVME_INVALID_FIELD | NVME_DNR;

        }

        qemu_sglist_destroy(&qsg);

    } else {

        if (qemu_iovec_to_buf(&iov, 0, ptr, len) != len) {

            status = NVME_INVALID_FIELD | NVME_DNR;

        }

        qemu_iovec_destroy(&iov);

    }

    return status;

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_uint16(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    qemu_get_be16s(f, v);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,
                int *algIds)
{
  char *startCur = ciphers;
  int algCount = 0;
  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {
    long alg = strtol(startCur, 0, 0);
    if(!alg)
      alg = get_alg_id_by_name(startCur);
    if(alg)
      algIds[algCount++] = alg;
    else if(!strncmp(startCur, ""USE_STRONG_CRYPTO"",
                     sizeof(""USE_STRONG_CRYPTO"") - 1) ||
            !strncmp(startCur, ""SCH_USE_STRONG_CRYPTO"",
                     sizeof(""SCH_USE_STRONG_CRYPTO"") - 1))
      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;
    else
      return CURLE_SSL_CIPHER;
    startCur = strchr(startCur, ':');
    if(startCur)
      startCur++;
  }
  schannel_cred->palgSupportedAlgs = algIds;
  schannel_cred->cSupportedAlgs = algCount;
  return CURLE_OK;
}",1
Detect whether the following code contains vulnerabilities.,"PJ_DEF(pj_status_t) pj_ssl_sock_set_user_data(pj_ssl_sock_t *ssock,
					      void *user_data)
{
    PJ_ASSERT_RETURN(ssock, PJ_EINVAL);

    ssock->param.user_data = user_data;
    return PJ_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"void bdrv_setup_io_funcs(BlockDriver *bdrv)

{

    /* Block drivers without coroutine functions need emulation */

    if (!bdrv->bdrv_co_readv) {

        bdrv->bdrv_co_readv = bdrv_co_readv_em;

        bdrv->bdrv_co_writev = bdrv_co_writev_em;



        /* bdrv_co_readv_em()/brdv_co_writev_em() work in terms of aio, so if

         * the block driver lacks aio we need to emulate that too.

         */

        if (!bdrv->bdrv_aio_readv) {

            /* add AIO emulation layer */

            bdrv->bdrv_aio_readv = bdrv_aio_readv_em;

            bdrv->bdrv_aio_writev = bdrv_aio_writev_em;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int pl061_init(SysBusDevice *dev, const unsigned char *id)

{

    int iomemtype;

    pl061_state *s = FROM_SYSBUS(pl061_state, dev);

    s->id = id;

    iomemtype = cpu_register_io_memory(pl061_readfn,

                                       pl061_writefn, s,

                                       DEVICE_NATIVE_ENDIAN);

    sysbus_init_mmio(dev, 0x1000, iomemtype);

    sysbus_init_irq(dev, &s->irq);

    qdev_init_gpio_in(&dev->qdev, pl061_set_irq, 8);

    qdev_init_gpio_out(&dev->qdev, s->out, 8);

    pl061_reset(s);

    register_savevm(&dev->qdev, ""pl061_gpio"", -1, 1, pl061_save, pl061_load, s);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int usb_device_detach(USBDevice *dev)

{

    USBBus *bus = usb_bus_from_device(dev);

    USBPort *port;



    if (!dev->attached) {

        error_report(""Error: tried to detach unattached usb device %s\n"",

                dev->product_desc);

        return -1;

    }

    dev->attached--;



    QTAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev == dev)

            break;

    }

    assert(port != NULL);



    QTAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);



    QTAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"SRC_RemoveDumpFiles(void)
{
  char pattern[PATH_MAX], name[64], *dumpdir, *s;
  IPAddr ip_addr;
  glob_t gl;
  size_t i;

  dumpdir = CNF_GetDumpDir();
  if (dumpdir[0] == '\0' ||
      snprintf(pattern, sizeof (pattern), ""%s/*.dat"", dumpdir) >= sizeof (pattern))
    return;

  if (glob(pattern, 0, NULL, &gl))
    return;

  for (i = 0; i < gl.gl_pathc; i++) {
    s = strrchr(gl.gl_pathv[i], '/');
    if (!s || snprintf(name, sizeof (name), ""%s"", s + 1) >= sizeof (name))
      continue;

    /* Remove .dat extension */
    if (strlen(name) < 4)
      continue;
    name[strlen(name) - 4] = '\0';

    /* Check if it looks like name of an actual dump file */
    if (strncmp(name, ""refid:"", 6) && !UTI_StringToIP(name, &ip_addr))
      continue;

    DEBUG_LOG(""Removing %s"", gl.gl_pathv[i]);
    unlink(gl.gl_pathv[i]);
  }

  globfree(&gl);
}",1
Detect whether the following code contains vulnerabilities.,"set_bash_input ()
{
  /* Make sure the fd from which we are reading input is not in
     no-delay mode. */
#if defined (BUFFERED_INPUT)
  if (interactive == 0)
    sh_unset_nodelay_mode (default_buffered_input);
  else
#endif /* !BUFFERED_INPUT */
    sh_unset_nodelay_mode (fileno (stdin));

  /* with_input_from_stdin really means `with_input_from_readline' */
  if (interactive && no_line_editing == 0)
    with_input_from_stdin ();
#if defined (BUFFERED_INPUT)
  else if (interactive == 0)
    with_input_from_buffered_stream (default_buffered_input, dollar_vars[0]);
#endif /* BUFFERED_INPUT */
  else
    with_input_from_stream (default_input, dollar_vars[0]);
}",0
Detect whether the following code contains vulnerabilities.,"static void soutp(int offset, u8 value)
{
	if (iommap)
		/* the register is memory-mapped */
		offset <<= ioshift;

	outb(value, io + offset);
}",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(palToY)(uint8_t *dst, uint8_t *src, int width, uint32_t *pal)

{

	int i;

	for(i=0; i<width; i++)

	{

		int d= src[i];



		dst[i]= pal[d] & 0xFF;

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static bool bdrv_drain_recurse(BlockDriverState *bs)

{

    BdrvChild *child;

    bool waited;



    waited = bdrv_drain_poll(bs);



    if (bs->drv && bs->drv->bdrv_drain) {

        bs->drv->bdrv_drain(bs);

    }



    QLIST_FOREACH(child, &bs->children, next) {

        waited |= bdrv_drain_recurse(child->bs);

    }



    return waited;

}
",0
Detect whether the following code contains vulnerabilities.,"static int nvdec_vp9_end_frame(AVCodecContext *avctx)

{

    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;

    int ret = ff_nvdec_end_frame(avctx);

    ctx->bitstream = NULL;

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void stl_le_phys(target_phys_addr_t addr, uint32_t val)

{

    stl_phys_internal(addr, val, DEVICE_LITTLE_ENDIAN);

}
",0
Detect whether the following code contains vulnerabilities.,"static void __exit fw_ohci_cleanup(void)
{
	pci_unregister_driver(&fw_ohci_pci_driver);
}",0
Detect whether the following code contains vulnerabilities.,"static void qemu_rbd_aio_event_reader(void *opaque)

{

    BDRVRBDState *s = opaque;



    ssize_t ret;



    do {

        char *p = (char *)&s->event_rcb;



        /* now read the rcb pointer that was sent from a non qemu thread */

        ret = read(s->fds[RBD_FD_READ], p + s->event_reader_pos,

                   sizeof(s->event_rcb) - s->event_reader_pos);

        if (ret > 0) {

            s->event_reader_pos += ret;

            if (s->event_reader_pos == sizeof(s->event_rcb)) {

                s->event_reader_pos = 0;

                qemu_rbd_complete_aio(s->event_rcb);

            }

        }

    } while (ret < 0 && errno == EINTR);

}
",1
Detect whether the following code contains vulnerabilities.,"snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)
{
	struct seq_oss_synth *rec;

	if (dp->synths[dev].is_midi) {
		struct midi_info minf;
		snd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);
		inf->synth_type = SYNTH_TYPE_MIDI;
		inf->synth_subtype = 0;
		inf->nr_voices = 16;
		inf->device = dev;
		strlcpy(inf->name, minf.name, sizeof(inf->name));
	} else {
		if ((rec = get_synthdev(dp, dev)) == NULL)
			return -ENXIO;
		inf->synth_type = rec->synth_type;
		inf->synth_subtype = rec->synth_subtype;
		inf->nr_voices = rec->nr_voices;
		inf->device = dev;
		strlcpy(inf->name, rec->name, sizeof(inf->name));
		snd_use_lock_free(&rec->use_lock);
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static av_cold int targa_encode_init(AVCodecContext *avctx)

{

    avctx->coded_frame = av_frame_alloc();

    if (!avctx->coded_frame)

        return AVERROR(ENOMEM);



    avctx->coded_frame->key_frame = 1;

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static __init int setup_numa_zonelist_order(char *s)
{
	if (!s)
		return 0;

	return __parse_numa_zonelist_order(s);
}",0
Detect whether the following code contains vulnerabilities.,"AUXBus *aux_init_bus(DeviceState *parent, const char *name)

{

    AUXBus *bus;



    bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));

    bus->bridge = AUXTOI2C(qdev_create(BUS(bus), TYPE_AUXTOI2C));



    /* Memory related. */

    bus->aux_io = g_malloc(sizeof(*bus->aux_io));

    memory_region_init(bus->aux_io, OBJECT(bus), ""aux-io"", (1 << 20));

    address_space_init(&bus->aux_addr_space, bus->aux_io, ""aux-io"");

    return bus;

}
",1
Detect whether the following code contains vulnerabilities.,"static int bus_manager_append_tainted(Manager *m, DBusMessageIter *i, const char *property, void *data) {
        const char *t;
        char buf[64] = """", *e = buf, *p = NULL;

        assert(m);
        assert(i);
        assert(property);

        if (path_is_mount_point(""/usr"") > 0 || dir_is_empty(""/usr"") > 0)
                e = stpcpy(e, ""usr-separate-fs"");

        if (readlink_malloc(""/etc/mtab"", &p) < 0) {
                if (e != buf)
                        e = stpcpy(e, "" "");
                e = stpcpy(e, ""etc-mtab-not-symlink"");
        } else
                free(p);

        t = buf;

        if (!dbus_message_iter_append_basic(i, DBUS_TYPE_STRING, &t))
                return -ENOMEM;

        return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void monitor_control_event(void *opaque, int event)

{

    if (event == CHR_EVENT_OPENED) {

        QObject *data;

        Monitor *mon = opaque;



        mon->mc->command_mode = 0;

        json_message_parser_init(&mon->mc->parser, handle_qmp_command);



        data = get_qmp_greeting();

        monitor_json_emitter(mon, data);

        qobject_decref(data);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static QObject *parser_context_pop_token(JSONParserContext *ctxt)

{

    qobject_decref(ctxt->current);

    assert(!g_queue_is_empty(ctxt->buf));

    ctxt->current = g_queue_pop_head(ctxt->buf);

    return ctxt->current;

}
",0
Detect whether the following code contains vulnerabilities.,"static char *sieve_srs_forward(char *return_path __attribute__((unused)))
{
    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static void qmp_input_type_any(Visitor *v, const char *name, QObject **obj,

                               Error **errp)

{

    QmpInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qmp_input_get_object(qiv, name, true, errp);



    *obj = NULL;

    if (!qobj) {

        return;

    }



    qobject_incref(qobj);

    *obj = qobj;

}
",0
Detect whether the following code contains vulnerabilities.,"void parse_options(void *optctx, int argc, char **argv, const OptionDef *options,

                   void (*parse_arg_function)(void *, const char*))

{

    const char *opt;

    int optindex, handleoptions = 1, ret;



    /* perform system-dependent conversions for arguments list */

    prepare_app_arguments(&argc, &argv);



    /* parse options */

    optindex = 1;

    while (optindex < argc) {

        opt = argv[optindex++];



        if (handleoptions && opt[0] == '-' && opt[1] != '\0') {

            if (opt[1] == '-' && opt[2] == '\0') {

                handleoptions = 0;

                continue;

            }

            opt++;



            if ((ret = parse_option(optctx, opt, argv[optindex], options)) < 0)

                exit(1);

            optindex += ret;

        } else {

            if (parse_arg_function)

                parse_arg_function(optctx, opt);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"nautilus_file_mark_desktop_file_trusted (GFile              *file,
                                         GtkWindow          *parent_window,
                                         gboolean            interactive,
                                         NautilusOpCallback  done_callback,
                                         gpointer            done_callback_data)
{
    GTask *task;
    MarkTrustedJob *job;

    job = op_job_new (MarkTrustedJob, parent_window);
    job->file = g_object_ref (file);
    job->interactive = interactive;
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;

    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, mark_trusted_task_thread_func);
    g_object_unref (task);
}",1
Detect whether the following code contains vulnerabilities.,"on_reauthentication_cancelled (GdmSession *session,
                               GdmManager *self)
{
        g_debug (""GdmManager: client cancelled reauthentication request"");
        close_transient_session (self, session);
}",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_synth_fstat(FsContext *fs_ctx, int fid_type,

                            V9fsFidOpenState *fs, struct stat *stbuf)

{

    V9fsSynthOpenState *synth_open = fs->private;

    v9fs_synth_fill_statbuf(synth_open->node, stbuf);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int bdrv_qed_is_allocated(BlockDriverState *bs, int64_t sector_num,

                                  int nb_sectors, int *pnum)

{

    BDRVQEDState *s = bs->opaque;

    uint64_t pos = (uint64_t)sector_num * BDRV_SECTOR_SIZE;

    size_t len = (size_t)nb_sectors * BDRV_SECTOR_SIZE;

    QEDIsAllocatedCB cb = {

        .is_allocated = -1,

        .pnum = pnum,

    };

    QEDRequest request = { .l2_table = NULL };



    async_context_push();



    qed_find_cluster(s, &request, pos, len, qed_is_allocated_cb, &cb);



    while (cb.is_allocated == -1) {

        qemu_aio_wait();

    }



    async_context_pop();



    qed_unref_l2_cache_entry(request.l2_table);



    return cb.is_allocated;

}
",0
Detect whether the following code contains vulnerabilities.,"static mz_bool mz_zip_writer_write_zeros(mz_zip_archive *pZip,
                                         mz_uint64 cur_file_ofs, mz_uint32 n) {
  char buf[4096];
  memset(buf, 0, MZ_MIN(sizeof(buf), n));
  while (n) {
    mz_uint32 s = MZ_MIN(sizeof(buf), n);
    if (pZip->m_pWrite(pZip->m_pIO_opaque, cur_file_ofs, buf, s) != s)
      return MZ_FALSE;
    cur_file_ofs += s;
    n -= s;
  }
  return MZ_TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"static void fts3SqlExec(
  int *pRC,                /* Result code */
  Fts3Table *p,            /* The FTS3 table */
  int eStmt,               /* Index of statement to evaluate */
  sqlite3_value **apVal    /* Parameters to bind */
){
  sqlite3_stmt *pStmt;
  int rc;
  if( *pRC ) return;
  rc = fts3SqlStmt(p, eStmt, &pStmt, apVal); 
  if( rc==SQLITE_OK ){
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
  }
  *pRC = rc;
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_load_fpr32h(TCGv_i32 t, int reg)

{

    TCGv_i64 t64 = tcg_temp_new_i64();

    tcg_gen_shri_i64(t64, fpu_f64[reg], 32);

    tcg_gen_trunc_i64_i32(t, t64);

    tcg_temp_free_i64(t64);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void* array_get_next(array_t* array) {

    unsigned int next = array->next;

    void* result;



    if (array_ensure_allocated(array, next) < 0)

	return NULL;



    array->next = next + 1;

    result = array_get(array, next);



    return result;

}
",0
Detect whether the following code contains vulnerabilities.,"R_API int r_socket_close_fd (RSocket *s) {
	return -1;
}",0
Detect whether the following code contains vulnerabilities.,"static void rtce_init(VIOsPAPRDevice *dev)

{

    size_t size = (dev->rtce_window_size >> SPAPR_VIO_TCE_PAGE_SHIFT)

        * sizeof(VIOsPAPR_RTCE);



    if (size) {

        dev->rtce_table = kvmppc_create_spapr_tce(dev->reg,

                                                  dev->rtce_window_size,

                                                  &dev->kvmtce_fd);



        if (!dev->rtce_table) {

            dev->rtce_table = g_malloc0(size);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"evbuffer_lock(struct evbuffer *buf)
{
	EVBUFFER_LOCK(buf);
}",0
Detect whether the following code contains vulnerabilities.,"static void async_free(AsyncURB *aurb)
{
    qemu_free(aurb);
}",0
Detect whether the following code contains vulnerabilities.,"int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
	error = cxgb3_ofld_send(tdev, skb);
	if (error < 0)
		kfree_skb(skb);
	return error < 0 ? error : 0;
}",0
Detect whether the following code contains vulnerabilities.,"int64_t bdrv_nb_sectors(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;



    if (drv->has_variable_length) {

        int ret = refresh_total_sectors(bs, bs->total_sectors);

        if (ret < 0) {

            return ret;

        }

    }

    return bs->total_sectors;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t intel_hda_mmio_readw(void *opaque, target_phys_addr_t addr)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    return intel_hda_reg_read(d, reg, 0xffff);

}
",0
Detect whether the following code contains vulnerabilities.,"void wrapper_libxsmm_spmdm_compute_generic_thread(
    empty_type_wrapper<float>, const libxsmm_spmdm_handle* handle, char transA,
    char transB, const float* alpha, libxsmm_CSR_sparseslice* A_sparse,
    const float* B, char transC, const float* beta, float* C, int block_id,
    int tid, int nthreads) {
  return libxsmm_spmdm_compute_fp32_thread(handle, transA, transB, alpha,
                                           A_sparse, B, transC, beta, C,
                                           block_id, tid, nthreads);
}",0
Detect whether the following code contains vulnerabilities.,"static void rtc_get_date(Object *obj, Visitor *v, void *opaque,

                         const char *name, Error **errp)

{

    Error *err = NULL;

    RTCState *s = MC146818_RTC(obj);

    struct tm current_tm;



    rtc_update_time(s);

    rtc_get_time(s, &current_tm);

    visit_start_struct(v, NULL, ""struct tm"", name, 0, &err);

    if (err) {

        goto out;

    }

    visit_type_int32(v, &current_tm.tm_year, ""tm_year"", &err);

    visit_type_int32(v, &current_tm.tm_mon, ""tm_mon"", &err);

    visit_type_int32(v, &current_tm.tm_mday, ""tm_mday"", &err);

    visit_type_int32(v, &current_tm.tm_hour, ""tm_hour"", &err);

    visit_type_int32(v, &current_tm.tm_min, ""tm_min"", &err);

    visit_type_int32(v, &current_tm.tm_sec, ""tm_sec"", &err);

    visit_end_struct(v, &err);



out:

    error_propagate(errp, err);

}
",1
Detect whether the following code contains vulnerabilities.,"static void nbd_coroutine_start(NbdClientSession *s,

   struct nbd_request *request)

{

    /* Poor man semaphore.  The free_sema is locked when no other request

     * can be accepted, and unlocked after receiving one reply.  */

    if (s->in_flight >= MAX_NBD_REQUESTS - 1) {

        qemu_co_mutex_lock(&s->free_sema);

        assert(s->in_flight < MAX_NBD_REQUESTS);

    }

    s->in_flight++;



    /* s->recv_coroutine[i] is set as soon as we get the send_lock.  */

}
",1
Detect whether the following code contains vulnerabilities.,"static void piix3_reset(void *opaque)
{
    PCIIDEState *d = opaque;
    PCIDevice *pd = PCI_DEVICE(d);
    uint8_t *pci_conf = pd->config;
    int i;

    for (i = 0; i < 2; i++) {
        ide_bus_reset(&d->bus[i]);
    }

    /* TODO: this is the default. do not override. */
    pci_conf[PCI_COMMAND] = 0x00;
    /* TODO: this is the default. do not override. */
    pci_conf[PCI_COMMAND + 1] = 0x00;
    /* TODO: use pci_set_word */
    pci_conf[PCI_STATUS] = PCI_STATUS_FAST_BACK;
    pci_conf[PCI_STATUS + 1] = PCI_STATUS_DEVSEL_MEDIUM >> 8;
    pci_conf[0x20] = 0x01; /* BMIBA: 20-23h */
}",0
Detect whether the following code contains vulnerabilities.,"static int virtio_balloon_init_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);

    VirtIODevice *vdev;



    vdev = virtio_balloon_init(&pci_dev->qdev);




    virtio_init_pci(proxy, vdev);

    return 0;
",1
Detect whether the following code contains vulnerabilities.,"static uint8_t qpci_pc_config_readb(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inb(0xcfc);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int btrfs_lookup_and_bind_dio_csum(struct btrfs_root *root,
						 struct inode *inode,
						 struct btrfs_dio_private *dip,
						 struct bio *bio,
						 u64 file_offset)
{
	struct btrfs_io_bio *io_bio = btrfs_io_bio(bio);
	struct btrfs_io_bio *orig_io_bio = btrfs_io_bio(dip->orig_bio);
	int ret;

	/*
	 * We load all the csum data we need when we submit
	 * the first bio to reduce the csum tree search and
	 * contention.
	 */
	if (dip->logical_offset == file_offset) {
		ret = btrfs_lookup_bio_sums_dio(root, inode, dip->orig_bio,
						file_offset);
		if (ret)
			return ret;
	}

	if (bio == dip->orig_bio)
		return 0;

	file_offset -= dip->logical_offset;
	file_offset >>= inode->i_sb->s_blocksize_bits;
	io_bio->csum = (u8 *)(((u32 *)orig_io_bio->csum) + file_offset);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)
{
  MYSQL_RES *result;
  MYSQL_DATA *query;
  char buff[255];
  int length= 0;

  LINT_INIT(query);

  length= snprintf(buff, 128, ""%s%c%s"", table, '\0', wild ? wild : """");

  if (ma_simple_command(mysql, COM_FIELD_LIST,buff,length,1,0) ||
      !(query = mysql->methods->db_read_rows(mysql,(MYSQL_FIELD*) 0,8)))
    return(NULL);

  free_old_query(mysql);
  if (!(result = (MYSQL_RES *) calloc(1, sizeof(MYSQL_RES))))
  {
    free_rows(query);
    return(NULL);
  }
  result->field_alloc=mysql->field_alloc;
  mysql->fields=0;
  result->field_count = (uint) query->rows;
  result->fields= unpack_fields(query,&result->field_alloc,
				result->field_count,1,
				(my_bool) test(mysql->server_capabilities &
					       CLIENT_LONG_FLAG));
  result->eof=1;
  return(result);
}",1
Detect whether the following code contains vulnerabilities.,"static void fw_cfg_write(FWCfgState *s, uint8_t value)

{

    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);

    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];



    FW_CFG_DPRINTF(""write %d\n"", value);



    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) {

        e->data[s->cur_offset++] = value;

        if (s->cur_offset == e->len) {

            e->callback(e->callback_opaque, e->data);

            s->cur_offset = 0;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"xmlLastElementChild(xmlNodePtr parent) {
    xmlNodePtr cur = NULL;

    if (parent == NULL)
        return(NULL);
    switch (parent->type) {
        case XML_ELEMENT_NODE:
        case XML_ENTITY_NODE:
        case XML_DOCUMENT_NODE:
        case XML_DOCUMENT_FRAG_NODE:
        case XML_HTML_DOCUMENT_NODE:
            cur = parent->last;
            break;
        default:
            return(NULL);
    }
    while (cur != NULL) {
        if (cur->type == XML_ELEMENT_NODE)
            return(cur);
        cur = cur->prev;
    }
    return(NULL);
}",0
Detect whether the following code contains vulnerabilities.,"static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, const ASN1_IA5STRING *email)
{
    char *emtmp;
    /* First some sanity checks */
    if (email->type != V_ASN1_IA5STRING)
        return 1;
    if (!email->data || !email->length)
        return 1;
    if (*sk == NULL)
        *sk = sk_OPENSSL_STRING_new(sk_strcmp);
    if (*sk == NULL)
        return 0;
    /* Don't add duplicates */
    if (sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1)
        return 1;
    emtmp = OPENSSL_strdup((char *)email->data);
    if (emtmp == NULL || !sk_OPENSSL_STRING_push(*sk, emtmp)) {
        OPENSSL_free(emtmp);    /* free on push failure */
        X509_email_free(*sk);
        *sk = NULL;
        return 0;
    }
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"void ConnectionImpl::StreamImpl::encodeData(Buffer::Instance& data, bool end_stream) {
  ASSERT(!local_end_stream_);
  local_end_stream_ = end_stream;
  pending_send_data_.move(data);
  if (data_deferred_) {
    int rc = nghttp2_session_resume_data(parent_.session_, stream_id_);
    ASSERT(rc == 0);

    data_deferred_ = false;
  }

  parent_.sendPendingFrames();
}",1
Detect whether the following code contains vulnerabilities.,"void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)
{
	UINT index = 0;

	if (formatList == NULL)
		return;

	if (formatList->formats)
	{
		for (index = 0; index < formatList->numFormats; index++)
		{
			free(formatList->formats[index].formatName);
		}

		free(formatList->formats);
	}
}",1
Detect whether the following code contains vulnerabilities.,"int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,
			int len)
{
	int r;
	unsigned long addr;

	addr = gfn_to_hva(kvm, gfn);
	if (kvm_is_error_hva(addr))
		return -EFAULT;
	r = __copy_from_user(data, (void __user *)addr + offset, len);
	if (r)
		return -EFAULT;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
{
	return do_pipe2(fildes, flags);
}",0
Detect whether the following code contains vulnerabilities.,"static void MSLWarning(void *context,const char *format,...)
{
  char
    *message,
    reason[MagickPathExtent];

  MSLInfo
    *msl_info;

  va_list
    operands;

  /**
    Display and format a warning messages, gives file, line, position and
    extra parameters.
  */
  va_start(operands,format);
  (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  SAX.warning: "");
  (void) LogMagickEvent(CoderEvent,GetMagickModule(),format,operands);
  msl_info=(MSLInfo *) context;
  (void) msl_info;
#if !defined(MAGICKCORE_HAVE_VSNPRINTF)
  (void) vsprintf(reason,format,operands);
#else
  (void) vsnprintf(reason,MagickPathExtent,format,operands);
#endif
  message=GetExceptionMessage(errno);
  ThrowMSLException(CoderError,reason,message);
  message=DestroyString(message);
  va_end(operands);
}",0
Detect whether the following code contains vulnerabilities.,"zzip_mem_disk_entry_strdup_name(ZZIP_MEM_DISK* dir, 
                                ZZIP_DISK_ENTRY* entry) {
    return zzip_disk_entry_strdup_name(dir->disk, entry); }",1
Detect whether the following code contains vulnerabilities.,"/* {{{ proto bool pspell_config_repl(int conf, string repl)
   Use a personal dictionary with replacement pairs for this config */
static PHP_FUNCTION(pspell_config_repl)
{
	int type;
	long conf;
	char *repl;
	int repl_len;
	PspellConfig *config;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &repl, &repl_len) == FAILURE) {
		return;
	}

	PSPELL_FETCH_CONFIG;

	pspell_config_replace(config, ""save-repl"", ""true"");

	if (PG(safe_mode) && (!php_checkuid(repl, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(repl TSRMLS_CC)) {
		RETURN_FALSE;
	}

	pspell_config_replace(config, ""repl"", repl);
",1
Detect whether the following code contains vulnerabilities.,"int fit_image_get_comp(const void *fit, int noffset, uint8_t *comp)
{
	int len;
	const void *data;

	/* Get compression name from property data */
	data = fdt_getprop(fit, noffset, FIT_COMP_PROP, &len);
	if (data == NULL) {
		fit_get_debug(fit, noffset, FIT_COMP_PROP, len);
		*comp = -1;
		return -1;
	}

	/* Translate compression name to id */
	*comp = genimg_get_comp_id(data);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"  std::string index(SHalfedge_iterator e) const
  { return SEI(e,verbose); }",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_extradata(MOVContext *c, ByteIOContext *pb, MOVAtom atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];

    uint64_t size= (uint64_t)st->codec->extradata_size + atom.size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;

    uint8_t *buf;

    if(size > INT_MAX || (uint64_t)atom.size > INT_MAX)

        return -1;

    buf= av_realloc(st->codec->extradata, size);

    if(!buf)

        return -1;

    st->codec->extradata= buf;

    buf+= st->codec->extradata_size;

    st->codec->extradata_size= size - FF_INPUT_BUFFER_PADDING_SIZE;

    AV_WB32(       buf    , atom.size + 8);

    AV_WL32(       buf + 4, atom.type);

    get_buffer(pb, buf + 8, atom.size);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pci_init_bus_master(PCIDevice *pci_dev)

{

    AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);



    memory_region_init_alias(&pci_dev->bus_master_enable_region,

                             OBJECT(pci_dev), ""bus master"",

                             dma_as->root, 0, memory_region_size(dma_as->root));

    memory_region_set_enabled(&pci_dev->bus_master_enable_region, false);

    address_space_init(&pci_dev->bus_master_as,

                       &pci_dev->bus_master_enable_region, pci_dev->name);

}
",0
Detect whether the following code contains vulnerabilities.,"static const char *lftp_ssl_find_ca_file()
{
   // a few possible locations of ca-bundle.crt
   static const char *const ca_file_location[]={
      ""/etc/pki/tls/certs/ca-bundle.crt"",
      ""/etc/certs/ca-bundle.crt"",
      ""/usr/share/ssl/certs/ca-bundle.crt"",
      ""/etc/ssl/certs/ca-certificates.crt"",
      ""/usr/local/ssl/certs/ca-bundle.crt"",
      ""/etc/apache/ssl.crt/ca-bundle.crt"",
      ""/usr/share/curl/curl-ca-bundle.crt"",
      0};
   for(int i=0; ca_file_location[i]; i++)
   {
      if(access(ca_file_location[i], R_OK)==0)
	 return ca_file_location[i];
   }
   return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void av_cold ff_ivi_free_buffers(IVIPlaneDesc *planes)

{

    int p, b, t;



    for (p = 0; p < 3; p++) {

        for (b = 0; b < planes[p].num_bands; b++) {

            av_freep(&planes[p].bands[b].bufs[0]);

            av_freep(&planes[p].bands[b].bufs[1]);

            av_freep(&planes[p].bands[b].bufs[2]);





            for (t = 0; t < planes[p].bands[b].num_tiles; t++)

                av_freep(&planes[p].bands[b].tiles[t].mbs);

            av_freep(&planes[p].bands[b].tiles);

        }

        av_freep(&planes[p].bands);

    }

}",1
Detect whether the following code contains vulnerabilities.,"ldns_str2rdf_long_str(ldns_rdf **rd, const char *str)
{
	uint8_t *data, *dp, ch = 0;
	size_t length;

	/* Worst case space requirement. We'll realloc to actual size later. */
	dp = data = LDNS_XMALLOC(uint8_t, strlen(str));
        if (! data) {
		return LDNS_STATUS_MEM_ERR;
	}

	/* Fill data with parsed bytes */
	while (parse_char(&ch, &str)) {
		*dp++ = ch;
		if (dp - data > LDNS_MAX_RDFLEN) {
			LDNS_FREE(data);
			return LDNS_STATUS_INVALID_STR;
		}
	}
	if (! str) {
		return LDNS_STATUS_SYNTAX_BAD_ESCAPE;
	}
	length = (size_t)(dp - data);

	/* Lose the overmeasure */
	data = LDNS_XREALLOC(dp = data, uint8_t, length);
	if (! data) {
		LDNS_FREE(dp);
		return LDNS_STATUS_MEM_ERR;
	}

	/* Create rdf */
	*rd = ldns_rdf_new(LDNS_RDF_TYPE_LONG_STR, length, data);
	if (! *rd) {
		LDNS_FREE(data);
		return LDNS_STATUS_MEM_ERR;
	}
	return LDNS_STATUS_OK;
}",1
Detect whether the following code contains vulnerabilities.,"void CLASS rollei_load_raw()
{
  uchar pixel[10];
  unsigned iten=0, isix, i, buffer=0, todo[16];

  isix = raw_width * raw_height * 5 / 8;
  while (fread (pixel, 1, 10, ifp) == 10) {
#ifdef LIBRAW_LIBRARY_BUILD
    checkCancel();
#endif
    for (i=0; i < 10; i+=2) {
      todo[i]   = iten++;
      todo[i+1] = pixel[i] << 8 | pixel[i+1];
      buffer    = pixel[i] >> 2 | buffer << 6;
    }
    for (   ; i < 16; i+=2) {
      todo[i]   = isix++;
      todo[i+1] = buffer >> (14-i)*5;
    }
    for (i=0; i < 16; i+=2)
      raw_image[todo[i]] = (todo[i+1] & 0x3ff);
  }
  maximum = 0x3ff;
}",1
Detect whether the following code contains vulnerabilities.,"static X509_STORE *init_revocation_store(fr_tls_server_conf_t *conf)
{
	X509_STORE *store = NULL;

	store = X509_STORE_new();

	/* Load the CAs we trust */
	if (conf->ca_file || conf->ca_path)
		if(!X509_STORE_load_locations(store, conf->ca_file, conf->ca_path)) {
			ERROR(LOG_PREFIX "": X509_STORE error %s"", ERR_error_string(ERR_get_error(), NULL));
			ERROR(LOG_PREFIX "": Error reading Trusted root CA list %s"",conf->ca_file );
			return NULL;
		}

#ifdef X509_V_FLAG_CRL_CHECK
	if (conf->check_crl)
		X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK);
#endif
	return store;
}",1
Detect whether the following code contains vulnerabilities.,"rsvg_new_filter_primitive_gaussian_blur (void)
{
    RsvgFilterPrimitiveGaussianBlur *filter;
    filter = g_new (RsvgFilterPrimitiveGaussianBlur, 1);
    _rsvg_node_init (&filter->super.super);
    filter->super.in = g_string_new (""none"");
    filter->super.result = g_string_new (""none"");
    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
        filter->super.height.factor = 'n';
    filter->sdx = 0;
    filter->sdy = 0;
    filter->super.render = &rsvg_filter_primitive_gaussian_blur_render;
    filter->super.super.free = &rsvg_filter_primitive_gaussian_blur_free;
    filter->super.super.set_atts = rsvg_filter_primitive_gaussian_blur_set_atts;
    return (RsvgNode *) filter;
}",1
Detect whether the following code contains vulnerabilities.,"selinux_determine_inode_label(const struct task_security_struct *tsec,
				 struct inode *dir,
				 const struct qstr *name, u16 tclass,
				 u32 *_new_isid)
{
	const struct superblock_security_struct *sbsec = dir->i_sb->s_security;

	if ((sbsec->flags & SE_SBINITIALIZED) &&
	    (sbsec->behavior == SECURITY_FS_USE_MNTPOINT)) {
		*_new_isid = sbsec->mntpoint_sid;
	} else if ((sbsec->flags & SBLABEL_MNT) &&
		   tsec->create_sid) {
		*_new_isid = tsec->create_sid;
	} else {
		const struct inode_security_struct *dsec = inode_security(dir);
		return security_transition_sid(&selinux_state, tsec->sid,
					       dsec->sid, tclass,
					       name, _new_isid);
	}

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"int bdrv_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)

{

    BdrvIoctlCoData data = {

        .bs = bs,

        .req = req,

        .buf = buf,

        .ret = -EINPROGRESS,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_co_ioctl_entry(&data);

    } else {

        Coroutine *co = qemu_coroutine_create(bdrv_co_ioctl_entry);



        qemu_coroutine_enter(co, &data);

        while (data.ret == -EINPROGRESS) {

            aio_poll(bdrv_get_aio_context(bs), true);

        }

    }

    return data.ret;

}
",1
Detect whether the following code contains vulnerabilities.,"find_abbrev_list_by_abbrev_offset (dwarf_vma abbrev_base,
				   dwarf_vma abbrev_offset)
{
  abbrev_list * list;

  for (list = abbrev_lists; list != NULL; list = list->next)
    if (list->abbrev_base == abbrev_base
	&& list->abbrev_offset == abbrev_offset)
      return list;

  return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static void virtio_net_vmstate_change(void *opaque, int running, int reason)

{

    VirtIONet *n = opaque;

    if (!running) {

        return;

    }

    /* This is called when vm is started, it will start vhost backend if

     * appropriate e.g. after migration. */

    virtio_net_set_status(&n->vdev, n->vdev.status);

}
",0
Detect whether the following code contains vulnerabilities.,"static int lua_ap_some_auth_required(request_rec *r)
{
    return ap_some_auth_required(r);
}",0
Detect whether the following code contains vulnerabilities.,"static void do_acl_show(Monitor *mon, const QDict *qdict)

{

    const char *aclname = qdict_get_str(qdict, ""aclname"");

    qemu_acl *acl = find_acl(mon, aclname);

    qemu_acl_entry *entry;

    int i = 0;



    if (acl) {

        monitor_printf(mon, ""policy: %s\n"",

                       acl->defaultDeny ? ""deny"" : ""allow"");

        TAILQ_FOREACH(entry, &acl->entries, next) {

            i++;

            monitor_printf(mon, ""%d: %s %s\n"", i,

                           entry->deny ? ""deny"" : ""allow"", entry->match);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"vte_sequence_handler_offset(VteTerminal *terminal,
			    GValueArray *params,
			    int increment,
			    VteTerminalSequenceHandler handler)
{
	guint i;
	long val;
	GValue *value;
	/* Decrement the parameters and let the _cs handler deal with it. */
	for (i = 0; (params != NULL) && (i < params->n_values); i++) {
		value = g_value_array_get_nth(params, i);
		if (G_VALUE_HOLDS_LONG(value)) {
			val = g_value_get_long(value);
			val += increment;
			g_value_set_long(value, val);
		}
	}
	handler (terminal, params);
}",0
Detect whether the following code contains vulnerabilities.,"int line6_send_raw_message_async(struct usb_line6 *line6, const char *buffer,
				 int size)
{
	struct message *msg;
	struct urb *urb;

	/* create message: */
	msg = kmalloc(sizeof(struct message), GFP_ATOMIC);
	if (msg == NULL)
		return -ENOMEM;

	/* create URB: */
	urb = usb_alloc_urb(0, GFP_ATOMIC);

	if (urb == NULL) {
		kfree(msg);
		return -ENOMEM;
	}

	/* set message data: */
	msg->line6 = line6;
	msg->buffer = buffer;
	msg->size = size;
	msg->done = 0;

	/* start sending: */
	return line6_send_raw_message_async_part(msg, urb);
}",0
Detect whether the following code contains vulnerabilities.,"static NFSServer *nfs_config(QDict *options, Error **errp)

{

    NFSServer *server = NULL;

    QDict *addr = NULL;

    QObject *crumpled_addr = NULL;

    Visitor *iv = NULL;

    Error *local_error = NULL;



    qdict_extract_subqdict(options, &addr, ""server."");

    if (!qdict_size(addr)) {

        error_setg(errp, ""NFS server address missing"");

        goto out;

    }



    crumpled_addr = qdict_crumple(addr, errp);

    if (!crumpled_addr) {

        goto out;

    }










    iv = qobject_input_visitor_new(crumpled_addr);

    visit_type_NFSServer(iv, NULL, &server, &local_error);

    if (local_error) {

        error_propagate(errp, local_error);

        goto out;

    }



out:

    QDECREF(addr);

    qobject_decref(crumpled_addr);

    visit_free(iv);

    return server;

}",1
Detect whether the following code contains vulnerabilities.,"static void guest_fsfreeze_cleanup(void)

{

    int64_t ret;

    Error *err = NULL;



    if (ga_is_frozen(ga_state) == GUEST_FSFREEZE_STATUS_FROZEN) {

        ret = qmp_guest_fsfreeze_thaw(&err);

        if (ret < 0 || err) {

            slog(""failed to clean up frozen filesystems"");

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"bool qemu_savevm_state_blocked(Monitor *mon)

{

    SaveStateEntry *se;



    QTAILQ_FOREACH(se, &savevm_handlers, entry) {

        if (se->no_migrate) {

            monitor_printf(mon, ""state blocked by non-migratable device '%s'\n"",

                           se->idstr);

            return true;

        }

    }

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_clock_enable(QEMUClockType type, bool enabled)

{

    QEMUClock *clock = qemu_clock_ptr(type);

    QEMUTimerList *tl;

    bool old = clock->enabled;

    clock->enabled = enabled;

    if (enabled && !old) {

        qemu_clock_notify(type);

    } else if (!enabled && old) {

        QLIST_FOREACH(tl, &clock->timerlists, list) {

            qemu_event_wait(&tl->timers_done_ev);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int qcrypto_hash_bytesv(QCryptoHashAlgorithm alg,

                        const struct iovec *iov,

                        size_t niov,

                        uint8_t **result,

                        size_t *resultlen,

                        Error **errp)

{

#ifdef CONFIG_AF_ALG

    int ret;



    ret = qcrypto_hash_afalg_driver.hash_bytesv(alg, iov, niov,

                                                result, resultlen,

                                                errp);

    if (ret == 0) {

        return ret;

    }



    /*

     * TODO:

     * Maybe we should treat some afalg errors as fatal

     */

    error_free(*errp);

#endif



    return qcrypto_hash_lib_driver.hash_bytesv(alg, iov, niov,

                                               result, resultlen,

                                               errp);

}
",1
Detect whether the following code contains vulnerabilities.,"static void nl80211_send_mlme_timeout(struct cfg80211_registered_device *rdev,
				      struct net_device *netdev, int cmd,
				      const u8 *addr, gfp_t gfp)
{
	struct sk_buff *msg;
	void *hdr;

	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);
	if (!msg)
		return;

	hdr = nl80211hdr_put(msg, 0, 0, 0, cmd);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}

	if (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||
	    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||
	    nla_put_flag(msg, NL80211_ATTR_TIMED_OUT) ||
	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr))
		goto nla_put_failure;

	genlmsg_end(msg, hdr);

	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
				NL80211_MCGRP_MLME, gfp);
	return;

 nla_put_failure:
	nlmsg_free(msg);
}",0
Detect whether the following code contains vulnerabilities.,"float32 HELPER(ucf64_sf2si)(float32 x, CPUUniCore32State *env)

{

    return ucf64_itos(float32_to_int32(x, &env->ucf64.fp_status));

}
",0
Detect whether the following code contains vulnerabilities.,"glob_func_error(VALUE val)
{
    struct glob_error_args *arg = (struct glob_error_args *)val;
    VALUE path = rb_enc_str_new_cstr(arg->path, arg->enc);
    rb_syserr_fail_str(arg->error, path);
    return Qnil;
}",0
Detect whether the following code contains vulnerabilities.,"static void calc_thr_3gpp(const FFPsyWindowInfo *wi, const int num_bands, AacPsyChannel *pch,

                          const uint8_t *band_sizes, const float *coefs)

{

    int i, w, g;

    int start = 0;

    for (w = 0; w < wi->num_windows*16; w += 16) {

        for (g = 0; g < num_bands; g++) {

            AacPsyBand *band = &pch->band[w+g];



            float form_factor = 0.0f;

            float Temp;

            band->energy = 0.0f;

            for (i = 0; i < band_sizes[g]; i++) {

                band->energy += coefs[start+i] * coefs[start+i];

                form_factor  += sqrtf(fabs(coefs[start+i]));

            }

            Temp = band->energy > 0 ? sqrtf((float)band_sizes[g] / band->energy) : 0;

            band->thr      = band->energy * 0.001258925f;

            band->nz_lines = form_factor * sqrtf(Temp);



            start += band_sizes[g];

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void write_header(AVFormatContext *s)

{

    double min_buffer_time = 1.0;

    avio_printf(s->pb, ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"");

    avio_printf(s->pb, ""<MPD\n"");

    avio_printf(s->pb, ""  xmlns:xsi=\""http://www.w3.org/2001/XMLSchema-instance\""\n"");

    avio_printf(s->pb, ""  xmlns=\""urn:mpeg:DASH:schema:MPD:2011\""\n"");

    avio_printf(s->pb, ""  xsi:schemaLocation=\""urn:mpeg:DASH:schema:MPD:2011\""\n"");

    avio_printf(s->pb, ""  type=\""static\""\n"");

    avio_printf(s->pb, ""  mediaPresentationDuration=\""PT%gS\""\n"",

                get_duration(s));

    avio_printf(s->pb, ""  minBufferTime=\""PT%gS\""\n"",

                min_buffer_time);

    avio_printf(s->pb, ""  profiles=\""urn:webm:dash:profile:webm-on-demand:2012\"""");

    avio_printf(s->pb, "">\n"");

}
",1
Detect whether the following code contains vulnerabilities.,"void spapr_core_unplug_request(HotplugHandler *hotplug_dev, DeviceState *dev,

                               Error **errp)

{

    int index;

    sPAPRDRConnector *drc;

    sPAPRDRConnectorClass *drck;

    Error *local_err = NULL;

    CPUCore *cc = CPU_CORE(dev);

    int smt = kvmppc_smt_threads();



    if (!spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index)) {

        error_setg(errp, ""Unable to find CPU core with core-id: %d"",

                   cc->core_id);

        return;

    }

    if (index == 0) {

        error_setg(errp, ""Boot CPU core may not be unplugged"");

        return;

    }



    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index * smt);

    g_assert(drc);



    drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    drck->detach(drc, dev, spapr_core_release, NULL, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    spapr_hotplug_req_remove_by_index(drc);

}
",0
Detect whether the following code contains vulnerabilities.,"PackLinuxElf64::elf_find_dynamic(unsigned int key) const
{
    Elf64_Dyn const *dynp= dynseg;
    if (dynp)
    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg
            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {
        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));
        if (t) {
            return &((unsigned char const *)file_image)[(size_t)t];
        }
        break;
    }
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void rtas_ibm_read_pci_config(sPAPREnvironment *spapr,

                                     uint32_t token, uint32_t nargs,

                                     target_ulong args,

                                     uint32_t nret, target_ulong rets)

{

    uint64_t buid;

    uint32_t size, addr;



    if ((nargs != 4) || (nret != 2)) {

        rtas_st(rets, 0, -1);

        return;

    }



    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);

    size = rtas_ld(args, 3);

    addr = rtas_ld(args, 0);



    finish_read_pci_config(spapr, buid, addr, size, rets);

}
",0
Detect whether the following code contains vulnerabilities.,"static void GCC_FMT_ATTR(2, 3) qtest_sendf(CharBackend *chr,

                                           const char *fmt, ...)

{

    va_list ap;

    gchar *buffer;



    va_start(ap, fmt);

    buffer = g_strdup_vprintf(fmt, ap);

    qtest_send(chr, buffer);


    va_end(ap);

}",1
Detect whether the following code contains vulnerabilities.,"int sm2_plaintext_size(const EC_KEY *key, const EVP_MD *digest, size_t msg_len,
                       size_t *pt_size)
{
    const size_t field_size = ec_field_size(EC_KEY_get0_group(key));
    const int md_size = EVP_MD_size(digest);
    size_t overhead;

    if (md_size < 0) {
        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_DIGEST);
        return 0;
    }
    if (field_size == 0) {
        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_FIELD);
        return 0;
    }

    overhead = 10 + 2 * field_size + (size_t)md_size;
    if (msg_len <= overhead) {
        SM2err(SM2_F_SM2_PLAINTEXT_SIZE, SM2_R_INVALID_ENCODING);
        return 0;
    }

    *pt_size = msg_len - overhead;
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"static void parse_type_bool(Visitor *v, const char *name, bool *obj,

                            Error **errp)

{

    StringInputVisitor *siv = to_siv(v);



    if (siv->string) {

        if (!strcasecmp(siv->string, ""on"") ||

            !strcasecmp(siv->string, ""yes"") ||

            !strcasecmp(siv->string, ""true"")) {

            *obj = true;

            return;

        }

        if (!strcasecmp(siv->string, ""off"") ||

            !strcasecmp(siv->string, ""no"") ||

            !strcasecmp(siv->string, ""false"")) {

            *obj = false;

            return;

        }

    }



    error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

               ""boolean"");

}
",1
Detect whether the following code contains vulnerabilities.,"static void __io_cqring_fill_event(struct io_kiocb *req, long res, long cflags)
{
	struct io_ring_ctx *ctx = req->ctx;
	struct io_uring_cqe *cqe;

	trace_io_uring_complete(ctx, req->user_data, res);

	/*
	 * If we can't get a cq entry, userspace overflowed the
	 * submission (by quite a lot). Increment the overflow count in
	 * the ring.
	 */
	cqe = io_get_cqring(ctx);
	if (likely(cqe)) {
		WRITE_ONCE(cqe->user_data, req->user_data);
		WRITE_ONCE(cqe->res, res);
		WRITE_ONCE(cqe->flags, cflags);
	} else if (ctx->cq_overflow_flushed) {
		WRITE_ONCE(ctx->rings->cq_overflow,
				atomic_inc_return(&ctx->cached_cq_overflow));
	} else {
		if (list_empty(&ctx->cq_overflow_list)) {
			set_bit(0, &ctx->sq_check_overflow);
			set_bit(0, &ctx->cq_check_overflow);
			ctx->rings->sq_flags |= IORING_SQ_CQ_OVERFLOW;
		}
		io_clean_op(req);
		req->result = res;
		req->compl.cflags = cflags;
		refcount_inc(&req->refs);
		list_add_tail(&req->compl.list, &ctx->cq_overflow_list);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static inline void SetPixelIndex(const Image *magick_restrict image,
  const Quantum index,Quantum *magick_restrict pixel)
{
  if (image->channel_map[IndexPixelChannel].traits != UndefinedPixelTrait)
    pixel[image->channel_map[IndexPixelChannel].offset]=index;
}",0
Detect whether the following code contains vulnerabilities.,"static int decode_pulses(Pulse *pulse, GetBitContext *gb,
                         const uint16_t *swb_offset, int num_swb)
{
    int i, pulse_swb;
    pulse->num_pulse = get_bits(gb, 2) + 1;
    pulse_swb        = get_bits(gb, 6);
    if (pulse_swb >= num_swb)
        return -1;
    pulse->pos[0]    = swb_offset[pulse_swb];
    pulse->pos[0]   += get_bits(gb, 5);
    if (pulse->pos[0] > 1023)
        return -1;
    pulse->amp[0]    = get_bits(gb, 4);
    for (i = 1; i < pulse->num_pulse; i++) {
        pulse->pos[i] = get_bits(gb, 5) + pulse->pos[i - 1];
        if (pulse->pos[i] > 1023)
            return -1;
        pulse->amp[i] = get_bits(gb, 4);
    }
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int kvm_mmu_notifier_clear_flush_young(struct mmu_notifier *mn,
					      struct mm_struct *mm,
					      unsigned long start,
					      unsigned long end)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int young, idx;

	idx = srcu_read_lock(&kvm->srcu);
	spin_lock(&kvm->mmu_lock);

	young = kvm_age_hva(kvm, start, end);
	if (young)
		kvm_flush_remote_tlbs(kvm);

	spin_unlock(&kvm->mmu_lock);
	srcu_read_unlock(&kvm->srcu, idx);

	return young;
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t m5206_mbar_readl(void *opaque, target_phys_addr_t offset)

{

    m5206_mbar_state *s = (m5206_mbar_state *)opaque;

    int width;

    offset &= 0x3ff;

    if (offset >= 0x200) {

        hw_error(""Bad MBAR read offset 0x%x"", (int)offset);

    }

    width = m5206_mbar_width[offset >> 2];

    if (width < 4) {

        uint32_t val;

        val = m5206_mbar_readw(opaque, offset) << 16;

        val |= m5206_mbar_readw(opaque, offset + 2);

        return val;

    }

    return m5206_mbar_read(s, offset, 4);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcp_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    TCPCharDriver *s = chr->opaque;

    uint8_t buf[READ_BUF_LEN];

    int len, size;



    if (!s->connected || s->max_size <= 0)

        return;

    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    size = tcp_chr_recv(chr, (void *)buf, len);

    if (size == 0) {

        /* connection closed */

        s->connected = 0;

        if (s->listen_fd >= 0) {

            qemu_set_fd_handler(s->listen_fd, tcp_chr_accept, NULL, chr);

        }

        qemu_set_fd_handler(s->fd, NULL, NULL, NULL);

        closesocket(s->fd);

        s->fd = -1;

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

    } else if (size > 0) {

        if (s->do_telnetopt)

            tcp_chr_process_IAC_bytes(chr, s, buf, &size);

        if (size > 0)

            qemu_chr_read(chr, buf, size);

        if (s->msgfd != -1) {

            close(s->msgfd);

            s->msgfd = -1;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"  void allocHealthChecker(const std::string& yaml) {
    health_checker_ = std::make_shared<TestProdHttpHealthChecker>(
        *cluster_, parseHealthCheckFromV3Yaml(yaml), dispatcher_, runtime_, random_,
        HealthCheckEventLoggerPtr(event_logger_storage_.release()));
  }",0
Detect whether the following code contains vulnerabilities.,"bool CIRCSock::OnPartMessage(CPartMessage& Message) {
    const CNick& Nick = Message.GetNick();
    CString sChan = Message.GetTarget();

    CChan* pChan = m_pNetwork->FindChan(sChan);
    bool bDetached = false;
    if (pChan) {
        pChan->RemNick(Nick.GetNick());
        Message.SetChan(pChan);
        IRCSOCKMODULECALL(OnPartMessage(Message), NOTHING);

        if (pChan->IsDetached()) bDetached = true;
    }

    if (Nick.NickEquals(GetNick())) {
        m_pNetwork->DelChan(sChan);
    }

    /*
     * We use this boolean because
     * m_pNetwork->DelChan() will delete this channel
     * and thus we would dereference an
     * already-freed pointer!
     */
    return bDetached;
}",0
Detect whether the following code contains vulnerabilities.,"static bool _db_chain_lt(const struct db_arg_chain_tree *a,
			 const struct db_arg_chain_tree *b)
{
	return ((a->arg < b->arg) ||
		((a->arg == b->arg) &&
		 ((a->op < b->op) ||
		  ((a->op == b->op) &&
		   ((a->mask < b->mask) ||
		    ((a->mask == b->mask) &&
		     (a->datum < b->datum)))))));
}",1
Detect whether the following code contains vulnerabilities.,"static inline void set_store_user_dirty(struct kmem_cache *cachep)
{
	if (is_store_user_clean(cachep))
		atomic_set(&cachep->store_user_clean, 0);
}",0
Detect whether the following code contains vulnerabilities.,"int bdrv_writev_vmstate(BlockDriverState *bs, QEMUIOVector *qiov, int64_t pos)

{

    BlockDriver *drv = bs->drv;



    if (!drv) {

        return -ENOMEDIUM;

    } else if (drv->bdrv_save_vmstate) {

        return drv->bdrv_save_vmstate(bs, qiov, pos);

    } else if (bs->file) {

        return bdrv_writev_vmstate(bs->file, qiov, pos);

    }



    return -ENOTSUP;

}
",0
Detect whether the following code contains vulnerabilities.,"void blockdev_mark_auto_del(BlockDriverState *bs)

{

    BlockBackend *blk = bs->blk;

    DriveInfo *dinfo = blk_legacy_dinfo(blk);



    if (dinfo && !dinfo->enable_auto_del) {

        return;

    }



    if (bs->job) {

        block_job_cancel(bs->job);

    }

    if (dinfo) {

        dinfo->auto_del = 1;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int pci_unin_map_irq(PCIDevice *pci_dev, int irq_num)

{

    int retval;

    int devfn = pci_dev->devfn & 0x00FFFFFF;



    retval = (((devfn >> 11) & 0x1F) + irq_num) & 3;



    return retval;

}
",0
Detect whether the following code contains vulnerabilities.,"static void recovery_abort(void) {
    if (!dry_run) {
        storage_reset();
    }

    awaiting_character = false;
    memzero(mnemonic, sizeof(mnemonic));
    memzero(cipher, sizeof(cipher));
}",1
Detect whether the following code contains vulnerabilities.,"static struct omap_pwt_s *omap_pwt_init(MemoryRegion *system_memory,

                                        target_phys_addr_t base,

                                        omap_clk clk)

{

    struct omap_pwt_s *s = g_malloc0(sizeof(*s));

    s->clk = clk;

    omap_pwt_reset(s);



    memory_region_init_io(&s->iomem, &omap_pwt_ops, s,

                          ""omap-pwt"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);

    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"correct_table_matrix(struct table *t, int col, int cspan, int a, double b)
{
    int i, j;
    int ecol = col + cspan;
    double w = 1. / (b * b);

    for (i = col; i < ecol; i++) {
	v_add_val(t->vector, i, w * a);
	for (j = i; j < ecol; j++) {
	    m_add_val(t->matrix, i, j, w);
	    m_set_val(t->matrix, j, i, m_entry(t->matrix, i, j));
	}
    }
    return i;
}",0
Detect whether the following code contains vulnerabilities.,"static DeviceState *sun4c_intctl_init(target_phys_addr_t addr,

                                      qemu_irq *parent_irq)

{

    DeviceState *dev;

    SysBusDevice *s;

    unsigned int i;



    dev = qdev_create(NULL, ""sun4c_intctl"");

    qdev_init(dev);



    s = sysbus_from_qdev(dev);



    for (i = 0; i < MAX_PILS; i++) {

        sysbus_connect_irq(s, i, parent_irq[i]);

    }

    sysbus_mmio_map(s, 0, addr);



    return dev;

}
",1
Detect whether the following code contains vulnerabilities.,"     (CirrusVGAState *s,
      uint8_t *dst, int dst_pitch,
      int width, int height)
{
    uint8_t *d, *d1;
    uint32_t col;
    int x, y;

    col = s->cirrus_blt_fgcol;

    d1 = dst;
    for(y = 0; y < height; y++) {
        d = d1;
        for(x = 0; x < width; x += (DEPTH / 8)) {
            PUTPIXEL();
            d += (DEPTH / 8);
        }
        d1 += dst_pitch;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void branch(DBDMA_channel *ch)

{

    dbdma_cmd *current = &ch->current;



    ch->regs[DBDMA_CMDPTR_LO] = current->cmd_dep;

    ch->regs[DBDMA_STATUS] |= cpu_to_be32(BT);

    dbdma_cmdptr_load(ch);

}
",0
Detect whether the following code contains vulnerabilities.,"mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len,
                                     tdefl_put_buf_func_ptr pPut_buf_func,
                                     void *pPut_buf_user, int flags) {
  tdefl_compressor *pComp;
  mz_bool succeeded;
  if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;
  pComp = (tdefl_compressor *)MZ_MALLOC(sizeof(tdefl_compressor));
  if (!pComp) return MZ_FALSE;
  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) ==
               TDEFL_STATUS_OKAY);
  succeeded =
      succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) ==
                    TDEFL_STATUS_DONE);
  MZ_FREE(pComp);
  return succeeded;
}",0
Detect whether the following code contains vulnerabilities.,"GC_API GC_ATTR_MALLOC void * GC_CALL GC_malloc_explicitly_typed(size_t lb,
                                                                GC_descr d)
{
    word *op;
    size_t lg;

    GC_ASSERT(GC_explicit_typing_initialized);
    lb += TYPD_EXTRA_BYTES;
    op = GC_malloc_kind(lb, GC_explicit_kind);
    if (EXPECT(NULL == op, FALSE))
        return NULL;
    lg = SMALL_OBJ(lb) ? GC_size_map[lb] : BYTES_TO_GRANULES(GC_size(op));
    op[GRANULES_TO_WORDS(lg) - 1] = d;
    return op;
}",1
Detect whether the following code contains vulnerabilities.,"semantic_type_new (uniqstr tag, const location *loc)
{
  semantic_type *res = xmalloc (sizeof *res);

  uniqstr_assert (tag);
  res->tag = tag;
  res->location = loc ? *loc : empty_loc;
  res->status = undeclared;
  for (int i = 0; i < CODE_PROPS_SIZE; ++i)
    code_props_none_init (&res->props[i]);

  return res;
}",0
Detect whether the following code contains vulnerabilities.,"BOOL update_write_scrblt_order(wStream* s, ORDER_INFO* orderInfo, const SCRBLT_ORDER* scrblt)
{
	if (!Stream_EnsureRemainingCapacity(s, update_approximate_scrblt_order(orderInfo, scrblt)))
		return FALSE;

	orderInfo->fieldFlags = 0;
	orderInfo->fieldFlags |= ORDER_FIELD_01;
	update_write_coord(s, scrblt->nLeftRect);
	orderInfo->fieldFlags |= ORDER_FIELD_02;
	update_write_coord(s, scrblt->nTopRect);
	orderInfo->fieldFlags |= ORDER_FIELD_03;
	update_write_coord(s, scrblt->nWidth);
	orderInfo->fieldFlags |= ORDER_FIELD_04;
	update_write_coord(s, scrblt->nHeight);
	orderInfo->fieldFlags |= ORDER_FIELD_05;
	Stream_Write_UINT8(s, scrblt->bRop);
	orderInfo->fieldFlags |= ORDER_FIELD_06;
	update_write_coord(s, scrblt->nXSrc);
	orderInfo->fieldFlags |= ORDER_FIELD_07;
	update_write_coord(s, scrblt->nYSrc);
	return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"const AST *ast_iter(const AST *a, uint32_t n, uint32_t m)
{
    AST *ast = new AST(a->loc, AST::ITER);
    ast->iter.ast = a;
    ast->iter.min = n;
    ast->iter.max = m;
    return ast;
}",1
Detect whether the following code contains vulnerabilities.,"evbuffer_ptr_memcmp(const struct evbuffer *buf, const struct evbuffer_ptr *pos,
    const char *mem, size_t len)
{
	struct evbuffer_chain *chain;
	size_t position;
	int r;

	ASSERT_EVBUFFER_LOCKED(buf);

	if (pos->pos + len > buf->total_len)
		return -1;

	chain = pos->_internal.chain;
	position = pos->_internal.pos_in_chain;
	while (len && chain) {
		size_t n_comparable;
		if (len + position > chain->off)
			n_comparable = chain->off - position;
		else
			n_comparable = len;
		r = memcmp(chain->buffer + chain->misalign + position, mem,
		    n_comparable);
		if (r)
			return r;
		mem += n_comparable;
		len -= n_comparable;
		position = 0;
		chain = chain->next;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"ecEncCtx* wc_ecc_ctx_new_ex(int flags, WC_RNG* rng, void* heap)
{
    int       ret = 0;
    ecEncCtx* ctx = (ecEncCtx*)XMALLOC(sizeof(ecEncCtx), heap,
                                                              DYNAMIC_TYPE_ECC);

    if (ctx) {
        ctx->protocol = (byte)flags;
        ctx->heap     = heap;
    }

    ret = wc_ecc_ctx_reset(ctx, rng);
    if (ret != 0) {
        wc_ecc_ctx_free(ctx);
        ctx = NULL;
    }

    return ctx;
}",0
Detect whether the following code contains vulnerabilities.,"vmxnet3_dump_rx_descr(struct Vmxnet3_RxDesc *descr)

{

    VMW_PKPRN(""RX DESCR: addr %"" PRIx64 "", len: %d, gen: %d, rsvd: %d, ""

              ""dtype: %d, ext1: %d, btype: %d"",

              le64_to_cpu(descr->addr), descr->len, descr->gen,

              descr->rsvd, descr->dtype, descr->ext1, descr->btype);

}
",1
Detect whether the following code contains vulnerabilities.,"static void cris_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    CRISCPU *cpu = CRIS_CPU(obj);

    CRISCPUClass *ccc = CRIS_CPU_GET_CLASS(obj);

    CPUCRISState *env = &cpu->env;

    static bool tcg_initialized;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    env->pregs[PR_VR] = ccc->vr;



#ifndef CONFIG_USER_ONLY

    /* IRQ and NMI lines.  */

    qdev_init_gpio_in(DEVICE(cpu), cris_cpu_set_irq, 2);

#endif



    if (tcg_enabled() && !tcg_initialized) {

        tcg_initialized = true;

        if (env->pregs[PR_VR] < 32) {

            cris_initialize_crisv10_tcg();

        } else {

            cris_initialize_tcg();

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"xfs_itruncate_clear_reflink_flags(
	struct xfs_inode	*ip)
{
	struct xfs_ifork	*dfork;
	struct xfs_ifork	*cfork;

	if (!xfs_is_reflink_inode(ip))
		return;
	dfork = XFS_IFORK_PTR(ip, XFS_DATA_FORK);
	cfork = XFS_IFORK_PTR(ip, XFS_COW_FORK);
	if (dfork->if_bytes == 0 && cfork->if_bytes == 0)
		ip->i_d.di_flags2 &= ~XFS_DIFLAG2_REFLINK;
	if (cfork->if_bytes == 0)
		xfs_inode_clear_cowblocks_tag(ip);
}",0
Detect whether the following code contains vulnerabilities.,"static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,
			 struct inode *parent)
{
	int len = *lenp;
	struct kernel_lb_addr location = UDF_I(inode)->i_location;
	struct fid *fid = (struct fid *)fh;
	int type = FILEID_UDF_WITHOUT_PARENT;

	if (parent && (len < 5)) {
		*lenp = 5;
		return 255;
	} else if (len < 3) {
		*lenp = 3;
		return 255;
	}

	*lenp = 3;
	fid->udf.block = location.logicalBlockNum;
	fid->udf.partref = location.partitionReferenceNum;
	fid->udf.generation = inode->i_generation;

	if (parent) {
		location = UDF_I(parent)->i_location;
		fid->udf.parent_block = location.logicalBlockNum;
		fid->udf.parent_partref = location.partitionReferenceNum;
		fid->udf.parent_generation = inode->i_generation;
		*lenp = 5;
		type = FILEID_UDF_WITH_PARENT;
	}

	return type;
}",1
Detect whether the following code contains vulnerabilities.,"test_non_svg_element (void)
{
    char *filename = get_test_filename (""335-non-svg-element.svg"");
    RsvgHandle *handle;
    GError *error = NULL;

    handle = rsvg_handle_new_from_file (filename, &error);
    g_free (filename);

    g_assert (handle == NULL);
    g_assert (g_error_matches (error, RSVG_ERROR, RSVG_ERROR_FAILED));

    g_error_free (error);
}",1
Detect whether the following code contains vulnerabilities.,"LDAPDN_rewrite( LDAPDN dn, unsigned flags, void *ctx )
{
	int 		iRDN;
	int 		rc;

	assert( dn != NULL );

	for ( iRDN = 0; dn[ iRDN ]; iRDN++ ) {
		rc = LDAPRDN_rewrite( dn[ iRDN ], flags, ctx );
		if ( rc != LDAP_SUCCESS ) {
			return rc;
		}
	}

	return LDAP_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(bccomp)
{
	char *left, *right;
	int left_len, right_len;
	long scale_param = 0;
	bc_num first, second;
	int scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""ss|l"", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {
		return;
	}
	
	if (argc == 3) {
		scale = (int) ((int)scale_param < 0) ? 0 : scale_param;
	}

	bc_init_num(&first TSRMLS_CC);
	bc_init_num(&second TSRMLS_CC);

	bc_str2num(&first, left, scale TSRMLS_CC);
	bc_str2num(&second, right, scale TSRMLS_CC);
	Z_LVAL_P(return_value) = bc_compare(first, second);
	Z_TYPE_P(return_value) = IS_LONG;

	bc_free_num(&first);
	bc_free_num(&second);
	return;
}",1
Detect whether the following code contains vulnerabilities.,"static const char *pxb_host_root_bus_path(PCIHostState *host_bridge,

                                          PCIBus *rootbus)

{

    PXBBus *bus = PXB_BUS(rootbus);



    snprintf(bus->bus_path, 8, ""0000:%02x"", pxb_bus_num(rootbus));

    return bus->bus_path;

}
",0
Detect whether the following code contains vulnerabilities.,"static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)
{
	int ret;
	struct k90_led *led = container_of(led_cdev, struct k90_led, cdev);
	struct device *dev = led->cdev.dev->parent;
	struct usb_interface *usbif = to_usb_interface(dev->parent);
	struct usb_device *usbdev = interface_to_usbdev(usbif);
	int brightness;
	char data[8];

	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
			      K90_REQUEST_STATUS,
			      USB_DIR_IN | USB_TYPE_VENDOR |
			      USB_RECIP_DEVICE, 0, 0, data, 8,
			      USB_CTRL_SET_TIMEOUT);
	if (ret < 0) {
		dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"",
			 ret);
		return -EIO;
	}
	brightness = data[4];
	if (brightness < 0 || brightness > 3) {
		dev_warn(dev,
			 ""Read invalid backlight brightness: %02hhx.\n"",
			 data[4]);
		return -EIO;
	}
	return brightness;
}",1
Detect whether the following code contains vulnerabilities.,"    std::string help() const override {
        return ""count objects in collection"";
    }",0
Detect whether the following code contains vulnerabilities.,"static inline int cpu_of(struct rq *rq)
{
#ifdef CONFIG_SMP
	return rq->cpu;
#else
	return 0;
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static size_t buffered_set_rate_limit(void *opaque, size_t new_rate)

{

    QEMUFileBuffered *s = opaque;



    if (s->has_error)

        goto out;



    s->xfer_limit = new_rate / 10;

    

out:

    return s->xfer_limit;

}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err tfdt_box_dump(GF_Box *a, FILE * trace)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox*) a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""TrackFragmentBaseMediaDecodeTimeBox"", trace);

	gf_fprintf(trace, ""baseMediaDecodeTime=\""""LLD""\"">\n"", ptr->baseMediaDecodeTime);
	gf_isom_box_dump_done(""TrackFragmentBaseMediaDecodeTimeBox"", a, trace);
	return GF_OK;
}",0
Detect whether the following code contains vulnerabilities.,"int dane_verify_session_crt (
        dane_state_t s,
	gnutls_session_t session,
	const char * hostname, const char* proto, unsigned int port,
	unsigned int sflags, unsigned int vflags,
	unsigned int *verify)
{
const gnutls_datum_t *cert_list;
unsigned int cert_list_size = 0;
unsigned int type;

	cert_list = gnutls_certificate_get_peers(session, &cert_list_size);
	if (cert_list_size == 0) {
		return gnutls_assert_val(DANE_E_NO_CERT);
	}
	
	type = gnutls_certificate_type_get(session);
	
	return dane_verify_crt(s, cert_list, cert_list_size, type, hostname, proto, port, sflags, vflags, verify);
}",1
Detect whether the following code contains vulnerabilities.,"static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)
{
	muscle_private_t* priv = MUSCLE_DATA(card);
	mscfs_t *fs = priv->fs;
	int x;
	int count = 0;

	mscfs_check_cache(priv->fs);

	for(x = 0; x < fs->cache.size; x++) {
		u8* oid= fs->cache.array[x].objectId.id;
		sc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,
			""FILE: %02X%02X%02X%02X\n"",
			oid[0],oid[1],oid[2],oid[3]);
		if(0 == memcmp(fs->currentPath, oid, 2)) {
			buf[0] = oid[2];
			buf[1] = oid[3];
			if(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */
			buf += 2;
			count+=2;
		}
	}
	return count;
}",1
Detect whether the following code contains vulnerabilities.,"SYSCALL_DEFINE1(getsid, pid_t, pid)
{
	struct task_struct *p;
	struct pid *sid;
	int retval;

	rcu_read_lock();
	if (!pid)
		sid = task_session(current);
	else {
		retval = -ESRCH;
		p = find_task_by_vpid(pid);
		if (!p)
			goto out;
		sid = task_session(p);
		if (!sid)
			goto out;

		retval = security_task_getsid(p);
		if (retval)
			goto out;
	}
	retval = pid_vnr(sid);
out:
	rcu_read_unlock();
	return retval;
}",0
Detect whether the following code contains vulnerabilities.,"StringVal EncryptionFunctions::from_base64(FunctionContext* ctx, const StringVal& src) {
    if (src.len == 0 || src.is_null) {
        return StringVal::null();
    }

    int cipher_len = src.len;
    std::unique_ptr<char[]> p;
    p.reset(new char[cipher_len]);

    int ret_code = base64_decode((const char*)src.ptr, src.len, p.get());
    if (ret_code < 0) {
        return StringVal::null();
    }
    return AnyValUtil::from_buffer_temp(ctx, p.get(), ret_code);
}",1
Detect whether the following code contains vulnerabilities.,"static void spapr_vlan_cleanup(NetClientState *nc)

{

    VIOsPAPRVLANDevice *dev = qemu_get_nic_opaque(nc);



    dev->nic = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_buffer(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_get_buffer(f, v, size);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"check_offset(char *memory, int total_size, char *name, void *offset, int size)
{
	ptrdiff_t need_size = (char *) offset - memory + size;

	/*debug(""check_offset: size=%x vs %x offset=%x size=%x\n"",
		need_size, total_size, (char *) offset - memory, size);*/

	if (need_size < 0 || need_size > total_size) {
		warn(_(""%s: premature end""), name);
		return false;
	}

	return true;
}",1
Detect whether the following code contains vulnerabilities.,"LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
                                              BasicType type) {
  int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);

  LIR_Address* addr;
  if (index_opr->is_constant()) {
    int elem_size = type2aelembytes(type);
    addr = new LIR_Address(array_opr,
                           offset_in_bytes + (intx)(index_opr->as_jint()) * elem_size, type);
  } else {
#ifdef _LP64
    if (index_opr->type() == T_INT) {
      LIR_Opr tmp = new_register(T_LONG);
      __ convert(Bytecodes::_i2l, index_opr, tmp);
      index_opr = tmp;
    }
#endif // _LP64
    addr =  new LIR_Address(array_opr,
                            index_opr,
                            LIR_Address::scale(type),
                            offset_in_bytes, type);
  }
  return addr;
}",1
Detect whether the following code contains vulnerabilities.,"u_savesub(linenr_T lnum)
{
    if (undo_off)
	return OK;

    return (u_savecommon(lnum - 1, lnum + 1, lnum + 1, FALSE));
}",0
Detect whether the following code contains vulnerabilities.,"static int qemu_reset_requested(void)

{

    int r = reset_requested;

    if (r && replay_checkpoint(CHECKPOINT_RESET_REQUESTED)) {

        reset_requested = 0;

        return r;

    }

    return false;

}
",1
Detect whether the following code contains vulnerabilities.,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    if (strlen(path) >= sizeof(helper.sun_path)) {

        fprintf(stderr, ""Socket name too large\n"");

        return -1;

    }

    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""failed to create socket: %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""failed to connect to %s: %s\n"", path, strerror(errno));

        close(sockfd);

        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}
",0
Detect whether the following code contains vulnerabilities.,"TEST_F(PlaintextRecordTest, TestReadAppData) {
  addToQueue(""17030100050123456789"");
  EXPECT_ANY_THROW(read_.read(queue_));
}",0
Detect whether the following code contains vulnerabilities.,"static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor,

                              uint32_t group_id)

{

    QEMUCursor *c;

    size_t size;



    c = cursor_alloc(cursor->header.width, cursor->header.height);

    c->hot_x = cursor->header.hot_spot_x;

    c->hot_y = cursor->header.hot_spot_y;

    switch (cursor->header.type) {

    case SPICE_CURSOR_TYPE_ALPHA:

        size = sizeof(uint32_t) * cursor->header.width * cursor->header.height;

        qxl_unpack_chunks(c->data, size, qxl, &cursor->chunk, group_id);

        if (qxl->debug > 2) {

            cursor_print_ascii_art(c, ""qxl/alpha"");

        }

        break;

    default:

        fprintf(stderr, ""%s: not implemented: type %d\n"",

                __FUNCTION__, cursor->header.type);

        goto fail;

    }

    return c;



fail:

    cursor_put(c);

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"have_handshake_fragment(SSL *s, int type, unsigned char *buf,
                        int len, int peek)
{

    if ((type == SSL3_RT_HANDSHAKE) && (s->d1->handshake_fragment_len > 0))
        /* (partially) satisfy request from storage */
    {
        unsigned char *src = s->d1->handshake_fragment;
        unsigned char *dst = buf;
        unsigned int k, n;

        /* peek == 0 */
        n = 0;
        while ((len > 0) && (s->d1->handshake_fragment_len > 0)) {
            *dst++ = *src++;
            len--;
            s->d1->handshake_fragment_len--;
            n++;
        }
        /* move any remaining fragment bytes: */
        for (k = 0; k < s->d1->handshake_fragment_len; k++)
            s->d1->handshake_fragment[k] = *src++;
        return n;
    }

    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t helper_bcdsetsgn(ppc_avr_t *r, ppc_avr_t *b, uint32_t ps)

{

    int i;

    int invalid = 0;

    int sgnb = bcd_get_sgn(b);



    *r = *b;

    bcd_put_digit(r, bcd_preferred_sgn(sgnb, ps), 0);



    for (i = 1; i < 32; i++) {

        bcd_get_digit(b, i, &invalid);

        if (unlikely(invalid)) {

            return CRF_SO;

        }

    }



    return bcd_cmp_zero(r);

}
",0
Detect whether the following code contains vulnerabilities.,"
static struct file *io_file_get_normal(struct io_kiocb *req, int fd)
{
	struct file *file = fget(fd);

	trace_io_uring_file_get(req->ctx, req, req->cqe.user_data, fd);

	/* we don't allow fixed io_uring files */
	if (file && file->f_op == &io_uring_fops)
		req->flags |= REQ_F_INFLIGHT;
	return file;",1
Detect whether the following code contains vulnerabilities.,"static void cancel_att_send_op(struct att_send_op *op)
{
	if (op->destroy)
		op->destroy(op->user_data);

	op->user_data = NULL;
	op->callback = NULL;
	op->destroy = NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static void rtas_read_pci_config(sPAPREnvironment *spapr,

                                 uint32_t token, uint32_t nargs,

                                 target_ulong args,

                                 uint32_t nret, target_ulong rets)

{

    uint32_t val, size, addr;

    PCIDevice *dev = find_dev(spapr, 0, rtas_ld(args, 0));



    if (!dev) {

        rtas_st(rets, 0, -1);

        return;

    }

    size = rtas_ld(args, 1);

    addr = rtas_pci_cfgaddr(rtas_ld(args, 0));

    val = pci_host_config_read_common(dev, addr, pci_config_size(dev), size);

    rtas_st(rets, 0, 0);

    rtas_st(rets, 1, val);

}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t aio_setup_single_vector(struct kiocb *kiocb,
				       int rw, char __user *buf,
				       unsigned long *nr_segs,
				       size_t len,
				       struct iovec *iovec)
{
	if (unlikely(!access_ok(!rw, buf, len)))
		return -EFAULT;

	iovec->iov_base = buf;
	iovec->iov_len = len;
	*nr_segs = 1;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int update_remove_entry(struct libmnt_update *upd, struct libmnt_lock *lc)
{
	struct libmnt_table *tb;
	int rc = 0, u_lc = -1;

	assert(upd);
	assert(upd->target);

	DBG(UPDATE, mnt_debug_h(upd, ""%s: remove entry"", upd->filename));

	if (lc)
		mnt_lock_file(lc);
	else if (upd->userspace_only)
		u_lc = utab_lock(upd->filename);

	tb = __mnt_new_table_from_file(upd->filename,
			upd->userspace_only ? MNT_FMT_UTAB : MNT_FMT_MTAB);
	if (tb) {
		struct libmnt_fs *rem = mnt_table_find_target(tb, upd->target, MNT_ITER_BACKWARD);
		if (rem) {
			mnt_table_remove_fs(tb, rem);
			rc = update_table(upd, tb);
			mnt_free_fs(rem);
		}
	}
	if (lc)
		mnt_unlock_file(lc);
	else if (u_lc != -1)
		utab_unlock(u_lc);

	mnt_free_table(tb);
	return rc;
}",1
Detect whether the following code contains vulnerabilities.,"void cpu_exec_init(CPUState *cpu, Error **errp)

{

    CPUClass *cc ATTRIBUTE_UNUSED = CPU_GET_CLASS(cpu);



    cpu_list_add(cpu);



#ifndef CONFIG_USER_ONLY

    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {

        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);

    }

    if (cc->vmsd != NULL) {

        vmstate_register(NULL, cpu->cpu_index, cc->vmsd, cpu);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void v9fs_flush(void *opaque)

{

    int16_t tag;

    size_t offset = 7;

    V9fsPDU *cancel_pdu;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""w"", &tag);




    QLIST_FOREACH(cancel_pdu, &s->active_list, next) {

        if (cancel_pdu->tag == tag) {

            break;

        }

    }

    if (cancel_pdu) {

        cancel_pdu->cancelled = 1;

        /*

         * Wait for pdu to complete.

         */

        qemu_co_queue_wait(&cancel_pdu->complete);

        cancel_pdu->cancelled = 0;

        free_pdu(pdu->s, cancel_pdu);

    }

    complete_pdu(s, pdu, 7);

    return;

}",1
Detect whether the following code contains vulnerabilities.,"static void revert_acfilter(WmallDecodeCtx *s, int tile_size)

{

    int ich, pred, i, j;

    int16_t *filter_coeffs = s->acfilter_coeffs;

    int scaling            = s->acfilter_scaling;

    int order              = s->acfilter_order;



    for (ich = 0; ich < s->num_channels; ich++) {

        int *prevvalues = s->acfilter_prevvalues[ich];

        for (i = 0; i < order; i++) {

            pred = 0;

            for (j = 0; j < order; j++) {

                if (i <= j)

                    pred += filter_coeffs[j] * prevvalues[j - i];

                else

                    pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];

            }

            pred >>= scaling;

            s->channel_residues[ich][i] += pred;

        }

        for (i = order; i < tile_size; i++) {

            pred = 0;

            for (j = 0; j < order; j++)

                pred += s->channel_residues[ich][i - j - 1] * filter_coeffs[j];

            pred >>= scaling;

            s->channel_residues[ich][i] += pred;

        }

        for (j = 0; j < order; j++)

            prevvalues[j] = s->channel_residues[ich][tile_size - j - 1];

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int read_sbr_single_channel_element(AACContext *ac,

                                            SpectralBandReplication *sbr,

                                            GetBitContext *gb)

{

    int ret;



    if (get_bits1(gb)) // bs_data_extra

        skip_bits(gb, 4); // bs_reserved



    if (read_sbr_grid(ac, sbr, gb, &sbr->data[0]))

        return -1;

    read_sbr_dtdf(sbr, gb, &sbr->data[0]);

    read_sbr_invf(sbr, gb, &sbr->data[0]);

    read_sbr_envelope(sbr, gb, &sbr->data[0], 0);

    if((ret = read_sbr_noise(ac, sbr, gb, &sbr->data[0], 0)) < 0)

        return ret;



    if ((sbr->data[0].bs_add_harmonic_flag = get_bits1(gb)))

        get_bits1_vector(gb, sbr->data[0].bs_add_harmonic, sbr->n[1]);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"unsigned long perf_instruction_pointer(struct pt_regs *regs)
{
	bool use_siar = regs_use_siar(regs);
	unsigned long siar = mfspr(SPRN_SIAR);

	if (ppmu->flags & PPMU_P10_DD1) {
		if (siar)
			return siar;
		else
			return regs->nip;
	} else if (use_siar && siar_valid(regs))
		return mfspr(SPRN_SIAR) + perf_ip_adjust(regs);
	else if (use_siar)
		return 0;		// no valid instruction pointer
	else
		return regs->nip;
}",1
Detect whether the following code contains vulnerabilities.,"HandShakeType HandShakeHeader::get_handshakeType() const
{
    return type_;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_prores_idct(DCTELEM *block, const int16_t *qmat)

{

    int i;



    for (i = 0; i < 64; i++)

        block[i] *= qmat[i];



    for (i = 0; i < 8; i++)

        idctRowCondDC_10(block + i*8);



    for (i = 0; i < 64; i++)

        block[i] >>= 2;



    for (i = 0; i < 8; i++)

        idctSparseCol_10(block + i);

}
",1
Detect whether the following code contains vulnerabilities.,"static int find_stream_index(AVFormatContext *s)

{

    int i;

    AVStream *st;



    if (s->nb_streams <= 0)

        return -1;

    for(i = 0; i < s->nb_streams; i++) {

        st = s->streams[i];

        if (st->codec.codec_type == CODEC_TYPE_VIDEO) {

            return i;

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,    Stats::Scope& listenerScope() override { return parent_.stats_store_; },0
Detect whether the following code contains vulnerabilities.,"mrb_false(mrb_state *mrb, mrb_value self)
{
  return mrb_false_value();
}",0
Detect whether the following code contains vulnerabilities.,"static size_t virtio_net_rsc_drain_seg(VirtioNetRscChain *chain,
                                       VirtioNetRscSeg *seg)
{
    int ret;
    struct virtio_net_hdr_v1 *h;

    h = (struct virtio_net_hdr_v1 *)seg->buf;
    h->flags = 0;
    h->gso_type = VIRTIO_NET_HDR_GSO_NONE;

    if (seg->is_coalesced) {
        h->rsc.segments = seg->packets;
        h->rsc.dup_acks = seg->dup_ack;
        h->flags = VIRTIO_NET_HDR_F_RSC_INFO;
        if (chain->proto == ETH_P_IP) {
            h->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;
        } else {
            h->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;
        }
    }

    ret = virtio_net_do_receive(seg->nc, seg->buf, seg->size);
    QTAILQ_REMOVE(&chain->buffers, seg, next);
    g_free(seg->buf);
    g_free(seg);

    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static void decode(AVCodecContext *dec_ctx, AVFrame *frame, AVPacket *pkt,

                   const char *filename)

{

    char buf[1024];

    int ret;



    ret = avcodec_send_packet(dec_ctx, pkt);

    if (ret < 0) {

        fprintf(stderr, ""Error sending a packet for decoding\n"");

        exit(1);

    }



    while (ret >= 0) {

        ret = avcodec_receive_frame(dec_ctx, frame);

        if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)

            return;

        else if (ret < 0) {

            fprintf(stderr, ""Error during decoding\n"");

            exit(1);

        }



        printf(""saving frame %3d\n"", dec_ctx->frame_number);

        fflush(stdout);



        /* the picture is allocated by the decoder. no need to

           free it */

        snprintf(buf, sizeof(buf), filename, dec_ctx->frame_number);

        pgm_save(frame->data[0], frame->linesize[0],

                 frame->width, frame->height, buf);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"afterTriggerCheckState(AfterTriggerShared evtshared)
{
	Oid			tgoid = evtshared->ats_tgoid;
	SetConstraintState state = afterTriggers->state;
	int			i;

	/*
	 * For not-deferrable triggers (i.e. normal AFTER ROW triggers and
	 * constraints declared NOT DEFERRABLE), the state is always false.
	 */
	if ((evtshared->ats_event & AFTER_TRIGGER_DEFERRABLE) == 0)
		return false;

	/*
	 * Check if SET CONSTRAINTS has been executed for this specific trigger.
	 */
	for (i = 0; i < state->numstates; i++)
	{
		if (state->trigstates[i].sct_tgoid == tgoid)
			return state->trigstates[i].sct_tgisdeferred;
	}

	/*
	 * Check if SET CONSTRAINTS ALL has been executed; if so use that.
	 */
	if (state->all_isset)
		return state->all_isdeferred;

	/*
	 * Otherwise return the default state for the trigger.
	 */
	return ((evtshared->ats_event & AFTER_TRIGGER_INITDEFERRED) != 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void make_dirty(uint8_t device)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;

    uint8_t status;

    size_t len = 512;

    uintptr_t guest_buf;

    void* buf;



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    guest_buf = guest_alloc(guest_malloc, len);

    buf = g_malloc(len);

    memset(buf, rand() % 255 + 1, len);

    g_assert(guest_buf);

    g_assert(buf);



    memwrite(guest_buf, buf, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);



    g_free(buf);


}",1
Detect whether the following code contains vulnerabilities.,"static int kvm_set_user_memory_region(KVMState *s, KVMSlot *slot)

{

    struct kvm_userspace_memory_region mem;



    mem.slot = slot->slot;

    mem.guest_phys_addr = slot->start_addr;

    mem.userspace_addr = (unsigned long)slot->ram;

    mem.flags = slot->flags;

    if (s->migration_log) {

        mem.flags |= KVM_MEM_LOG_DIRTY_PAGES;

    }

    if (mem.flags & KVM_MEM_READONLY) {

        /* Set the slot size to 0 before setting the slot to the desired

         * value. This is needed based on KVM commit 75d61fbc. */

        mem.memory_size = 0;

        kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);

    }

    mem.memory_size = slot->memory_size;

    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);

}
",1
Detect whether the following code contains vulnerabilities.,"void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)
{
	unsigned len;
	uint8_t *optionptr = packet->options;
	unsigned end = udhcp_end_option(optionptr);

	len = OPT_DATA + addopt[OPT_LEN];
	/* end position + (option code/length + addopt length) + end option */
	if (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {
//TODO: learn how to use overflow option if we exhaust packet->options[]
		bb_error_msg(""option 0x%02x did not fit into the packet"",
				addopt[OPT_CODE]);
		return;
	}
	log_option(""Adding option"", addopt);
	memcpy(optionptr + end, addopt, len);
	optionptr[end + len] = DHCP_END;
}",0
Detect whether the following code contains vulnerabilities.,"static void ff_h264_idct8_add4_mmx(uint8_t *dst, const int *block_offset, DCTELEM *block, int stride, const uint8_t nnzc[6*8]){

    int i;

    for(i=0; i<16; i+=4){

        if(nnzc[ scan8[i] ])

            ff_h264_idct8_add_mmx(dst + block_offset[i], block + i*16, stride);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"  C_OnMapCommit(OSD *o, epoch_t f, epoch_t l, MOSDMap *m)
    : osd(o), first(f), last(l), msg(m) {}",0
Detect whether the following code contains vulnerabilities.,"format_LEARN(const struct ofpact_learn *a,
             const struct ofpact_format_params *fp)
{
    learn_format(a, fp->port_map, fp->table_map, fp->s);
}",0
Detect whether the following code contains vulnerabilities.,"display_shell_version (count, c)
     int count, c;
{
  rl_crlf ();
  show_shell_version (0);
  putc ('\r', rl_outstream);
  fflush (rl_outstream);
  rl_on_new_line ();
  rl_redisplay ();
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static
size_t php_mysqlnd_sha256_pk_request_write(MYSQLND_CONN_DATA * conn, void * _packet)
{
	MYSQLND_ERROR_INFO * error_info = conn->error_info;
	MYSQLND_PFC * pfc = conn->protocol_frame_codec;
	MYSQLND_VIO * vio = conn->vio;
	MYSQLND_STATS * stats = conn->stats;
	zend_uchar buffer[MYSQLND_HEADER_SIZE + 1];
	size_t sent;

	DBG_ENTER(""php_mysqlnd_sha256_pk_request_write"");

	int1store(buffer + MYSQLND_HEADER_SIZE, '\1');
	sent = pfc->data->m.send(pfc, vio, buffer, 1, stats, error_info);

	DBG_RETURN(sent);",0
Detect whether the following code contains vulnerabilities.,"static void process(char const* whoami,
                    char const* infile,
                    std::string outprefix)
{
    QPDF inpdf;
    inpdf.processFile(infile);
    std::vector<QPDFPageObjectHelper> pages =
        QPDFPageDocumentHelper(inpdf).getAllPages();
    int pageno_len = QUtil::int_to_string(pages.size()).length();
    int pageno = 0;
    for (std::vector<QPDFPageObjectHelper>::iterator iter = pages.begin();
         iter != pages.end(); ++iter)
    {
        QPDFPageObjectHelper& page(*iter);
        std::string outfile =
            outprefix + QUtil::int_to_string(++pageno, pageno_len) + "".pdf"";
        QPDF outpdf;
        outpdf.emptyPDF();
        QPDFPageDocumentHelper(outpdf).addPage(page, false);
        QPDFWriter outpdfw(outpdf, outfile.c_str());
	if (static_id)
	{
	    // For the test suite, uncompress streams and use static
	    // IDs.
	    outpdfw.setStaticID(true); // for testing only
	    outpdfw.setStreamDataMode(qpdf_s_uncompress);
	}
        outpdfw.write();
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int get_real_id(const char *devpath, const char *idname, uint16_t *val)

{

    FILE *f;

    char name[128];

    long id;



    snprintf(name, sizeof(name), ""%s%s"", devpath, idname);

    f = fopen(name, ""r"");

    if (f == NULL) {

        error_report(""%s: %s: %m"", __func__, name);

        return -1;

    }

    if (fscanf(f, ""%li\n"", &id) == 1) {

        *val = id;

    } else {


        return -1;

    }




    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"void vga_hw_screen_dump(const char *filename)

{

    TextConsole *previous_active_console;



    previous_active_console = active_console;

    active_console = consoles[0];

    /* There is currently no way of specifying which screen we want to dump,

       so always dump the first one.  */

    if (consoles[0] && consoles[0]->hw_screen_dump)

        consoles[0]->hw_screen_dump(consoles[0]->hw, filename);

    active_console = previous_active_console;

}
",1
Detect whether the following code contains vulnerabilities.,"  explicit ReverseSequenceOp(OpKernelConstruction* context)
      : OpKernel(context) {
    OP_REQUIRES_OK(context, context->GetAttr(""batch_dim"", &batch_dim_));
    OP_REQUIRES_OK(context, context->GetAttr(""seq_dim"", &seq_dim_));
  }",1
Detect whether the following code contains vulnerabilities.,"int av_image_get_linesize(enum PixelFormat pix_fmt, int width, int plane)

{

    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[pix_fmt];

    int max_step     [4];       /* max pixel step for each plane */

    int max_step_comp[4];       /* the component for each plane which has the max pixel step */

    int s, linesize;



    if ((unsigned)pix_fmt >= PIX_FMT_NB || desc->flags & PIX_FMT_HWACCEL)

        return AVERROR(EINVAL);



    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);

    s = (max_step_comp[plane] == 1 || max_step_comp[plane] == 2) ? desc->log2_chroma_w : 0;

    linesize = max_step[plane] * (((width + (1 << s) - 1)) >> s);

    if (desc->flags & PIX_FMT_BITSTREAM)

        linesize = (linesize + 7) >> 3;

    return linesize;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vdi_close(BlockDriverState *bs)

{

    BDRVVdiState *s = bs->opaque;



    g_free(s->bmap);



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",1
Detect whether the following code contains vulnerabilities.,"static void m68k_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    M68kCPU *cpu = M68K_CPU(obj);

    CPUM68KState *env = &cpu->env;

    static bool inited;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    if (tcg_enabled() && !inited) {

        inited = true;

        m68k_tcg_init();

    }

}
",1
Detect whether the following code contains vulnerabilities.,"target_ulong helper_srad(CPUPPCState *env, target_ulong value,

                         target_ulong shift)

{

    int64_t ret;



    if (likely(!(shift & 0x40))) {

        if (likely((uint64_t)shift != 0)) {

            shift &= 0x3f;

            ret = (int64_t)value >> shift;

            if (likely(ret >= 0 || (value & ((1 << shift) - 1)) == 0)) {

                env->ca = 0;

            } else {

                env->ca = 1;

            }

        } else {

            ret = (int64_t)value;

            env->ca = 0;

        }

    } else {

        ret = (int64_t)value >> 63;

        env->ca = (ret != 0);

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"void arm_translate_init(void)

{

    cpu_env = tcg_global_reg_new(TCG_TYPE_PTR, TCG_AREG0, ""env"");



    cpu_T[0] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG1, ""T0"");

    cpu_T[1] = tcg_global_reg_new(TCG_TYPE_I32, TCG_AREG2, ""T1"");

}
",0
Detect whether the following code contains vulnerabilities.,"zdoneshowpage(i_ctx_t *i_ctx_p)
{
    gx_device *dev = gs_currentdevice(igs);
    gx_device *tdev = (*dev_proc(dev, get_page_device)) (dev);

    if (tdev != 0)
        tdev->ShowpageCount++;
    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void __proc_set_tty(struct tty_struct *tty)
{
	unsigned long flags;

	spin_lock_irqsave(&tty->ctrl_lock, flags);
	/*
	 * The session and fg pgrp references will be non-NULL if
	 * tiocsctty() is stealing the controlling tty
	 */
	put_pid(tty->session);
	put_pid(tty->pgrp);
	tty->pgrp = get_pid(task_pgrp(current));
	spin_unlock_irqrestore(&tty->ctrl_lock, flags);
	tty->session = get_pid(task_session(current));
	if (current->signal->tty) {
		tty_debug(tty, ""current tty %s not NULL!!\n"",
			  current->signal->tty->name);
		tty_kref_put(current->signal->tty);
	}
	put_pid(current->signal->tty_old_pgrp);
	current->signal->tty = tty_kref_get(tty);
	current->signal->tty_old_pgrp = NULL;
}",1
Detect whether the following code contains vulnerabilities.,"bool timer_expired(QEMUTimer *timer_head, int64_t current_time)

{

    return timer_expired_ns(timer_head, current_time * timer_head->scale);

}
",0
Detect whether the following code contains vulnerabilities.,"static void bind_ssbo_locs(struct vrend_linked_shader_program *sprog,
                           int id)
{
   int i;
   char name[32];
   if (!has_feature(feat_ssbo))
      return;
   if (sprog->ss[id]->sel->sinfo.ssbo_used_mask) {
      const char *prefix = pipe_shader_to_prefix(id);
      uint32_t mask = sprog->ss[id]->sel->sinfo.ssbo_used_mask;
      sprog->ssbo_locs[id] = calloc(util_last_bit(mask), sizeof(uint32_t));

      while (mask) {
         i = u_bit_scan(&mask);
         snprintf(name, 32, ""%sssbo%d"", prefix, i);
         sprog->ssbo_locs[id][i] = glGetProgramResourceIndex(sprog->id, GL_SHADER_STORAGE_BLOCK, name);
      }
   } else
      sprog->ssbo_locs[id] = NULL;
   sprog->ssbo_used_mask[id] = sprog->ss[id]->sel->sinfo.ssbo_used_mask;
}",0
Detect whether the following code contains vulnerabilities.,"plperl_sv_to_literal(SV *sv, char *fqtypename)
{
	Datum		str = CStringGetDatum(fqtypename);
	Oid			typid = DirectFunctionCall1(regtypein, str);
	Oid			typoutput;
	Datum		datum;
	bool		typisvarlena,
				isnull;

	if (!OidIsValid(typid))
		elog(ERROR, ""lookup failed for type %s"", fqtypename);

	datum = plperl_sv_to_datum(sv,
							   typid, -1,
							   NULL, NULL, InvalidOid,
							   &isnull);

	if (isnull)
		return NULL;

	getTypeOutputInfo(typid,
					  &typoutput, &typisvarlena);

	return OidOutputFunctionCall(typoutput, datum);
}",0
Detect whether the following code contains vulnerabilities.,"static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *skb_out;
	struct sadb_msg *hdr;

	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_out)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
	hdr->sadb_msg_pid = c->portid;
	hdr->sadb_msg_version = PF_KEY_V2;
	hdr->sadb_msg_errno = (uint8_t) 0;
	hdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;
	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
	return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void tilegx_cpu_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    CPUClass *cc = CPU_CLASS(oc);
    TileGXCPUClass *tcc = TILEGX_CPU_CLASS(oc);
    tcc->parent_realize = dc->realize;
    dc->realize = tilegx_cpu_realizefn;
    tcc->parent_reset = cc->reset;
    cc->reset = tilegx_cpu_reset;
    cc->has_work = tilegx_cpu_has_work;
    cc->do_interrupt = tilegx_cpu_do_interrupt;
    cc->cpu_exec_interrupt = tilegx_cpu_exec_interrupt;
    cc->dump_state = tilegx_cpu_dump_state;
    cc->set_pc = tilegx_cpu_set_pc;
    cc->handle_mmu_fault = tilegx_cpu_handle_mmu_fault;
    cc->gdb_num_core_regs = 0;
}",1
Detect whether the following code contains vulnerabilities.,"btreesel(Oid operatorObjectId,
		 Oid indrelid,
		 AttrNumber attributeNumber,
		 char *constValue,
		 int32 constFlag,
		 int32 nIndexKeys,
		 Oid indexrelid)
{
	float64		result;
	float64data resultData;

	if (FunctionalSelectivity(nIndexKeys, attributeNumber))
	{

		/*
		 * Need to call the functions selectivity function here.  For now
		 * simply assume it's 1/3 since functions don't currently have
		 * selectivity functions
		 */
		resultData = 1.0 / 3.0;
		result = &resultData;
	}
	else
	{
		result = (float64) fmgr(get_oprrest(operatorObjectId),
								(char *) operatorObjectId,
								(char *) indrelid,
								(char *) (int) attributeNumber,
								(char *) constValue,
								(char *) constFlag,
								NULL);
	}

	if (!PointerIsValid(result))
		elog(ERROR, ""Btree Selectivity: bad pointer"");
	if (*result < 0.0 || *result > 1.0)
		elog(ERROR, ""Btree Selectivity: bad value %lf"", *result);

	return result;
}",0
Detect whether the following code contains vulnerabilities.,"static int get_uint32(QEMUFile *f, void *pv, size_t size)

{

    uint32_t *v = pv;

    qemu_get_be32s(f, v);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"update_tg_cfs_util(struct cfs_rq *cfs_rq, struct sched_entity *se, struct cfs_rq *gcfs_rq)
{
	long delta = gcfs_rq->avg.util_avg - se->avg.util_avg;

	/* Nothing to update */
	if (!delta)
		return;

	/*
	 * The relation between sum and avg is:
	 *
	 *   LOAD_AVG_MAX - 1024 + sa->period_contrib
	 *
	 * however, the PELT windows are not aligned between grq and gse.
	 */

	/* Set new sched_entity's utilization */
	se->avg.util_avg = gcfs_rq->avg.util_avg;
	se->avg.util_sum = se->avg.util_avg * LOAD_AVG_MAX;

	/* Update parent cfs_rq utilization */
	add_positive(&cfs_rq->avg.util_avg, delta);
	cfs_rq->avg.util_sum = cfs_rq->avg.util_avg * LOAD_AVG_MAX;
}",0
Detect whether the following code contains vulnerabilities.,"cli_file_t cli_get_container_type(cli_ctx *ctx, int index)
{
    if (index < 0)
	index = ctx->recursion + index + 1;
    if (index >= 0 && index <= ctx->recursion)
	return ctx->containers[index].type;
    return CL_TYPE_ANY;
}",1
Detect whether the following code contains vulnerabilities.,"void os_setup_post(void)

{

    int fd = 0;



    if (daemonize) {

        uint8_t status = 0;

        ssize_t len;



        do {        

            len = write(daemon_pipe, &status, 1);

        } while (len < 0 && errno == EINTR);

        if (len != 1) {

            exit(1);

        }

        if (chdir(""/"")) {

            perror(""not able to chdir to /"");

            exit(1);

        }

        TFR(fd = qemu_open(""/dev/null"", O_RDWR));

        if (fd == -1) {

            exit(1);

        }

    }



    change_root();

    change_process_uid();



    if (daemonize) {

        dup2(fd, 0);

        dup2(fd, 1);

        dup2(fd, 2);



        close(fd);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static char* sdl_deserialize_string(char **in)
{
	char *s;
	int len;

	WSDL_CACHE_GET_INT(len, in);
	if (len == WSDL_NO_STRING_MARKER) {
		return NULL;
	} else {
		s = emalloc(len+1);
		WSDL_CACHE_GET_N(s, len, in);
		s[len] = '\0';
		return s;
	}
}",0
Detect whether the following code contains vulnerabilities.,"static int check_btf_info(struct bpf_verifier_env *env,
			  const union bpf_attr *attr,
			  union bpf_attr __user *uattr)
{
	struct btf *btf;
	int err;

	if (!attr->func_info_cnt && !attr->line_info_cnt) {
		if (check_abnormal_return(env))
			return -EINVAL;
		return 0;
	}

	btf = btf_get_by_fd(attr->prog_btf_fd);
	if (IS_ERR(btf))
		return PTR_ERR(btf);
	env->prog->aux->btf = btf;

	err = check_btf_func(env, attr, uattr);
	if (err)
		return err;

	err = check_btf_line(env, attr, uattr);
	if (err)
		return err;

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"TEST_F(QueryPlannerTest, MustFetchWhenNotAllSortKeysAreCoveredByIndex) {
    params.options &= ~QueryPlannerParams::INCLUDE_COLLSCAN;
    addIndex(fromjson(""{a: 1, b: 1}""));

    runQueryAsCommand(
        fromjson(""{find: 'testns', filter: {a: {$gt: 0}}, projection: {a: 1, b:1, _id: 0}, ""
                 ""sort: {b: 1, c: 1}}""));

    assertNumSolutions(1U);
    assertSolutionExists(
        ""{proj: {spec: {a: 1, b:1, _id: 0}, node: {sort: {pattern: {b: 1, c: 1}, limit: 0, node: ""
        ""{sortKeyGen:{node: {fetch: {node: {ixscan: ""
        ""{pattern: {a: 1, b: 1}}}}}}}}}}}"");
}",0
Detect whether the following code contains vulnerabilities.,"httpLocalRequest(ObjectPtr object, int method, int from, int to,
                 HTTPRequestPtr requestor, void *closure)
{
    if(object->requestor == NULL)
        object->requestor = requestor;

    if(!disableLocalInterface && urlIsSpecial(object->key, object->key_size))
        return httpSpecialRequest(object, method, from, to, 
                                  requestor, closure);

    if(method >= METHOD_POST) {
        httpClientError(requestor, 405, internAtom(""Method not allowed""));
        requestor->connection->flags &= ~CONN_READER;
        return 1;
    }

    /* objectFillFromDisk already did the real work but we have to
       make sure we don't get into an infinite loop. */
    if(object->flags & OBJECT_INITIAL) {
        abortObject(object, 404, internAtom(""Not found""));
    }
    object->age = current_time.tv_sec;
    object->date = current_time.tv_sec;

    object->flags &= ~OBJECT_VALIDATING;
    notifyObject(object);
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"void trace_init_vcpu_events(void)

{

    TraceEvent *ev = NULL;

    while ((ev = trace_event_pattern(""*"", ev)) != NULL) {

        if (trace_event_is_vcpu(ev) &&

            trace_event_get_state_static(ev) &&

            trace_event_get_state_dynamic(ev)) {

            TraceEventID id = trace_event_get_id(ev);

            /* check preconditions */

            assert(trace_events_dstate[id] == 1);

            /* disable early-init state ... */

            trace_events_dstate[id] = 0;

            trace_events_enabled_count--;

            /* ... and properly re-enable */

            trace_event_set_state_dynamic(ev, true);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"
void pdo_row_free_storage(pdo_stmt_t *stmt TSRMLS_DC)
{
	if (stmt) {
		ZVAL_NULL(&stmt->lazy_object_ref);

		if (--stmt->refcount == 0) {
			free_statement(stmt TSRMLS_CC);
		}
	}",0
Detect whether the following code contains vulnerabilities.,"static int walk_hugetlb_range(unsigned long addr, unsigned long end,
			      struct mm_walk *walk)
{
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static std::string getComment(const std::string &fulltext, int line)
{
	if (line < 1) return """";

	// Locate line
	unsigned int start = 0;
	for (; start<fulltext.length() ; ++start) {
		if (line <= 1) break;
		if (fulltext[start] == '\n') line--;
	}

	int end = start + 1;
	while (fulltext[end] != '\n') end++;

	std::string comment = fulltext.substr(start, end - start);

	// Locate comment
	unsigned int startText = 0;
	int noOfSemicolon = 0;
	bool inString = false;
	for (; startText < comment.length() - 1; ++startText) {
		if (inString && comment.compare(startText, 2, ""\\\"""") == 0) {
			startText++;
			continue;
		}
		if (comment[startText] == '""') inString = !inString;
		if (!inString) {
			if (comment.compare(startText, 2, ""//"") == 0) break;
			if (comment[startText] == ';' && noOfSemicolon > 0) return """";
			if (comment[startText] == ';') noOfSemicolon++;
		}
	}

	if (startText + 2 > comment.length()) return """";

	std::string result = comment.substr(startText + 2);
	return result;
}",1
Detect whether the following code contains vulnerabilities.,"static void tcp_chr_close(CharDriverState *chr)

{

    TCPCharDriver *s = chr->opaque;

    if (s->fd >= 0) {

        if (s->tag) {

            g_source_remove(s->tag);

            s->tag = 0;

        }

        if (s->chan) {

            g_io_channel_unref(s->chan);

        }

        closesocket(s->fd);

    }

    if (s->listen_fd >= 0) {

        if (s->listen_tag) {

            g_source_remove(s->listen_tag);

            s->listen_tag = 0;

        }

        if (s->listen_chan) {

            g_io_channel_unref(s->listen_chan);

        }

        closesocket(s->listen_fd);

    }

    g_free(s);

    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);

}
",1
Detect whether the following code contains vulnerabilities.,"void dump_start(struct req_state *s)
{
  if (!s->content_started) {
    s->formatter->output_header();
    s->content_started = true;
  }
}",0
Detect whether the following code contains vulnerabilities.,"static bool extractFileTo(zip* zip, const std::string &file, std::string& to,
                          char* buf, size_t len) {
  auto sep = file.rfind('/');
  if (sep != std::string::npos) {
    auto path = to + file.substr(0, sep);
    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {
      return false;
    }

    if (sep == file.length() - 1) {
      return true;
    }
  }

  to.append(file);
  struct zip_stat zipStat;
  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {
    return false;
  }

  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);
  FAIL_IF_INVALID_PTR(zipFile);

  auto outFile = fopen(to.c_str(), ""wb"");
  if (outFile == nullptr) {
    zip_fclose(zipFile);
    return false;
  }

  for (auto n = zip_fread(zipFile, buf, len); n != 0;
       n = zip_fread(zipFile, buf, len)) {
    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {
      zip_fclose(zipFile);
      fclose(outFile);
      remove(to.c_str());
      return false;
    }
  }

  zip_fclose(zipFile);
  if (fclose(outFile) != 0) {
    return false;
  }

  return true;
}",1
Detect whether the following code contains vulnerabilities.,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;

	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > TASK_SIZE)
		return -ENOMEM;

	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}

	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (TASK_SIZE - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}",1
Detect whether the following code contains vulnerabilities.,"static int ast2400_rambits(AspeedSDMCState *s)

{

    switch (s->ram_size >> 20) {

    case 64:

        return ASPEED_SDMC_DRAM_64MB;

    case 128:

        return ASPEED_SDMC_DRAM_128MB;

    case 256:

        return ASPEED_SDMC_DRAM_256MB;

    case 512:

        return ASPEED_SDMC_DRAM_512MB;

    default:

        break;

    }



    /* use a common default */

    error_report(""warning: Invalid RAM size 0x%"" PRIx64

                 "". Using default 256M"", s->ram_size);

    s->ram_size = 256 << 20;

    return ASPEED_SDMC_DRAM_256MB;

}
",0
Detect whether the following code contains vulnerabilities.,"vmxnet3_pop_next_tx_descr(VMXNET3State *s,

                          int qidx,

                          struct Vmxnet3_TxDesc *txd,

                          uint32_t *descr_idx)

{

    Vmxnet3Ring *ring = &s->txq_descr[qidx].tx_ring;

    PCIDevice *d = PCI_DEVICE(s);



    vmxnet3_ring_read_curr_cell(d, ring, txd);

    if (txd->gen == vmxnet3_ring_curr_gen(ring)) {

        /* Only read after generation field verification */

        smp_rmb();

        /* Re-read to be sure we got the latest version */

        vmxnet3_ring_read_curr_cell(d, ring, txd);

        VMXNET3_RING_DUMP(VMW_RIPRN, ""TX"", qidx, ring);

        *descr_idx = vmxnet3_ring_curr_cell_idx(ring);

        vmxnet3_inc_tx_consumption_counter(s, qidx);

        return true;

    }



    return false;

}
",1
Detect whether the following code contains vulnerabilities.,"ssize_t mcopy_atomic(struct mm_struct *dst_mm, unsigned long dst_start,
		     unsigned long src_start, unsigned long len,
		     bool *mmap_changing)
{
	return __mcopy_atomic(dst_mm, dst_start, src_start, len, false,
			      mmap_changing);
}",0
Detect whether the following code contains vulnerabilities.,"void *ff_png_zalloc(void *opaque, unsigned int items, unsigned int size)

{

    if(items >= UINT_MAX / size)

        return NULL;

    return av_malloc(items * size);

}
",1
Detect whether the following code contains vulnerabilities.,"int st_select_lex_unit::save_union_explain(Explain_query *output)
{
  SELECT_LEX *first= first_select();

  if (output->get_union(first->select_number))
    return 0; /* Already added */
    
  Explain_union *eu= 
    new (output->mem_root) Explain_union(output->mem_root, 
                                         thd->lex->analyze_stmt);
  if (unlikely(!eu))
    return 0;

  if (with_element && with_element->is_recursive)
    eu->is_recursive_cte= true;
 
  if (derived)
    eu->connection_type= Explain_node::EXPLAIN_NODE_DERIVED;
  /* 
    Note: Non-merged semi-joins cannot be made out of UNIONs currently, so we
    dont ever set EXPLAIN_NODE_NON_MERGED_SJ.
  */
  for (SELECT_LEX *sl= first; sl; sl= sl->next_select())
    eu->add_select(sl->select_number);

  eu->fake_select_type= unit_operation_text[eu->operation= common_op()];
  eu->using_filesort= MY_TEST(global_parameters()->order_list.first);
  eu->using_tmp= union_needs_tmp_table();

  // Save the UNION node
  output->add_node(eu);

  if (eu->get_select_id() == 1)
    output->query_plan_ready();

  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t proxy_readlink(FsContext *fs_ctx, V9fsPath *fs_path,

                              char *buf, size_t bufsz)

{

    int retval;

    retval = v9fs_request(fs_ctx->private, T_READLINK, buf, ""sd"",

                          fs_path, bufsz);

    if (retval < 0) {

        errno = -retval;

        return -1;

    }

    return strlen(buf);

}
",0
Detect whether the following code contains vulnerabilities.,"static int proxy_init(FsContext *ctx)

{

    V9fsProxy *proxy = g_malloc(sizeof(V9fsProxy));

    int sock_id;



    if (ctx->export_flags & V9FS_PROXY_SOCK_NAME) {

        sock_id = connect_namedsocket(ctx->fs_root);

    } else {

        sock_id = atoi(ctx->fs_root);

        if (sock_id < 0) {

            fprintf(stderr, ""socket descriptor not initialized\n"");


            return -1;

        }

    }

    g_free(ctx->fs_root);




    proxy->in_iovec.iov_base  = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);

    proxy->in_iovec.iov_len   = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;

    proxy->out_iovec.iov_base = g_malloc(PROXY_MAX_IO_SZ + PROXY_HDR_SZ);

    proxy->out_iovec.iov_len  = PROXY_MAX_IO_SZ + PROXY_HDR_SZ;



    ctx->private = proxy;

    proxy->sockfd = sock_id;

    qemu_mutex_init(&proxy->mutex);



    ctx->export_flags |= V9FS_PATHNAME_FSCONTEXT;

    ctx->exops.get_st_gen = proxy_ioc_getversion;

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"xps_select_font_encoding(xps_font_t *font, int idx)
{
    byte *cmapdata, *entry;
    int pid, eid;
    if (idx < 0 || idx >= font->cmapsubcount)
        return;
    cmapdata = font->data + font->cmaptable;
    entry = cmapdata + 4 + idx * 8;
    pid = u16(entry + 0);
    eid = u16(entry + 2);
    font->cmapsubtable = font->cmaptable + u32(entry + 4);
    font->usepua = (pid == 3 && eid == 0);
}",1
Detect whether the following code contains vulnerabilities.,"release_buffer (HB_Buffer buffer, gboolean free_buffer)
{
  if (G_LIKELY (!free_buffer))
    {
      hb_buffer_clear (buffer);
      G_UNLOCK (cached_buffer);
    }
  else
    hb_buffer_free (buffer);
}",1
Detect whether the following code contains vulnerabilities.,"int kvm_irqchip_add_msi_route(KVMState *s, MSIMessage msg)

{

    struct kvm_irq_routing_entry kroute;

    int virq;



    if (!kvm_gsi_routing_enabled()) {

        return -ENOSYS;

    }



    virq = kvm_irqchip_get_virq(s);

    if (virq < 0) {

        return virq;

    }



    kroute.gsi = virq;

    kroute.type = KVM_IRQ_ROUTING_MSI;

    kroute.flags = 0;

    kroute.u.msi.address_lo = (uint32_t)msg.address;

    kroute.u.msi.address_hi = msg.address >> 32;

    kroute.u.msi.data = le32_to_cpu(msg.data);



    kvm_add_routing_entry(s, &kroute);

    kvm_irqchip_commit_routes(s);



    return virq;

}
",1
Detect whether the following code contains vulnerabilities.,"d_lite_downto(VALUE self, VALUE min)
{
    VALUE date;

    RETURN_ENUMERATOR(self, 1, &min);

    date = self;
    while (FIX2INT(d_lite_cmp(date, min)) >= 0) {
	rb_yield(date);
	date = d_lite_plus(date, INT2FIX(-1));
    }
    return self;
}",0
Detect whether the following code contains vulnerabilities.,"    StatusWith<UserHandle> acquireUserForSessionRefresh(OperationContext*,
                                                        const UserName&,
                                                        const User::UserId&) override {
        UASSERT_NOT_IMPLEMENTED;
    }",0
Detect whether the following code contains vulnerabilities.,"static void legacy_kbd_event(DeviceState *dev, QemuConsole *src,

                             InputEvent *evt)

{

    QEMUPutKbdEntry *entry = (QEMUPutKbdEntry *)dev;

    int scancodes[3], i, count;



    if (!entry || !entry->put_kbd) {

        return;

    }

    count = qemu_input_key_value_to_scancode(evt->key->key,

                                             evt->key->down,

                                             scancodes);

    for (i = 0; i < count; i++) {

        entry->put_kbd(entry->opaque, scancodes[i]);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"apr_status_t h2_push_diary_digest64_set(h2_push_diary *diary, const char *authority, 
                                        const char *data64url, apr_pool_t *pool)
{
    const char *data;
    apr_size_t len = h2_util_base64url_decode(&data, data64url, pool);
    /* Intentional no APLOGNO */
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, pool,
                  ""h2_push_diary_digest64_set: digest=%s, dlen=%d"", 
                  data64url, (int)len);
    return h2_push_diary_digest_set(diary, authority, data, len);
}",1
Detect whether the following code contains vulnerabilities.,"void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)
{
	__issue_discard_cmd(sbi, false);
	__drop_discard_cmd(sbi);
	__wait_discard_cmd(sbi, false);
}",1
Detect whether the following code contains vulnerabilities.,"send_session_type (GdmSession *self,
                   GdmSessionConversation *conversation)
{
        const char *session_type = ""x11"";

        if (self->priv->session_type != NULL) {
                session_type = self->priv->session_type;
        }

        gdm_dbus_worker_call_set_environment_variable (conversation->worker_proxy,
                                                       ""XDG_SESSION_TYPE"",
                                                       session_type,
                                                       NULL, NULL, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"int wav_parse(wav_reader_t *reader, int64_t *data_length)
{
    uint32_t container, fcc, chunk_size;

    *data_length = 0;
    container = riff_next_chunk(reader, &chunk_size);
    ENSURE(container == RIFF_FOURCC('R','I','F','F') ||
           container == RIFF_FOURCC('R','F','6','4'));
    TRY_IO(pcm_read32le(&reader->io, &fcc));
    ENSURE(fcc == RIFF_FOURCC('W','A','V','E'));

    if (container == RIFF_FOURCC('R','F','6','4'))
        riff_ds64(reader, data_length);
    while ((fcc = riff_next_chunk(reader, &chunk_size)) != 0) {
        if (fcc == RIFF_FOURCC('f','m','t',' ')) {
            if (wav_fmt(reader, chunk_size) < 0)
                goto FAIL;
        } else if (fcc == RIFF_FOURCC('d','a','t','a')) {
            if (container == RIFF_FOURCC('R','I','F','F'))
                *data_length = chunk_size;
            reader->data_offset = pcm_tell(&reader->io);
            break;
        } else {
            TRY_IO(pcm_skip(&reader->io, (chunk_size + 1) & ~1));
        }
    }
    if (fcc == RIFF_FOURCC('d','a','t','a'))
        return 0;
FAIL:
    return -1;
}",1
Detect whether the following code contains vulnerabilities.,"int ff_thread_get_buffer(AVCodecContext *avctx, ThreadFrame *f, int flags)

{

    f->owner = avctx;

    return ff_get_buffer(avctx, f->f, flags);

}
",1
Detect whether the following code contains vulnerabilities.,"int ext4_force_commit(struct super_block *sb)
{
	journal_t *journal;

	if (sb->s_flags & MS_RDONLY)
		return 0;

	journal = EXT4_SB(sb)->s_journal;
	return ext4_journal_force_commit(journal);
}",0
Detect whether the following code contains vulnerabilities.,"  void start() {
    entity_addr_t addr;
    addr.parse(bindaddr.c_str());
    msgr->bind(addr);
    msgr->add_dispatcher_head(&dispatcher);
    msgr->start();
    msgr->wait();
  }",0
Detect whether the following code contains vulnerabilities.,"Aml *aml_add(Aml *arg1, Aml *arg2)

{

    Aml *var = aml_opcode(0x72 /* AddOp */);

    aml_append(var, arg1);

    aml_append(var, arg2);

    build_append_byte(var->buf, 0x00 /* NullNameOp */);

    return var;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void nvme_sg_init(NvmeCtrl *n, NvmeSg *sg, bool dma)
{
    if (dma) {
        pci_dma_sglist_init(&sg->qsg, &n->parent_obj, 0);
        sg->flags = NVME_SG_DMA;
    } else {
        qemu_iovec_init(&sg->iov, 0);
    }

    sg->flags |= NVME_SG_ALLOC;
}",0
Detect whether the following code contains vulnerabilities.,"TfLiteStatus GetAxisValueFromTensor(TfLiteContext* context,
                                    const TfLiteTensor& axis, int* axis_value) {
  TF_LITE_ENSURE_EQ(context, NumElements(&axis), 1);
  switch (axis.type) {
    case kTfLiteInt32:
      *axis_value = *GetTensorData<int32_t>(&axis);
      return kTfLiteOk;
    case kTfLiteInt64:
      *axis_value = *GetTensorData<int64_t>(&axis);
      return kTfLiteOk;
    default:
      return kTfLiteError;
  }
}",0
Detect whether the following code contains vulnerabilities.,"static void slow_bar_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    AssignedDevRegion *d = opaque;

    uint32_t *out = (uint32_t *)(d->u.r_virtbase + addr);



    DEBUG(""slow_bar_writel addr=0x"" TARGET_FMT_plx "" val=0x%08x\n"", addr, val);

    *out = val;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool umem_access_ok(u64 uaddr, u64 size, int access)
{
	unsigned long a = uaddr;

	/* Make sure 64 bit math will not overflow. */
	if (vhost_overflow(uaddr, size))
		return false;

	if ((access & VHOST_ACCESS_RO) &&
	    !access_ok((void __user *)a, size))
		return false;
	if ((access & VHOST_ACCESS_WO) &&
	    !access_ok((void __user *)a, size))
		return false;
	return true;
}",0
Detect whether the following code contains vulnerabilities.,"static inline MagickBooleanType IsBenchmarkedOpenCLDevice(MagickCLDevice a,
  MagickCLDeviceBenchmark *b)
{
  if ((LocaleCompare(a->platform_name,b->platform_name) == 0) &&
      (LocaleCompare(a->vendor_name,b->vendor_name) == 0) &&
      (LocaleCompare(a->name,b->name) == 0) &&
      (LocaleCompare(a->version,b->version) == 0) &&
      (a->max_clock_frequency == b->max_clock_frequency) &&
      (a->max_compute_units == b->max_compute_units))
    return(MagickTrue);

  return(MagickFalse);
}",0
Detect whether the following code contains vulnerabilities.,"static int sctp_setsockopt_hmac_ident(struct sock *sk,
				    char __user *optval,
				    int optlen)
{
	struct sctp_hmacalgo *hmacs;
	int err;

	if (!sctp_auth_enable)
		return -EACCES;

	if (optlen < sizeof(struct sctp_hmacalgo))
		return -EINVAL;

	hmacs = kmalloc(optlen, GFP_KERNEL);
	if (!hmacs)
		return -ENOMEM;

	if (copy_from_user(hmacs, optval, optlen)) {
		err = -EFAULT;
		goto out;
	}

	if (hmacs->shmac_num_idents == 0 ||
	    hmacs->shmac_num_idents > SCTP_AUTH_NUM_HMACS) {
		err = -EINVAL;
		goto out;
	}

	err = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);
out:
	kfree(hmacs);
	return err;
}",1
Detect whether the following code contains vulnerabilities.,"mac_writereg(E1000State *s, int index, uint32_t val)

{

    uint32_t macaddr[2];



    s->mac_reg[index] = val;



    if (index == RA || index == RA + 1) {

        macaddr[0] = cpu_to_le32(s->mac_reg[RA]);

        macaddr[1] = cpu_to_le32(s->mac_reg[RA + 1]);

        qemu_format_nic_info_str(qemu_get_queue(s->nic), (uint8_t *)macaddr);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void rds_ib_send_add_credits(struct rds_connection *conn, unsigned int credits)
{
	struct rds_ib_connection *ic = conn->c_transport_data;

	if (credits == 0)
		return;

	rdsdebug(""rds_ib_send_add_credits(%u): current=%u%s\n"",
			credits,
			IB_GET_SEND_CREDITS(atomic_read(&ic->i_credits)),
			test_bit(RDS_LL_SEND_FULL, &conn->c_flags) ? "", ll_send_full"" : """");

	atomic_add(IB_SET_SEND_CREDITS(credits), &ic->i_credits);
	if (test_and_clear_bit(RDS_LL_SEND_FULL, &conn->c_flags))
		queue_delayed_work(rds_wq, &conn->c_send_w, 0);

	WARN_ON(IB_GET_SEND_CREDITS(credits) >= 16384);

	rds_ib_stats_inc(s_ib_rx_credit_updates);
}",0
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel4_mc03_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_vt_qrt_4w_msa(src - (stride * 2), stride, dst, stride, 4, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,
				unsigned long end, struct mm_walk *walk)
{
	struct vm_area_struct *vma = walk->private;
	pte_t *pte, ptent;
	spinlock_t *ptl;
	struct page *page;

	split_huge_page_pmd(walk->mm, pmd);

	pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
	for (; addr != end; pte++, addr += PAGE_SIZE) {
		ptent = *pte;
		if (!pte_present(ptent))
			continue;

		page = vm_normal_page(vma, addr, ptent);
		if (!page)
			continue;

		if (PageReserved(page))
			continue;

		/* Clear accessed and referenced bits. */
		ptep_test_and_clear_young(vma, addr, pte);
		ClearPageReferenced(page);
	}
	pte_unmap_unlock(pte - 1, ptl);
	cond_resched();
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void cpu_ioreq_pio(ioreq_t *req)

{

    int i;



    if (req->dir == IOREQ_READ) {

        if (!req->data_is_ptr) {

            req->data = do_inp(req->addr, req->size);

        } else {

            uint32_t tmp;



            for (i = 0; i < req->count; i++) {

                tmp = do_inp(req->addr, req->size);

                write_phys_req_item(req->data, req, i, &tmp);

            }

        }

    } else if (req->dir == IOREQ_WRITE) {

        if (!req->data_is_ptr) {

            do_outp(req->addr, req->size, req->data);

        } else {

            for (i = 0; i < req->count; i++) {

                uint32_t tmp = 0;



                read_phys_req_item(req->data, req, i, &tmp);

                do_outp(req->addr, req->size, tmp);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int vnc_zywrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)
{
    vs->zrle.type = VNC_ENCODING_ZYWRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, h);
}",1
Detect whether the following code contains vulnerabilities.,"static TAPState *net_tap_fd_init(VLANState *vlan, int fd)

{

    TAPState *s;



    s = qemu_mallocz(sizeof(TAPState));

    if (!s)

        return NULL;

    s->fd = fd;

    s->vc = qemu_new_vlan_client(vlan, tap_receive, s);

    qemu_set_fd_handler(s->fd, tap_send, NULL, s);

    snprintf(s->vc->info_str, sizeof(s->vc->info_str), ""tap: fd=%d"", fd);

    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"void acpi_pcihp_device_unplug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,

                                 DeviceState *dev, Error **errp)

{

    PCIDevice *pdev = PCI_DEVICE(dev);

    int slot = PCI_SLOT(pdev->devfn);

    int bsel = acpi_pcihp_get_bsel(pdev->bus);

    if (bsel < 0) {

        error_setg(errp, ""Unsupported bus. Bus doesn't have property '""

                   ACPI_PCIHP_PROP_BSEL ""' set"");

        return;

    }



    s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);

    acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);

}
",0
Detect whether the following code contains vulnerabilities.,"vg_resource_attach_backing(VuGpu *g,
                           struct virtio_gpu_ctrl_command *cmd)
{
    struct virtio_gpu_simple_resource *res;
    struct virtio_gpu_resource_attach_backing ab;
    int ret;

    VUGPU_FILL_CMD(ab);
    virtio_gpu_bswap_32(&ab, sizeof(ab));

    res = virtio_gpu_find_resource(g, ab.resource_id);
    if (!res) {
        g_critical(""%s: illegal resource specified %d"",
                   __func__, ab.resource_id);
        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
        return;
    }

    ret = vg_create_mapping_iov(g, &ab, cmd, &res->iov);
    if (ret != 0) {
        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;
        return;
    }

    res->iov_cnt = ab.nr_entries;
}",1
Detect whether the following code contains vulnerabilities.,"static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)
{
	struct xfrm_algo *algo;
	struct nlattr *nla;

	nla = nla_reserve(skb, XFRMA_ALG_AUTH,
			  sizeof(*algo) + (auth->alg_key_len + 7) / 8);
	if (!nla)
		return -EMSGSIZE;

	algo = nla_data(nla);
	strcpy(algo->alg_name, auth->alg_name);
	memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);
	algo->alg_key_len = auth->alg_key_len;

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void tcp_chr_accept(void *opaque)

{

    CharDriverState *chr = opaque;

    TCPCharDriver *s = chr->opaque;

    struct sockaddr_in saddr;

#ifndef _WIN32

    struct sockaddr_un uaddr;

#endif

    struct sockaddr *addr;

    socklen_t len;

    int fd;



    for(;;) {

#ifndef _WIN32

	if (s->is_unix) {

	    len = sizeof(uaddr);

	    addr = (struct sockaddr *)&uaddr;

	} else

#endif

	{

	    len = sizeof(saddr);

	    addr = (struct sockaddr *)&saddr;

	}

        fd = accept(s->listen_fd, addr, &len);

        if (fd < 0 && errno != EINTR) {

            return;

        } else if (fd >= 0) {

            if (s->do_telnetopt)

                tcp_chr_telnet_init(fd);

            break;

        }

    }

    socket_set_nonblock(fd);

    if (s->do_nodelay)

        socket_set_nodelay(fd);

    s->fd = fd;

    qemu_set_fd_handler(s->listen_fd, NULL, NULL, NULL);

    tcp_chr_connect(chr);

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_keycode(const char *key)

{

    const KeyDef *p;

    char *endp;

    int ret;



    for(p = key_defs; p->name != NULL; p++) {

        if (!strcmp(key, p->name))

            return p->keycode;

    }

    if (strstart(key, ""0x"", NULL)) {

        ret = strtoul(key, &endp, 0);

        if (*endp == '\0' && ret >= 0x01 && ret <= 0xff)

            return ret;

    }

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t driver_override_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct platform_device *pdev = to_platform_device(dev);
	ssize_t len;

	device_lock(dev);
	len = sprintf(buf, ""%s\n"", pdev->driver_override);
	device_unlock(dev);
	return len;
}",1
Detect whether the following code contains vulnerabilities.,"static int nvdec_vp9_decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)

{

    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;

    void *tmp;



    tmp = av_fast_realloc(ctx->slice_offsets, &ctx->slice_offsets_allocated,

                          (ctx->nb_slices + 1) * sizeof(*ctx->slice_offsets));

    if (!tmp)

        return AVERROR(ENOMEM);

    ctx->slice_offsets = tmp;



    if (!ctx->bitstream)

        ctx->bitstream = (uint8_t*)buffer;



    ctx->slice_offsets[ctx->nb_slices] = buffer - ctx->bitstream;

    ctx->bitstream_len += size;

    ctx->nb_slices++;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"gnome_desktop_thumbnail_factory_save_thumbnail (GnomeDesktopThumbnailFactory *factory,
						GdkPixbuf             *thumbnail,
						const char            *uri,
						time_t                 original_mtime)
{
  char *path;

  path = thumbnail_path (uri, factory->priv->size);
  if (!save_thumbnail (thumbnail, path, uri, original_mtime))
    {
      thumbnail = make_failed_thumbnail ();
      g_free (path);
      path = thumbnail_failed_path (uri);
      save_thumbnail (thumbnail, path, uri, original_mtime);
      g_object_unref (thumbnail);
    }
  g_free (path);
}",0
Detect whether the following code contains vulnerabilities.,"static void btrfs_close_one_device(struct btrfs_device *device)
{
	struct btrfs_fs_devices *fs_devices = device->fs_devices;
	struct btrfs_device *new_device;
	struct rcu_string *name;

	if (device->bdev)
		fs_devices->open_devices--;

	if (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state) &&
	    device->devid != BTRFS_DEV_REPLACE_DEVID) {
		list_del_init(&device->dev_alloc_list);
		fs_devices->rw_devices--;
	}

	if (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))
		fs_devices->missing_devices--;

	btrfs_close_bdev(device);

	new_device = btrfs_alloc_device(NULL, &device->devid,
					device->uuid);
	BUG_ON(IS_ERR(new_device)); /* -ENOMEM */

	/* Safe because we are under uuid_mutex */
	if (device->name) {
		name = rcu_string_strdup(device->name->str, GFP_NOFS);
		BUG_ON(!name); /* -ENOMEM */
		rcu_assign_pointer(new_device->name, name);
	}

	list_replace_rcu(&device->dev_list, &new_device->dev_list);
	new_device->fs_devices = device->fs_devices;

	call_rcu(&device->rcu, free_device_rcu);
}",0
Detect whether the following code contains vulnerabilities.,"static void __exit ipgre_fini(void)
{
	rtnl_link_unregister(&ipgre_tap_ops);
	rtnl_link_unregister(&ipgre_link_ops);
	unregister_pernet_device(&ipgre_net_ops);
	if (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)
		printk(KERN_INFO ""ipgre close: can't remove protocol\n"");
}",1
Detect whether the following code contains vulnerabilities.,"TIFFNumberOfStrips(TIFF* tif)
{
	TIFFDirectory *td = &tif->tif_dir;
	uint32 nstrips;

    /* If the value was already computed and store in td_nstrips, then return it,
       since ChopUpSingleUncompressedStrip might have altered and resized the
       since the td_stripbytecount and td_stripoffset arrays to the new value
       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in
       tif_dirread.c ~line 3612.
       See http://bugzilla.maptools.org/show_bug.cgi?id=2587 */
    if( td->td_nstrips )
        return td->td_nstrips;

	nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :
	     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));
	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,
		    ""TIFFNumberOfStrips"");
	return (nstrips);
}",1
Detect whether the following code contains vulnerabilities.,"void exec_start_incoming_migration(const char *command, Error **errp)

{

    QEMUFile *f;



    DPRINTF(""Attempting to start an incoming migration\n"");

    f = qemu_popen_cmd(command, ""r"");

    if(f == NULL) {

        error_setg_errno(errp, errno, ""failed to popen the migration source"");

        return;

    }



    qemu_set_fd_handler2(qemu_get_fd(f), NULL,

			 exec_accept_incoming_migration, NULL, f);

}
",1
Detect whether the following code contains vulnerabilities.,"static int proxy_utimensat(FsContext *s, V9fsPath *fs_path,

                           const struct timespec *buf)

{

    int retval;

    retval = v9fs_request(s->private, T_UTIME, NULL, ""sqqqq"",

                          fs_path,

                          buf[0].tv_sec, buf[0].tv_nsec,

                          buf[1].tv_sec, buf[1].tv_nsec);

    if (retval < 0) {

        errno = -retval;

    }

    return retval;

}
",0
Detect whether the following code contains vulnerabilities.,"TEST_F(ZNCTest, AwayNotify) {
    auto znc = Run();
    auto ircd = ConnectIRCd();
    auto client = ConnectClient();
    client.Write(""CAP LS"");
    client.Write(""PASS :hunter2"");
    client.Write(""NICK nick"");
    client.Write(""USER user/test x x :x"");
    QByteArray cap_ls;
    client.ReadUntilAndGet("" LS :"", cap_ls);
    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(""cap-notify""), Not(HasSubstr(""away-notify""))));
    client.Write(""CAP REQ :cap-notify"");
    client.ReadUntil(""ACK :cap-notify"");
    client.Write(""CAP END"");
    client.ReadUntil("" 001 "");
    ircd.ReadUntil(""USER"");
    ircd.Write(""CAP user LS :away-notify"");
    ircd.ReadUntil(""CAP REQ :away-notify"");
    ircd.Write(""CAP user ACK :away-notify"");
    ircd.ReadUntil(""CAP END"");
    ircd.Write("":server 001 user :welcome"");
    client.ReadUntil(""CAP user NEW :away-notify"");
    client.Write(""CAP REQ :away-notify"");
    client.ReadUntil(""ACK :away-notify"");
    ircd.Write("":x!y@z AWAY :reason"");
    client.ReadUntil("":x!y@z AWAY :reason"");
    ircd.Close();
    client.ReadUntil(""DEL :away-notify"");
}",1
Detect whether the following code contains vulnerabilities.,"int qemu_ram_foreach_block(RAMBlockIterFunc func, void *opaque)
{
    RAMBlock *block;
    int ret = 0;

    rcu_read_lock();
    RAMBLOCK_FOREACH(block) {
        ret = func(block->idstr, block->host, block->offset,
                   block->used_length, opaque);
        if (ret) {
            break;
        }
    }
    rcu_read_unlock();
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *conn, itt_t itt)
{
	struct iscsi_session *session = conn->session;
	int i;

	if (itt == RESERVED_ITT)
		return NULL;

	if (session->tt->parse_pdu_itt)
		session->tt->parse_pdu_itt(conn, itt, &i, NULL);
	else
		i = get_itt(itt);
	if (i >= session->cmds_max)
		return NULL;

	return session->cmds[i];
}",0
Detect whether the following code contains vulnerabilities.,"static void m5206_mbar_writew(void *opaque, target_phys_addr_t offset,

                              uint32_t value)

{

    m5206_mbar_state *s = (m5206_mbar_state *)opaque;

    int width;

    offset &= 0x3ff;

    if (offset > 0x200) {

        hw_error(""Bad MBAR write offset 0x%x"", (int)offset);

    }

    width = m5206_mbar_width[offset >> 2];

    if (width > 2) {

        uint32_t tmp;

        tmp = m5206_mbar_readl(opaque, offset & ~3);

        if (offset & 3) {

            tmp = (tmp & 0xffff0000) | value;

        } else {

            tmp = (tmp & 0x0000ffff) | (value << 16);

        }

        m5206_mbar_writel(opaque, offset & ~3, tmp);

        return;

    } else if (width < 2) {

        m5206_mbar_writeb(opaque, offset, value >> 8);

        m5206_mbar_writeb(opaque, offset + 1, value & 0xff);

        return;

    }

    m5206_mbar_write(s, offset, value, 2);

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_done(CPUSPARCState *env)

{

    trap_state *tsptr = cpu_tsptr(env);



    env->pc = tsptr->tnpc;

    env->npc = tsptr->tnpc + 4;

    cpu_put_ccr(env, tsptr->tstate >> 32);

    env->asi = (tsptr->tstate >> 24) & 0xff;

    cpu_change_pstate(env, (tsptr->tstate >> 8) & 0xf3f);

    cpu_put_cwp64(env, tsptr->tstate & 0xff);

    if (cpu_has_hypervisor(env)) {

        uint32_t new_gl = (tsptr->tstate >> 40) & 7;

        env->hpstate = env->htstate[env->tl];

        cpu_gl_switch_gregs(env, new_gl);

        env->gl = new_gl;

    }

    env->tl--;



    trace_win_helper_done(env->tl);



#if !defined(CONFIG_USER_ONLY)

    if (cpu_interrupts_enabled(env)) {


        cpu_check_irqs(env);


    }

#endif

}",1
Detect whether the following code contains vulnerabilities.,"void __iomem *hns_rcb_common_get_vaddr(struct rcb_common_cb *rcb_common)
{
	struct dsaf_device *dsaf_dev = rcb_common->dsaf_dev;

	return dsaf_dev->ppe_base + RCB_COMMON_REG_OFFSET;
}",0
Detect whether the following code contains vulnerabilities.,"x509_error_string( void )
{
	return _globus_error_message;
}",0
Detect whether the following code contains vulnerabilities.,"static unsigned char *createIntList() {
    unsigned char *zl = ziplistNew();
    char buf[32];

    sprintf(buf, ""100"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
    sprintf(buf, ""128000"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
    sprintf(buf, ""-100"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
    sprintf(buf, ""4294967296"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
    sprintf(buf, ""non integer"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
    sprintf(buf, ""much much longer non integer"");
    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
    return zl;
}",0
Detect whether the following code contains vulnerabilities.,"long do_rt_sigreturn(CPUState *env)

{

    fprintf(stderr, ""do_rt_sigreturn: not implemented\n"");

    return -TARGET_ENOSYS;

}
",1
Detect whether the following code contains vulnerabilities.,"static int cls_rgw_set_bucket_resharding(cls_method_context_t hctx, bufferlist *in,  bufferlist *out)
{
  cls_rgw_set_bucket_resharding_op op;

  bufferlist::iterator in_iter = in->begin();
  try {
    ::decode(op, in_iter);
  } catch (buffer::error& err) {
    CLS_LOG(1, ""ERROR: cls_rgw_set_bucket_resharding: failed to decode entry\n"");
    return -EINVAL;
  }

  bufferlist bl;
  ::encode(true, bl);
  int ret = cls_cxx_setxattr(hctx, resharding_attr.c_str(), &bl);
  if (ret < 0) {
    CLS_LOG(0, ""ERROR: %s(): cls_cxx_setxattr (attr=%s) returned %d"", __func__, resharding_attr.c_str(), ret);
    return ret;
  }

  ret = cls_cxx_write(hctx, 0, op.entry.data.length(), &op.entry.data);
  if (ret < 0) {
    CLS_LOG(0, ""ERROR: %s(): cls_cxx_write returned %d"", __func__, ret);
    return ret;
  }

  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void xen_be_unbind_evtchn(struct XenDevice *xendev)

{

    if (xendev->local_port == -1) {

        return;

    }

    qemu_set_fd_handler(xc_evtchn_fd(xendev->evtchndev), NULL, NULL, NULL);

    xc_evtchn_unbind(xendev->evtchndev, xendev->local_port);

    xen_be_printf(xendev, 2, ""unbind evtchn port %d\n"", xendev->local_port);

    xendev->local_port = -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vnc_tls_handshake_io(void *opaque) {

    struct VncState *vs = (struct VncState *)opaque;



    VNC_DEBUG(""Handshake IO continue\n"");

    vnc_start_vencrypt_handshake(vs);

}
",0
Detect whether the following code contains vulnerabilities.,"void cuda_init (int *cuda_mem_index, qemu_irq irq)

{

    struct tm tm;

    CUDAState *s = &cuda_state;



    s->irq = irq;



    s->timers[0].index = 0;

    s->timers[0].timer = qemu_new_timer(vm_clock, cuda_timer1, s);



    s->timers[1].index = 1;



    qemu_get_timedate(&tm, RTC_OFFSET);

    s->tick_offset = mktimegm(&tm);



    s->adb_poll_timer = qemu_new_timer(vm_clock, cuda_adb_poll, s);

    *cuda_mem_index = cpu_register_io_memory(0, cuda_read, cuda_write, s);

    register_savevm(""cuda"", -1, 1, cuda_save, cuda_load, s);

    qemu_register_reset(cuda_reset, s);

    cuda_reset(s);

}
",1
Detect whether the following code contains vulnerabilities.,"static int sk_alloc_security(struct sock *sk, int family, gfp_t priority)
{
	struct sk_security_struct *ssec;

	ssec = kzalloc(sizeof(*ssec), priority);
	if (!ssec)
		return -ENOMEM;

	ssec->peer_sid = SECINITSID_UNLABELED;
	ssec->sid = SECINITSID_UNLABELED;
	sk->sk_security = ssec;

	selinux_netlbl_sk_security_reset(ssec);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"PPC_OP(cmpli)

{

    if (T0 < PARAM(1)) {

        T0 = 0x08;

    } else if (T0 > PARAM(1)) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static bool cpu_thread_is_idle(CPUState *cpu)

{

    if (cpu->stop || cpu->queued_work_first) {

        return false;

    }

    if (cpu->stopped || !runstate_is_running()) {

        return true;

    }

    if (!cpu->halted || qemu_cpu_has_work(cpu) ||

        kvm_async_interrupts_enabled()) {

        return false;

    }

    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"mysql_free_result(MYSQL_RES *result)
{
  DBUG_ENTER(""mysql_free_result"");
  DBUG_PRINT(""enter"",(""mysql_res: 0x%lx"", (long) result));
  if (result)
  {
    MYSQL *mysql= result->handle;
    if (mysql)
    {
      if (mysql->unbuffered_fetch_owner == &result->unbuffered_fetch_cancelled)
        mysql->unbuffered_fetch_owner= 0;
      if (mysql->status == MYSQL_STATUS_USE_RESULT)
      {
        (*mysql->methods->flush_use_result)(mysql, FALSE);
        mysql->status=MYSQL_STATUS_READY;
        if (mysql->unbuffered_fetch_owner)
          *mysql->unbuffered_fetch_owner= TRUE;
      }
    }
    free_rows(result->data);
    if (result->fields)
      free_root(&result->field_alloc,MYF(0));
    my_free(result->row);
    my_free(result);
  }
  DBUG_VOID_RETURN;
}",0
Detect whether the following code contains vulnerabilities.,"static int get_int32_equal(QEMUFile *f, void *pv, size_t size,

                           VMStateField *field)

{

    int32_t *v = pv;

    int32_t v2;

    qemu_get_sbe32s(f, &v2);



    if (*v == v2) {

        return 0;


    error_report(""%"" PRIx32 "" != %"" PRIx32, *v, v2);




    return -EINVAL;
",1
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateInt( int64_t num )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_Number;
		item->valuefloat = num;
		item->valueint = num;
	}
	return item;
}",1
Detect whether the following code contains vulnerabilities.,"static int decode_i_block(FourXContext *f, DCTELEM *block){
    int code, i, j, level, val;
    /* DC coef */
    val = get_vlc2(&f->pre_gb, f->pre_vlc.table, ACDC_VLC_BITS, 3);
    if (val>>4){
        av_log(f->avctx, AV_LOG_ERROR, ""error dc run != 0\n"");
    if(val)
        val = get_xbits(&f->gb, val);
    val = val * dequant_table[0] + f->last_dc;
    f->last_dc =
    block[0] = val;
    /* AC coefs */
    i = 1;
    for(;;) {
        code = get_vlc2(&f->pre_gb, f->pre_vlc.table, ACDC_VLC_BITS, 3);
        /* EOB */
        if (code == 0)
            break;
        if (code == 0xf0) {
            i += 16;
        } else {
            level = get_xbits(&f->gb, code & 0xf);
            i += code >> 4;
            if (i >= 64) {
                av_log(f->avctx, AV_LOG_ERROR, ""run %d oveflow\n"", i);
                return 0;
            j= ff_zigzag_direct[i];
            block[j] = level * dequant_table[j];
            i++;
            if (i >= 64)
                break;
    return 0;",1
Detect whether the following code contains vulnerabilities.,"DocumentSourceLookUp::DocumentSourceLookUp(NamespaceString fromNs,
                                           std::string as,
                                           const boost::intrusive_ptr<ExpressionContext>& expCtx)
    : DocumentSource(kStageName, expCtx),
      _fromNs(std::move(fromNs)),
      _as(std::move(as)),
      _variables(expCtx->variables),
      _variablesParseState(expCtx->variablesParseState.copyWith(_variables.useIdGenerator())) {
    const auto& resolvedNamespace = expCtx->getResolvedNamespace(_fromNs);
    _resolvedNs = resolvedNamespace.ns;
    _resolvedPipeline = resolvedNamespace.pipeline;
    _fromExpCtx = expCtx->copyWith(_resolvedNs);

    _fromExpCtx->subPipelineDepth += 1;
    uassert(ErrorCodes::MaxSubPipelineDepthExceeded,
            str::stream() << ""Maximum number of nested $lookup sub-pipelines exceeded. Limit is ""
                          << kMaxSubPipelineDepth,
            _fromExpCtx->subPipelineDepth <= kMaxSubPipelineDepth);
}",1
Detect whether the following code contains vulnerabilities.,"TCGv_i64 tcg_global_reg_new_i64(int reg, const char *name)

{

    int idx;



    idx = tcg_global_reg_new_internal(TCG_TYPE_I64, reg, name);

    return MAKE_TCGV_I64(idx);

}
",0
Detect whether the following code contains vulnerabilities.,"static bool spapr_drc_needed(void *opaque)

{

    sPAPRDRConnector *drc = (sPAPRDRConnector *)opaque;

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    /* If no dev is plugged in there is no need to migrate the DRC state */

    if (!drc->dev) {

        return false;

    }



    /*

     * We need to migrate the state if it's not equal to the expected

     * long-term state, which is the same as the coldplugged initial

     * state */

    return (drc->state != drck->ready_state);

}
",1
Detect whether the following code contains vulnerabilities.,"void block_job_cancel_sync(BlockJob *job)

{

    BlockDriverState *bs = job->bs;



    assert(bs->job == job);

    block_job_cancel(job);

    while (bs->job != NULL && bs->job->busy) {

        qemu_aio_wait();

    }

}
",1
Detect whether the following code contains vulnerabilities.,"TEST_F(HttpConnectionManagerConfigTest, NormalizePathFalse) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  route_config:
    name: local_route
  normalize_path: false
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_,
              featureEnabled(""http_connection_manager.normalize_path"", An<uint64_t>()))
      .Times(0);
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_FALSE(config.shouldNormalizePath());
}",1
Detect whether the following code contains vulnerabilities.,"struct ldb_message *ldb_msg_copy(TALLOC_CTX *mem_ctx,
				 const struct ldb_message *msg)
{
	struct ldb_message *msg2;
	unsigned int i, j;

	msg2 = ldb_msg_copy_shallow(mem_ctx, msg);
	if (msg2 == NULL) return NULL;

	if (msg2->dn != NULL) {
		msg2->dn = ldb_dn_copy(msg2, msg2->dn);
		if (msg2->dn == NULL) goto failed;
	}

	for (i=0;i<msg2->num_elements;i++) {
		struct ldb_message_element *el = &msg2->elements[i];
		struct ldb_val *values = el->values;
		el->name = talloc_strdup(msg2->elements, el->name);
		if (el->name == NULL) goto failed;
		el->values = talloc_array(msg2->elements, struct ldb_val, el->num_values);
		if (el->values == NULL) goto failed;
		for (j=0;j<el->num_values;j++) {
			el->values[j] = ldb_val_dup(el->values, &values[j]);
			if (el->values[j].data == NULL && values[j].length != 0) {
				goto failed;
			}
		}
	}

	return msg2;

failed:
	talloc_free(msg2);
	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    // Insert key and tuples into the map
    map_.insert({key, std::move(*tuple)});

    notify_removers();

    return Status::OK();
  }",1
Detect whether the following code contains vulnerabilities.,"static int qemu_chr_open_udp(QemuOpts *opts, CharDriverState **_chr)

{

    CharDriverState *chr = NULL;

    NetCharDriver *s = NULL;

    int fd = -1;

    int ret;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(NetCharDriver));



    fd = inet_dgram_opts(opts);

    if (fd < 0) {

        fprintf(stderr, ""inet_dgram_opts failed\n"");

        ret = -errno;

        goto return_err;

    }



    s->fd = fd;

    s->bufcnt = 0;

    s->bufptr = 0;

    chr->opaque = s;

    chr->chr_write = udp_chr_write;

    chr->chr_update_read_handler = udp_chr_update_read_handler;

    chr->chr_close = udp_chr_close;



    *_chr = chr;

    return 0;



return_err:

    g_free(chr);

    g_free(s);

    if (fd >= 0) {

        closesocket(fd);

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)
{
    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);
    double rounded;

    if (code == gs_error_undefinedresult) {
        /* The CTM is degenerate.
           Can't know the distance in user space.
           Set zero because we believe it is not important for rendering.
           We want to copy the text to PDF to make it searchable.
           Bug 689006.
         */
        pdist->x = pdist->y = 0;
    } else if (code < 0)
        return code;
    /* If the distance is very close to integers, round it. */
    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)
        pdist->x = rounded;
    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)
        pdist->y = rounded;
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void tftp_input(struct sockaddr_storage *srcsas, struct mbuf *m)
{
    struct tftp_t *tp = (struct tftp_t *)m->m_data;

    switch (ntohs(tp->tp_op)) {
    case TFTP_RRQ:
        tftp_handle_rrq(m->slirp, srcsas, tp, m->m_len);
        break;

    case TFTP_ACK:
        tftp_handle_ack(m->slirp, srcsas, tp, m->m_len);
        break;

    case TFTP_ERROR:
        tftp_handle_error(m->slirp, srcsas, tp, m->m_len);
        break;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void virgl_cmd_resource_flush(VirtIOGPU *g,
                                     struct virtio_gpu_ctrl_command *cmd)
{
    struct virtio_gpu_resource_flush rf;
    int i;

    VIRTIO_GPU_FILL_CMD(rf);
    trace_virtio_gpu_cmd_res_flush(rf.resource_id,
                                   rf.r.width, rf.r.height, rf.r.x, rf.r.y);

    for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {
        if (g->scanout[i].resource_id != rf.resource_id) {
            continue;
        }
        virtio_gpu_rect_update(g, i, rf.r.x, rf.r.y, rf.r.width, rf.r.height);
    }
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_get_timedate(struct tm *tm, int offset)

{

    time_t ti;



    time(&ti);

    ti += offset;

    if (rtc_date_offset == -1) {

        if (rtc_utc)

            gmtime_r(&ti, tm);

        else

            localtime_r(&ti, tm);

    } else {

        ti -= rtc_date_offset;

        gmtime_r(&ti, tm);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {
    const char *cbuf = buf;
#ifdef __APPLE__
    int flags = 0;
#else
    int flags = MSG_NOSIGNAL;
#endif

    while ( len ) {
        int sent = send( conn->sock, cbuf, len, flags );
        if ( sent == -1 ) {
            if (errno == EPIPE)
                conn->connected = 0;
            __mongo_set_error( conn, MONGO_IO_ERROR, strerror( errno ), errno );
            return MONGO_ERROR;
        }
        cbuf += sent;
        len -= sent;
    }

    return MONGO_OK;
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_input_event_sync(void)

{

    QemuInputHandlerState *s;



    if (!runstate_is_running() && !runstate_check(RUN_STATE_SUSPENDED)) {

        return;

    }



    trace_input_event_sync();



    QTAILQ_FOREACH(s, &handlers, node) {

        if (!s->events) {

            continue;

        }

        if (s->handler->sync) {

            s->handler->sync(s->dev);

        }

        s->events = 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"    if (dirName == NULL) {
        return WS_MEMORY_E;
    }",0
Detect whether the following code contains vulnerabilities.,"static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)
{
	u8 *buffer;
	int err;

	buffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);
	if (!buffer)
		return -ENOMEM;

	buffer[0] = 0;
	buffer[1] = !!loaded;

	err = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,
				    PCAN_USBPRO_FCT_DRVLD, buffer,
				    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);
	kfree(buffer);

	return err;
}",1
Detect whether the following code contains vulnerabilities.,"static int mov_read_elst(MOVContext *c, ByteIOContext *pb, MOVAtom atom)

{

    MOVStreamContext *sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;

    int i, edit_count;



    get_byte(pb); /* version */

    get_be24(pb); /* flags */

    edit_count= sc->edit_count = get_be32(pb);     /* entries */



    for(i=0; i<edit_count; i++){

        int time;

        get_be32(pb); /* Track duration */

        time = get_be32(pb); /* Media time */

        get_be32(pb); /* Media rate */

        if (time != 0)

            av_log(c->fc, AV_LOG_WARNING, ""edit list not starting at 0, ""

                   ""a/v desync might occur, patch welcome\n"");

    }

    dprintf(c->fc, ""track[%i].edit_count = %i\n"", c->fc->nb_streams-1, sc->edit_count);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"  uint32_t readMapEnd() {
    T_VIRTUAL_CALL();
    return readMapEnd_virt();
  }",0
Detect whether the following code contains vulnerabilities.,"static void ehci_mem_writew(void *ptr, target_phys_addr_t addr, uint32_t val)

{

    fprintf(stderr, ""EHCI doesn't handle 16-bit writes to MMIO\n"");

    exit(1);

}
",1
Detect whether the following code contains vulnerabilities.,"void av_frame_unref(AVFrame *frame)
{
    int i;
    wipe_side_data(frame);
    for (i = 0; i < FF_ARRAY_ELEMS(frame->buf); i++)
        av_buffer_unref(&frame->buf[i]);
    for (i = 0; i < frame->nb_extended_buf; i++)
        av_buffer_unref(&frame->extended_buf[i]);
    av_freep(&frame->extended_buf);
    av_dict_free(&frame->metadata);
    av_buffer_unref(&frame->qp_table_buf);
    get_frame_defaults(frame);
}",1
Detect whether the following code contains vulnerabilities.,"LUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {
  const char *name;
  lua_lock(L);
  if (ar == NULL) {  /* information about non-active function? */
    if (!isLfunction(s2v(L->top - 1)))  /* not a Lua function? */
      name = NULL;
    else  /* consider live variables at function start (parameters) */
      name = luaF_getlocalname(clLvalue(s2v(L->top - 1))->p, n, 0);
  }
  else {  /* active function; get information through 'ar' */
    StkId pos = NULL;  /* to avoid warnings */
    name = luaG_findlocal(L, ar->i_ci, n, &pos);
    if (name) {
      setobjs2s(L, L->top, pos);
      api_incr_top(L);
    }
  }
  lua_unlock(L);
  return name;
}",0
Detect whether the following code contains vulnerabilities.,"int ff_j2k_dwt_init(DWTContext *s, uint16_t border[2][2], int decomp_levels, int type)
{
    int i, j, lev = decomp_levels, maxlen,
        b[2][2];

    if (decomp_levels >= FF_DWT_MAX_DECLVLS)
        return AVERROR_INVALIDDATA;
    s->ndeclevels = decomp_levels;
    s->type = type;

    for (i = 0; i < 2; i++)
        for(j = 0; j < 2; j++)
            b[i][j] = border[i][j];

    maxlen = FFMAX(b[0][1] - b[0][0],
                   b[1][1] - b[1][0]);

    while(--lev >= 0){
        for (i = 0; i < 2; i++){
            s->linelen[lev][i] = b[i][1] - b[i][0];
            s->mod[lev][i] = b[i][0] & 1;
            for (j = 0; j < 2; j++)
                b[i][j] = (b[i][j] + 1) >> 1;
        }
    }
    if (type == FF_DWT97)
        s->linebuf = av_malloc((maxlen + 12) * sizeof(float));
    else if (type == FF_DWT53)
        s->linebuf = av_malloc((maxlen + 6) * sizeof(int));
    else
        return -1;

    if (!s->linebuf)
        return AVERROR(ENOMEM);

    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void cm_get_ack_delay(struct cm_device *cm_dev)
{
	struct ib_device_attr attr;

	if (ib_query_device(cm_dev->ib_device, &attr))
		cm_dev->ack_delay = 0; /* acks will rely on packet life time */
	else
		cm_dev->ack_delay = attr.local_ca_ack_delay;
}",0
Detect whether the following code contains vulnerabilities.,"RAMBlock *qemu_ram_block_from_host(struct uc_struct *uc, void *ptr,
                                   bool round_offset, ram_addr_t *offset)
{
    RAMBlock *block;
    uint8_t *host = ptr;

    block = uc->ram_list.mru_block;
    if (block && block->host && host - block->host < block->max_length) {
        goto found;
    }

    RAMBLOCK_FOREACH(block) {
        /* This case append when the block is not mapped. */
        if (block->host == NULL) {
            continue;
        }
        if (host - block->host < block->max_length) {
            goto found;
        }
    }

    return NULL;

found:
    *offset = (host - block->host);
    if (round_offset) {
        *offset &= TARGET_PAGE_MASK;
    }
    return block;
}",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_pp_fd(int fd)

{

    CharDriverState *chr;

    ParallelCharDriver *drv;



    if (ioctl(fd, PPCLAIM) < 0) {

        close(fd);

        return NULL;

    }



    drv = g_malloc0(sizeof(ParallelCharDriver));

    drv->fd = fd;

    drv->mode = IEEE1284_MODE_COMPAT;



    chr = qemu_chr_alloc();

    chr->chr_write = null_chr_write;

    chr->chr_ioctl = pp_ioctl;

    chr->chr_close = pp_close;

    chr->opaque = drv;



    return chr;

}
",1
Detect whether the following code contains vulnerabilities.,"string RtmpProtocol::get_C1_key(const uint8_t *ptr){
    /* 764bytes key结构
    random-data: (offset)bytes
    key-data: 128bytes
    random-data: (764-offset-128-4)bytes
    offset: 4bytes
     */
    int offset = 0;
    for (int i = C1_SCHEMA_SIZE - C1_OFFSET_SIZE; i < C1_SCHEMA_SIZE; ++i) {
        offset += ptr[i];
    }
    offset %= (C1_SCHEMA_SIZE - C1_KEY_SIZE - C1_OFFSET_SIZE);
    string key((char *) ptr + offset, C1_KEY_SIZE);
    //DebugL << ""key offset:"" << offset << "",key:"" << hexdump(key.data(),key.size());
    return key;
}",0
Detect whether the following code contains vulnerabilities.,"void FileBody::Dump(std::ostream& os, const std::string& prefix) const {
  os << prefix << ""<file: "" << path_.string() << "">"" << std::endl;
}",1
Detect whether the following code contains vulnerabilities.,"static void celt_search_for_dual_stereo(OpusPsyContext *s, CeltFrame *f)
{
    float td1, td2;
    f->dual_stereo = 0;
    bands_dist(s, f, &td1);
    f->dual_stereo = 1;
    bands_dist(s, f, &td2);
    f->dual_stereo = td2 < td1;
    s->dual_stereo_used += td2 < td1;
}",1
Detect whether the following code contains vulnerabilities.,"file_asynch_zero (struct rw *rw, struct command *command,
                  nbd_completion_callback cb, bool allocate)
{
  int dummy = 0;

  if (!file_synch_zero (rw, command->offset, command->slice.len, allocate))
    return false;
  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
  return true;
}",1
Detect whether the following code contains vulnerabilities.,"static void vhost_vdpa_config_put(struct vhost_vdpa *v)
{
	if (v->config_ctx)
		eventfd_ctx_put(v->config_ctx);
}",1
Detect whether the following code contains vulnerabilities.,"static int ehci_init_transfer(EHCIPacket *p)

{

    uint32_t cpage, offset, bytes, plen;

    dma_addr_t page;

    USBBus *bus = &p->queue->ehci->bus;

    BusState *qbus = BUS(bus);



    cpage  = get_field(p->qtd.token, QTD_TOKEN_CPAGE);

    bytes  = get_field(p->qtd.token, QTD_TOKEN_TBYTES);

    offset = p->qtd.bufptr[0] & ~QTD_BUFPTR_MASK;

    qemu_sglist_init(&p->sgl, qbus->parent, 5, p->queue->ehci->as);



    while (bytes > 0) {

        if (cpage > 4) {

            fprintf(stderr, ""cpage out of range (%d)\n"", cpage);

            return -1;

        }



        page  = p->qtd.bufptr[cpage] & QTD_BUFPTR_MASK;

        page += offset;

        plen  = bytes;

        if (plen > 4096 - offset) {

            plen = 4096 - offset;

            offset = 0;

            cpage++;

        }



        qemu_sglist_add(&p->sgl, page, plen);

        bytes -= plen;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"TPMU_SCHEME_KEYEDHASH_Unmarshal(TPMU_SCHEME_KEYEDHASH *target, BYTE **buffer, INT32 *size, UINT32 selector)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    switch (selector) {
#if ALG_HMAC
      case TPM_ALG_HMAC:
	rc = TPMS_SCHEME_HMAC_Unmarshal(&target->hmac, buffer, size);
	break;
#endif
#if ALG_XOR
      case TPM_ALG_XOR:
	rc = TPMS_SCHEME_XOR_Unmarshal(&target->xorr, buffer, size);
	break;
#endif
      case TPM_ALG_NULL:
	break;
      default:
	rc = TPM_RC_SELECTOR;
    }
    return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int rb_time_cnt(unsigned long val)
{
	return (val >> RB_TIME_SHIFT) & 3;
}",0
Detect whether the following code contains vulnerabilities.,"static void buffer_reset(Buffer *buffer)

{

	buffer->offset = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"process_palette(STREAM s)
{
	COLOURENTRY *entry;
	COLOURMAP map;
	RD_HCOLOURMAP hmap;
	int i;

	in_uint8s(s, 2);	/* pad */
	in_uint16_le(s, map.ncolours);
	in_uint8s(s, 2);	/* pad */

	map.colours = (COLOURENTRY *) xmalloc(sizeof(COLOURENTRY) * map.ncolours);

	logger(Graphics, Debug, ""process_palette(), colour count %d"", map.ncolours);

	for (i = 0; i < map.ncolours; i++)
	{
		entry = &map.colours[i];
		in_uint8(s, entry->red);
		in_uint8(s, entry->green);
		in_uint8(s, entry->blue);
	}

	hmap = ui_create_colourmap(&map);
	ui_set_colourmap(hmap);

	xfree(map.colours);
}",0
Detect whether the following code contains vulnerabilities.,"static int blk_root_inactivate(BdrvChild *child)

{

    BlockBackend *blk = child->opaque;



    if (blk->disable_perm) {

        return 0;

    }



    /* Only inactivate BlockBackends for guest devices (which are inactive at

     * this point because the VM is stopped) and unattached monitor-owned

     * BlockBackends. If there is still any other user like a block job, then

     * we simply can't inactivate the image. */

    if (!blk->dev && !blk_name(blk)[0]) {

        return -EPERM;

    }



    blk->disable_perm = true;

    if (blk->root) {

        bdrv_child_try_set_perm(blk->root, 0, BLK_PERM_ALL, &error_abort);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"_g_file_is_external_link (GFile      *file,
			  GFile      *destination,
			  GHashTable *external_links)
{
	GFileInfo *info;
	gboolean   external;

	if (g_hash_table_lookup (external_links, file) != NULL)
		return TRUE;

	info = g_file_query_info (file,
				  G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,
				  G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
				  NULL,
				  NULL);

	if (info == NULL)
		return FALSE;

	external = FALSE;

	if (g_file_info_get_is_symlink (info)) {
		if (_symlink_is_external_to_destination (file,
							 g_file_info_get_symlink_target (info),
							 destination,
							 external_links))
		{
			g_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));
			external = TRUE;
		}
	}

	g_object_unref (info);

	return external;
}",1
Detect whether the following code contains vulnerabilities.,"static void gd_menu_switch_vc(GtkMenuItem *item, void *opaque)
{
    GtkDisplayState *s = opaque;
    VirtualConsole *vc = gd_vc_find_by_menu(s);
    GtkNotebook *nb = GTK_NOTEBOOK(s->notebook);
    gint page;
    gtk_release_modifiers(s);
    if (vc) {
        page = gtk_notebook_page_num(nb, vc->tab_item);
        gtk_notebook_set_current_page(nb, page);
        gtk_widget_grab_focus(vc->focus);
    }
}",1
Detect whether the following code contains vulnerabilities.,"header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = 0 ;
		psf->header [psf->headindex++] = 0 ;
		psf->header [psf->headindex++] = 0 ;
		psf->header [psf->headindex++] = 0 ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
} /* header_put_be_8byte */",1
Detect whether the following code contains vulnerabilities.,"GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)
{
	u8 iv_size;
	GF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;

	ISOM_DECREASE_SIZE(ptr, 3);

	gf_bs_read_u8(bs); //reserved

	if (!ptr->version) {
		gf_bs_read_u8(bs); //reserved
	} else {
		ptr->crypt_byte_block = gf_bs_read_int(bs, 4);
		ptr->skip_byte_block = gf_bs_read_int(bs, 4);
	}
	ptr->isProtected = gf_bs_read_u8(bs);


	ISOM_DECREASE_SIZE(ptr, 17);

	ptr->key_info[0] = 0;
	ptr->key_info[1] = 0;
	ptr->key_info[2] = 0;
	ptr->key_info[3] = iv_size = gf_bs_read_u8(bs);
	gf_bs_read_data(bs, ptr->key_info+4, 16);
	if (!iv_size && ptr->isProtected) {
		ISOM_DECREASE_SIZE(ptr, 1);
		iv_size = ptr->key_info[20] = gf_bs_read_u8(bs);
		ISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);
		gf_bs_read_data(bs, ptr->key_info+21, iv_size);
	}
	return GF_OK;
}",1
Detect whether the following code contains vulnerabilities.,"void xrangeGenericCommand(client *c, int rev) {
    robj *o;
    stream *s;
    streamID startid, endid;
    long long count = 0;
    robj *startarg = rev ? c->argv[3] : c->argv[2];
    robj *endarg = rev ? c->argv[2] : c->argv[3];

    if (streamParseIDOrReply(c,startarg,&startid,0) == C_ERR) return;
    if (streamParseIDOrReply(c,endarg,&endid,UINT64_MAX) == C_ERR) return;

    /* Parse the COUNT option if any. */
    if (c->argc > 4) {
        for (int j = 4; j < c->argc; j++) {
            int additional = c->argc-j-1;
            if (strcasecmp(c->argv[j]->ptr,""COUNT"") == 0 && additional >= 1) {
                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&count,NULL)
                    != C_OK) return;
                if (count < 0) count = 0;
                j++; /* Consume additional arg. */
            } else {
                addReply(c,shared.syntaxerr);
                return;
            }
        }
    }

    /* Return the specified range to the user. */
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptymultibulk)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    s = o->ptr;
    streamReplyWithRange(c,s,&startid,&endid,count,rev,NULL,NULL,0,NULL);
}",0
Detect whether the following code contains vulnerabilities.,"static int scsi_get_bus(struct request_queue *q, int __user *p)
{
	return put_user(0, p);
}",0
Detect whether the following code contains vulnerabilities.,"long ssl2_ctx_callback_ctrl(SSL_CTX *ctx, int cmd, void (*fp)(void))
	{
	return(0);
	}",0
Detect whether the following code contains vulnerabilities.,"static int getlocalattribute (LexState *ls) {
  /* ATTRIB -> ['<' Name '>'] */
  if (testnext(ls, '<')) {
    const char *attr = getstr(str_checkname(ls));
    checknext(ls, '>');
    if (strcmp(attr, ""const"") == 0)
      return RDKCONST;  /* read-only variable */
    else if (strcmp(attr, ""close"") == 0)
      return RDKTOCLOSE;  /* to-be-closed variable */
    else
      luaK_semerror(ls,
        luaO_pushfstring(ls->L, ""unknown attribute '%s'"", attr));
  }
  return VDKREG;  /* regular variable */
}",0
Detect whether the following code contains vulnerabilities.,"static void vnc_dpy_setdata(DisplayState *ds)

{

    /* We don't have to do anything */

}
",0
Detect whether the following code contains vulnerabilities.,"void virtio_queue_update_rings(VirtIODevice *vdev, int n)

{

    VRing *vring = &vdev->vq[n].vring;



    if (!vring->desc) {

        /* not yet setup -> nothing to do */

        return;

    }

    vring->avail = vring->desc + vring->num * sizeof(VRingDesc);

    vring->used = vring_align(vring->avail +

                              offsetof(VRingAvail, ring[vring->num]),

                              vring->align);

    virtio_init_region_cache(vdev, n);

}
",1
Detect whether the following code contains vulnerabilities.,"static int av_dict_set_fxp(AVDictionary **pm, const char *key, uint64_t value, unsigned int digits,

                int flags)

{

    char valuestr[44];

    snprintf(valuestr, sizeof(valuestr), ""%""PRId64"".%0*""PRId64,

             value / PRECISION, digits, ( value % PRECISION ) / ( PRECISION / uintpow(10,digits) ));

    return av_dict_set(pm, key, valuestr, flags);

}
",1
Detect whether the following code contains vulnerabilities.,"static int check_sysreg_table(const struct sys_reg_desc *table, unsigned int n)
{
	unsigned int i;

	for (i = 1; i < n; i++) {
		if (cmp_sys_reg(&table[i-1], &table[i]) >= 0) {
			kvm_err(""sys_reg table %p out of order (%d)\n"", table, i - 1);
			return 1;
		}
	}

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"g_socket_client_proxy_connect_callback (GObject      *object,
					GAsyncResult *result,
					gpointer      user_data)
{
  GSocketClientAsyncConnectData *data = user_data;

  g_object_unref (data->connection);
  data->connection = g_proxy_connect_finish (G_PROXY (object),
					     result,
					     &data->last_error);
  if (data->connection)
    {
      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATED, data->connectable, data->connection);
    }
  else
    {
      enumerator_next_async (data);
      return;
    }

  g_socket_client_tls_handshake (data);
}",1
Detect whether the following code contains vulnerabilities.,"void replicationHandleMasterDisconnection(void) {
    server.master = NULL;
    server.repl_state = REPL_STATE_CONNECT;
    server.repl_down_since = server.unixtime;
    /* We lost connection with our master, force our slaves to resync
     * with us as well to load the new data set.
     *
     * If server.masterhost is NULL the user called SLAVEOF NO ONE so
     * slave resync is not needed. */
    if (server.masterhost != NULL) disconnectSlaves();
}",0
Detect whether the following code contains vulnerabilities.,"static void ehci_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    EHCIPCIInfo *i = data;



    k->init = usb_ehci_pci_initfn;

    k->vendor_id = i->vendor_id;

    k->device_id = i->device_id;

    k->revision = i->revision;

    k->class_id = PCI_CLASS_SERIAL_USB;

    k->config_write = usb_ehci_pci_write_config;


    dc->vmsd = &vmstate_ehci_pci;

    dc->props = ehci_pci_properties;

}",1
Detect whether the following code contains vulnerabilities.,"static void dequantization_float(int x, int y, Jpeg2000Cblk *cblk,

                                 Jpeg2000Component *comp,

                                 Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j, idx;

    float *datap = &comp->data[(comp->coord[0][1] - comp->coord[0][0]) * y + x];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j)

        for (i = 0; i < (cblk->coord[0][1] - cblk->coord[0][0]); ++i) {

            idx        = (comp->coord[0][1] - comp->coord[0][0]) * j + i;

            datap[idx] = (float)(t1->data[j][i]) * band->f_stepsize;

        }

}
",1
Detect whether the following code contains vulnerabilities.,"static void recv_buffer_cleanup(h2_bucket_beam *beam, h2_beam_lock *bl)
{
    if (beam->recv_buffer && !APR_BRIGADE_EMPTY(beam->recv_buffer)) {
        apr_bucket_brigade *bb = beam->recv_buffer;
        apr_off_t bblen = 0;
        
        beam->recv_buffer = NULL;
        apr_brigade_length(bb, 0, &bblen);
        beam->received_bytes += bblen;
        
        /* need to do this unlocked since bucket destroy might 
         * call this beam again. */
        if (bl) leave_yellow(beam, bl);
        apr_brigade_destroy(bb);
        if (bl) enter_yellow(beam, bl);
        
        if (beam->cons_ev_cb) { 
            beam->cons_ev_cb(beam->cons_ctx, beam);
        }
    }
}",1
Detect whether the following code contains vulnerabilities.,  void ms_handle_fast_connect(Connection *con) override {},0
Detect whether the following code contains vulnerabilities.,"static inline bool rom_order_compare(Rom *rom, Rom *item)

{

    return (rom->as > item->as) ||

           (rom->as == item->as && rom->addr >= item->addr);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void reset_bit(uint32_t *field, int bit)

{

    field[bit >> 5] &= ~(1 << (bit & 0x1F));

}
",0
Detect whether the following code contains vulnerabilities.,"
      unsigned int scalar5(const mp_func op,
                           const unsigned int arg1, const unsigned int arg2, const unsigned int arg3,
                           const unsigned int arg4, const unsigned int arg5) {
        const unsigned int pos =
          arg1!=~0U && arg1>_cimg_mp_slot_c && _cimg_mp_is_comp(arg1)?arg1:
          arg2!=~0U && arg2>_cimg_mp_slot_c && _cimg_mp_is_comp(arg2)?arg2:
          arg3!=~0U && arg3>_cimg_mp_slot_c && _cimg_mp_is_comp(arg3)?arg3:
          arg4!=~0U && arg4>_cimg_mp_slot_c && _cimg_mp_is_comp(arg4)?arg4:
          arg5!=~0U && arg5>_cimg_mp_slot_c && _cimg_mp_is_comp(arg5)?arg5:scalar();
        CImg<ulongT>::vector((ulongT)op,pos,arg1,arg2,arg3,arg4,arg5).move_to(code);
        return pos;",0
Detect whether the following code contains vulnerabilities.,"void coroutine_fn qemu_co_mutex_lock(CoMutex *mutex)

{

    Coroutine *self = qemu_coroutine_self();



    trace_qemu_co_mutex_lock_entry(mutex, self);



    while (mutex->locked) {

        qemu_co_queue_wait(&mutex->queue);

    }



    mutex->locked = true;




    trace_qemu_co_mutex_lock_return(mutex, self);

}",1
Detect whether the following code contains vulnerabilities.,"Sql_mode_dependency Item_args::value_depends_on_sql_mode_bit_or() const
{
  Sql_mode_dependency res;
  for (uint i= 0; i < arg_count; i++)
    res|= args[i]->value_depends_on_sql_mode();
  return res;
}",0
Detect whether the following code contains vulnerabilities.,"bool error_is_type(Error *err, const char *fmt)

{

    const char *error_class;

    char *ptr;

    char *end;



    if (!err) {

        return false;

    }



    ptr = strstr(fmt, ""'class': '"");

    assert(ptr != NULL);

    ptr += strlen(""'class': '"");



    end = strchr(ptr, '\'');

    assert(end != NULL);



    error_class = error_get_field(err, ""class"");

    if (strlen(error_class) != end - ptr) {

        return false;

    }



    return strncmp(ptr, error_class, end - ptr) == 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool fuse_range_is_writeback(struct inode *inode, pgoff_t idx_from,
				   pgoff_t idx_to)
{
	struct fuse_inode *fi = get_fuse_inode(inode);
	bool found;

	spin_lock(&fi->lock);
	found = fuse_find_writeback(fi, idx_from, idx_to);
	spin_unlock(&fi->lock);

	return found;
}",0
Detect whether the following code contains vulnerabilities.,"lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)
{
    const struct lys_node *snode = NULL, *siblings;

    if ((!parent && !module) || !name) {
        LOGARG;
        return NULL;
    }

    siblings = lyd_new_find_schema(parent, module, 0);
    if (!siblings) {
        LOGARG;
        return NULL;
    }

    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF
                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {
        LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."",
               name, lys_node_module(siblings)->name, siblings->name);
        return NULL;
    }

    return _lyd_new(parent, snode, 0);
}",1
Detect whether the following code contains vulnerabilities.,"void aarp_cleanup_module(void)
{
	del_timer_sync(&aarp_timer);
	unregister_netdevice_notifier(&aarp_notifier);
	unregister_snap_client(aarp_dl);
	aarp_purge();
}",0
Detect whether the following code contains vulnerabilities.,"void qmp_migrate_set_capabilities(MigrationCapabilityStatusList *params,

                                  Error **errp)

{

    MigrationState *s = migrate_get_current();

    MigrationCapabilityStatusList *cap;



    if (s->state == MIG_STATE_ACTIVE || s->state == MIG_STATE_SETUP) {

        error_set(errp, QERR_MIGRATION_ACTIVE);

        return;

    }



    for (cap = params; cap; cap = cap->next) {

        s->enabled_capabilities[cap->value->capability] = cap->value->state;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"bool io_mem_read(MemoryRegion *mr, hwaddr addr, uint64_t *pval, unsigned size)

{

    return memory_region_dispatch_read(mr, addr, pval, size);

}
",1
Detect whether the following code contains vulnerabilities.,  inline boost::shared_ptr<TTransport> getOutputTransport() { return ptrans_; },0
Detect whether the following code contains vulnerabilities.,"    CImgDisplay& move_inside_screen() {
      if (is_empty()) return *this;
      const int
        x0 = window_x(),
        y0 = window_y(),
        x1 = x0 + window_width() - 1,
        y1 = y0 + window_height() - 1,
        sw = CImgDisplay::screen_width(),
        sh = CImgDisplay::screen_height();
      if (x0<0 || y0<0 || x1>=sw || y1>=sh)
        move(std::max(0,std::min(x0,sw - x1 + x0)),
             std::max(0,std::min(y0,sh - y1 + y0)));
      return *this;
    }",0
Detect whether the following code contains vulnerabilities.,"ms_escher_read_Textbox (MSEscherState *state, MSEscherHeader *h)
{
	return FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"long ASN1_INTEGER_get(const ASN1_INTEGER *a)
	{
	int neg=0,i;
	long r=0;

	if (a == NULL) return(0L);
	i=a->type;
	if (i == V_ASN1_NEG_INTEGER)
		neg=1;
	else if (i != V_ASN1_INTEGER)
		return -1;
	
	if (a->length > (int)sizeof(long))
		{
		/* hmm... a bit ugly */
		return(0xffffffffL);
		}
	if (a->data == NULL)
		return 0;

	for (i=0; i<a->length; i++)
		{
		r<<=8;
		r|=(unsigned char)a->data[i];
		}
	if (neg) r= -r;
	return(r);
	}",0
Detect whether the following code contains vulnerabilities.,"static void pnv_chip_power8nvl_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PnvChipClass *k = PNV_CHIP_CLASS(klass);



    k->cpu_model = ""POWER8NVL"";

    k->chip_type = PNV_CHIP_POWER8NVL;

    k->chip_cfam_id = 0x120d304980000000ull;  /* P8 Naples DD1.0 */

    k->cores_mask = POWER8_CORE_MASK;

    k->core_pir = pnv_chip_core_pir_p8;


    dc->desc = ""PowerNV Chip POWER8NVL"";

}",1
Detect whether the following code contains vulnerabilities.,"static gboolean compare_by_coherent_set_key(gconstpointer a, gconstpointer b) {
  const coherent_set_key * guid_a = (const coherent_set_key *)a;
  const coherent_set_key * guid_b = (const coherent_set_key *)b;
  return memcmp(guid_a, guid_b, sizeof(coherent_set_key)) == 0;
}",1
Detect whether the following code contains vulnerabilities.,"static gint tvb_skip_wsp_return(tvbuff_t* tvb, gint offset){
	gint counter = offset;
	gint end;
	guint8 tempchar;
	end = 0;

	for(counter = offset; counter > end &&
		((tempchar = tvb_get_guint8(tvb,counter)) == ' ' ||
		tempchar == '\t'|| tempchar == '\n');counter--);
	counter++;
	return (counter);
}",0
Detect whether the following code contains vulnerabilities.,"static int stdio_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileStdio *s = opaque;

    FILE *fp = s->stdio_file;

    int bytes;



    do {

        clearerr(fp);

        bytes = fread(buf, 1, size, fp);

    } while ((bytes == 0) && ferror(fp) && (errno == EINTR));

    return bytes;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qxl_reset_surfaces(PCIQXLDevice *d)

{

    dprint(d, 1, ""%s:\n"", __FUNCTION__);

    d->mode = QXL_MODE_UNDEFINED;

    qemu_mutex_unlock_iothread();

    d->ssd.worker->destroy_surfaces(d->ssd.worker);

    qemu_mutex_lock_iothread();

    memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));

}
",1
Detect whether the following code contains vulnerabilities.,"void timer_deinit(QEMUTimer *ts)

{

    assert(ts->expire_time == -1);

    ts->timer_list = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static int handle_intercept(CPUS390XState *env)

{

    struct kvm_run *run = env->kvm_run;

    int icpt_code = run->s390_sieic.icptcode;

    int r = 0;



    dprintf(""intercept: 0x%x (at 0x%lx)\n"", icpt_code,

            (long)env->kvm_run->psw_addr);

    switch (icpt_code) {

        case ICPT_INSTRUCTION:

            r = handle_instruction(env, run);


        case ICPT_WAITPSW:







        case ICPT_CPU_STOP:

            if (s390_del_running_cpu(env) == 0) {





        case ICPT_SOFT_INTERCEPT:

            fprintf(stderr, ""KVM unimplemented icpt SOFT\n"");

            exit(1);


        case ICPT_IO:

            fprintf(stderr, ""KVM unimplemented icpt IO\n"");

            exit(1);


        default:

            fprintf(stderr, ""Unknown intercept code: %d\n"", icpt_code);

            exit(1);





    return r;
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(chdir)
{
	char *str;
	int ret, str_len;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p"", &str, &str_len) == FAILURE) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(str TSRMLS_CC)) {
		RETURN_FALSE;
	}
	ret = VCWD_CHDIR(str);
	
	if (ret != 0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s (errno %d)"", strerror(errno), errno);
		RETURN_FALSE;
	}

	if (BG(CurrentStatFile) && !IS_ABSOLUTE_PATH(BG(CurrentStatFile), strlen(BG(CurrentStatFile)))) {
		efree(BG(CurrentStatFile));
		BG(CurrentStatFile) = NULL;
	}
	if (BG(CurrentLStatFile) && !IS_ABSOLUTE_PATH(BG(CurrentLStatFile), strlen(BG(CurrentLStatFile)))) {
		efree(BG(CurrentLStatFile));
		BG(CurrentLStatFile) = NULL;
	}

	RETURN_TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *dev = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(

        usbredirparser_peer_has_cap(dev->parser,

                                    usb_redir_cap_ep_info_max_packet_size) &&

        usbredirparser_peer_has_cap(dev->parser,

                                    usb_redir_cap_32bits_bulk_length) &&

        usbredirparser_peer_has_cap(dev->parser,

                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(dev);

        return;

    }



    if (usb_device_attach(&dev->dev) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(dev);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int ntop_snmpget(lua_State* vm)     { return(ntop_snmp_get_fctn(vm, SNMP_GET_REQUEST_TYPE)); }",0
Detect whether the following code contains vulnerabilities.,"static void yuv_a_to_rgba(const uint8_t *ycbcr, const uint8_t *alpha, uint32_t *rgba, int num_values)

{

    const uint8_t *cm = ff_crop_tab + MAX_NEG_CROP;

    uint8_t r, g, b;

    int i, y, cb, cr;

    int r_add, g_add, b_add;



    for (i = num_values; i > 0; i--) {

        y = *ycbcr++;

        cr = *ycbcr++;

        cb = *ycbcr++;

        YUV_TO_RGB1_CCIR(cb, cr);

        YUV_TO_RGB2_CCIR(r, g, b, y);

        *rgba++ = (*alpha++ << 24) | (r << 16) | (g << 8) | b;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void zrle_write_u32(VncState *vs, uint32_t value)
{
    vnc_write(vs, (uint8_t *)&value, 4);
}",0
Detect whether the following code contains vulnerabilities.,"static int qcow2_save_vmstate(BlockDriverState *bs, QEMUIOVector *qiov,

                              int64_t pos)

{

    BDRVQcowState *s = bs->opaque;

    int64_t total_sectors = bs->total_sectors;

    int growable = bs->growable;


    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_VMSTATE_SAVE);

    bs->growable = 1;


    ret = bdrv_pwritev(bs, qcow2_vm_state_offset(s) + pos, qiov);

    bs->growable = growable;




    /* bdrv_co_do_writev will have increased the total_sectors value to include

     * the VM state - the VM state is however not an actual part of the block

     * device, therefore, we need to restore the old value. */

    bs->total_sectors = total_sectors;



    return ret;

}",1
Detect whether the following code contains vulnerabilities.,"do_notify_resume(struct pt_regs *regs, void *unused, __u32 thread_info_flags)
{
#ifdef CONFIG_X86_MCE
	/* notify userspace of pending MCEs */
	if (thread_info_flags & _TIF_MCE_NOTIFY)
		mce_notify_process();
#endif /* CONFIG_X86_64 && CONFIG_X86_MCE */

	/* deal with pending signal delivery */
	if (thread_info_flags & _TIF_SIGPENDING)
		do_signal(regs);

	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(regs);
		if (current->replacement_session_keyring)
			key_replace_session_keyring();
	}
	if (thread_info_flags & _TIF_USER_RETURN_NOTIFY)
		fire_user_return_notifiers();

#ifdef CONFIG_X86_32
	clear_thread_flag(TIF_IRET);
#endif /* CONFIG_X86_32 */
}",1
Detect whether the following code contains vulnerabilities.,"void rgb16tobgr32(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	const uint16_t *end;

	uint8_t *d = (uint8_t *)dst;

	const uint16_t *s = (uint16_t *)src;

	end = s + src_size/2;

	while(s < end)

	{

		register uint16_t bgr;

		bgr = *s++;

		*d++ = (bgr&0xF800)>>8;

		*d++ = (bgr&0x7E0)>>3;

		*d++ = (bgr&0x1F)<<3;

		*d++ = 0;

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static int r3d_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    R3DContext *r3d = s->priv_data;

    Atom atom;

    int err = 0;



    while (!err) {

        if (read_atom(s, &atom) < 0) {

            err = -1;

            break;

        }

        switch (atom.tag) {

        case MKTAG('R','E','D','V'):

            if (s->streams[0]->discard == AVDISCARD_ALL)

                goto skip;

            if (!(err = r3d_read_redv(s, pkt, &atom)))

                return 0;

            break;

        case MKTAG('R','E','D','A'):

            if (!r3d->audio_channels)

                return -1;

            if (s->streams[1]->discard == AVDISCARD_ALL)

                goto skip;

            if (!(err = r3d_read_reda(s, pkt, &atom)))

                return 0;

            break;

        default:

        skip:

            avio_skip(s->pb, atom.size-8);

        }

    }

    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"static QEMUMachine *machine_parse(const char *name)

{

    QEMUMachine *m, *machine = NULL;



    if (name) {

        machine = find_machine(name);

    }

    if (machine) {

        return machine;

    }

    printf(""Supported machines are:\n"");

    for (m = first_machine; m != NULL; m = m->next) {

        if (m->alias) {

            printf(""%-20s %s (alias of %s)\n"", m->alias, m->desc, m->name);

        }

        printf(""%-20s %s%s\n"", m->name, m->desc,

               m->is_default ? "" (default)"" : """");

    }

    exit(!name || *name != '?');

}
",1
Detect whether the following code contains vulnerabilities.,"static void mem_cgroup_may_update_nodemask(struct mem_cgroup *memcg)
{
	int nid;
	/*
	 * numainfo_events > 0 means there was at least NUMAINFO_EVENTS_TARGET
	 * pagein/pageout changes since the last update.
	 */
	if (!atomic_read(&memcg->numainfo_events))
		return;
	if (atomic_inc_return(&memcg->numainfo_updating) > 1)
		return;

	/* make a nodemask where this memcg uses memory from */
	memcg->scan_nodes = node_states[N_HIGH_MEMORY];

	for_each_node_mask(nid, node_states[N_HIGH_MEMORY]) {

		if (!test_mem_cgroup_node_reclaimable(memcg, nid, false))
			node_clear(nid, memcg->scan_nodes);
	}

	atomic_set(&memcg->numainfo_events, 0);
	atomic_set(&memcg->numainfo_updating, 0);
}",0
Detect whether the following code contains vulnerabilities.,"TfFinder::getTf()
{
    return this->tf;
}",0
Detect whether the following code contains vulnerabilities.,"static int check_clock(const clockid_t which_clock)
{
	int error = 0;
	struct task_struct *p;
	const pid_t pid = CPUCLOCK_PID(which_clock);

	if (CPUCLOCK_WHICH(which_clock) >= CPUCLOCK_MAX)
		return -EINVAL;

	if (pid == 0)
		return 0;

	read_lock(&tasklist_lock);
	p = find_task_by_vpid(pid);
	if (!p || !(CPUCLOCK_PERTHREAD(which_clock) ?
		   same_thread_group(p, current) : thread_group_leader(p))) {
		error = -EINVAL;
	}
	read_unlock(&tasklist_lock);

	return error;
}",0
Detect whether the following code contains vulnerabilities.,"static int usb_net_handle_data(USBDevice *dev, USBPacket *p)

{

    USBNetState *s = (USBNetState *) dev;

    int ret = 0;



    switch(p->pid) {

    case USB_TOKEN_IN:

        switch (p->devep) {

        case 1:

            ret = usb_net_handle_statusin(s, p);

            break;



        case 2:

            ret = usb_net_handle_datain(s, p);

            break;



        default:

            goto fail;

        }

        break;



    case USB_TOKEN_OUT:

        switch (p->devep) {

        case 2:

            ret = usb_net_handle_dataout(s, p);

            break;



        default:

            goto fail;

        }

        break;



    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }

    if (ret == USB_RET_STALL)

        fprintf(stderr, ""usbnet: failed data transaction: ""

                        ""pid 0x%x ep 0x%x len 0x%zx\n"",

                        p->pid, p->devep, p->iov.size);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err senc_box_size(GF_Box *s)
{
	u32 sample_count;
	u32 i, nb_crypt_samples;
	GF_SampleEncryptionBox *ptr = (GF_SampleEncryptionBox*)s;
	sample_count = gf_list_count(ptr->samp_aux_info);
	//temp patch until we cleanup the spec...
	nb_crypt_samples=0;
	for (i = 0; i < sample_count; i++) {
		GF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);
		if (!sai->isNotProtected) nb_crypt_samples++;
	}

	if (!nb_crypt_samples) {
		ptr->size = 0;
		return GF_OK;
	}

	//WARNING - PSEC (UUID) IS TYPECASTED TO SENC (FULL BOX) SO WE CANNOT USE USUAL FULL BOX FUNCTIONS
	ptr->size += 4; //version and flags

	ptr->size += 4; //sample count
	for (i = 0; i < sample_count; i++) {
		GF_CENCSampleAuxInfo *sai = (GF_CENCSampleAuxInfo *)gf_list_get(ptr->samp_aux_info, i);
		if (sai->isNotProtected)
			continue;
		ptr->size += sai->cenc_data_size;
	}
	return GF_OK;
}",0
Detect whether the following code contains vulnerabilities.,"GF_Err piff_pssh_box_write(GF_Box *s, GF_BitStream *bs)
{
	GF_PIFFProtectionSystemHeaderBox *ptr = (GF_PIFFProtectionSystemHeaderBox *) s;
	GF_Err e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u8(bs, ptr->version);
	gf_bs_write_u24(bs, ptr->flags);

	gf_bs_write_data(bs, (char *) ptr->SystemID, 16);
	gf_bs_write_u32(bs, ptr->private_data_size);
	gf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);
	return GF_OK;
}",0
Detect whether the following code contains vulnerabilities.,"uint64_t HELPER(popcnt)(uint64_t r2)

{

    uint64_t ret = 0;

    int i;



    for (i = 0; i < 64; i += 8) {

        uint64_t t = ctpop32((r2 >> i) & 0xff);

        ret |= t << i;

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"bool Item_in_subselect::fix_having(Item *having, SELECT_LEX *select_lex)
{
  bool fix_res= 0;
  DBUG_ASSERT(thd);
  if (!having->fixed)
  {
    select_lex->having_fix_field= 1;
    fix_res= having->fix_fields(thd, 0);
    select_lex->having_fix_field= 0;
  }
  return fix_res;
}",0
Detect whether the following code contains vulnerabilities.,"static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)
{
        OPJ_UINT32 l_nb_bytes = 0;
        OPJ_UINT32 l_nb_comps;
        OPJ_UINT32 l_coc_bytes,l_qcc_bytes;

        l_nb_comps = p_j2k->m_private_image->numcomps - 1;
        l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);

        if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {
                l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
                l_nb_bytes += l_nb_comps * l_coc_bytes;

                l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
                l_nb_bytes += l_nb_comps * l_qcc_bytes;
        }

        l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);

        /*** DEVELOPER CORNER, Add room for your headers ***/

        return l_nb_bytes;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int unix_recvq_full(struct sock const *sk)
{
	return skb_queue_len(&sk->sk_receive_queue) > sk->sk_max_ack_backlog;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void flags_to_str_internal(uint32_t flags, char *flagstr)
{
    size_t i, len = 0;
    size_t map_size;
    char *p;

    p = flagstr;
    memset(p, 0, FLAGMAPSTR_MAXLEN);
    map_size = sizeof(msgflagmap) / sizeof(struct MsgFlagMap);

    for (i = 0; i <  map_size && len < FLAGMAPSTR_MAXLEN; i++) {
        if (flags & msgflagmap[i].flag) {
            if (p != flagstr) {
                *p++ = '|';
                len++;
            }

            *p++ = msgflagmap[i].code[0];
            *p++ = msgflagmap[i].code[1];
            len += 2;
        }
    }
}",0
Detect whether the following code contains vulnerabilities.,"static struct pxa2xx_i2s_s *pxa2xx_i2s_init(target_phys_addr_t base,

                qemu_irq irq, struct pxa2xx_dma_state_s *dma)

{

    int iomemtype;

    struct pxa2xx_i2s_s *s = (struct pxa2xx_i2s_s *)

            qemu_mallocz(sizeof(struct pxa2xx_i2s_s));



    s->base = base;

    s->irq = irq;

    s->dma = dma;

    s->data_req = pxa2xx_i2s_data_req;



    pxa2xx_i2s_reset(s);



    iomemtype = cpu_register_io_memory(0, pxa2xx_i2s_readfn,

                    pxa2xx_i2s_writefn, s);

    cpu_register_physical_memory(s->base & 0xfff00000, 0xfffff, iomemtype);



    register_savevm(""pxa2xx_i2s"", base, 0,

                    pxa2xx_i2s_save, pxa2xx_i2s_load, s);



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"SRP_gN *SRP_get_default_gN(const char *id)
	{
	size_t i;

	if (id == NULL) 
		return knowngN;
	for(i = 0; i < KNOWN_GN_NUMBER; i++)
		{
		if (strcmp(knowngN[i].id, id)==0)
			return knowngN + i;
		}
	return NULL;
	}",0
Detect whether the following code contains vulnerabilities.,"long do_sigreturn(CPUS390XState *env)

{

    sigframe *frame;

    abi_ulong frame_addr = env->regs[15];

    target_sigset_t target_set;

    sigset_t set;



    trace_user_do_sigreturn(env, frame_addr);

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {

        goto badframe;

    }

    __get_user(target_set.sig[0], &frame->sc.oldmask[0]);



    target_to_host_sigset_internal(&set, &target_set);

    set_sigmask(&set); /* ~_BLOCKABLE? */



    if (restore_sigregs(env, &frame->sregs)) {

        goto badframe;

    }



    unlock_user_struct(frame, frame_addr, 0);

    return -TARGET_QEMU_ESIGRETURN;



badframe:

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else av_assert0(0);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static target_ulong h_remove(PowerPCCPU *cpu, sPAPRMachineState *spapr,

                             target_ulong opcode, target_ulong *args)

{

    CPUPPCState *env = &cpu->env;

    target_ulong flags = args[0];

    target_ulong pte_index = args[1];

    target_ulong avpn = args[2];

    RemoveResult ret;



    ret = remove_hpte(cpu, pte_index, avpn, flags,

                      &args[0], &args[1]);



    switch (ret) {

    case REMOVE_SUCCESS:

        check_tlb_flush(env);

        return H_SUCCESS;



    case REMOVE_NOT_FOUND:

        return H_NOT_FOUND;



    case REMOVE_PARM:

        return H_PARAMETER;



    case REMOVE_HW:

        return H_HARDWARE;

    }



    g_assert_not_reached();

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_bytes(const uint8_t *input, uint8_t *out, int bytes)

{

    int i, off;

    uint32_t c;

    const uint32_t *buf;

    uint32_t *output = (uint32_t *)out;



    off = (intptr_t)input & 3;

    buf = (const uint32_t *)(input - off);

    c   = av_be2ne32((0x537F6103 >> (off * 8)) | (0x537F6103 << (32 - (off * 8))));

    bytes += 3 + off;

    for (i = 0; i < bytes / 4; i++)

        output[i] = c ^ buf[i];



    if (off)

        avpriv_request_sample(NULL, ""Offset of %d"", off);



    return off;

}
",1
Detect whether the following code contains vulnerabilities.,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm && idx < MAX_NAME)
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",1
Detect whether the following code contains vulnerabilities.,"void memory_region_notify_one(IOMMUNotifier *notifier,

                              IOMMUTLBEntry *entry)

{

    IOMMUNotifierFlag request_flags;



    /*

     * Skip the notification if the notification does not overlap

     * with registered range.

     */

    if (notifier->start > entry->iova + entry->addr_mask + 1 ||

        notifier->end < entry->iova) {

        return;

    }



    if (entry->perm & IOMMU_RW) {

        request_flags = IOMMU_NOTIFIER_MAP;

    } else {

        request_flags = IOMMU_NOTIFIER_UNMAP;

    }



    if (notifier->notifier_flags & request_flags) {

        notifier->notify(notifier, entry);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"may_get_cmd_block(exarg_T *eap, char_u *p, char_u **tofree, int *flags)
{
    char_u *retp = p;

    if (*p == '{' && ends_excmd2(eap->arg, skipwhite(p + 1))
						       && eap->getline != NULL)
    {
	garray_T    ga;
	char_u	    *line = NULL;

	ga_init2(&ga, sizeof(char_u *), 10);
	if (ga_add_string(&ga, p) == FAIL)
	    return retp;

	// If the argument ends in ""}"" it must have been concatenated already
	// for ISN_EXEC.
	if (p[STRLEN(p) - 1] != '}')
	    // Read lines between '{' and '}'.  Does not support nesting or
	    // here-doc constructs.
	    for (;;)
	    {
		vim_free(line);
		if ((line = eap->getline(':', eap->cookie,
					   0, GETLINE_CONCAT_CONTBAR)) == NULL)
		{
		    emsg(_(e_missing_rcurly));
		    break;
		}
		if (ga_add_string(&ga, line) == FAIL)
		    break;
		if (*skipwhite(line) == '}')
		    break;
	    }
	vim_free(line);
	retp = *tofree = ga_concat_strings(&ga, ""\n"");
	ga_clear_strings(&ga);
	*flags |= UC_VIM9;
    }
    return retp;
}",1
Detect whether the following code contains vulnerabilities.,"void pcie_cap_slot_hotplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,

                              Error **errp)

{

    uint8_t *exp_cap;

    PCIDevice *pci_dev = PCI_DEVICE(dev);



    pcie_cap_slot_hotplug_common(PCI_DEVICE(hotplug_dev), dev, &exp_cap, errp);



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (!dev->hotplugged) {

        pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,

                                   PCI_EXP_SLTSTA_PDS);

        return;

    }



    /* TODO: multifunction hot-plug.

     * Right now, only a device of function = 0 is allowed to be

     * hot plugged/unplugged.

     */

    assert(PCI_FUNC(pci_dev->devfn) == 0);



    pci_word_test_and_set_mask(exp_cap + PCI_EXP_SLTSTA,

                               PCI_EXP_SLTSTA_PDS);

    pcie_cap_slot_event(PCI_DEVICE(hotplug_dev), PCI_EXP_HP_EV_PDC);

}
",1
Detect whether the following code contains vulnerabilities.,"void xsetenv(const char *key, const char *value)
{
    if (setenv(key, value, 1))
        die_out_of_memory();
}",0
Detect whether the following code contains vulnerabilities.,"void CompressTest::testSetZipComment()
{
	std::string comment(""Testing...123..."");
	std::ofstream out(""comment.zip"", std::ios::binary);
	Poco::Path theFile(ZipTest::getTestFile(""data"", ""test.zip""));
	Compress c(out, true);
	c.addFile(theFile, theFile.getFileName());
	c.setZipComment(comment);
	ZipArchive a(c.close());
	assert(a.getZipComment() == comment);
}",1
Detect whether the following code contains vulnerabilities.,"static int hclge_tm_pg_shapping_cfg(struct hclge_dev *hdev,
				    enum hclge_shap_bucket bucket, u8 pg_id,
				    u32 shapping_para)
{
	struct hclge_pg_shapping_cmd *shap_cfg_cmd;
	enum hclge_opcode_type opcode;
	struct hclge_desc desc;

	opcode = bucket ? HCLGE_OPC_TM_PG_P_SHAPPING :
		 HCLGE_OPC_TM_PG_C_SHAPPING;
	hclge_cmd_setup_basic_desc(&desc, opcode, false);

	shap_cfg_cmd = (struct hclge_pg_shapping_cmd *)desc.data;

	shap_cfg_cmd->pg_id = pg_id;

	shap_cfg_cmd->pg_shapping_para = cpu_to_le32(shapping_para);

	return hclge_cmd_send(&hdev->hw, &desc, 1);
}",0
Detect whether the following code contains vulnerabilities.,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;

	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
	}

	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;

	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
	}

	return 0;

error:
	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"int thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg)
{
	return pthread_create(&thr->pth, attr, start, arg);
}",0
Detect whether the following code contains vulnerabilities.,"static void tilegx_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    TileGXCPU *cpu = TILEGX_CPU(obj);

    CPUTLGState *env = &cpu->env;

    static bool tcg_initialized;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    if (tcg_enabled() && !tcg_initialized) {

        tcg_initialized = true;

        tilegx_tcg_init();

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int property_read_system_call_filter(
                sd_bus *bus,
                const char *member,
                sd_bus_message *m,
                sd_bus_error *error,
                void *userdata) {

        struct security_info *info = userdata;
        int whitelist, r;

        assert(bus);
        assert(member);
        assert(m);

        r = sd_bus_message_enter_container(m, 'r', ""bas"");
        if (r < 0)
                return r;

        r = sd_bus_message_read(m, ""b"", &whitelist);
        if (r < 0)
                return r;

        info->system_call_filter_whitelist = whitelist;

        r = sd_bus_message_enter_container(m, 'a', ""s"");
        if (r < 0)
                return r;

        for (;;) {
                const char *name;

                r = sd_bus_message_read(m, ""s"", &name);
                if (r < 0)
                        return r;
                if (r == 0)
                        break;

                r = set_ensure_allocated(&info->system_call_filter, &string_hash_ops);
                if (r < 0)
                        return r;

                r = set_put_strdup(info->system_call_filter, name);
                if (r < 0)
                        return r;
        }

        r = sd_bus_message_exit_container(m);
        if (r < 0)
                return r;

        return sd_bus_message_exit_container(m);
}",0
Detect whether the following code contains vulnerabilities.,"void free_pipe_info(struct pipe_inode_info *pipe)
{
	int i;

	for (i = 0; i < pipe->buffers; i++) {
		struct pipe_buffer *buf = pipe->bufs + i;
		if (buf->ops)
			buf->ops->release(pipe, buf);
	}
	if (pipe->tmp_page)
		__free_page(pipe->tmp_page);
	kfree(pipe->bufs);
	kfree(pipe);
}",1
Detect whether the following code contains vulnerabilities.,"XML_StopParser(XML_Parser parser, XML_Bool resumable)
{
  if (parser == NULL)
    return XML_STATUS_ERROR;
  switch (parser->m_parsingStatus.parsing) {
  case XML_SUSPENDED:
    if (resumable) {
      parser->m_errorCode = XML_ERROR_SUSPENDED;
      return XML_STATUS_ERROR;
    }
    parser->m_parsingStatus.parsing = XML_FINISHED;
    break;
  case XML_FINISHED:
    parser->m_errorCode = XML_ERROR_FINISHED;
    return XML_STATUS_ERROR;
  default:
    if (resumable) {
#ifdef XML_DTD
      if (parser->m_isParamEntity) {
        parser->m_errorCode = XML_ERROR_SUSPEND_PE;
        return XML_STATUS_ERROR;
      }
#endif
      parser->m_parsingStatus.parsing = XML_SUSPENDED;
    }
    else
      parser->m_parsingStatus.parsing = XML_FINISHED;
  }
  return XML_STATUS_OK;
}",0
Detect whether the following code contains vulnerabilities.,"void jas_iccattrtab_dump(jas_iccattrtab_t *attrtab, FILE *out)
{
	int i;
	jas_iccattr_t *attr;
	jas_iccattrval_t *attrval;
	jas_iccattrvalinfo_t *info;
	char buf[16];
	fprintf(out, ""numattrs=%d\n"", attrtab->numattrs);
	fprintf(out, ""---\n"");
	for (i = 0; i < attrtab->numattrs; ++i) {
		attr = &attrtab->attrs[i];
		attrval = attr->val;
		info = jas_iccattrvalinfo_lookup(attrval->type);
		if (!info) abort();
		fprintf(out, ""attrno=%d; attrname=\""%s\""(0x%08""PRIxFAST32""); attrtype=\""%s\""(0x%08""PRIxFAST32"")\n"",
		  i,
		  jas_iccsigtostr(attr->name, &buf[0]),
		  attr->name,
		  jas_iccsigtostr(attrval->type, &buf[8]),
		  attrval->type
		  );
		jas_iccattrval_dump(attrval, out);
		fprintf(out, ""---\n"");
	}
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t find_subframe_rice_params(FlacEncodeContext *s,

                                          FlacSubframe *sub, int pred_order)

{

    int pmin = get_max_p_order(s->options.min_partition_order,

                               s->frame.blocksize, pred_order);

    int pmax = get_max_p_order(s->options.max_partition_order,

                               s->frame.blocksize, pred_order);



    uint32_t bits = 8 + pred_order * sub->obits + 2 + 4;

    if (sub->type == FLAC_SUBFRAME_LPC)

        bits += 4 + 5 + pred_order * s->options.lpc_coeff_precision;

    bits += calc_rice_params(&sub->rc, pmin, pmax, sub->residual,

                             s->frame.blocksize, pred_order);

    return bits;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline struct stable_node *alloc_stable_node(void)
{
	return kmem_cache_alloc(stable_node_cache, GFP_KERNEL);
}",0
Detect whether the following code contains vulnerabilities.,"int tls1_cert_verify_mac(SSL *s, int md_nid, unsigned char *out)
	{
	unsigned int ret;
	EVP_MD_CTX ctx, *d=NULL;
	int i;

	if (s->s3->handshake_buffer) 
		if (!ssl3_digest_cached_records(s))
			return 0;

	for (i=0;i<SSL_MAX_DIGEST;i++) 
		{
		  if (s->s3->handshake_dgst[i]&&EVP_MD_CTX_type(s->s3->handshake_dgst[i])==md_nid) 
		  	{
		  	d=s->s3->handshake_dgst[i];
			break;
			}
		}
	if (!d) {
		SSLerr(SSL_F_TLS1_CERT_VERIFY_MAC,SSL_R_NO_REQUIRED_DIGEST);
		return 0;
	}	

	EVP_MD_CTX_init(&ctx);
	EVP_MD_CTX_copy_ex(&ctx,d);
	EVP_DigestFinal_ex(&ctx,out,&ret);
	EVP_MD_CTX_cleanup(&ctx);
	return((int)ret);
	}",0
Detect whether the following code contains vulnerabilities.,"TEST(HeaderMapImplTest, DoubleInlineSet) {
  HeaderMapImpl headers;
  headers.setReferenceKey(Headers::get().ContentType, ""blah"");
  headers.setReferenceKey(Headers::get().ContentType, ""text/html"");
  EXPECT_EQ(""text/html"", headers.ContentType()->value().getStringView());
  EXPECT_EQ(1UL, headers.size());
}",1
Detect whether the following code contains vulnerabilities.,"static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)
{
    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {
        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,
                                 ""Could not parse tiny protocol buffer message"");
        return;
    }

    msg_tiny_id = entry->msg_id;
}",1
Detect whether the following code contains vulnerabilities.,"static int parse_vdiname(BDRVSheepdogState *s, const char *filename,

                         char *vdi, uint32_t *snapid, char *tag)

{

    char *p, *q, *uri;

    const char *host_spec, *vdi_spec;

    int nr_sep, ret;



    strstart(filename, ""sheepdog:"", &filename);

    p = q = g_strdup(filename);



    /* count the number of separators */

    nr_sep = 0;

    while (*p) {

        if (*p == ':') {

            nr_sep++;

        }

        p++;

    }

    p = q;



    /* use the first two tokens as host_spec. */

    if (nr_sep >= 2) {

        host_spec = p;

        p = strchr(p, ':');

        p++;

        p = strchr(p, ':');

        *p++ = '\0';

    } else {

        host_spec = """";

    }



    vdi_spec = p;



    p = strchr(vdi_spec, ':');

    if (p) {

        *p++ = '#';

    }



    uri = g_strdup_printf(""sheepdog://%s/%s"", host_spec, vdi_spec);



    ret = sd_parse_uri(s, uri, vdi, snapid, tag);



    g_free(q);

    g_free(uri);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"xmlNewTextLen(const xmlChar *content, int len) {
    xmlNodePtr cur;

    /*
     * Allocate a new node and fill the fields.
     */
    cur = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));
    if (cur == NULL) {
	xmlTreeErrMemory(""building text"");
	return(NULL);
    }
    memset(cur, 0, sizeof(xmlNode));
    cur->type = XML_TEXT_NODE;

    cur->name = xmlStringText;
    if (content != NULL) {
	cur->content = xmlStrndup(content, len);
    }

    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))
	xmlRegisterNodeDefaultValue(cur);
    return(cur);
}",0
Detect whether the following code contains vulnerabilities.,"static int proc_oom_score(struct task_struct *task, char *buffer)
{
	unsigned long points;
	struct timespec uptime;

	do_posix_clock_monotonic_gettime(&uptime);
	read_lock(&tasklist_lock);
	points = badness(task->group_leader, uptime.tv_sec);
	read_unlock(&tasklist_lock);
	return sprintf(buffer, ""%lu\n"", points);
}",1
Detect whether the following code contains vulnerabilities.,"char *rindex(const char *s,int c)
{
  char *t;

  t = NullS;
  do if (*s == (char) c) t = (char*) s; while (*s++);
  return (char*) t;
}",0
Detect whether the following code contains vulnerabilities.,"static uint8_t pfkey_proto_from_xfrm(uint8_t proto)
{
	return proto ? proto : IPSEC_PROTO_ANY;
}",0
Detect whether the following code contains vulnerabilities.,"static int virtio_net_has_buffers(VirtIONet *n, int bufsize)

{

    if (virtio_queue_empty(n->rx_vq) ||

        (n->mergeable_rx_bufs &&

         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {

        virtio_queue_set_notification(n->rx_vq, 1);

        return 0;

    }



    virtio_queue_set_notification(n->rx_vq, 0);

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void hidp_process_report(struct hidp_session *session, int type,
				const u8 *data, unsigned int len, int intr)
{
	if (len > HID_MAX_BUFFER_SIZE)
		len = HID_MAX_BUFFER_SIZE;

	memcpy(session->input_buf, data, len);
	hid_input_report(session->hid, type, session->input_buf, len, intr);
}",0
Detect whether the following code contains vulnerabilities.,"log_cachedcname (const char *dn, const char *dn2)
{
    string(""cached cname "");
    name (dn);
    space ();
    name (dn2);

    line();
}",0
Detect whether the following code contains vulnerabilities.,"static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
		unsigned int *rsize)
{
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
		rdesc[11] = rdesc[16] = 0xff;
		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}",1
Detect whether the following code contains vulnerabilities.,"static void qbus_initfn(Object *obj)

{

    BusState *bus = BUS(obj);



    QTAILQ_INIT(&bus->children);

    object_property_add_link(obj, QDEV_HOTPLUG_HANDLER_PROPERTY,

                             TYPE_HOTPLUG_HANDLER,

                             (Object **)&bus->hotplug_handler, NULL);

    object_property_add_bool(obj, ""realized"",

                             bus_get_realized, bus_set_realized, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static void qemu_chr_parse_spice_port(QemuOpts *opts, ChardevBackend *backend,

                                      Error **errp)

{

    const char *name = qemu_opt_get(opts, ""name"");

    ChardevSpicePort *spiceport;



    if (name == NULL) {

        error_setg(errp, ""chardev: spice port: no name given"");

        return;

    }

    spiceport = backend->u.spiceport = g_new0(ChardevSpicePort, 1);

    qemu_chr_parse_common(opts, qapi_ChardevSpicePort_base(spiceport));

    spiceport->fqdn = g_strdup(name);

}
",0
Detect whether the following code contains vulnerabilities.,"static void memory_region_update_coalesced_range(MemoryRegion *mr)

{

    FlatRange *fr;

    CoalescedMemoryRange *cmr;

    AddrRange tmp;



    FOR_EACH_FLAT_RANGE(fr, &address_space_memory.current_map) {

        if (fr->mr == mr) {

            qemu_unregister_coalesced_mmio(int128_get64(fr->addr.start),

                                           int128_get64(fr->addr.size));

            QTAILQ_FOREACH(cmr, &mr->coalesced, link) {

                tmp = addrrange_shift(cmr->addr,

                                      int128_sub(fr->addr.start,

                                                 int128_make64(fr->offset_in_region)));

                if (!addrrange_intersects(tmp, fr->addr)) {

                    continue;

                }

                tmp = addrrange_intersection(tmp, fr->addr);

                qemu_register_coalesced_mmio(int128_get64(tmp.start),

                                             int128_get64(tmp.size));

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void map_linear_vram(CirrusVGAState *s)

{




    if (!s->map_addr && s->lfb_addr && s->lfb_end) {

        s->map_addr = s->lfb_addr;

        s->map_end = s->lfb_end;

        cpu_register_physical_memory(s->map_addr, s->map_end - s->map_addr, s->vram_offset);

    }



    if (!s->map_addr)

        return;



    s->lfb_vram_mapped = 0;







    if (!(s->cirrus_srcptr != s->cirrus_srcptr_end)

        && !((s->sr[0x07] & 0x01) == 0)

        && !((s->gr[0x0B] & 0x14) == 0x14)

        && !(s->gr[0x0B] & 0x02)) {





                                    (s->vram_offset + s->cirrus_bank_base[0]) | IO_MEM_RAM);


                                    (s->vram_offset + s->cirrus_bank_base[1]) | IO_MEM_RAM);



        s->lfb_vram_mapped = 1;

    }

    else {

        cpu_register_physical_memory(isa_mem_base + 0xa0000, 0x20000,

                                     s->vga_io_memory);

    }



    vga_dirty_log_start((VGAState *)s);

}",1
Detect whether the following code contains vulnerabilities.,"static int ppc_hash64_check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int btrfs_previous_extent_item(struct btrfs_root *root,
			struct btrfs_path *path, u64 min_objectid)
{
	struct btrfs_key found_key;
	struct extent_buffer *leaf;
	u32 nritems;
	int ret;

	while (1) {
		if (path->slots[0] == 0) {
			ret = btrfs_prev_leaf(root, path);
			if (ret != 0)
				return ret;
		} else {
			path->slots[0]--;
		}
		leaf = path->nodes[0];
		nritems = btrfs_header_nritems(leaf);
		if (nritems == 0)
			return 1;
		if (path->slots[0] == nritems)
			path->slots[0]--;

		btrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);
		if (found_key.objectid < min_objectid)
			break;
		if (found_key.type == BTRFS_EXTENT_ITEM_KEY ||
		    found_key.type == BTRFS_METADATA_ITEM_KEY)
			return 0;
		if (found_key.objectid == min_objectid &&
		    found_key.type < BTRFS_EXTENT_ITEM_KEY)
			break;
	}
	return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static int vhost_user_get_u64(struct vhost_dev *dev, int request, uint64_t *u64)

{

    VhostUserMsg msg = {

        .request = request,

        .flags = VHOST_USER_VERSION,

    };



    if (vhost_user_one_time_request(request) && dev->vq_index != 0) {

        return 0;

    }



    vhost_user_write(dev, &msg, NULL, 0);



    if (vhost_user_read(dev, &msg) < 0) {

        return 0;

    }



    if (msg.request != request) {

        error_report(""Received unexpected msg type. Expected %d received %d"",

                     request, msg.request);

        return -1;

    }



    if (msg.size != sizeof(m.u64)) {

        error_report(""Received bad msg size."");

        return -1;

    }



    *u64 = msg.u64;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"read_32 (IOBUF inp)
{
  unsigned long a;
  a = iobuf_get_noeof (inp) << 24;
  a |= iobuf_get_noeof (inp) << 16;
  a |= iobuf_get_noeof (inp) << 8;
  a |= iobuf_get_noeof (inp);
  return a;
}",1
Detect whether the following code contains vulnerabilities.,"static ram_addr_t s390_virtio_device_num_vq(VirtIOS390Device *dev)

{

    VirtIODevice *vdev = dev->vdev;

    int num_vq;



    for (num_vq = 0; num_vq < VIRTIO_PCI_QUEUE_MAX; num_vq++) {

        if (!virtio_queue_get_num(vdev, num_vq)) {

            break;

        }

    }



    return num_vq;

}
",0
Detect whether the following code contains vulnerabilities.,"void *qemu_memalign(size_t alignment, size_t size)

{

    return VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);

}
",0
Detect whether the following code contains vulnerabilities.,"static int mxf_read_cryptographic_context(MXFCryptoContext *cryptocontext, ByteIOContext *pb, int tag, int size, UID uid)

{

    if (size != 16)

        return -1;

    if (IS_KLV_KEY(uid, mxf_crypto_source_container_ul))

        get_buffer(pb, cryptocontext->source_container_ul, 16);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int snd_timer_stop(struct snd_timer_instance *timeri)
{
	struct snd_timer *timer;
	unsigned long flags;
	int err;

	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);
	if (err < 0)
		return err;
	timer = timeri->timer;
	if (!timer)
		return -EINVAL;
	spin_lock_irqsave(&timer->lock, flags);
	timeri->cticks = timeri->ticks;
	timeri->pticks = 0;
	spin_unlock_irqrestore(&timer->lock, flags);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"validate_exec_list(struct drm_i915_gem_exec_object2 *exec,
		   int count)
{
	int i;

	for (i = 0; i < count; i++) {
		char __user *ptr = (char __user *)(uintptr_t)exec[i].relocs_ptr;
		int length; /* limited by fault_in_pages_readable() */

		if (exec[i].flags & __EXEC_OBJECT_UNKNOWN_FLAGS)
			return -EINVAL;

		/* First check for malicious input causing overflow */
		if (exec[i].relocation_count >
		    INT_MAX / sizeof(struct drm_i915_gem_relocation_entry))
			return -EINVAL;

		length = exec[i].relocation_count *
			sizeof(struct drm_i915_gem_relocation_entry);
		/* we may also need to update the presumed offsets */
		if (!access_ok(VERIFY_WRITE, ptr, length))
			return -EFAULT;

		if (fault_in_multipages_readable(ptr, length))
			return -EFAULT;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void *idr_get_next(struct idr *idp, int *nextidp)
{
	struct idr_layer *p, *pa[MAX_IDR_LEVEL];
	struct idr_layer **paa = &pa[0];
	int id = *nextidp;
	int n, max;

	/* find first ent */
	p = rcu_dereference_raw(idp->top);
	if (!p)
		return NULL;
	n = (p->layer + 1) * IDR_BITS;
	max = 1 << n;

	while (id < max) {
		while (n > 0 && p) {
			n -= IDR_BITS;
			*paa++ = p;
			p = rcu_dereference_raw(p->ary[(id >> n) & IDR_MASK]);
		}

		if (p) {
			*nextidp = id;
			return p;
		}

		/*
		 * Proceed to the next layer at the current level.  Unlike
		 * idr_for_each(), @id isn't guaranteed to be aligned to
		 * layer boundary at this point and adding 1 << n may
		 * incorrectly skip IDs.  Make sure we jump to the
		 * beginning of the next layer using round_up().
		 */
		id = round_up(id + 1, 1 << n);
		while (n < fls(id)) {
			n += IDR_BITS;
			p = *--paa;
		}
	}
	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_spice_display_init(DisplayState *ds)

{

    assert(sdpy.ds == NULL);

    sdpy.ds = ds;

    sdpy.bufsize = (16 * 1024 * 1024);

    sdpy.buf = qemu_malloc(sdpy.bufsize);

    pthread_mutex_init(&sdpy.lock, NULL);

    register_displaychangelistener(ds, &display_listener);



    sdpy.qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_interface(&sdpy.qxl.base);

    assert(sdpy.worker);



    qemu_add_vm_change_state_handler(qemu_spice_vm_change_state_handler, &sdpy);

    qemu_spice_create_host_memslot(&sdpy);

    qemu_spice_create_host_primary(&sdpy);

}
",0
Detect whether the following code contains vulnerabilities.,"int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {
  Cursor c(buf.front());
  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {
    auto b = c.read<char>();
    if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {
      return i;
    } else if (terminatorType_ != TerminatorType::NEWLINE &&
               b == '\r' && !c.isAtEnd() && c.read<char>() == '\n') {
      return i;
    }
  }

  return -1;
}",1
Detect whether the following code contains vulnerabilities.,"static inline void flush_free_hpage_work(struct hstate *h)
{
	if (free_vmemmap_pages_per_hpage(h))
		flush_work(&free_hpage_work);
}",0
Detect whether the following code contains vulnerabilities.,"nvmet_fc_format_rjt(void *buf, u16 buflen, u8 ls_cmd,
			u8 reason, u8 explanation, u8 vendor)
{
	struct fcnvme_ls_rjt *rjt = buf;

	nvmet_fc_format_rsp_hdr(buf, FCNVME_LSDESC_RQST,
			fcnvme_lsdesc_len(sizeof(struct fcnvme_ls_rjt)),
			ls_cmd);
	rjt->rjt.desc_tag = cpu_to_be32(FCNVME_LSDESC_RJT);
	rjt->rjt.desc_len = fcnvme_lsdesc_len(sizeof(struct fcnvme_lsdesc_rjt));
	rjt->rjt.reason_code = reason;
	rjt->rjt.reason_explanation = explanation;
	rjt->rjt.vendor = vendor;

	return sizeof(struct fcnvme_ls_rjt);
}",0
Detect whether the following code contains vulnerabilities.,"static int cmm_timeout_handler(struct ctl_table *ctl, int write,
			       void __user *buffer, size_t *lenp, loff_t *ppos)
{
	char buf[64], *p;
	long nr, seconds;
	unsigned int len;

	if (!*lenp || (*ppos && !write)) {
		*lenp = 0;
		return 0;
	}

	if (write) {
		len = *lenp;
		if (copy_from_user(buf, buffer,
				   len > sizeof(buf) ? sizeof(buf) : len))
			return -EFAULT;
		buf[sizeof(buf) - 1] = '\0';
		cmm_skip_blanks(buf, &p);
		nr = simple_strtoul(p, &p, 0);
		cmm_skip_blanks(p, &p);
		seconds = simple_strtoul(p, &p, 0);
		cmm_set_timeout(nr, seconds);
	} else {
		len = sprintf(buf, ""%ld %ld\n"",
			      cmm_timeout_pages, cmm_timeout_seconds);
		if (len > *lenp)
			len = *lenp;
		if (copy_to_user(buffer, buf, len))
			return -EFAULT;
	}
	*lenp = len;
	*ppos += len;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void qpci_spapr_io_writew(QPCIBus *bus, void *addr, uint16_t value)

{

    QPCIBusSPAPR *s = container_of(bus, QPCIBusSPAPR, bus);

    uint64_t port = (uintptr_t)addr;

    value = bswap16(value);

    if (port < s->pio.size) {

        writew(s->pio_cpu_base + port, value);

    } else {

        writew(s->mmio_cpu_base + port, value);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void qeth_free_cq(struct qeth_card *card)
{
	if (card->qdio.c_q) {
		--card->qdio.no_in_queues;
		kfree(card->qdio.c_q);
		card->qdio.c_q = NULL;
	}
	kfree(card->qdio.out_bufstates);
	card->qdio.out_bufstates = NULL;
}",0
Detect whether the following code contains vulnerabilities.,"void RemoteFsDevice::unmount()
{
    if (details.isLocalFile()) {
        return;
    }

    if (!isConnected() || proc) {
        return;
    }

    if (messageSent) {
        return;
    }

    QString cmd;
    QStringList args;
    if (!details.isLocalFile()) {
        QString mp=mountPoint(details, false);
        if (!mp.isEmpty()) {
            cmd=Utils::findExe(""fusermount"");
            if (!cmd.isEmpty()) {
                args << QLatin1String(""-u"") << QLatin1String(""-z"") << mp;
            } else {
                emit error(tr(""\""fusermount\"" is not installed!""));
            }
        }
    }

    if (!cmd.isEmpty()) {
        setStatusMessage(tr(""Disconnecting...""));
        proc=new QProcess(this);
        proc->setProperty(""unmount"", true);
        connect(proc, SIGNAL(finished(int)), SLOT(procFinished(int)));
        proc->start(cmd, args, QIODevice::ReadOnly);
    }
}",0
Detect whether the following code contains vulnerabilities.,"  switch (recv_into_rbuf (h)) {
  case -1: SET_NEXT_STATE (%.DEAD); return 0;
  case 1:
    save_reply_state (h);
    SET_NEXT_STATE (%.READY);
    return 0;
  case 0:
    length = be32toh (h->sbuf.sr.structured_reply.length);
    offset = be64toh (h->sbuf.sr.payload.offset_data.offset);

    assert (cmd); /* guaranteed by CHECK */
    if (CALLBACK_IS_NOT_NULL (cmd->cb.fn.chunk)) {
      int error = cmd->error;

      if (CALL_CALLBACK (cmd->cb.fn.chunk, cmd->data + (offset - cmd->offset),
                         length - sizeof offset, offset,
                         LIBNBD_READ_DATA, &error) == -1)
        if (cmd->error == 0)
          cmd->error = error ? error : EPROTO;
    }

    SET_NEXT_STATE (%FINISH);
  }",1
Detect whether the following code contains vulnerabilities.,"static int xen_pt_long_reg_write(XenPCIPassthroughState *s, XenPTReg *cfg_entry,

                                 uint32_t *val, uint32_t dev_value,

                                 uint32_t valid_mask)

{

    XenPTRegInfo *reg = cfg_entry->reg;

    uint32_t writable_mask = 0;

    uint32_t throughable_mask = get_throughable_mask(s, reg, valid_mask);



    /* modify emulate register */

    writable_mask = reg->emu_mask & ~reg->ro_mask & valid_mask;

    cfg_entry->data = XEN_PT_MERGE_VALUE(*val, cfg_entry->data, writable_mask);



    /* create value for writing to I/O device register */

    *val = XEN_PT_MERGE_VALUE(*val, dev_value, throughable_mask);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ff_compute_band_indexes(MPADecodeContext *s, GranuleDef *g)

{

    if (g->block_type == 2) {

        if (g->switch_point) {

            /* if switched mode, we handle the 36 first samples as

                long blocks.  For 8000Hz, we handle the 72 first

                exponents as long blocks */

            if (s->sample_rate_index <= 2)

                g->long_end = 8;

            else

                g->long_end = 6;



            g->short_start = 2 + (s->sample_rate_index != 8);

        } else {

            g->long_end    = 0;

            g->short_start = 0;

        }

    } else {

        g->short_start = 13;

        g->long_end    = 22;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void FNAME(update_pte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,
			      u64 *spte, const void *pte)
{
	pt_element_t gpte = *(const pt_element_t *)pte;

	FNAME(prefetch_gpte)(vcpu, sp, spte, gpte, false);
}",0
Detect whether the following code contains vulnerabilities.,"void *g_try_malloc(size_t n_bytes)

{

    __coverity_negative_sink__(n_bytes);

    return malloc(n_bytes == 0 ? 1 : n_bytes);

}
",1
Detect whether the following code contains vulnerabilities.,"compile_parenthesis(char_u **arg, cctx_T *cctx, ppconst_T *ppconst)
{
    int	    ret;
    char_u  *p = *arg + 1;

    if (may_get_next_line_error(p, arg, cctx) == FAIL)
	return FAIL;
    if (ppconst->pp_used <= PPSIZE - 10)
    {
	ret = compile_expr1(arg, cctx, ppconst);
    }
    else
    {
	// Not enough space in ppconst, flush constants.
	if (generate_ppconst(cctx, ppconst) == FAIL)
	    return FAIL;
	ret = compile_expr0(arg, cctx);
    }
    if (may_get_next_line_error(*arg, arg, cctx) == FAIL)
	return FAIL;
    if (**arg == ')')
	++*arg;
    else if (ret == OK)
    {
	emsg(_(e_missing_closing_paren));
	ret = FAIL;
    }
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static void extract_nonewprivs(pid_t pid) {
	char *fname;
	if (asprintf(&fname, ""/proc/%d/root%s"", pid, RUN_NONEWPRIVS_CFG) == -1)
		errExit(""asprintf"");

	struct stat s;
	if (stat(fname, &s) == -1) {
		free(fname);
		return;
	}

	arg_nonewprivs = 1;
	free(fname);
}",1
Detect whether the following code contains vulnerabilities.,"gs_copydevice(gx_device ** pnew_dev, const gx_device * dev, gs_memory_t * mem)
{
    return gs_copydevice2(pnew_dev, dev, false, mem);
}",0
Detect whether the following code contains vulnerabilities.,"static uint64_t omap_pwt_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_read8(opaque, addr);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        return s->frc;

    case 0x04:	/* VCR */

        return s->vrc;

    case 0x08:	/* GCR */

        return s->gcr;

    }

    OMAP_BAD_REG(addr);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int fts3DoAutoincrmerge(
  Fts3Table *p,                   /* FTS3 table handle */
  const char *zParam              /* Nul-terminated string containing boolean */
){
  int rc = SQLITE_OK;
  sqlite3_stmt *pStmt = 0;
  p->nAutoincrmerge = fts3Getint(&zParam);
  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>MergeCount(p) ){
    p->nAutoincrmerge = 8;
  }
  if( !p->bHasStat ){
    assert( p->bFts4==0 );
    sqlite3Fts3CreateStatTable(&rc, p);
    if( rc ) return rc;
  }
  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);
  if( rc ) return rc;
  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);
  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);
  sqlite3_step(pStmt);
  rc = sqlite3_reset(pStmt);
  return rc;
}",0
Detect whether the following code contains vulnerabilities.,"void xen_map_cache_init(void)

{

    unsigned long size;

    struct rlimit rlimit_as;



    mapcache = g_malloc0(sizeof (MapCache));



    QTAILQ_INIT(&mapcache->locked_entries);

    mapcache->last_address_index = -1;



    getrlimit(RLIMIT_AS, &rlimit_as);

    if (rlimit_as.rlim_max < MCACHE_MAX_SIZE) {

        rlimit_as.rlim_cur = rlimit_as.rlim_max;

    } else {

        rlimit_as.rlim_cur = MCACHE_MAX_SIZE;

    }



    setrlimit(RLIMIT_AS, &rlimit_as);

    mapcache->max_mcache_size = rlimit_as.rlim_cur;



    mapcache->nr_buckets =

        (((mapcache->max_mcache_size >> XC_PAGE_SHIFT) +

          (1UL << (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT)) - 1) >>

         (MCACHE_BUCKET_SHIFT - XC_PAGE_SHIFT));



    size = mapcache->nr_buckets * sizeof (MapCacheEntry);

    size = (size + XC_PAGE_SIZE - 1) & ~(XC_PAGE_SIZE - 1);

    DPRINTF(""%s, nr_buckets = %lx size %lu\n"", __func__,

            mapcache->nr_buckets, size);

    mapcache->entry = g_malloc0(size);

}
",1
Detect whether the following code contains vulnerabilities.,"static int oidc_handle_redirect_authorization_response(request_rec *r,
		oidc_cfg *c, oidc_session_t *session) {

	oidc_debug(r, ""enter"");

	/* read the parameters from the query string */
	apr_table_t *params = apr_table_make(r->pool, 8);
	oidc_util_read_form_encoded_params(r, params, r->args);

	/* do the actual work */
	return oidc_handle_authorization_response(r, c, session, params, ""query"");
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t srpt_tpg_enable_show(struct config_item *item, char *page)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct srpt_port *sport = container_of(se_tpg, struct srpt_port, port_tpg_1);

	return snprintf(page, PAGE_SIZE, ""%d\n"", (sport->enabled) ? 1: 0);
}",0
Detect whether the following code contains vulnerabilities.,"static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {
	pyc_object *tmp = NULL;
	pyc_object *ret = NULL;
	ut32 i = 0;

	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->data = r_list_newf ((RListFree)free_object);
	if (!ret->data) {
		free (ret);
		return NULL;
	}
	for (i = 0; i < size; i++) {
		tmp = get_object (buffer);
		if (!tmp) {
			r_list_free (ret->data);
			R_FREE (ret);
			return NULL;
		}
		if (!r_list_append (ret->data, tmp)) {
			free_object (tmp);
			r_list_free (ret->data);
			free (ret);
			return NULL;
		}
	}
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static const struct usb_cdc_union_desc *
ims_pcu_get_cdc_union_desc(struct usb_interface *intf)
{
	const void *buf = intf->altsetting->extra;
	size_t buflen = intf->altsetting->extralen;
	struct usb_cdc_union_desc *union_desc;

	if (!buf) {
		dev_err(&intf->dev, ""Missing descriptor data\n"");
		return NULL;
	}

	if (!buflen) {
		dev_err(&intf->dev, ""Zero length descriptor\n"");
		return NULL;
	}

	while (buflen > 0) {
		union_desc = (struct usb_cdc_union_desc *)buf;

		if (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&
		    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {
			dev_dbg(&intf->dev, ""Found union header\n"");
			return union_desc;
		}

		buflen -= union_desc->bLength;
		buf += union_desc->bLength;
	}

	dev_err(&intf->dev, ""Missing CDC union descriptor\n"");
	return NULL;",1
Detect whether the following code contains vulnerabilities.,"static void ssh_parse_filename(const char *filename, QDict *options,

                               Error **errp)

{

    if (qdict_haskey(options, ""user"") ||

        qdict_haskey(options, ""host"") ||

        qdict_haskey(options, ""port"") ||

        qdict_haskey(options, ""path"") ||

        qdict_haskey(options, ""host_key_check"")) {

        error_setg(errp, ""user, host, port, path, host_key_check cannot be used at the same time as a file option"");

        return;

    }



    parse_uri(filename, options, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_syslog_parse_identifier(const char *str,
                                         const char *ident, const char *pid, int ret) {
        const char *buf = str;
        _cleanup_free_ char *ident2 = NULL, *pid2 = NULL;
        int ret2;

        ret2 = syslog_parse_identifier(&buf, &ident2, &pid2);

        assert_se(ret == ret2);
        assert_se(ident == ident2 || streq_ptr(ident, ident2));
        assert_se(pid == pid2 || streq_ptr(pid, pid2));
}",1
Detect whether the following code contains vulnerabilities.,"static pj_status_t tls_shutdown(pjsip_transport *transport)
{
    struct tls_transport *tls = (struct tls_transport*)transport;
    
    /* Stop keep-alive timer. */
    if (tls->ka_timer.id) {
	pjsip_endpt_cancel_timer(tls->base.endpt, &tls->ka_timer);
	tls->ka_timer.id = PJ_FALSE;
    }

    return PJ_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	int result;
	handle_t *handle = NULL;
	struct super_block *sb = file_inode(vma->vm_file)->i_sb;
	bool write = vmf->flags & FAULT_FLAG_WRITE;

	if (write) {
		sb_start_pagefault(sb);
		file_update_time(vma->vm_file);
		handle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,
						EXT4_DATA_TRANS_BLOCKS(sb));
	}

	if (IS_ERR(handle))
		result = VM_FAULT_SIGBUS;
	else
		result = __dax_fault(vma, vmf, ext4_get_block_dax,
						ext4_end_io_unwritten);

	if (write) {
		if (!IS_ERR(handle))
			ext4_journal_stop(handle);
		sb_end_pagefault(sb);
	}

	return result;
}",1
Detect whether the following code contains vulnerabilities.,"GF_Err trgr_box_read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs);
}",0
Detect whether the following code contains vulnerabilities.,"ossl_cipher_set_key_length(VALUE self, VALUE key_length)
{
    int len = NUM2INT(key_length);
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);
    if (EVP_CIPHER_CTX_set_key_length(ctx, len) != 1)
        ossl_raise(eCipherError, NULL);

    return key_length;
}",0
Detect whether the following code contains vulnerabilities.,"hook_infolist_get (struct t_weechat_plugin *plugin, const char *infolist_name,
                   void *pointer, const char *arguments)
{
    struct t_hook *ptr_hook, *next_hook;
    struct t_infolist *value;
    
    /* make C compiler happy */
    (void) plugin;
    
    if (!infolist_name || !infolist_name[0])
        return NULL;
    
    hook_exec_start ();
    
    ptr_hook = weechat_hooks[HOOK_TYPE_INFOLIST];
    while (ptr_hook)
    {
        next_hook = ptr_hook->next_hook;
        
        if (!ptr_hook->deleted
            && !ptr_hook->running
            && (string_strcasecmp (HOOK_INFOLIST(ptr_hook, infolist_name),
                                   infolist_name) == 0))
        {
            ptr_hook->running = 1;
            value = (HOOK_INFOLIST(ptr_hook, callback))
                (ptr_hook->callback_data, infolist_name, pointer, arguments);
            ptr_hook->running = 0;
            
            hook_exec_end ();
            return value;
        }
        
        ptr_hook = next_hook;
    }
    
    hook_exec_end ();
    
    /* infolist not found */
    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"xmlDictComputeBigQKey(const xmlChar *prefix, int plen,
                      const xmlChar *name, int len)
{
    uint32_t hash;
    int i;

    hash = 0;

    for (i = 0;i < plen; i++) {
        hash += prefix[i];
	hash += (hash << 10);
	hash ^= (hash >> 6);
    }
    hash += ':';
    hash += (hash << 10);
    hash ^= (hash >> 6);

    for (i = 0;i < len; i++) {
        hash += name[i];
	hash += (hash << 10);
	hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}",1
Detect whether the following code contains vulnerabilities.,"int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
{
	struct au1100fb_device *fbdev;
	unsigned int len;
	unsigned long start=0, off;

	fbdev = to_au1100fb_device(fbi);

	if (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {
		return -EINVAL;
	}

	start = fbdev->fb_phys & PAGE_MASK;
	len = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);

	off = vma->vm_pgoff << PAGE_SHIFT;

	if ((vma->vm_end - vma->vm_start + off) > len) {
		return -EINVAL;
	}

	off += start;
	vma->vm_pgoff = off >> PAGE_SHIFT;

	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
	pgprot_val(vma->vm_page_prot) |= (6 << 9); //CCA=6

	if (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,
				vma->vm_end - vma->vm_start,
				vma->vm_page_prot)) {
		return -EAGAIN;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void *umm_calloc( size_t num, size_t item_size ) {
  void *ret;
  size_t size = item_size * num;

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  if (POISON_SIZE(size) >= SIZE_MAX - size) return NULL;  // Overflow
  size += POISON_SIZE(size);
  ret = _umm_malloc(size);
  if (ret != NULL) memset(ret, 0x00, size);

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}",0
Detect whether the following code contains vulnerabilities.,"char ssl3_cbc_record_digest_supported(const EVP_MD *digest)
	{
#ifdef OPENSSL_FIPS
	if (FIPS_mode())
		return 0;
#endif
	switch (digest->type)
		{
		case NID_md5:
		case NID_sha1:
		case NID_sha224:
		case NID_sha256:
		case NID_sha384:
		case NID_sha512:
			return 1;
		default:
			return 0;
		}
	}",1
Detect whether the following code contains vulnerabilities.,"static void piix4_ide_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->no_hotplug = 1;

    k->init = pci_piix_ide_initfn;

    k->exit = pci_piix_ide_exitfn;

    k->vendor_id = PCI_VENDOR_ID_INTEL;

    k->device_id = PCI_DEVICE_ID_INTEL_82371AB;

    k->class_id = PCI_CLASS_STORAGE_IDE;

    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);

    dc->no_user = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"void append_info(DYNAMIC_STRING *ds, ulonglong affected_rows,
                 const char *info)
{
  char buf[40], buff2[21];
  sprintf(buf,""affected rows: %s\n"", llstr(affected_rows, buff2));
  dynstr_append(ds, buf);
  if (info)
  {
    dynstr_append(ds, ""info: "");
    dynstr_append(ds, info);
    dynstr_append_mem(ds, ""\n"", 1);
  }
}",0
Detect whether the following code contains vulnerabilities.,"int __xfrm_state_delete(struct xfrm_state *x)
{
	struct net *net = xs_net(x);
	int err = -ESRCH;

	if (x->km.state != XFRM_STATE_DEAD) {
		x->km.state = XFRM_STATE_DEAD;
		spin_lock(&net->xfrm.xfrm_state_lock);
		list_del(&x->km.all);
		hlist_del_rcu(&x->bydst);
		hlist_del_rcu(&x->bysrc);
		if (x->id.spi)
			hlist_del_rcu(&x->byspi);
		net->xfrm.state_num--;
		spin_unlock(&net->xfrm.xfrm_state_lock);

		xfrm_dev_state_delete(x);

		/* All xfrm_state objects are created by xfrm_state_alloc.
		 * The xfrm_state_alloc call gives a reference, and that
		 * is what we are dropping here.
		 */
		xfrm_state_put(x);
		err = 0;
	}

	return err;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_mov_close_hinting(MOVTrack *track) {

    AVFormatContext* rtp_ctx = track->rtp_ctx;

    uint8_t *ptr;



    av_freep(&track->enc);

    sample_queue_free(&track->sample_queue);

    if (!rtp_ctx)

        return;

    if (rtp_ctx->pb) {

        av_write_trailer(rtp_ctx);

        url_close_dyn_buf(rtp_ctx->pb, &ptr);

        av_free(ptr);

    }

    av_metadata_free(&rtp_ctx->streams[0]->metadata);

    av_metadata_free(&rtp_ctx->metadata);


    av_free(rtp_ctx->streams[0]);

    av_freep(&rtp_ctx);

}",1
Detect whether the following code contains vulnerabilities.,"  int ADDCALL sass_compiler_parse(struct Sass_Compiler* compiler)
  {
    if (compiler == 0) return 1;
    if (compiler->state == SASS_COMPILER_PARSED) return 0;
    if (compiler->state != SASS_COMPILER_CREATED) return -1;
    if (compiler->c_ctx == NULL) return 1;
    if (compiler->cpp_ctx == NULL) return 1;
    if (compiler->c_ctx->error_status)
      return compiler->c_ctx->error_status;
    // parse the context we have set up (file or data)
    compiler->root = sass_parse_block(compiler);
    // success
    return 0;
  }",0
Detect whether the following code contains vulnerabilities.,"static SSL_METHOD *ssl23_get_client_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
	if (ver == SSL2_VERSION)
		return(SSLv2_client_method());
#endif
	if (ver == SSL3_VERSION)
		return(SSLv3_client_method());
	else if (ver == TLS1_VERSION)
		return(TLSv1_client_method());
	else
		return(NULL);
	}",1
Detect whether the following code contains vulnerabilities.,"static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;

    assert(qemu_in_coroutine());
    /* Negotiation are always in main loop. */
    watch = qio_channel_add_watch(ioc,
                                  G_IO_IN,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = nbd_read(ioc, buffer, size, NULL);
    g_source_remove(watch);
    return ret;

}",1
Detect whether the following code contains vulnerabilities.,"static void local_mapped_file_attr(FsContext *ctx, const char *path,

                                   struct stat *stbuf)

{

    FILE *fp;

    char buf[ATTR_MAX];

    char *attr_path;



    attr_path = local_mapped_attr_path(ctx, path);

    fp = local_fopen(attr_path, ""r"");

    g_free(attr_path);

    if (!fp) {

        return;

    }

    memset(buf, 0, ATTR_MAX);

    while (fgets(buf, ATTR_MAX, fp)) {

        if (!strncmp(buf, ""virtfs.uid"", 10)) {

            stbuf->st_uid = atoi(buf+11);

        } else if (!strncmp(buf, ""virtfs.gid"", 10)) {

            stbuf->st_gid = atoi(buf+11);

        } else if (!strncmp(buf, ""virtfs.mode"", 11)) {

            stbuf->st_mode = atoi(buf+12);

        } else if (!strncmp(buf, ""virtfs.rdev"", 11)) {

            stbuf->st_rdev = atoi(buf+12);

        }

        memset(buf, 0, ATTR_MAX);

    }

    fclose(fp);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int32_t efsctsi(uint32_t val)

{

    CPU_FloatU u;



    u.l = val;

    /* NaN are not treated the same way IEEE 754 does */

    if (unlikely(float32_is_nan(u.f)))

        return 0;



    return float32_to_int32(u.f, &env->vec_status);

}
",0
Detect whether the following code contains vulnerabilities.,"int av_packet_ref(AVPacket *dst, const AVPacket *src)

{

    int ret;



    ret = av_packet_copy_props(dst, src);

    if (ret < 0)

        return ret;



    if (!src->buf) {

        ret = packet_alloc(&dst->buf, src->size);

        if (ret < 0)

            goto fail;

        memcpy(dst->buf->data, src->data, src->size);



        dst->data = dst->buf->data;

    } else {

        dst->buf = av_buffer_ref(src->buf);

        if (!dst->buf) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }

        dst->data = src->data;

    }



    dst->size = src->size;



    return 0;

fail:

    av_packet_free_side_data(dst);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"        QueryParamsTest()
            : cxxtools::unit::TestSuite(""queryparams"")
        {
            registerMethod(""testQueryParams"", *this, &QueryParamsTest::testQueryParams);
            registerMethod(""testCopy"", *this, &QueryParamsTest::testCopy);
            registerMethod(""testParseUrl"", *this, &QueryParamsTest::testParseUrl);
            registerMethod(""testParseUrlSpecialChar"", *this, &QueryParamsTest::testParseUrlSpecialChar);
            registerMethod(""testCount"", *this, &QueryParamsTest::testCount);
            registerMethod(""testCombine"", *this, &QueryParamsTest::testCombine);
            registerMethod(""testIterator"", *this, &QueryParamsTest::testIterator);
            registerMethod(""testGetUrl"", *this, &QueryParamsTest::testGetUrl);
        }",1
Detect whether the following code contains vulnerabilities.,"time_t base64totime_t(char* s, database* db, const char* field_name){
  
  byte* b=decode_base64(s,strlen(s),NULL);
  char* endp;
  
  if (b==NULL||strcmp(s,""0"")==0) {
    
    /* Should we print error here? */
    free(b);
    
    return 0;
  } else {
    time_t t = strtol((char *)b,&endp,10);
    
    if (endp[0]!='\0') {
      LOG_DB_FORMAT_LINE(LOG_LEVEL_WARNING, could not read '%s' from database: strtoll failed for '%s' (base64 encoded value: '%s'), field_name, b, s)
      free(b);
      return 0;
    }
    log_msg(LOG_LEVEL_DEBUG, ""base64totime_t: converted '%s': '%s' to %lld (base64 encoded value '%s')"", field_name, b, (long long) t, s);
    free(b);
    return t;
  }
  
  
}",1
Detect whether the following code contains vulnerabilities.,"QPDF_Stream::setDescription(QPDF* qpdf, std::string const& description)
{
    this->QPDFObject::setDescription(qpdf, description);
    setDictDescription();
}",0
Detect whether the following code contains vulnerabilities.,"static int get_max_p_order(int max_porder, int n, int order)

{

    int porder, max_parts;



    porder = max_porder;

    while(porder > 0) {

        max_parts = (1 << porder);

        if(!(n % max_parts) && (n > max_parts*order)) {

            break;

        }

        porder--;

    }

    return porder;

}
",0
Detect whether the following code contains vulnerabilities.,"ccid_transceive_escape (ccid_driver_t handle,
                        const unsigned char *data, size_t datalen,
                        unsigned char *resp, size_t maxresplen, size_t *nresp)
{
  return send_escape_cmd (handle, data, datalen, resp, maxresplen, nresp);
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(xml_parse_into_struct)
{
	xml_parser *parser;
	zval *pind, **xdata, **info = NULL;
	char *data;
	int data_len, ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rsZ|Z"", &pind, &data, &data_len, &xdata, &info) == FAILURE) {
		return;
	}
	
	if (info) {	
		zval_dtor(*info);
		array_init(*info);
	}

	ZEND_FETCH_RESOURCE(parser,xml_parser *, &pind, -1, ""XML Parser"", le_xml_parser);

	zval_dtor(*xdata);
	array_init(*xdata);

	parser->data = *xdata;
	
	if (info) {
		parser->info = *info;
	}
	
	parser->level = 0;
	parser->ltags = safe_emalloc(XML_MAXLEVEL, sizeof(char *), 0);

	XML_SetDefaultHandler(parser->parser, _xml_defaultHandler);
	XML_SetElementHandler(parser->parser, _xml_startElementHandler, _xml_endElementHandler);
	XML_SetCharacterDataHandler(parser->parser, _xml_characterDataHandler);

	parser->isparsing = 1;
	ret = XML_Parse(parser->parser, data, data_len, 1);
	parser->isparsing = 0;

	RETVAL_LONG(ret);
}",1
Detect whether the following code contains vulnerabilities.,"    char* parseKey( char* ptr, FileNode& map_node, FileNode& value_placeholder )
    {
        char c;
        char *endptr = ptr - 1, *saveptr;

        if( *ptr == '-' )
            CV_PARSE_ERROR_CPP( ""Key may not start with \'-\'"" );

        do c = *++endptr;
        while( cv_isprint(c) && c != ':' );

        if( c != ':' )
            CV_PARSE_ERROR_CPP( ""Missing \':\'"" );

        saveptr = endptr + 1;
        do c = *--endptr;
        while( c == ' ' );

        ++endptr;
        if( endptr == ptr )
            CV_PARSE_ERROR_CPP( ""An empty key"" );

        value_placeholder = fs->addNode(map_node, std::string(ptr, endptr - ptr), FileNode::NONE);
        ptr = saveptr;

        return ptr;
    }",1
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qmp_chardev_open_serial(ChardevHostdev *serial,

                                                Error **errp)

{

#ifdef HAVE_CHARDEV_TTY

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (error_is_set(errp)) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

#else

    error_setg(errp, ""character device backend type 'serial' not supported"");

    return NULL;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void gf_filter_abort(GF_Filter *filter)
{
	u32 i;
	GF_FilterEvent evt;
	if (!filter) return;
	gf_mx_p(filter->tasks_mx);
	GF_FEVT_INIT(evt, GF_FEVT_STOP, NULL);
	for (i=0; i<filter->num_input_pids; i++) {
		GF_FilterPid *pid = gf_list_get(filter->input_pids, i);
		gf_filter_pid_set_discard(pid, GF_TRUE);
		evt.base.on_pid = pid;
		gf_filter_pid_send_event(pid, &evt);
	}
	for (i=0; i<filter->num_output_pids; i++) {
		GF_FilterPid *pid = gf_list_get(filter->output_pids, i);
		gf_filter_pid_set_eos(pid);
	}
	gf_mx_v(filter->tasks_mx);
}",0
Detect whether the following code contains vulnerabilities.,"static int cow_read(BlockDriverState *bs, int64_t sector_num,

                    uint8_t *buf, int nb_sectors)

{

    BDRVCowState *s = bs->opaque;

    int ret, n;



    while (nb_sectors > 0) {

        if (cow_is_allocated(bs, sector_num, nb_sectors, &n)) {

            ret = bdrv_pread(bs->file,

                        s->cow_sectors_offset + sector_num * 512,

                        buf, n * 512);

            if (ret != n * 512)

                return -1;

        } else {

            if (bs->backing_hd) {

                /* read from the base image */

                ret = bdrv_read(bs->backing_hd, sector_num, buf, n);

                if (ret < 0)

                    return -1;

            } else {

            memset(buf, 0, n * 512);

        }

        }

        nb_sectors -= n;

        sector_num += n;

        buf += n * 512;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void sdp_parse_fmtp_config(AVCodecContext *codec, char *attr, char *value)

{

    switch (codec->codec_id) {

        case CODEC_ID_MPEG4:

        case CODEC_ID_AAC:

            if (!strcmp(attr, ""config"")) {

                /* decode the hexa encoded parameter */

                int len = hex_to_data(NULL, value);



                codec->extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);

                if (!codec->extradata)

                    return;

                codec->extradata_size = len;

                hex_to_data(codec->extradata, value);

            }

            break;

        default:

            break;

    }

    return;

}",1
Detect whether the following code contains vulnerabilities.,"static inline bool migration_bitmap_clear_dirty(RAMState *rs, ram_addr_t addr)

{

    bool ret;

    int nr = addr >> TARGET_PAGE_BITS;

    unsigned long *bitmap = atomic_rcu_read(&rs->ram_bitmap)->bmap;



    ret = test_and_clear_bit(nr, bitmap);



    if (ret) {

        rs->migration_dirty_pages--;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"handle_raw_data(char *packet, int len, struct query *q, int dns_fd, int tun_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));

	/* copy to packet buffer, update length */
	users[userid].inpacket.offset = 0;
	memcpy(users[userid].inpacket.data, packet, len);
	users[userid].inpacket.len = len;

	if (debug >= 1) {
		fprintf(stderr, ""IN   pkt raw, total %d, from user %d\n"",
			users[userid].inpacket.len, userid);
	}

	handle_full_packet(tun_fd, dns_fd, userid);
}",1
Detect whether the following code contains vulnerabilities.,"int ff_packet_split_and_drop_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){

        int i;

        unsigned int size;

        uint8_t *p;



        p = pkt->data + pkt->size - 8 - 5;

        for (i=1; ; i++){

            size = AV_RB32(p);

            if (size>INT_MAX - 5 || p - pkt->data < size)


            if (p[4]&128)

                break;

            if (p - pkt->data < size + 5)


            p-= size+5;



        }

        pkt->size = p - pkt->data - size;

        av_assert0(pkt->size >= 0);

        return 1;

    }


}",1
Detect whether the following code contains vulnerabilities.,"static inline void sem_getref_and_unlock(struct sem_array *sma)
{
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
}",1
Detect whether the following code contains vulnerabilities.,"  void reset_offset_limit()
  {
    unit->offset_limit_cnt= 0;
  }",0
Detect whether the following code contains vulnerabilities.,"void do_tlbwr (void)

{

    int r = cpu_mips_get_random(env);



    invalidate_tlb(r, 1);

    fill_tlb(r);

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t omap_lpg_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    struct omap_lpg_s *s = (struct omap_lpg_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_read8(opaque, addr);

    }



    switch (offset) {

    case 0x00:	/* LCR */

        return s->control;



    case 0x04:	/* PMR */

        return s->power;

    }



    OMAP_BAD_REG(addr);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void block_job_sleep_ns(BlockJob *job, QEMUClockType type, int64_t ns)

{

    assert(job->busy);



    /* Check cancellation *before* setting busy = false, too!  */

    if (block_job_is_cancelled(job)) {

        return;

    }



    job->busy = false;

    if (!block_job_should_pause(job)) {

        co_aio_sleep_ns(blk_get_aio_context(job->blk), type, ns);

    }

    /* The job can be paused while sleeping, so check this again */

    if (block_job_should_pause(job)) {

        qemu_coroutine_yield();

    }

    job->busy = true;

}
",1
Detect whether the following code contains vulnerabilities.,"Item::Type Item_name_const::type() const
{
  /*
    As 
    1. one can try to create the Item_name_const passing non-constant 
    arguments, although it's incorrect and 
    2. the type() method can be called before the fix_fields() to get
    type information for a further type cast, e.g. 
    if (item->type() == FIELD_ITEM) 
      ((Item_field *) item)->... 
    we return NULL_ITEM in the case to avoid wrong casting.

    valid_args guarantees value_item->basic_const_item(); if type is
    FUNC_ITEM, then we have a fudged item_func_neg() on our hands
    and return the underlying type.
    For Item_func_set_collation()
    e.g. NAME_CONST('name', 'value' COLLATE collation) we return its
    'value' argument type. 
  */
  if (!valid_args)
    return NULL_ITEM;
  Item::Type value_type= value_item->type();
  if (value_type == FUNC_ITEM)
  {
    /* 
      The second argument of NAME_CONST('name', 'value') must be 
      a simple constant item or a NEG_FUNC/COLLATE_FUNC.
    */
    DBUG_ASSERT(((Item_func *) value_item)->functype() == 
                Item_func::NEG_FUNC ||
                ((Item_func *) value_item)->functype() == 
                Item_func::COLLATE_FUNC);
    return ((Item_func *) value_item)->key_item()->type();            
  }
  return value_type;
}",0
Detect whether the following code contains vulnerabilities.,"  inline TMP_TABLE_SHARE *tmp_table_share(TABLE *table)
  {
    DBUG_ASSERT(table->s->tmp_table);
    return static_cast<TMP_TABLE_SHARE *>(table->s);
  }",0
Detect whether the following code contains vulnerabilities.,"transit_state_singlebyte (struct dfa *d, int s, unsigned char const *p,
                                  int *next_state)
{
  int *t;
  int works = s;

  status_transit_state rval = TRANSIT_STATE_IN_PROGRESS;

  while (rval == TRANSIT_STATE_IN_PROGRESS)
    {
      if ((t = d->trans[works]) != NULL)
        {
          works = t[*p];
          rval = TRANSIT_STATE_DONE;
          if (works < 0)
            works = 0;
        }
      else if (works < 0)
        {
          if (p == buf_end)
            {
              /* At the moment, it must not happen.  */
              abort ();
            }
          works = 0;
        }
      else if (d->fails[works])
        {
          works = d->fails[works][*p];
          rval = TRANSIT_STATE_DONE;
        }
      else
        {
          build_state(works, d);
        }
    }
  *next_state = works;
  return rval;
}",1
Detect whether the following code contains vulnerabilities.,"parse_identifier(const char *id)
{
    unsigned int parsed = 0;

    assert(id);

    if (!isalpha(id[0]) && (id[0] != '_')) {
        return -parsed;
    }

    ++parsed;
    ++id;

    while (isalnum(id[0]) || (id[0] == '_') || (id[0] == '-') || (id[0] == '.')) {
        ++parsed;
        ++id;
    }

    return parsed;
}",0
Detect whether the following code contains vulnerabilities.,"static void sigp_store_status_at_address(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;

    uint32_t address = si->param & 0x7ffffe00u;



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    cpu_synchronize_state(cs);



    if (s390_store_status(cpu, address, false)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* params = GetInput(context, node, kParams);
  const TfLiteTensor* indices = GetInput(context, node, kIndices);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);

  switch (indices->type) {
    case kTfLiteInt32:
      return EvalGatherNd<int32_t>(context, params, indices, output);
    case kTfLiteInt64:
      return EvalGatherNd<int64_t>(context, params, indices, output);
    default:
      context->ReportError(
          context, ""Indices of type '%s' are not supported by gather_nd."",
          TfLiteTypeGetName(indices->type));
      return kTfLiteError;
  }
}",1
Detect whether the following code contains vulnerabilities.,"static int subviewer_decode_frame(AVCodecContext *avctx,

                                  void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    char c;

    AVSubtitle *sub = data;

    const char *ptr = avpkt->data;

    AVBPrint buf;



    /* To be removed later */

    if (sscanf(ptr, ""%*u:%*u:%*u.%*u,%*u:%*u:%*u.%*u%c"", &c) == 1) {

        av_log(avctx, AV_LOG_ERROR, ""AVPacket is not clean (contains timing ""

               ""information). You need to upgrade your libavformat or ""

               ""sanitize your packet.\n"");

        return AVERROR_INVALIDDATA;

    }



    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);

    // note: no need to rescale pts & duration since they are in the same

    // timebase as ASS (1/100)

    if (ptr && avpkt->size > 0 && !subviewer_event_to_ass(&buf, ptr))

        ff_ass_add_rect(sub, buf.str, avpkt->pts, avpkt->duration, 0);

    *got_sub_ptr = sub->num_rects > 0;

    av_bprint_finalize(&buf, NULL);

    return avpkt->size;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vtd_iommu_notify_flag_changed(MemoryRegion *iommu,

                                          IOMMUNotifierFlag old,

                                          IOMMUNotifierFlag new)

{

    VTDAddressSpace *vtd_as = container_of(iommu, VTDAddressSpace, iommu);



    if (new & IOMMU_NOTIFIER_MAP) {

        error_report(""Device at bus %s addr %02x.%d requires iommu ""

                     ""notifier which is currently not supported by ""

                     ""intel-iommu emulation"",

                     vtd_as->bus->qbus.name, PCI_SLOT(vtd_as->devfn),

                     PCI_FUNC(vtd_as->devfn));

        exit(1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return;
	newitem->next = c->next;
	newitem->prev = c->prev;
	if ( newitem->next )
		newitem->next->prev = newitem;
	if ( c == array->child )
		array->child = newitem;
	else
		newitem->prev->next = newitem;
	c->next = c->prev = 0;
	cJSON_Delete( c );
}",1
Detect whether the following code contains vulnerabilities.,"Http2Stream::Provider::Stream::Stream(Http2Stream* stream, int options)
    : Http2Stream::Provider(stream, options) {
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",0
Detect whether the following code contains vulnerabilities.,"qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
	      u32 level, const char *fmt, ...)
{
	va_list va;
	struct va_format vaf;
	char nfunc[32];

	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);

	va_start(va, fmt);

	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & level))
		goto ret;

	if (likely(qedi) && likely(qedi->pdev))
		pr_info(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
			nfunc, line, qedi->host_no, &vaf);
	else
		pr_info(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);

ret:
	va_end(va);
}",1
Detect whether the following code contains vulnerabilities.,"static bool is_special_wait_psw(CPUState *cs)

{

    /* signal quiesce */

    return cs->kvm_run->psw_addr == 0xfffUL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void thread_pool_init(void)

{

    thread_pool_init_one(&global_pool, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"Aml *aml_arg(int pos)

{

    Aml *var;

    uint8_t op = 0x68 /* ARG0 op */ + pos;



    assert(pos <= 6);

    var = aml_opcode(op);

    return var;

}
",0
Detect whether the following code contains vulnerabilities.,"void timeoutcb(struct ev_loop *loop, ev_timer *w, int revents) {
  auto conn = static_cast<Connection *>(w->data);
  auto dconn = static_cast<HttpDownstreamConnection *>(conn->data);

  if (w == &conn->rt && !conn->expired_rt()) {
    return;
  }

  if (LOG_ENABLED(INFO)) {
    DCLOG(INFO, dconn) << ""Time out"";
  }

  auto downstream = dconn->get_downstream();
  auto upstream = downstream->get_upstream();
  auto handler = upstream->get_client_handler();
  auto &resp = downstream->response();

  // Do this so that dconn is not pooled
  resp.connection_close = true;

  if (upstream->downstream_error(dconn, Downstream::EVENT_TIMEOUT) != 0) {
    delete handler;
  }
}",0
Detect whether the following code contains vulnerabilities.,"static inline int xfrm_byidx_should_resize(struct net *net, int total)
{
	unsigned int hmask = net->xfrm.policy_idx_hmask;

	if ((hmask + 1) < xfrm_policy_hashmax &&
	    total > hmask)
		return 1;

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void do_addo (void)

{

    T2 = T0;

    T0 += T1;

    if (likely(!((T2 ^ T1 ^ (-1)) & (T2 ^ T0) & (1 << 31)))) {

        xer_ov = 0;

    } else {

        xer_so = 1;

        xer_ov = 1;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)
{
    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
    Icc -> manufacturer = (cmsUInt32Number) manufacturer;
}",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(duplicate)(uint8_t src[], int stride)

{

#if TEMPLATE_PP_MMX

    __asm__ volatile(

        ""movq (%0), %%mm0               \n\t""

        ""add %1, %0                     \n\t""

        ""movq %%mm0, (%0)               \n\t""

        ""movq %%mm0, (%0, %1)           \n\t""

        ""movq %%mm0, (%0, %1, 2)        \n\t""

        : ""+r"" (src)

        : ""r"" ((x86_reg)-stride)

    );

#else

    int i;

    uint8_t *p=src;

    for(i=0; i<3; i++){

        p-= stride;

        memcpy(p, src, 8);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void jv_parser_set_buf(struct jv_parser* p, const char* buf, int length, int is_partial) {
  assert((p->curr_buf == 0 || p->curr_buf_pos == p->curr_buf_length)
         && ""previous buffer not exhausted"");
  while (length > 0 && p->bom_strip_position < sizeof(UTF8_BOM)) {
    if ((unsigned char)*buf == UTF8_BOM[p->bom_strip_position]) {
      // matched a BOM character
      buf++;
      length--;
      p->bom_strip_position++;
    } else {
      if (p->bom_strip_position == 0) {
        // no BOM in this document
        p->bom_strip_position = sizeof(UTF8_BOM);
      } else {
        // malformed BOM (prefix present, rest missing)
        p->bom_strip_position = 0xff;
      }
    }
  }
  p->curr_buf = buf;
  p->curr_buf_length = length;
  p->curr_buf_pos = 0;
  p->curr_buf_is_partial = is_partial;
}",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(SplObjectStorage, key)
{
	spl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	
	RETURN_LONG(intern->index);
} /* }}} */",1
Detect whether the following code contains vulnerabilities.,"void machine_register_compat_props(MachineState *machine)

{

    MachineClass *mc = MACHINE_GET_CLASS(machine);

    int i;

    GlobalProperty *p;



    if (!mc->compat_props) {

        return;

    }



    for (i = 0; i < mc->compat_props->len; i++) {

        p = g_array_index(mc->compat_props, GlobalProperty *, i);



        qdev_prop_register_global(p);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static const char *cgm_get_cgroup(void *hdata, const char *subsystem)
{
	struct cgm_data *d = hdata;

	if (!d || !d->cgroup_path)
		return NULL;
	return d->cgroup_path;
}",0
Detect whether the following code contains vulnerabilities.,"static int get_avc_nalsize(H264Context *h, const uint8_t *buf,

                           int buf_size, int *buf_index)

{

    int i, nalsize = 0;



    if (*buf_index >= buf_size - h->nal_length_size)

        return -1;



    for (i = 0; i < h->nal_length_size; i++)

        nalsize = (nalsize << 8) | buf[(*buf_index)++];

    if (nalsize <= 0 || nalsize > buf_size - *buf_index) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""AVC: nal size %d\n"", nalsize);

        return -1;

    }

    return nalsize;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline TCGv gen_ld8s(TCGv addr, int index)

{

    TCGv tmp = new_tmp();

    tcg_gen_qemu_ld8s(tmp, addr, index);

    return tmp;

}
",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);

  if (type == kGenericOptimized) {
    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),
                         GetTensorShape(output), GetTensorData<float>(output));
  } else {
    reference_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),
                         GetTensorShape(output), GetTensorData<float>(output));
  }

  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"static bool is_zero_sectors(BlockDriverState *bs, int64_t start,

                            uint32_t count)

{

    int nr;

    BlockDriverState *file;

    int64_t res;



    if (start + count > bs->total_sectors) {

        count = bs->total_sectors - start;

    }



    if (!count) {

        return true;

    }

    res = bdrv_get_block_status_above(bs, NULL, start, count,

                                      &nr, &file);

    return res >= 0 && (res & BDRV_BLOCK_ZERO) && nr == count;

}
",0
Detect whether the following code contains vulnerabilities.,"void CGraph::ScaleMin()
{
	int i = 0;
	m_Min = m_Max;
	for(i = 0; i < MAX_VALUES; i++)
	{
		if(m_aValues[i] < m_Min)
			m_Min = m_aValues[i];
	}
}",0
Detect whether the following code contains vulnerabilities.,"soup_cookie_jar_get_cookies (SoupCookieJar *jar, SoupURI *uri,
			     gboolean for_http)
{
	GSList *cookies;

	g_return_val_if_fail (SOUP_IS_COOKIE_JAR (jar), NULL);
	g_return_val_if_fail (uri != NULL, NULL);

	cookies = get_cookies (jar, uri, for_http, FALSE);

	if (cookies) {
		char *result = soup_cookies_to_cookie_header (cookies);
		g_slist_free (cookies);

		if (!*result) {
			g_free (result);
			result = NULL;
		}
		return result;
	} else
		return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"float ff_amr_set_fixed_gain(float fixed_gain_factor, float fixed_mean_energy,

                            float *prediction_error, float energy_mean,

                            const float *pred_table)

{

    // Equations 66-69:

    // ^g_c = ^gamma_gc * 100.05 (predicted dB + mean dB - dB of fixed vector)

    // Note 10^(0.05 * -10log(average x2)) = 1/sqrt((average x2)).

    float val = fixed_gain_factor *

        ff_exp10(0.05 *

              (avpriv_scalarproduct_float_c(pred_table, prediction_error, 4) +

               energy_mean)) /

        sqrtf(fixed_mean_energy);



    // update quantified prediction error energy history

    memmove(&prediction_error[0], &prediction_error[1],

            3 * sizeof(prediction_error[0]));

    prediction_error[3] = 20.0 * log10f(fixed_gain_factor);



    return val;

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_fd_register(int fd)

{

    WSAEventSelect(fd, qemu_event_handle, FD_READ | FD_ACCEPT | FD_CLOSE |

                   FD_CONNECT | FD_WRITE | FD_OOB);

}
",0
Detect whether the following code contains vulnerabilities.,"bool visit_start_union(Visitor *v, bool data_present, Error **errp)

{

    if (v->start_union) {

        return v->start_union(v, data_present, errp);

    }

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static void __user *__vhost_get_user_slow(struct vhost_virtqueue *vq,
					  void __user *addr, unsigned int size,
					  int type)
{
	int ret;

	ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
			     ARRAY_SIZE(vq->iotlb_iov),
			     VHOST_ACCESS_RO);
	if (ret < 0) {
		vq_err(vq, ""IOTLB translation failure: uaddr ""
			""%p size 0x%llx\n"", addr,
			(unsigned long long) size);
		return NULL;
	}

	if (ret != 1 || vq->iotlb_iov[0].iov_len != size) {
		vq_err(vq, ""Non atomic userspace memory access: uaddr ""
			""%p size 0x%llx\n"", addr,
			(unsigned long long) size);
		return NULL;
	}

	return vq->iotlb_iov[0].iov_base;
}",0
Detect whether the following code contains vulnerabilities.,"ews_backend_new_calendar (EEwsBackend *backend,
                          EEwsFolder *folder)
{
	/* No extra configuration to do. */
	return ews_backend_new_child (backend, folder);
}",0
Detect whether the following code contains vulnerabilities.,"static int __ext4_expand_extra_isize(struct inode *inode,
				     unsigned int new_extra_isize,
				     struct ext4_iloc *iloc,
				     handle_t *handle, int *no_expand)
{
	struct ext4_inode *raw_inode;
	struct ext4_xattr_ibody_header *header;
	int error;

	raw_inode = ext4_raw_inode(iloc);

	header = IHDR(inode, raw_inode);

	/* No extended attributes present */
	if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||
	    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {
		memset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +
		       EXT4_I(inode)->i_extra_isize, 0,
		       new_extra_isize - EXT4_I(inode)->i_extra_isize);
		EXT4_I(inode)->i_extra_isize = new_extra_isize;
		return 0;
	}

	/* try to expand with EAs present */
	error = ext4_expand_extra_isize_ea(inode, new_extra_isize,
					   raw_inode, handle);
	if (error) {
		/*
		 * Inode size expansion failed; don't try again
		 */
		*no_expand = 1;
	}

	return error;
}",1
Detect whether the following code contains vulnerabilities.,"int FIFOSampleBuffer::isEmpty() const
{
    return (samplesInBuffer == 0) ? 1 : 0;
}",0
Detect whether the following code contains vulnerabilities.,"  Status BuildFeatureReaders(const OpInputList& ragged_values_list,
                             const OpInputList& ragged_splits_list,
                             const OpInputList& sparse_indices_list,
                             const OpInputList& sparse_values_list,
                             const OpInputList& dense_list, int64 batch_size,
                             FeatureReaders* features) {
    features->reserve(input_order_.size());

    int next_ragged = 0;
    int next_sparse = 0;
    int next_dense = 0;
    for (char c : input_order_) {
      if (c == 'R') {
        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(
            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],
            features));
        next_ragged++;
      } else if (c == 'S') {
        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(
            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],
            batch_size, features));
        next_sparse++;
      } else if (c == 'D') {
        TF_RETURN_IF_ERROR(
            BuildDenseFeatureReader(dense_list[next_dense++], features));
      } else {
        return errors::InvalidArgument(""Unexpected input_order value."");
      }
    }

    return Status::OK();
  }",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(wddx_packet_start)
{
	char *comment = NULL;
	int comment_len = 0;
	wddx_packet *packet;

	comment = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|s"", &comment, &comment_len) == FAILURE) {
		return;
	}

	packet = php_wddx_constructor();
	
	php_wddx_packet_start(packet, comment, comment_len);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);

	ZEND_REGISTER_RESOURCE(return_value, packet, le_wddx);
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t __cgroup1_procs_write(struct kernfs_open_file *of,
				     char *buf, size_t nbytes, loff_t off,
				     bool threadgroup)
{
	struct cgroup *cgrp;
	struct task_struct *task;
	const struct cred *cred, *tcred;
	ssize_t ret;
	bool locked;

	cgrp = cgroup_kn_lock_live(of->kn, false);
	if (!cgrp)
		return -ENODEV;

	task = cgroup_procs_write_start(buf, threadgroup, &locked);
	ret = PTR_ERR_OR_ZERO(task);
	if (ret)
		goto out_unlock;

	/*
	 * Even if we're attaching all tasks in the thread group, we only
	 * need to check permissions on one of them.
	 */
	cred = current_cred();
	tcred = get_task_cred(task);
	if (!uid_eq(cred->euid, GLOBAL_ROOT_UID) &&
	    !uid_eq(cred->euid, tcred->uid) &&
	    !uid_eq(cred->euid, tcred->suid))
		ret = -EACCES;
	put_cred(tcred);
	if (ret)
		goto out_finish;

	ret = cgroup_attach_task(cgrp, task, threadgroup);

out_finish:
	cgroup_procs_write_finish(task, locked);
out_unlock:
	cgroup_kn_unlock(of->kn);

	return ret ?: nbytes;
}",1
Detect whether the following code contains vulnerabilities.,"void btd_adapter_register_pin_cb(struct btd_adapter *adapter,
							btd_adapter_pin_cb_t cb)
{
	adapter->pin_callbacks = g_slist_prepend(adapter->pin_callbacks, cb);
}",0
Detect whether the following code contains vulnerabilities.,"vmxnet3_physical_memory_writev(const struct iovec *iov,
                               size_t start_iov_off,
                               hwaddr target_addr,
                               size_t bytes_to_copy)
{
    size_t curr_off = 0;
    size_t copied = 0;

    while (bytes_to_copy) {
        if (start_iov_off < (curr_off + iov->iov_len)) {
            size_t chunk_len =
                MIN((curr_off + iov->iov_len) - start_iov_off, bytes_to_copy);

            cpu_physical_memory_write(target_addr + copied,
                                      iov->iov_base + start_iov_off - curr_off,
                                      chunk_len);

            copied += chunk_len;
            start_iov_off += chunk_len;
            curr_off = start_iov_off;
            bytes_to_copy -= chunk_len;
        } else {
            curr_off += iov->iov_len;
        }
        iov++;
    }
}",0
Detect whether the following code contains vulnerabilities.,"static inline void downmix_2f_1r_to_stereo(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += samples[i + 512];

        samples[i + 256] += samples[i + 512];

        samples[i + 512] = 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)
{
	int err;
	const int on = 1;

	if (udev_monitor->snl.nl_family != 0) {
		err = bind(udev_monitor->sock,
			   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));
		if (err < 0) {
			err(udev_monitor->udev, ""bind failed: %m\n"");
			return err;
		}
		dbg(udev_monitor->udev, ""monitor %p listening on netlink\n"", udev_monitor);
	} else if (udev_monitor->sun.sun_family != 0) {
		err = bind(udev_monitor->sock,
			   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);
		if (err < 0) {
			err(udev_monitor->udev, ""bind failed: %m\n"");
			return err;
		}
		/* enable receiving of the sender credentials */
		setsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
		dbg(udev_monitor->udev, ""monitor %p listening on socket\n"", udev_monitor);
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"xfs_ioc_fsgeometry_v1(
	xfs_mount_t		*mp,
	void			__user *arg)
{
	xfs_fsop_geom_v1_t	fsgeo;
	int			error;

	error = xfs_fs_geometry(mp, (xfs_fsop_geom_t *)&fsgeo, 3);
	if (error)
		return -error;

	if (copy_to_user(arg, &fsgeo, sizeof(fsgeo)))
		return -XFS_ERROR(EFAULT);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"  ResponseWrapper(const Http::ResponseHeaderMap* headers, const Http::ResponseTrailerMap* trailers,
                  const StreamInfo::StreamInfo& info)
      : headers_(headers), trailers_(trailers), info_(info) {}",1
Detect whether the following code contains vulnerabilities.,"bool PDFDoc::checkLinearization() {
  if (linearization == nullptr)
    return false;
  if (linearizationState == 1)
    return true;
  if (linearizationState == 2)
    return false;
  if (!hints) {
    hints = new Hints(str, linearization, getXRef(), secHdlr);
  }
  if (!hints->isOk()) {
    linearizationState = 2;
    return false;
  }
  for (int page = 1; page <= linearization->getNumPages(); page++) {
    Ref pageRef;

    pageRef.num = hints->getPageObjectNum(page);
    if (!pageRef.num) {
      linearizationState = 2;
      return false;
    }

    // check for bogus ref - this can happen in corrupted PDF files
    if (pageRef.num < 0 || pageRef.num >= xref->getNumObjects()) {
      linearizationState = 2;
      return false;
    }

    pageRef.gen = xref->getEntry(pageRef.num)->gen;
    Object obj = xref->fetch(pageRef);
    if (!obj.isDict(""Page"")) {
      linearizationState = 2;
      return false;
    }
  }
  linearizationState = 1;
  return true;
}",0
Detect whether the following code contains vulnerabilities.,"ct_get_status (int slot, unsigned int *status)
{
  (void)slot;
  /* The status we returned is wrong but we don't care becuase ctAPI
     is not anymore required.  */
  *status = APDU_CARD_USABLE|APDU_CARD_PRESENT|APDU_CARD_ACTIVE;
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"StatusWith<Message> MessageCompressorManager::decompressMessage(const Message& msg) {
    auto inputHeader = msg.header();
    ConstDataRangeCursor input(inputHeader.data(), inputHeader.data() + inputHeader.dataLen());
    CompressionHeader compressionHeader(&input);

    auto compressor = _registry->getCompressor(compressionHeader.compressorId);
    if (!compressor) {
        return {ErrorCodes::InternalError,
                ""Compression algorithm specified in message is not available""};
    }

    auto bufferSize = compressionHeader.uncompressedSize + MsgData::MsgDataHeaderSize;
    auto outputMessageBuffer = SharedBuffer::allocate(bufferSize);
    MsgData::View outMessage(outputMessageBuffer.get());
    outMessage.setId(inputHeader.getId());
    outMessage.setResponseToMsgId(inputHeader.getResponseToMsgId());
    outMessage.setOperation(compressionHeader.originalOpCode);
    outMessage.setLen(bufferSize);

    DataRangeCursor output(outMessage.data(), outMessage.data() + outMessage.dataLen());

    auto sws = compressor->decompressData(input, output);

    if (!sws.isOK())
        return sws.getStatus();

    if (sws.getValue() != static_cast<std::size_t>(compressionHeader.uncompressedSize)) {
        return {ErrorCodes::BadValue, ""Decompressing message returned less data than expected""};
    }

    outMessage.setLen(sws.getValue() + MsgData::MsgDataHeaderSize);

    return {Message(outputMessageBuffer)};
}",1
Detect whether the following code contains vulnerabilities.,"static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}",1
Detect whether the following code contains vulnerabilities.,"static void get_socket_name( char* buf, int len )
{
    char* dpy = g_strdup(g_getenv(""DISPLAY""));
    if(dpy && *dpy)
    {
        char* p = strchr(dpy, ':');
        for(++p; *p && *p != '.' && *p != '\n';)
            ++p;
        if(*p)
            *p = '\0';
    }
    g_snprintf( buf, len, ""%s/.menu-cached-%s-%s"", g_get_tmp_dir(),
                dpy ? dpy : "":0"", g_get_user_name() );
    g_free(dpy);
}",1
Detect whether the following code contains vulnerabilities.,"rdpsnd_process_training(STREAM in)
{
	uint16 tick;
	uint16 packsize;
	STREAM out;

	in_uint16_le(in, tick);
	in_uint16_le(in, packsize);

	logger(Sound, Debug, ""rdpsnd_process_training(), tick=0x%04x"", (unsigned) tick);

	out = rdpsnd_init_packet(SNDC_TRAINING, 4);
	out_uint16_le(out, tick);
	out_uint16_le(out, packsize);
	s_mark_end(out);
	rdpsnd_send(out);
}",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(GlobIterator, count)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		/* should not happen */
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}",1
Detect whether the following code contains vulnerabilities.,"int seccomp_load_syscall_filter_set(uint32_t default_action, const SyscallFilterSet *set, uint32_t action, bool log_missing) {
        uint32_t arch;
        int r;

        assert(set);

        /* The one-stop solution: allocate a seccomp object, add the specified filter to it, and apply it. Once for
         * each local arch. */

        SECCOMP_FOREACH_LOCAL_ARCH(arch) {
                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;

                log_debug(""Operating on architecture: %s"", seccomp_arch_to_string(arch));

                r = seccomp_init_for_arch(&seccomp, arch, default_action);
                if (r < 0)
                        return r;

                r = seccomp_add_syscall_filter_set(seccomp, set, action, NULL, log_missing);
                if (r < 0)
                        return log_debug_errno(r, ""Failed to add filter set: %m"");

                r = seccomp_load(seccomp);
                if (IN_SET(r, -EPERM, -EACCES))
                        return r;
                if (r < 0)
                        log_debug_errno(r, ""Failed to install filter set for architecture %s, skipping: %m"", seccomp_arch_to_string(arch));
        }

        return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void nbd_read(void *opaque)

{

    NBDClient *client = opaque;



    if (client->recv_coroutine) {

        qemu_coroutine_enter(client->recv_coroutine, NULL);

    } else {

        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip), client);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int xen_pt_cmd_reg_read(XenPCIPassthroughState *s, XenPTReg *cfg_entry,

                               uint16_t *value, uint16_t valid_mask)

{

    XenPTRegInfo *reg = cfg_entry->reg;

    uint16_t valid_emu_mask = 0;

    uint16_t emu_mask = reg->emu_mask;



    if (s->is_virtfn) {

        emu_mask |= PCI_COMMAND_MEMORY;

    }



    /* emulate word register */

    valid_emu_mask = emu_mask & valid_mask;

    *value = XEN_PT_MERGE_VALUE(*value, cfg_entry->data, ~valid_emu_mask);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"ast_for_with_stmt(struct compiling *c, const node *n0, bool is_async)
{
    const node * const n = is_async ? CHILD(n0, 1) : n0;
    int i, n_items, end_lineno, end_col_offset;
    asdl_seq *items, *body;

    REQ(n, with_stmt);

    n_items = (NCH(n) - 2) / 2;
    items = _Py_asdl_seq_new(n_items, c->c_arena);
    if (!items)
        return NULL;
    for (i = 1; i < NCH(n) - 2; i += 2) {
        withitem_ty item = ast_for_with_item(c, CHILD(n, i));
        if (!item)
            return NULL;
        asdl_seq_SET(items, (i - 1) / 2, item);
    }

    body = ast_for_suite(c, CHILD(n, NCH(n) - 1));
    if (!body)
        return NULL;
    get_last_end_pos(body, &end_lineno, &end_col_offset);

    if (is_async)
        return AsyncWith(items, body, LINENO(n0), n0->n_col_offset,
                         end_lineno, end_col_offset, c->c_arena);
    else
        return With(items, body, LINENO(n), n->n_col_offset,
                    end_lineno, end_col_offset, c->c_arena);
}",1
Detect whether the following code contains vulnerabilities.,"void kqemu_set_notdirty(CPUState *env, ram_addr_t ram_addr)

{

    LOG_INT(""kqemu_set_notdirty: addr=%08lx\n"", 

                (unsigned long)ram_addr);

    /* we only track transitions to dirty state */

    if (phys_ram_dirty[ram_addr >> TARGET_PAGE_BITS] != 0xff)

        return;

    if (nb_ram_pages_to_update >= KQEMU_MAX_RAM_PAGES_TO_UPDATE)

        nb_ram_pages_to_update = KQEMU_RAM_PAGES_UPDATE_ALL;

    else

        ram_pages_to_update[nb_ram_pages_to_update++] = ram_addr;

}
",0
Detect whether the following code contains vulnerabilities.,"shape_desc *find_user_shape(const char *name)
{
    int i;
    if (UserShape) {
	for (i = 0; i < N_UserShape; i++) {
	    if (streq(UserShape[i]->name, name))
		return UserShape[i];
	}
    }
    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static void vnc_init_basic_info(SocketAddress *addr,

                                VncBasicInfo *info,

                                Error **errp)

{

    switch (addr->type) {

    case SOCKET_ADDRESS_KIND_INET:

        info->host = g_strdup(addr->u.inet->host);

        info->service = g_strdup(addr->u.inet->port);

        if (addr->u.inet->ipv6) {

            info->family = NETWORK_ADDRESS_FAMILY_IPV6;

        } else {

            info->family = NETWORK_ADDRESS_FAMILY_IPV4;

        }

        break;



    case SOCKET_ADDRESS_KIND_UNIX:

        info->host = g_strdup("""");

        info->service = g_strdup(addr->u.q_unix->path);

        info->family = NETWORK_ADDRESS_FAMILY_UNIX;

        break;



    default:

        error_setg(errp, ""Unsupported socket kind %d"",

                   addr->type);

        break;

    }



    return;

}
",0
Detect whether the following code contains vulnerabilities.,"    const char* rawdata() const {
        return data;
    }",0
Detect whether the following code contains vulnerabilities.,"static inline bool unconditional(const struct ipt_ip *ip)
{
	static const struct ipt_ip uncond;

	return memcmp(ip, &uncond, sizeof(uncond)) == 0;
#undef FWINV
}",1
Detect whether the following code contains vulnerabilities.,"Dispatcher::OpenCLException::OpenCLException(const std::string s, const cl_int res) :
	std::runtime_error( s + "" (res = "" + toString(res) + "")""),
	m_res(res)
{

}",0
Detect whether the following code contains vulnerabilities.,"static bool bpf_map_is_rdonly(const struct bpf_map *map)
{
	return (map->map_flags & BPF_F_RDONLY_PROG) && map->frozen;
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t pm_qos_resume_latency_us_show(struct device *dev,
					     struct device_attribute *attr,
					     char *buf)
{
	s32 value = dev_pm_qos_requested_resume_latency(dev);

	if (value == 0)
		return sprintf(buf, ""n/a\n"");
	if (value == PM_QOS_RESUME_LATENCY_NO_CONSTRAINT)
		value = 0;

	return sprintf(buf, ""%d\n"", value);
}",1
Detect whether the following code contains vulnerabilities.,"unwrap(struct magic_set *ms, const char *fn)
{
	FILE *f;
	ssize_t len;
	char *line = NULL;
	size_t llen = 0;
	int wid = 0, cwid;
	int e = 0;

	if (strcmp(""-"", fn) == 0) {
		f = stdin;
		wid = 1;
	} else {
		if ((f = fopen(fn, ""r"")) == NULL) {
			(void)fprintf(stderr, ""%s: Cannot open `%s' (%s).\n"",
			    progname, fn, strerror(errno));
			return 1;
		}

		while ((len = getline(&line, &llen, f)) > 0) {
			if (line[len - 1] == '\n')
				line[len - 1] = '\0';
			cwid = file_mbswidth(line);
			if (cwid > wid)
				wid = cwid;
		}

		rewind(f);
	}

	while ((len = getline(&line, &llen, f)) > 0) {
		if (line[len - 1] == '\n')
			line[len - 1] = '\0';
		e |= process(ms, line, wid);
		if(nobuffer)
			(void)fflush(stdout);
	}

	free(line);
	(void)fclose(f);
	return e;
}",0
Detect whether the following code contains vulnerabilities.,"sh_single_quote (string)
     const char *string;
{
  register int c;
  char *result, *r;
  const char *s;

  result = (char *)xmalloc (3 + (4 * strlen (string)));
  r = result;
  *r++ = '\'';

  for (s = string; s && (c = *s); s++)
    {
      *r++ = c;

      if (c == '\'')
	{
	  *r++ = '\\';	/* insert escaped single quote */
	  *r++ = '\'';
	  *r++ = '\'';	/* start new quoted string */
	}
    }

  *r++ = '\'';
  *r = '\0';

  return (result);
}",0
Detect whether the following code contains vulnerabilities.,"void rgb8tobgr8(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size;

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint8_t rgb;

	    rgb = src[i];

	    r = (rgb&0x07);

	    g = (rgb&0x38)>>3;

	    b = (rgb&0xC0)>>6;

	    dst[i] = ((b<<1)&0x07) | ((g&0x07)<<3) | ((r&0x03)<<6);

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static void fib6_start_gc(struct net *net, struct fib6_info *rt)
{
	if (!timer_pending(&net->ipv6.ip6_fib_timer) &&
	    (rt->fib6_flags & RTF_EXPIRES))
		mod_timer(&net->ipv6.ip6_fib_timer,
			  jiffies + net->ipv6.sysctl.ip6_rt_gc_interval);
}",0
Detect whether the following code contains vulnerabilities.,"    bool parse( char* ptr )
    {
        ptr = skipSpaces( ptr );
        if ( !ptr || !*ptr )
            return false;

        FileNode root_collection(fs->getFS(), 0, 0);

        if( *ptr == '{' )
        {
            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::MAP);
            parseMap( ptr, root_node );
        }
        else if ( *ptr == '[' )
        {
            FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::SEQ);
            parseSeq( ptr, root_node );
        }
        else
        {
            CV_PARSE_ERROR_CPP( ""left-brace of top level is missing"" );
        }

        if( !ptr || !*ptr )
            CV_PARSE_ERROR_CPP( ""Unexpected End-Of-File"" );
        return true;
    }",1
Detect whether the following code contains vulnerabilities.,"static int pdiag_put_ring(struct packet_ring_buffer *ring, int ver, int nl_type,
		struct sk_buff *nlskb)
{
	struct packet_diag_ring pdr;

	if (!ring->pg_vec || ((ver > TPACKET_V2) &&
				(nl_type == PACKET_DIAG_TX_RING)))
		return 0;

	pdr.pdr_block_size = ring->pg_vec_pages << PAGE_SHIFT;
	pdr.pdr_block_nr = ring->pg_vec_len;
	pdr.pdr_frame_size = ring->frame_size;
	pdr.pdr_frame_nr = ring->frame_max + 1;

	if (ver > TPACKET_V2) {
		pdr.pdr_retire_tmo = ring->prb_bdqc.retire_blk_tov;
		pdr.pdr_sizeof_priv = ring->prb_bdqc.blk_sizeof_priv;
		pdr.pdr_features = ring->prb_bdqc.feature_req_word;
	} else {
		pdr.pdr_retire_tmo = 0;
		pdr.pdr_sizeof_priv = 0;
		pdr.pdr_features = 0;
	}

	return nla_put(nlskb, nl_type, sizeof(pdr), &pdr);
}",0
Detect whether the following code contains vulnerabilities.,"QObject *qmp_dispatch(QObject *request)

{

    Error *err = NULL;

    QObject *ret;

    QDict *rsp;



    ret = do_qmp_dispatch(request, &err);



    rsp = qdict_new();

    if (err) {

        qdict_put_obj(rsp, ""error"", error_get_qobject(err));

        error_free(err);

    } else if (ret) {

        qdict_put_obj(rsp, ""return"", ret);

    } else {

        QDECREF(rsp);

        return NULL;

    }



    return QOBJECT(rsp);

}
",1
Detect whether the following code contains vulnerabilities.,"void OPPROTO op_divb_AL_T0(void)

{

    unsigned int num, den, q, r;



    num = (EAX & 0xffff);

    den = (T0 & 0xff);

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

    q = (num / den) & 0xff;

    r = (num % den) & 0xff;

    EAX = (EAX & ~0xffff) | (r << 8) | q;

}
",1
Detect whether the following code contains vulnerabilities.,"void virtio_panic(const char *string)

{

    sclp_print(string);

    disabled_wait();

    while (1) { }

}
",1
Detect whether the following code contains vulnerabilities.,"AioContext *aio_context_new(Error **errp)

{

    int ret;

    AioContext *ctx;



    ctx = (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));

    aio_context_setup(ctx);



    ret = event_notifier_init(&ctx->notifier, false);

    if (ret < 0) {

        error_setg_errno(errp, -ret, ""Failed to initialize event notifier"");

        goto fail;

    }

    g_source_set_can_recurse(&ctx->source, true);

    aio_set_event_notifier(ctx, &ctx->notifier,

                           false,

                           (EventNotifierHandler *)

                           event_notifier_dummy_cb,

                           event_notifier_poll);

#ifdef CONFIG_LINUX_AIO

    ctx->linux_aio = NULL;

#endif

    ctx->thread_pool = NULL;

    qemu_mutex_init(&ctx->bh_lock);

    qemu_rec_mutex_init(&ctx->lock);

    timerlistgroup_init(&ctx->tlg, aio_timerlist_notify, ctx);




    ctx->poll_max_ns = 0;





    return ctx;

fail:

    g_source_destroy(&ctx->source);

    return NULL;

}",1
Detect whether the following code contains vulnerabilities.,"get_lineno (var)
     SHELL_VAR *var;
{
  char *p;
  int ln;

  ln = executing_line_number ();
  p = itos (ln);
  FREE (value_cell (var));
  var_setvalue (var, p);
  return (var);
}",0
Detect whether the following code contains vulnerabilities.,"static struct libscols_line *add_line(struct libscols_table *table, struct libmnt_fs *fs,
					struct libscols_line *parent)
{
	size_t i;
	struct libscols_line *line = scols_table_new_line(table, parent);

	if (!line)
		err(EXIT_FAILURE, _(""failed to allocate output line""));

	for (i = 0; i < ncolumns; i++) {
		if (scols_line_refer_data(line, i, get_data(fs, i)))
			err(EXIT_FAILURE, _(""failed to add output data""));
	}

	scols_line_set_userdata(line, fs);
	return line;
}",0
Detect whether the following code contains vulnerabilities.,"static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)
{
	u32 sec_exec_control;

	/*
	 * There is not point to enable virtualize x2apic without enable
	 * apicv
	 */
	if (!cpu_has_vmx_virtualize_x2apic_mode() ||
				!vmx_vm_has_apicv(vcpu->kvm))
		return;

	if (!vm_need_tpr_shadow(vcpu->kvm))
		return;

	sec_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);

	if (set) {
		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
	} else {
		sec_exec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
	}
	vmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);

	vmx_set_msr_bitmap(vcpu);
}",0
Detect whether the following code contains vulnerabilities.,"CloseUndoneFileDownload(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	if(cl == NULL)
		return;
	
	if(rtcp->rcft.rcfd.downloadInProgress == TRUE) {
		rtcp->rcft.rcfd.downloadInProgress = FALSE;

		if(rtcp->rcft.rcfd.downloadFD != -1) {			
			close(rtcp->rcft.rcfd.downloadFD);
			rtcp->rcft.rcfd.downloadFD = -1;
		}
		memset(rtcp->rcft.rcfd.fName, 0 , PATH_MAX);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static __inline__ int cbq_dump_fopt(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_fopt opt;

	if (cl->split || cl->defmap) {
		opt.split = cl->split ? cl->split->classid : 0;
		opt.defmap = cl->defmap;
		opt.defchange = ~0;
		RTA_PUT(skb, TCA_CBQ_FOPT, sizeof(opt), &opt);
	}
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",0
Detect whether the following code contains vulnerabilities.,"xmlRelaxNGParseImportRef(void *payload, void *data, xmlChar *name) {
    xmlRelaxNGParserCtxtPtr ctxt = (xmlRelaxNGParserCtxtPtr) data;
    xmlRelaxNGDefinePtr def = (xmlRelaxNGDefinePtr) payload;
    int tmp;

    def->dflags |= IS_EXTERNAL_REF;

    tmp = xmlHashAddEntry(ctxt->grammar->refs, name, def);
    if (tmp < 0) {
        xmlRelaxNGDefinePtr prev;

        prev = (xmlRelaxNGDefinePtr)
            xmlHashLookup(ctxt->grammar->refs, def->name);
        if (prev == NULL) {
            if (def->name != NULL) {
                xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,
                           ""Error refs definitions '%s'\n"",
                           def->name, NULL);
            } else {
                xmlRngPErr(ctxt, NULL, XML_RNGP_REF_CREATE_FAILED,
                           ""Error refs definitions\n"",
                           NULL, NULL);
            }
        } else {
            def->nextHash = prev->nextHash;
            prev->nextHash = def;
        }
    }
}",0
Detect whether the following code contains vulnerabilities.,"PJ_DEF(const char*) pj_stun_get_class_name(unsigned msg_type)
{
    if (PJ_STUN_IS_REQUEST(msg_type))
	return ""request"";
    else if (PJ_STUN_IS_SUCCESS_RESPONSE(msg_type))
	return ""success response"";
    else if (PJ_STUN_IS_ERROR_RESPONSE(msg_type))
	return ""error response"";
    else if (PJ_STUN_IS_INDICATION(msg_type))
	return ""indication"";
    else
	return ""???"";
}",0
Detect whether the following code contains vulnerabilities.,"MONGO_EXPORT void bson_init( bson *b ) {
    _bson_init_size( b, initialBufferSize );
}",0
Detect whether the following code contains vulnerabilities.,"static int wait_for_bgprint_to_finish(void)
{
	if (!bgprint.active || !bgprint.started)
		return 0;

	mu_wait_semaphore(&bgprint.stop);
	bgprint.started = 0;
	return bgprint.status;
}",0
Detect whether the following code contains vulnerabilities.,"g_file_is_native (GFile *file)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);

  iface = G_FILE_GET_IFACE (file);

  return (* iface->is_native) (file);
}",0
Detect whether the following code contains vulnerabilities.,"get_pka_info (const char *address, unsigned char *fpr)
{
  (void)address;
  (void)fpr;
  return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"SecureRandomDataProvider::provideRandomData(unsigned char* data, size_t len)
{
#if defined(_WIN32)

    // Optimization: make the WindowsCryptProvider static as long as
    // it can be done in a thread-safe fashion.
    WindowsCryptProvider c;
    if (! CryptGenRandom(c.crypt_prov, len, reinterpret_cast<BYTE*>(data)))
    {
        throw std::runtime_error(""unable to generate secure random data"");
    }

#elif defined(RANDOM_DEVICE)

    // Optimization: wrap the file open and close in a class so that
    // the file is closed in a destructor, then make this static to
    // keep the file handle open.  Only do this if it can be done in a
    // thread-safe fashion.
    FILE* f = QUtil::safe_fopen(RANDOM_DEVICE, ""rb"");
    size_t fr = fread(data, 1, len, f);
    fclose(f);
    if (fr != len)
    {
        throw std::runtime_error(
            ""unable to read "" +
            QUtil::int_to_string(len) +
            "" bytes from "" + std::string(RANDOM_DEVICE));
    }

#else

#  error ""Don't know how to generate secure random numbers on this platform.  See random number generation in the top-level README.md""

#endif
}",1
Detect whether the following code contains vulnerabilities.,"void decoder_context::compute_framedrop_table()
{
  int highestTID = get_highest_TID();

  for (int tid=highestTID ; tid>=0 ; tid--) {
    int lower  = 100 *  tid   /(highestTID+1);
    int higher = 100 * (tid+1)/(highestTID+1);

    for (int l=lower; l<=higher; l++) {
      int ratio = 100 * (l-lower) / (higher-lower);

      // if we would exceed our TID limit, decode the highest TID at full frame-rate
      if (tid > limit_HighestTid) {
        tid   = limit_HighestTid;
        ratio = 100;
      }

      framedrop_tab[l].tid   = tid;
      framedrop_tab[l].ratio = ratio;
    }

    framedrop_tid_index[tid] = higher;
  }

#if 0
  for (int i=0;i<=100;i++) {
    printf(""%d%%: %d/%d"",i, framedrop_tab[i].tid, framedrop_tab[i].ratio);
    for (int k=0;k<=highestTID;k++) {
      if (framedrop_tid_index[k] == i) printf("" ** TID=%d **"",k);
    }
    printf(""\n"");
  }
#endif
}",0
Detect whether the following code contains vulnerabilities.,"QPDFObjectHandle::getKeys()
{
    assertDictionary();
    return dynamic_cast<QPDF_Dictionary*>(obj.getPointer())->getKeys();
}",0
Detect whether the following code contains vulnerabilities.,"static inline double LevelPixel(const double black_point,
  const double white_point,const double gamma,const double pixel)
{
  double
    level_pixel,
    scale;

  scale=PerceptibleReciprocal(white_point-black_point);
  level_pixel=QuantumRange*gamma_pow(scale*((double) pixel-black_point),
    1.0/gamma);
  return(level_pixel);
}",1
Detect whether the following code contains vulnerabilities.,"static int __dev_open(struct net_device *dev)
{
	const struct net_device_ops *ops = dev->netdev_ops;
	int ret;

	ASSERT_RTNL();

	if (!netif_device_present(dev))
		return -ENODEV;

	/* Block netpoll from trying to do any rx path servicing.
	 * If we don't do this there is a chance ndo_poll_controller
	 * or ndo_poll may be running while we open the device
	 */
	netpoll_rx_disable(dev);

	ret = call_netdevice_notifiers(NETDEV_PRE_UP, dev);
	ret = notifier_to_errno(ret);
	if (ret)
		return ret;

	set_bit(__LINK_STATE_START, &dev->state);

	if (ops->ndo_validate_addr)
		ret = ops->ndo_validate_addr(dev);

	if (!ret && ops->ndo_open)
		ret = ops->ndo_open(dev);

	netpoll_rx_enable(dev);

	if (ret)
		clear_bit(__LINK_STATE_START, &dev->state);
	else {
		dev->flags |= IFF_UP;
		net_dmaengine_get();
		dev_set_rx_mode(dev);
		dev_activate(dev);
		add_device_randomness(dev->dev_addr, dev->addr_len);
	}

	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void framebuffer_update_request(VncState *vs, int incremental,
                                       int x_position, int y_position,
                                       int w, int h)
{
    int i;
    const size_t width = surface_width(vs->vd->ds) / VNC_DIRTY_PIXELS_PER_BIT;
    const size_t height = surface_height(vs->vd->ds);

    if (y_position > height) {
        y_position = height;
    }
    if (y_position + h >= height) {
        h = height - y_position;
    }

    vs->need_update = 1;
    if (!incremental) {
        vs->force_update = 1;
        for (i = 0; i < h; i++) {
            bitmap_set(vs->dirty[y_position + i], 0, width);
            bitmap_clear(vs->dirty[y_position + i], width,
                         VNC_DIRTY_BITS - width);
        }
    }
}",1
Detect whether the following code contains vulnerabilities.,"void gf_hinter_track_get_payload_name(GF_RTPHinter *tkHinter, char *payloadName)
{
	char mediaName[30];
	gf_rtp_builder_get_payload_name(tkHinter->rtp_p, payloadName, mediaName);
}",0
Detect whether the following code contains vulnerabilities.,"static int vhost_scsi_exit(DeviceState *qdev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);

    VHostSCSI *s = VHOST_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);



    /* This will stop vhost backend. */

    vhost_scsi_set_status(vdev, 0);



    g_free(s->dev.vqs);

    return virtio_scsi_common_exit(vs);

}
",1
Detect whether the following code contains vulnerabilities.,"int cpu_get_dump_info(ArchDumpInfo *info)

{

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void rtsp_cmd_pause(HTTPContext *c, const char *url, RTSPHeader *h)

{

    HTTPContext *rtp_c;



    rtp_c = find_rtp_session_with_url(url, h->session_id);

    if (!rtp_c) {

        rtsp_reply_error(c, RTSP_STATUS_SESSION);

        return;

    }

    

    if (rtp_c->state != HTTPSTATE_SEND_DATA &&

        rtp_c->state != HTTPSTATE_WAIT_FEED) {

        rtsp_reply_error(c, RTSP_STATUS_STATE);

        return;

    }

    

    rtp_c->state = HTTPSTATE_READY;

    

    /* now everything is OK, so we can send the connection parameters */

    rtsp_reply_header(c, RTSP_STATUS_OK);

    /* session ID */

    url_fprintf(c->pb, ""Session: %s\r\n"", rtp_c->session_id);

    url_fprintf(c->pb, ""\r\n"");

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_wrpstate(CPUSPARCState *env, target_ulong new_state)

{

    cpu_change_pstate(env, new_state & 0xf3f);



#if !defined(CONFIG_USER_ONLY)

    if (cpu_interrupts_enabled(env)) {


        cpu_check_irqs(env);


    }

#endif

}",1
Detect whether the following code contains vulnerabilities.,"void ActiveStreamDecoderFilter::sendLocalReply(
    Code code, absl::string_view body,
    std::function<void(ResponseHeaderMap& headers)> modify_headers,
    const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) {
  parent_.sendLocalReply(code, body, modify_headers, grpc_status, details);
}",0
Detect whether the following code contains vulnerabilities.,"MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {
    if ( type == BSON_BIN_BINARY_OLD ) {
        int subtwolen = len + 4;
        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )
            return BSON_ERROR;
        bson_append32( b, &subtwolen );
        bson_append_byte( b, type );
        bson_append32( b, &len );
        bson_append( b, str, len );
    }
    else {
        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )
            return BSON_ERROR;
        bson_append32( b, &len );
        bson_append_byte( b, type );
        bson_append( b, str, len );
    }
    return BSON_OK;
}",1
Detect whether the following code contains vulnerabilities.,"void WebContents::ReceivePostMessage(
    const std::string& channel,
    blink::TransferableMessage message,
    content::RenderFrameHost* render_frame_host) {
  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();
  v8::HandleScope handle_scope(isolate);
  auto wrapped_ports =
      MessagePort::EntanglePorts(isolate, std::move(message.ports));
  v8::Local<v8::Value> message_value =
      electron::DeserializeV8Value(isolate, message);
  EmitWithSender(""-ipc-ports"", render_frame_host,
                 electron::mojom::ElectronBrowser::InvokeCallback(), false,
                 channel, message_value, std::move(wrapped_ports));
}",1
Detect whether the following code contains vulnerabilities.,"drv_keyok(TERMINAL_CONTROL_BLOCK * TCB, int c, int flag)
{
    SCREEN *sp;
    int code = ERR;
    int count = 0;
    char *s;

    AssertTCB();
    SetSP();

    if (c >= 0) {
	unsigned ch = (unsigned) c;
	if (flag) {
	    while ((s = _nc_expand_try(sp->_key_ok,
				       ch, &count, (size_t) 0)) != 0) {
		if (_nc_remove_key(&(sp->_key_ok), ch)) {
		    code = _nc_add_to_try(&(sp->_keytry), s, ch);
		    free(s);
		    count = 0;
		    if (code != OK)
			break;
		} else {
		    free(s);
		}
	    }
	} else {
	    while ((s = _nc_expand_try(sp->_keytry,
				       ch, &count, (size_t) 0)) != 0) {
		if (_nc_remove_key(&(sp->_keytry), ch)) {
		    code = _nc_add_to_try(&(sp->_key_ok), s, ch);
		    free(s);
		    count = 0;
		    if (code != OK)
			break;
		} else {
		    free(s);
		}
	    }
	}
    }
    return (code);
}",0
Detect whether the following code contains vulnerabilities.,"compat_check_calc_match(struct ipt_entry_match *m,
	    const char *name,
	    const struct ipt_ip *ip,
	    unsigned int hookmask,
	    int *size, int *i)
{
	struct ipt_match *match;

	match = try_then_request_module(xt_find_match(AF_INET, m->u.user.name,
						   m->u.user.revision),
					""ipt_%s"", m->u.user.name);
	if (IS_ERR(match) || !match) {
		duprintf(""compat_check_calc_match: `%s' not found\n"",
				m->u.user.name);
		return match ? PTR_ERR(match) : -ENOENT;
	}
	m->u.kernel.match = match;

	if (m->u.kernel.match->compat)
		m->u.kernel.match->compat(m, NULL, size, COMPAT_CALC_SIZE);
	else
		xt_compat_match(m, NULL, size, COMPAT_CALC_SIZE);

	(*i)++;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static long btrfs_ioctl_balance_ctl(struct btrfs_fs_info *fs_info, int cmd)
{
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	switch (cmd) {
	case BTRFS_BALANCE_CTL_PAUSE:
		return btrfs_pause_balance(fs_info);
	case BTRFS_BALANCE_CTL_CANCEL:
		return btrfs_cancel_balance(fs_info);
	}

	return -EINVAL;
}",0
Detect whether the following code contains vulnerabilities.,"static int mailbox_reconstruct_acl(struct mailbox *mailbox, int flags)
{
    int make_changes = flags & RECONSTRUCT_MAKE_CHANGES;
    int r;

    r = mailbox_read_header(mailbox);
    if (r) return r;

    if (strcmp(mailbox_acl(mailbox), mailbox->h.acl)) {
        printf(""%s: update acl from header %s => %s\n"", mailbox_name(mailbox),
               mailbox_acl(mailbox), mailbox->h.acl);
        if (make_changes)
            printf(""XXX - this is a noop right now - needs to update mailboxes.db\n"");
    }

    return r;
}",1
Detect whether the following code contains vulnerabilities.,"static int _server_handle_c(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {
	char message[64];
	if (send_ack (g) < 0) {
		return -1;
	}
	if (g->data_len > 1) {
		// We don't handle s[addr] packet
		return send_msg (g, ""E01"");
	}
	if (cmd_cb (core_ptr, ""dc"", NULL, 0) < 0) {
		send_msg (g, ""E01"");
		return -1;
	}
	// TODO This packet should specify why we stopped. Right now only for trap
	snprintf (message, sizeof (message) - 1, ""T05thread:%x;"", cmd_cb (core_ptr, ""dptr"", NULL, 0));
	return send_msg (g, message);
}",0
Detect whether the following code contains vulnerabilities.,"static int xennet_remove(struct xenbus_device *dev)
{
	struct netfront_info *info = dev_get_drvdata(&dev->dev);

	xennet_bus_close(dev);
	xennet_disconnect_backend(info);

	if (info->netdev->reg_state == NETREG_REGISTERED)
		unregister_netdev(info->netdev);

	if (info->queues) {
		rtnl_lock();
		xennet_destroy_queues(info);
		rtnl_unlock();
	}
	xennet_free_netdev(info->netdev);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"
GF_Err svhd_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;
	ptr->string = gf_malloc(sizeof(char) * ((u32) ptr->size+1));
	if (!ptr->string) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, ptr->string, (u32) ptr->size);
	ptr->string[ptr->size] = 0;
	return GF_OK;",0
Detect whether the following code contains vulnerabilities.,"static int jacosub_probe(AVProbeData *p)

{

    const char *ptr     = p->buf;

    const char *ptr_end = p->buf + p->buf_size;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3; /* skip UTF-8 BOM */



    while (ptr < ptr_end) {

        while (jss_whitespace(*ptr))

            ptr++;

        if (*ptr != '#' && *ptr != '\n') {

            if (timed_line(ptr))

                return AVPROBE_SCORE_EXTENSION + 1;

            return 0;

        }

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"const char *cJSON_GetErrorPtr( void )
{
	return ep;
}",1
Detect whether the following code contains vulnerabilities.,"static bool drbg_fips_continuous_test(struct drbg_state *drbg,
				      const unsigned char *buf)
{
#ifdef CONFIG_CRYPTO_FIPS
	int ret = 0;
	/* skip test if we test the overall system */
	if (drbg->test_data)
		return true;
	/* only perform test in FIPS mode */
	if (0 == fips_enabled)
		return true;
	if (!drbg->fips_primed) {
		/* Priming of FIPS test */
		memcpy(drbg->prev, buf, drbg_blocklen(drbg));
		drbg->fips_primed = true;
		/* return false due to priming, i.e. another round is needed */
		return false;
	}
	ret = memcmp(drbg->prev, buf, drbg_blocklen(drbg));
	if (!ret)
		panic(""DRBG continuous self test failed\n"");
	memcpy(drbg->prev, buf, drbg_blocklen(drbg));
	/* the test shall pass when the two compared values are not equal */
	return ret != 0;
#else
	return true;
#endif /* CONFIG_CRYPTO_FIPS */
}",1
Detect whether the following code contains vulnerabilities.,"static void kempf_restore_buf(const uint8_t *src, int len,

                              uint8_t *dst, int stride,

                              const uint8_t *jpeg_tile, int tile_stride,

                              int width, int height,

                              const uint8_t *pal, int npal, int tidx)

{

    GetBitContext gb;

    int i, j, nb, col;



    init_get_bits8(&gb, src, len);



    if (npal <= 2)       nb = 1;

    else if (npal <= 4)  nb = 2;

    else if (npal <= 16) nb = 4;

    else                 nb = 8;



    for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {

        if (get_bits(&gb, 8))

            continue;

        for (i = 0; i < width; i++) {

            col = get_bits(&gb, nb);

            if (col != tidx)

                memcpy(dst + i * 3, pal + col * 3, 3);

            else

                memcpy(dst + i * 3, jpeg_tile + i * 3, 3);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],

                         const uint8_t *src,

                         enum AVPixelFormat pix_fmt, int width, int height, int align)

{

    int ret, i;



    if ((ret = av_image_check_size(width, height, 0, NULL)) < 0)

        return ret;



    if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        dst_linesize[i] = FFALIGN(dst_linesize[i], align);



    if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) < 0)

        return ret;



    return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize);

}
",0
Detect whether the following code contains vulnerabilities.,"TEST_P(Security, BuiltinAuthenticationAndAccessAndCryptoPlugin_PermissionsDisableDiscoveryEnableAccessEncrypt_validation_ok_enable_discovery_disable_access_encrypt)
// *INDENT-ON*
{
    PubSubReader<HelloWorldType> reader(TEST_TOPIC_NAME);
    PubSubWriter<HelloWorldType> writer(TEST_TOPIC_NAME);
    std::string governance_file(""governance_disable_discovery_enable_access_encrypt.smime"");

    BuiltinAuthenticationAndAccessAndCryptoPlugin_Permissions_validation_ok_common(reader, writer, governance_file);
}",0
Detect whether the following code contains vulnerabilities.,"trash_or_delete_internal (GList                  *files,
                          GtkWindow              *parent_window,
                          gboolean                try_trash,
                          NautilusDeleteCallback  done_callback,
                          gpointer                done_callback_data)
{
    GTask *task;
    DeleteJob *job;

    /* TODO: special case desktop icon link files ... */

    job = op_job_new (DeleteJob, parent_window);
    job->files = g_list_copy_deep (files, (GCopyFunc) g_object_ref, NULL);
    job->try_trash = try_trash;
    job->user_cancel = FALSE;
    job->done_callback = done_callback;
    job->done_callback_data = done_callback_data;

    if (try_trash)
    {
        inhibit_power_manager ((CommonJob *) job, _(""Trashing Files""));
    }
    else
    {
        inhibit_power_manager ((CommonJob *) job, _(""Deleting Files""));
    }

    if (!nautilus_file_undo_manager_is_operating () && try_trash)
    {
        job->common.undo_info = nautilus_file_undo_info_trash_new (g_list_length (files));
    }

    task = g_task_new (NULL, NULL, delete_task_done, job);
    g_task_set_task_data (task, job, NULL);
    g_task_run_in_thread (task, delete_task_thread_func);
    g_object_unref (task);
}",0
Detect whether the following code contains vulnerabilities.,"static char *visitor_get(TestOutputVisitorData *data)

{

    data->str = string_output_get_string(data->sov);

    g_assert(data->str);

    return data->str;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_visitor_out_empty(TestOutputVisitorData *data,

                                   const void *unused)

{

    QObject *arg;



    arg = qmp_output_get_qobject(data->qov);

    g_assert(qobject_type(arg) == QTYPE_QNULL);



    qobject_decref(arg);

}",1
Detect whether the following code contains vulnerabilities.,"check_limit(VALUE str, VALUE opt)
{
    StringValue(str);
    size_t slen = RSTRING_LEN(str);
    size_t limit = get_limit(opt);
    if (slen > limit) {
	rb_raise(rb_eArgError,
		 ""string length (%""PRI_SIZE_PREFIX""u) exceeds the limit %""PRI_SIZE_PREFIX""u"", slen, limit);
    }
}",1
Detect whether the following code contains vulnerabilities.,"size_t c_shquote_strncspn(const char *string,
                          size_t n_string,
                          const char *reject) {
        bool buffer[UCHAR_MAX] = {};

        if (strlen(reject) == 1) {
                const char *p;

                p = memchr(string, reject[0], n_string);
                if (!p)
                        return n_string;
                else
                        return p - string;
        }

        for ( ; *reject; ++reject)
                buffer[(unsigned char)*reject] = true;

        for (size_t i = 0; i < n_string; ++i)
                if (buffer[(unsigned char)string[i]])
                        return i;

        return n_string;
}",1
Detect whether the following code contains vulnerabilities.,"GF_Box *def_parent_full_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_Box, 0);
	return (GF_Box *) tmp;
}",0
Detect whether the following code contains vulnerabilities.,"prepend_args (char const *options, char *buf, char **argv)
{
  char const *o = options;
  char *b = buf;
  int n = 0;

  for (;;)
    {
      while (c_isspace ((unsigned char) *o))
        o++;
      if (!*o)
        return n;
      if (argv)
        argv[n] = b;
      n++;

      do
        if ((*b++ = *o++) == '\\' && *o)
          b[-1] = *o++;
      while (*o && ! c_isspace ((unsigned char) *o));

      *b++ = '\0';
    }
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)
{
	ssize_t ret;

#ifdef CONFIG_COMPAT
	if (compat)
		ret = compat_rw_copy_check_uvector(type,
				(struct compat_iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	else
#endif
		ret = rw_copy_check_uvector(type,
				(struct iovec __user *)kiocb->ki_buf,
				kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,
				&kiocb->ki_iovec, 1);
	if (ret < 0)
		goto out;

	kiocb->ki_nr_segs = kiocb->ki_nbytes;
	kiocb->ki_cur_seg = 0;
	/* ki_nbytes/left now reflect bytes instead of segs */
	kiocb->ki_nbytes = ret;
	kiocb->ki_left = ret;

	ret = 0;
out:
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static int hdev_has_zero_init(BlockDriverState *bs)

{

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"unref_var_dict(dict_T *dict)
{
    // Now the dict needs to be freed if no one else is using it, go back to
    // normal reference counting.
    dict->dv_refcount -= DO_NOT_FREE_CNT - 1;
    dict_unref(dict);
}",0
Detect whether the following code contains vulnerabilities.,"onigenc_single_byte_code_to_mbclen(OnigCodePoint code ARG_UNUSED, OnigEncoding enc ARG_UNUSED)
{
  return 1;
}",1
Detect whether the following code contains vulnerabilities.,"char *msSDELayerGetSpatialColumn(layerObj *layer)
{
#ifdef USE_SDE
  msSDELayerInfo *sde=NULL;
   
  sde = layer->sdelayer;
  if(!sde) {
    msSetError(MS_SDEERR, ""SDE layer has not been opened."", ""msSDELayerGetSpatialColumn()"");
    return(NULL);
  }

  return(strdup(sde->column));
#else
  msSetError(MS_MISCERR, ""SDE support is not available."", ""msSDELayerGetSpatialColumn()"");
  return(NULL);
#endif
}",0
Detect whether the following code contains vulnerabilities.,"char **breakline(char *input, int *count)

{

    int c = 0;

    char *p;

    char **rval = calloc(sizeof(char *), 1);



    while (rval && (p = qemu_strsep(&input, "" "")) != NULL) {

        if (!*p) {

            continue;

        }

        c++;

        rval = realloc(rval, sizeof(*rval) * (c + 1));

        if (!rval) {

            c = 0;

            break;

        }

        rval[c - 1] = p;

        rval[c] = NULL;

    }

    *count = c;

    return rval;

}
",1
Detect whether the following code contains vulnerabilities.,"static void iowarrior_disconnect(struct usb_interface *interface)
{
	struct iowarrior *dev;
	int minor;

	dev = usb_get_intfdata(interface);
	mutex_lock(&iowarrior_open_disc_lock);
	usb_set_intfdata(interface, NULL);

	minor = dev->minor;

	/* give back our minor */
	usb_deregister_dev(interface, &iowarrior_class);

	mutex_lock(&dev->mutex);

	/* prevent device read, write and ioctl */
	dev->present = 0;

	mutex_unlock(&dev->mutex);
	mutex_unlock(&iowarrior_open_disc_lock);

	if (dev->opened) {
		/* There is a process that holds a filedescriptor to the device ,
		   so we only shutdown read-/write-ops going on.
		   Deleting the device is postponed until close() was called.
		 */
		usb_kill_urb(dev->int_in_urb);
		wake_up_interruptible(&dev->read_wait);
		wake_up_interruptible(&dev->write_wait);
	} else {
		/* no process is using the device, cleanup now */
		iowarrior_delete(dev);
	}

	dev_info(&interface->dev, ""I/O-Warror #%d now disconnected\n"",
		 minor - IOWARRIOR_MINOR_BASE);
}",1
Detect whether the following code contains vulnerabilities.,"DEFUN(nextRD, NEXT_RIGHT_DOWN, ""Move right or downward to the next hyperlink"")
{
    nextX(1, 1);
}",0
Detect whether the following code contains vulnerabilities.,"void kvmppc_update_sdr1(target_ulong sdr1)

{

    CPUState *cs;



    CPU_FOREACH(cs) {

        run_on_cpu(cs, kvmppc_pivot_hpt_cpu, RUN_ON_CPU_TARGET_PTR(sdr1));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtol_full_empty(void)

{

    const char *str = """";

    long res = 999L;

    int err;



    err =  qemu_strtol(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"static int date_to_ISO8601 (time_t value, char *buf, int length) {
   struct tm *tm, tmbuf;
   tm = php_localtime_r(&value, &tmbuf);
   if (!tm) {
	   return 0;
   }
#if 0  /* TODO: soap seems to favor this method. xmlrpc the latter. */
	return strftime (buf, length, ""%Y-%m-%dT%H:%M:%SZ"", tm);
#else
   return strftime(buf, length, ""%Y%m%dT%H:%M:%S"", tm);
#endif
}",1
Detect whether the following code contains vulnerabilities.,"  PbrMetallicRoughness()
      : baseColorFactor(std::vector<double>{1.0, 1.0, 1.0, 1.0}),
        metallicFactor(1.0),
        roughnessFactor(1.0) {}",0
Detect whether the following code contains vulnerabilities.,"size_t olm_pk_encryption_set_recipient_key (
    OlmPkEncryption *encryption,
    void const * key, size_t key_length
) {
    if (key_length < olm_pk_key_length()) {
        encryption->last_error =
            OlmErrorCode::OLM_INPUT_BUFFER_TOO_SMALL;
        return std::size_t(-1);
    }
    olm::decode_base64(
        (const uint8_t*)key,
        olm_pk_key_length(),
        (uint8_t *)encryption->recipient_key.public_key
    );
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"  uint64_t append(const void* data, uint64_t size) {
    uint64_t copy_size = std::min(size, reservableSize());
    uint8_t* dest = base_ + reservable_;
    reservable_ += copy_size;
    // NOLINTNEXTLINE(clang-analyzer-core.NullDereference)
    memcpy(dest, data, copy_size);
    return copy_size;
  }",1
Detect whether the following code contains vulnerabilities.,"_Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)
{
    if (idx < 0 || idx >= self->memo_size)
        return NULL;

    return self->memo[idx];
}",1
Detect whether the following code contains vulnerabilities.,"static int daala_packet(AVFormatContext *s, int idx)

{

    int seg, duration = 1;

    struct ogg *ogg = s->priv_data;

    struct ogg_stream *os = ogg->streams + idx;



    /*

     * first packet handling: here we parse the duration of each packet in the

     * first page and compare the total duration to the page granule to find the

     * encoder delay and set the first timestamp

     */



    if ((!os->lastpts || os->lastpts == AV_NOPTS_VALUE) && !(os->flags & OGG_FLAG_EOS)) {

        for (seg = os->segp; seg < os->nsegs; seg++)

            if (os->segments[seg] < 255)

                duration++;



        os->lastpts = os->lastdts = daala_gptopts(s, idx, os->granule, NULL) - duration;

        if(s->streams[idx]->start_time == AV_NOPTS_VALUE) {

            s->streams[idx]->start_time = os->lastpts;

            if (s->streams[idx]->duration)

                s->streams[idx]->duration -= s->streams[idx]->start_time;

        }

    }



    /* parse packet duration */

    if (os->psize > 0)

        os->pduration = 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int devid_cmp(void *priv, struct list_head *a, struct list_head *b)
{
	struct btrfs_device *dev1, *dev2;

	dev1 = list_entry(a, struct btrfs_device, dev_list);
	dev2 = list_entry(b, struct btrfs_device, dev_list);

	if (dev1->devid < dev2->devid)
		return -1;
	else if (dev1->devid > dev2->devid)
		return 1;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int vmdk_is_cid_valid(BlockDriverState *bs)

{

#ifdef CHECK_CID

    BDRVVmdkState *s = bs->opaque;

    BlockDriverState *p_bs = bs->backing_hd;

    uint32_t cur_pcid;



    if (p_bs) {

        cur_pcid = vmdk_read_cid(p_bs, 0);

        if (s->parent_cid != cur_pcid) {

            /* CID not valid */

            return 0;

        }

    }

#endif

    /* CID valid */

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"int MACH0_(get_bits)(struct MACH0_(obj_t) * bin) {
	if (bin) {
		int bits = MACH0_(get_bits_from_hdr)(&bin->hdr);
		if (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {
			return 16;
		}
		return bits;
	}
	return 32;
}",0
Detect whether the following code contains vulnerabilities.,"static uint8_t fw_cfg_read(FWCfgState *s)

{

    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);

    FWCfgEntry *e = (s->cur_entry == FW_CFG_INVALID) ? NULL :

                    &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];

    uint8_t ret;



    if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)

        ret = 0;

    else {

        ret = e->data[s->cur_offset++];

    }



    trace_fw_cfg_read(s, ret);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void assert_file_overwrite(const char *filename)

{

    if (file_overwrite && no_file_overwrite) {

        fprintf(stderr, ""Error, both -y and -n supplied. Exiting.\n"");

        exit_program(1);

    }



    if (!file_overwrite &&

        (strchr(filename, ':') == NULL || filename[1] == ':' ||

         av_strstart(filename, ""file:"", NULL))) {

        if (avio_check(filename, 0) == 0) {

            if (stdin_interaction && !no_file_overwrite) {

                fprintf(stderr,""File '%s' already exists. Overwrite ? [y/N] "", filename);

                fflush(stderr);

                term_exit();

                signal(SIGINT, SIG_DFL);

                if (!read_yesno()) {

                    av_log(NULL, AV_LOG_FATAL, ""Not overwriting - exiting\n"");

                    exit_program(1);

                }

                term_init();

            }

            else {

                av_log(NULL, AV_LOG_FATAL, ""File '%s' already exists. Exiting.\n"", filename);

                exit_program(1);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"local int decode(struct state *s, struct huffman *h)
{
    int len;            /* current number of bits in code */
    int code;           /* len bits being decoded */
    int first;          /* first code of length len */
    int count;          /* number of codes of length len */
    int index;          /* index of first code of length len in symbol table */
    int bitbuf;         /* bits from stream */
    int left;           /* bits left in next or left to process */
	 boost::int16_t *next;        /* next number of codes */

    bitbuf = s->bitbuf;
    left = s->bitcnt;
    code = first = index = 0;
    len = 1;
    next = h->count + 1;
    while (1) {
        while (left--) {
            code |= bitbuf & 1;
            bitbuf >>= 1;
            count = *next++;
            if (code < first + count) { /* if length len, return symbol */
                s->bitbuf = bitbuf;
                s->bitcnt = (s->bitcnt - len) & 7;
                return h->symbol[index + (code - first)];
            }
            index += count;             /* else update for next length */
            first += count;
            first <<= 1;
            code <<= 1;
            len++;
        }
        left = (MAXBITS+1) - len;
        if (left == 0) break;
        if (s->incnt == s->inlen) longjmp(s->env, 1);   /* out of input */
        bitbuf = s->in[s->incnt++];
        if (left > 8) left = 8;
    }
    return -9;                          /* ran out of codes */
}",1
Detect whether the following code contains vulnerabilities.,"int addraw_l(struct nlmsghdr *n, int maxlen, const void *data, int len)
{
	if (NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len) > maxlen) {
		fprintf(stderr,
			""addraw_l ERROR: message exceeded bound of %d\n"",
			maxlen);
		return -1;
	}

	memcpy(NLMSG_TAIL(n), data, len);
	memset((void *) NLMSG_TAIL(n) + len, 0, NLMSG_ALIGN(len) - len);
	n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + NLMSG_ALIGN(len);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"z2restore(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    check_type(*op, t_save);

    while (gs_gstate_saved(gs_gstate_saved(igs))) {
        if (restore_page_device(igs, gs_gstate_saved(igs)))
            return push_callout(i_ctx_p, ""%restore1pagedevice"");
        gs_grestore(igs);
    }
    if (restore_page_device(igs, gs_gstate_saved(igs)))
        return push_callout(i_ctx_p, ""%restorepagedevice"");
    return zrestore(i_ctx_p);
}",1
Detect whether the following code contains vulnerabilities.,"Value ExpressionMap::serialize(bool explain) const {
    return Value(DOC(""$map"" << DOC(""input"" << _input->serialize(explain) << ""as"" << _varName << ""in""
                                           << _each->serialize(explain))));
}",0
Detect whether the following code contains vulnerabilities.,"static int addr6_resolve(struct sockaddr *src_sock,
			 const struct sockaddr *dst_sock,
			 struct rdma_dev_addr *addr,
			 struct dst_entry **pdst)
{
	struct sockaddr_in6 *src_in = (struct sockaddr_in6 *)src_sock;
	const struct sockaddr_in6 *dst_in =
				(const struct sockaddr_in6 *)dst_sock;
	struct flowi6 fl6;
	struct dst_entry *dst;
	int ret;

	memset(&fl6, 0, sizeof fl6);
	fl6.daddr = dst_in->sin6_addr;
	fl6.saddr = src_in->sin6_addr;
	fl6.flowi6_oif = addr->bound_dev_if;

	ret = ipv6_stub->ipv6_dst_lookup(addr->net, NULL, &dst, &fl6);
	if (ret < 0)
		return ret;

	if (ipv6_addr_any(&src_in->sin6_addr))
		src_in->sin6_addr = fl6.saddr;

	addr->hoplimit = ip6_dst_hoplimit(dst);

	*pdst = dst;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void qemu_tcg_init_vcpu(void *_env)

{

    CPUState *env = _env;

    /* share a single thread for all cpus with TCG */

    if (!tcg_cpu_thread) {

        env->thread = qemu_mallocz(sizeof(QemuThread));

        env->halt_cond = qemu_mallocz(sizeof(QemuCond));

        qemu_cond_init(env->halt_cond);

        qemu_thread_create(env->thread, qemu_tcg_cpu_thread_fn, env);

        while (env->created == 0)

            qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

        tcg_cpu_thread = env->thread;

        tcg_halt_cond = env->halt_cond;

    } else {

        env->thread = tcg_cpu_thread;

        env->halt_cond = tcg_halt_cond;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void sd_1d97_float(float *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] *= F_LFTG_X;

        else

            p[0] *= F_LFTG_K;

        return;

    }



    extend97_float(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2*i+1] -= 1.586134 * (p[2*i] + p[2*i+2]);

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2*i] -= 0.052980 * (p[2*i-1] + p[2*i+1]);

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2*i+1] += 0.882911 * (p[2*i] + p[2*i+2]);

    for (i = i0/2; i < i1/2; i++)

        p[2*i] += 0.443506 * (p[2*i-1] + p[2*i+1]);

}
",1
Detect whether the following code contains vulnerabilities.,"static void free_vfsmnt(struct mount *mnt)
{
	kfree_const(mnt->mnt_devname);
#ifdef CONFIG_SMP
	free_percpu(mnt->mnt_pcp);
#endif
	kmem_cache_free(mnt_cache, mnt);
}",0
Detect whether the following code contains vulnerabilities.,"expand_dynamic_string_token (struct link_map *l, const char *s)
{
  /* We make two runs over the string.  First we determine how large the
     resulting string is and then we copy it over.  Since this is now
     frequently executed operation we are looking here not for performance
     but rather for code size.  */
  size_t cnt;
  size_t total;
  char *result;

  /* Determine the nubmer of DST elements.  */
  cnt = DL_DST_COUNT (s, 1);

  /* If we do not have to replace anything simply copy the string.  */
  if (cnt == 0)
    return local_strdup (s);

  /* Determine the length of the substituted string.  */
  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);

  /* Allocate the necessary memory.  */
  result = (char *) malloc (total + 1);
  if (result == NULL)
    return NULL;

  return DL_DST_SUBSTITUTE (l, s, result, 1);
}",1
Detect whether the following code contains vulnerabilities.,"ar6000_bitrate_rx(void *devt, s32 rateKbps)
{
    struct ar6_softc *ar = (struct ar6_softc *)devt;

    ar->arBitRate = rateKbps;
    wake_up(&arEvent);
}",0
Detect whether the following code contains vulnerabilities.,"static ipaddr_chain *new_ipaddr_chain(apr_pool_t *p,
                                      server_rec *s, server_addr_rec *sar)
{
    ipaddr_chain *new;

    new = apr_palloc(p, sizeof(*new));
    new->names = NULL;
    new->initialnames = NULL;
    new->server = s;
    new->sar = sar;
    new->next = NULL;
    return new;
}",0
Detect whether the following code contains vulnerabilities.,"TEST_F(OptimizePipeline, MixedMatchPushedDown) {
    auto unpack = fromjson(
        ""{$_internalUnpackBucket: { exclude: [], timeField: 'time', metaField: 'myMeta', ""
        ""bucketMaxSpanSeconds: 3600}}"");
    auto pipeline = Pipeline::parse(
        makeVector(unpack, fromjson(""{$match: {myMeta: {$gte: 0, $lte: 5}, a: {$lte: 4}}}"")),
        getExpCtx());
    ASSERT_EQ(2u, pipeline->getSources().size());

    pipeline->optimizePipeline();

    // To get the optimized $match from the pipeline, we have to serialize with explain.
    auto stages = pipeline->writeExplainOps(ExplainOptions::Verbosity::kQueryPlanner);
    ASSERT_EQ(3u, stages.size());

    // We should push down the $match on the metaField and the predicates on the control field.
    // The created $match stages should be added before $_internalUnpackBucket and merged.
    ASSERT_BSONOBJ_EQ(fromjson(""{$match: {$and: [{'control.min.a': {$_internalExprLte: 4}}, {meta: ""
                               ""{$gte: 0}}, {meta: {$lte: 5}}]}}""),
                      stages[0].getDocument().toBson());
    ASSERT_BSONOBJ_EQ(unpack, stages[1].getDocument().toBson());
    ASSERT_BSONOBJ_EQ(fromjson(""{$match: {a: {$lte: 4}}}""), stages[2].getDocument().toBson());
}",1
Detect whether the following code contains vulnerabilities.,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        alac->direct_output = alac->sample_size > 16 && av_sample_fmt_is_planar(alac->avctx->sample_fmt);

        if (!alac->direct_output) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",1
Detect whether the following code contains vulnerabilities.,"may_record_change(
    linenr_T	lnum,
    colnr_T	col,
    linenr_T	lnume,
    long	xtra)
{
    dict_T	*dict;

    if (curbuf->b_listener == NULL)
	return;

    // If the new change is going to change the line numbers in already listed
    // changes, then flush.
    check_recorded_changes(curbuf, lnum, lnume, xtra);

    if (curbuf->b_recorded_changes == NULL)
    {
	curbuf->b_recorded_changes = list_alloc();
	if (curbuf->b_recorded_changes == NULL)  // out of memory
	    return;
	++curbuf->b_recorded_changes->lv_refcount;
	curbuf->b_recorded_changes->lv_lock = VAR_FIXED;
    }

    dict = dict_alloc();
    if (dict == NULL)
	return;
    dict_add_number(dict, ""lnum"", (varnumber_T)lnum);
    dict_add_number(dict, ""end"", (varnumber_T)lnume);
    dict_add_number(dict, ""added"", (varnumber_T)xtra);
    dict_add_number(dict, ""col"", (varnumber_T)col + 1);

    list_append_dict(curbuf->b_recorded_changes, dict);
}",0
Detect whether the following code contains vulnerabilities.,"static int attr_char(char c) 
{
    switch (c) {
        case '!':
        case '#':
        case '$':
        case '&':
        case '+':
        case '-':
        case '.':
        case '^':
        case '_':
        case '`':
        case '|':
        case '~':
            return 1;
        default:
            return apr_isalnum(c);
    }
}",0
Detect whether the following code contains vulnerabilities.,"static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,

                const uint8_t *data, int start, int len)

{

    struct hci_acl_hdr *pkt = (void *) hci->acl_buf;



    /* TODO: packet flags */

    /* TODO: avoid memcpy'ing */



    if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {

        fprintf(stderr, ""%s: can't take ACL packets %i bytes long\n"",

                        __FUNCTION__, len);

        return;

    }

    memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);



    pkt->handle = cpu_to_le16(

                    acl_handle_pack(handle, start ? ACL_START : ACL_CONT));

    pkt->dlen = cpu_to_le16(len);

    hci->info.acl_recv(hci->info.opaque,

                    hci->acl_buf, len + HCI_ACL_HDR_SIZE);

}
",0
Detect whether the following code contains vulnerabilities.,"static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)

{

    opcode_t *opc, *start, *end;



    fill_new_table(env->opcodes, 0x40);

    if (&opc_start < &opc_end) {

        start = &opc_start;

        end = &opc_end;

    } else {

        start = &opc_end;

        end = &opc_start;

    }

    for (opc = start + 1; opc != end; opc++) {

        if ((opc->handler.type & def->insns_flags) != 0) {

            if (register_insn(env->opcodes, opc) < 0) {

                printf(""*** ERROR initializing PowerPC instruction ""

                       ""0x%02x 0x%02x 0x%02x\n"", opc->opc1, opc->opc2,

                       opc->opc3);

                return -1;

            }

        }

    }

    fix_opcode_tables(env->opcodes);

    fflush(stdout);

    fflush(stderr);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ogg_free(AVFormatContext *s)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        OGGStreamContext *oggstream = st->priv_data;



        if (st->codecpar->codec_id == AV_CODEC_ID_FLAC ||

            st->codecpar->codec_id == AV_CODEC_ID_SPEEX ||

            st->codecpar->codec_id == AV_CODEC_ID_OPUS ||

            st->codecpar->codec_id == AV_CODEC_ID_VP8) {

            av_freep(&oggstream->header[0]);

        }

        av_freep(&oggstream->header[1]);

        av_freep(&st->priv_data);

    }

}",1
Detect whether the following code contains vulnerabilities.,"QString RemoteFsDevice::settingsFileName() const
{
    if (audioFolder.isEmpty()) {
        setAudioFolder();
    }
    return audioFolder+constCantataSettingsFile;
}",0
Detect whether the following code contains vulnerabilities.,"num_stmts(const node *n)
{
    int i, l;
    node *ch;

    switch (TYPE(n)) {
        case single_input:
            if (TYPE(CHILD(n, 0)) == NEWLINE)
                return 0;
            else
                return num_stmts(CHILD(n, 0));
        case file_input:
            l = 0;
            for (i = 0; i < NCH(n); i++) {
                ch = CHILD(n, i);
                if (TYPE(ch) == stmt)
                    l += num_stmts(ch);
            }
            return l;
        case stmt:
            return num_stmts(CHILD(n, 0));
        case compound_stmt:
            return 1;
        case simple_stmt:
            return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */
        case suite:
            if (NCH(n) == 1)
                return num_stmts(CHILD(n, 0));
            else {
                l = 0;
                for (i = 2; i < (NCH(n) - 1); i++)
                    l += num_stmts(CHILD(n, i));
                return l;
            }
        default: {
            char buf[128];

            sprintf(buf, ""Non-statement found: %d %d"",
                    TYPE(n), NCH(n));
            Py_FatalError(buf);
        }
    }
    Py_UNREACHABLE();
}",1
Detect whether the following code contains vulnerabilities.,"TEST_P(RBACIntegrationTest, PathWithQueryAndFragment) {
  config_helper_.addFilter(RBAC_CONFIG_WITH_PATH_EXACT_MATCH);
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  const std::vector<std::string> paths{""/allow"", ""/allow?p1=v1&p2=v2"", ""/allow?p1=v1#seg""};

  for (const auto& path : paths) {
    auto response = codec_client_->makeRequestWithBody(
        Http::TestRequestHeaderMapImpl{
            {"":method"", ""POST""},
            {"":path"", path},
            {"":scheme"", ""http""},
            {"":authority"", ""host""},
            {""x-forwarded-for"", ""10.0.0.1""},
        },
        1024);
    waitForNextUpstreamRequest();
    upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);

    response->waitForEndStream();
    ASSERT_TRUE(response->complete());
    EXPECT_EQ(""200"", response->headers().getStatusValue());
  }
}",0
Detect whether the following code contains vulnerabilities.,"gerbv_gdk_draw_circle(GdkPixmap *pixmap, GdkGC *gc, 
		  gint filled, gint x, gint y, gint dia)
{
    static const gint full_circle = 23360;
    gint real_x = x - dia / 2;
    gint real_y = y - dia / 2;
    
    gdk_draw_arc(pixmap, gc, filled, real_x, real_y, dia, dia, 0, full_circle);
    
    return;
} /* gerbv_gdk_draw_circle */",0
Detect whether the following code contains vulnerabilities.,"static void fw_cfg_realize(DeviceState *dev, Error **errp)

{

    FWCfgState *s = FW_CFG(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);



    if (s->ctl_iobase + 1 == s->data_iobase) {

        sysbus_add_io(sbd, s->ctl_iobase, &s->comb_iomem);

    } else {

        if (s->ctl_iobase) {

            sysbus_add_io(sbd, s->ctl_iobase, &s->ctl_iomem);

        }

        if (s->data_iobase) {

            sysbus_add_io(sbd, s->data_iobase, &s->data_iomem);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"  bool has_int_value() const
  {
    return state == SHORT_DATA_VALUE &&
           value.type_handler()->cmp_type() == INT_RESULT;
  }",0
Detect whether the following code contains vulnerabilities.,"static int sctp_setsockopt_auth_key(struct sock *sk,
				    char __user *optval,
				    int optlen)
{
	struct sctp_authkey *authkey;
	struct sctp_association *asoc;
	int ret;

	if (!sctp_auth_enable)
		return -EACCES;

	if (optlen <= sizeof(struct sctp_authkey))
		return -EINVAL;

	authkey = kmalloc(optlen, GFP_KERNEL);
	if (!authkey)
		return -ENOMEM;

	if (copy_from_user(authkey, optval, optlen)) {
		ret = -EFAULT;
		goto out;
	}

	asoc = sctp_id2assoc(sk, authkey->sca_assoc_id);
	if (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {
		ret = -EINVAL;
		goto out;
	}

	ret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);
out:
	kfree(authkey);
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static inline int emulate_grp1a(struct x86_emulate_ctxt *ctxt,
				struct x86_emulate_ops *ops)
{
	struct decode_cache *c = &ctxt->decode;
	int rc;

	rc = emulate_pop(ctxt, ops, &c->dst.val, c->dst.bytes);
	if (rc != 0)
		return rc;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_pci_exit(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);

    virtio_pci_stop_ioeventfd(proxy);

    memory_region_destroy(&proxy->bar);

    msix_uninit_exclusive_bar(pci_dev);

}
",1
Detect whether the following code contains vulnerabilities.,"static void qmp_input_start_struct(Visitor *v, const char *name, void **obj,

                                   size_t size, Error **errp)

{

    QmpInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qmp_input_get_object(qiv, name, true);

    Error *err = NULL;






    if (!qobj || qobject_type(qobj) != QTYPE_QDICT) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""QDict"");

        return;




    qmp_input_push(qiv, qobj, &err);

    if (err) {

        error_propagate(errp, err);

        return;





        *obj = g_malloc0(size);

",1
Detect whether the following code contains vulnerabilities.,"static void pl041_device_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = pl041_init;

    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);

    dc->no_user = 1;

    dc->reset = pl041_device_reset;

    dc->vmsd = &vmstate_pl041;

    dc->props = pl041_device_properties;

}
",1
Detect whether the following code contains vulnerabilities.,"static int aspeed_lpc_ctrl_mmap(struct file *file, struct vm_area_struct *vma)
{
	struct aspeed_lpc_ctrl *lpc_ctrl = file_aspeed_lpc_ctrl(file);
	unsigned long vsize = vma->vm_end - vma->vm_start;
	pgprot_t prot = vma->vm_page_prot;

	if (vma->vm_pgoff + vsize > lpc_ctrl->mem_base + lpc_ctrl->mem_size)
		return -EINVAL;

	/* ast2400/2500 AHB accesses are not cache coherent */
	prot = pgprot_noncached(prot);

	if (remap_pfn_range(vma, vma->vm_start,
		(lpc_ctrl->mem_base >> PAGE_SHIFT) + vma->vm_pgoff,
		vsize, prot))
		return -EAGAIN;

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"xmlDictCreateSub(xmlDictPtr sub) {
    xmlDictPtr dict = xmlDictCreate();

    if ((dict != NULL) && (sub != NULL)) {
#ifdef DICT_DEBUG_PATTERNS
        fprintf(stderr, ""R"");
#endif
        dict->subdict = sub;
	xmlDictReference(dict->subdict);
    }
    return(dict);
}",1
Detect whether the following code contains vulnerabilities.,"TEST_F(HttpConnectionManagerConfigTest, ServerOverwrite) {
  const std::string yaml_string = R""EOF(
  stat_prefix: ingress_http
  server_header_transformation: OVERWRITE
  route_config:
    name: local_route
  http_filters:
  - name: envoy.filters.http.router
  )EOF"";

  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))
      .WillOnce(Invoke(&context_.runtime_loader_.snapshot_,
                       &Runtime::MockSnapshot::featureEnabledDefault));
  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,
                                     date_provider_, route_config_provider_manager_,
                                     scoped_routes_config_provider_manager_, http_tracer_manager_,
                                     filter_config_provider_manager_);
  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::OVERWRITE,
            config.serverHeaderTransformation());
}",1
Detect whether the following code contains vulnerabilities.,"int hci_conn_check_link_mode(struct hci_conn *conn)
{
	BT_DBG(""hcon %p"", conn);

	/* In Secure Connections Only mode, it is required that Secure
	 * Connections is used and the link is encrypted with AES-CCM
	 * using a P-256 authenticated combination key.
	 */
	if (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {
		if (!hci_conn_sc_enabled(conn) ||
		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||
		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)
			return 0;
	}

	if (hci_conn_ssp_enabled(conn) &&
	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
		return 0;

	/* The minimum encryption key size needs to be enforced by the
	 * host stack before establishing any L2CAP connections. The
	 * specification in theory allows a minimum of 1, but to align
	 * BR/EDR and LE transports, a minimum of 7 is chosen.
	 */
	if (conn->enc_key_size < HCI_MIN_ENC_KEY_SIZE)
		return 0;

	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(DirectoryIterator, rewind)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	intern->u.dir.index = 0;
	if (intern->u.dir.dirp) {
		php_stream_rewinddir(intern->u.dir.dirp);
	}
	spl_filesystem_dir_read(intern TSRMLS_CC);
}",1
Detect whether the following code contains vulnerabilities.,    ~Mounter() { },1
Detect whether the following code contains vulnerabilities.,"void user_destroy(struct key *key)
{
	struct user_key_payload *upayload = key->payload.data[0];

	kfree(upayload);
}",0
Detect whether the following code contains vulnerabilities.,"new_type_comment(const char *s, struct compiling *c)
{
    PyObject *res = PyUnicode_DecodeUTF8(s, strlen(s), NULL);
    if (res == NULL)
        return NULL;
    if (PyArena_AddPyObject(c->c_arena, res) < 0) {
        Py_DECREF(res);
        return NULL;
    }
    return res;
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)

{

    const ARMCPRegInfo *ri = rip;



    return ri->readfn(env, ri);

}
",1
Detect whether the following code contains vulnerabilities.,"static void task_tick_numa(struct rq *rq, struct task_struct *curr)
{
	struct callback_head *work = &curr->numa_work;
	u64 period, now;

	/*
	 * We don't care about NUMA placement if we don't have memory.
	 */
	if (!curr->mm || (curr->flags & PF_EXITING) || work->next != work)
		return;

	/*
	 * Using runtime rather than walltime has the dual advantage that
	 * we (mostly) drive the selection from busy threads and that the
	 * task needs to have done some actual work before we bother with
	 * NUMA placement.
	 */
	now = curr->se.sum_exec_runtime;
	period = (u64)curr->numa_scan_period * NSEC_PER_MSEC;

	if (now > curr->node_stamp + period) {
		if (!curr->node_stamp)
			curr->numa_scan_period = task_scan_start(curr);
		curr->node_stamp += period;

		if (!time_before(jiffies, curr->mm->numa_next_scan)) {
			init_task_work(work, task_numa_work); /* TODO: move this into sched_fork() */
			task_work_add(curr, work, true);
		}
	}
}",0
Detect whether the following code contains vulnerabilities.,"const opaque* ServerHello::get_random() const
{
    return random_;
}",0
Detect whether the following code contains vulnerabilities.,"PCIBus *pci_find_bus(PCIBus *bus, int bus_num)

{

    PCIBus *sec;



    if (!bus)

        return NULL;



    if (pci_bus_num(bus) == bus_num) {

        return bus;

    }



    /* try child bus */

    QLIST_FOREACH(sec, &bus->child, sibling) {



        if (!bus->parent_dev /* pci host bridge */

            || (pci_bus_num(sec) <= bus_num &&

                bus->parent_dev->config[PCI_SUBORDINATE_BUS])) {

            return pci_find_bus(sec, bus_num);

        }

    }



    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int blah (int32_t i)

{

    if (i > 0x43c07fff)

        return 32767;

    else if (i < 0x43bf8000)

        return -32768;

    else

        return i - 0x43c00000;

}
",0
Detect whether the following code contains vulnerabilities.,"static int p54u_load_firmware(struct ieee80211_hw *dev,
			      struct usb_interface *intf)
{
	struct usb_device *udev = interface_to_usbdev(intf);
	struct p54u_priv *priv = dev->priv;
	struct device *device = &udev->dev;
	int err, i;

	BUILD_BUG_ON(ARRAY_SIZE(p54u_fwlist) != __NUM_P54U_HWTYPES);

	init_completion(&priv->fw_wait_load);
	i = p54_find_type(priv);
	if (i < 0)
		return i;

	dev_info(&priv->udev->dev, ""Loading firmware file %s\n"",
	       p54u_fwlist[i].fw);

	usb_get_dev(udev);
	err = request_firmware_nowait(THIS_MODULE, 1, p54u_fwlist[i].fw,
				      device, GFP_KERNEL, priv,
				      p54u_load_firmware_cb);
	if (err) {
		dev_err(&priv->udev->dev, ""(p54usb) cannot load firmware %s ""
					  ""(%d)!\n"", p54u_fwlist[i].fw, err);
		usb_put_dev(udev);
	}

	return err;
}",1
Detect whether the following code contains vulnerabilities.,"static int sdp_probe(AVProbeData *p1)

{

    const char *p = p1->buf, *p_end = p1->buf + p1->buf_size;



    /* we look for a line beginning ""c=IN IP4"" */

    while (p < p_end && *p != '\0') {

        if (p + sizeof(""c=IN IP4"") - 1 < p_end && av_strstart(p, ""c=IN IP4"", NULL))

            return AVPROBE_SCORE_MAX / 2;



        while(p < p_end - 1 && *p != '\n') p++;

        if (++p >= p_end)

            break;

        if (*p == '\r')

            p++;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"bool LEX::stmt_create_stored_function_finalize_standalone(const sp_name *end_name)
{
  if (sphead->check_standalone_routine_end_name(end_name))
    return true;
  stmt_create_routine_finalize();
  return false;
}",0
Detect whether the following code contains vulnerabilities.,"static struct strbufinfo setTempString(void)
{
	struct strbufinfo current;
	current.size=strsize;
	current.maxsize=strmaxsize;
	current.str=dcstr;
	current.ptr=dcptr;
	dcinit();
	return current;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t mipsnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)

{

    MIPSnetState *s = qemu_get_nic_opaque(nc);



    trace_mipsnet_receive(size);

    if (!mipsnet_can_receive(nc))







    s->busy = 1;



    /* Just accept everything. */



    /* Write packet data. */

    memcpy(s->rx_buffer, buf, size);



    s->rx_count = size;

    s->rx_read = 0;



    /* Now we can signal we have received something. */

    s->intctl |= MIPSNET_INTCTL_RXDONE;

    mipsnet_update_irq(s);



    return size;
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_co_readv(BlockDriverState *bs, int64_t sector_num,

                        int nb_sectors, QEMUIOVector *qiov)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_readv(&s->client, sector_num,

                                       nb_sectors, qiov);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoull_max(void)

{

    char *str = g_strdup_printf(""%llu"", ULLONG_MAX);

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

    g_free(str);

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_co_rwlock_unlock(CoRwlock *lock)

{

    assert(qemu_in_coroutine());

    if (lock->writer) {

        lock->writer = false;

        while (!qemu_co_queue_empty(&lock->queue)) {

            /*

             * Wakeup every body. This will include some

             * writers too.

             */

            qemu_co_queue_next(&lock->queue);

        }

    } else {

        lock->reader--;

        assert(lock->reader >= 0);

        /* Wakeup only one waiting writer */

        if (!lock->reader) {

            qemu_co_queue_next(&lock->queue);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int scale_vector(int16_t *dst, const int16_t *vector, int length)

{

    int bits, max = 0;

    int i;



    for (i = 0; i < length; i++)

        max |= FFABS(vector[i]);



    bits  = normalize_bits(max, 15);



    if (bits == 15)

        for (i = 0; i < length; i++)

            dst[i] = vector[i] * 0x7fff >> 3;

    else

        for (i = 0; i < length; i++)

            dst[i] = vector[i] << bits >> 3;



    return bits - 3;

}
",1
Detect whether the following code contains vulnerabilities.,"static int dx2_decode_slice_410(GetBitContext *gb, AVFrame *frame,

                                int line, int left,

                                uint8_t lru[3][8])

{

    int x, y, i, j;

    int width   = frame->width;



    int ystride = frame->linesize[0];

    int ustride = frame->linesize[1];

    int vstride = frame->linesize[2];



    uint8_t *Y  = frame->data[0] + ystride * line;

    uint8_t *U  = frame->data[1] + (ustride >> 2) * line;

    uint8_t *V  = frame->data[2] + (vstride >> 2) * line;



    for (y = 0; y < left - 3 && get_bits_left(gb) > 16; y += 4) {

        for (x = 0; x < width; x += 4) {

            for (j = 0; j < 4; j++)

                for (i = 0; i < 4; i++)

                    Y[x + i + j * ystride] = decode_sym(gb, lru[0]);

            U[x >> 2] = decode_sym(gb, lru[1]) ^ 0x80;

            V[x >> 2] = decode_sym(gb, lru[2]) ^ 0x80;

        }



        Y += ystride << 2;

        U += ustride;

        V += vstride;

    }



    return y;

}
",1
Detect whether the following code contains vulnerabilities.,"static int vmci_transport_send_negotiate2(struct sock *sk, size_t size,
					  u16 version)
{
	return vmci_transport_send_control_pkt(
					sk,
					VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,
					size, 0, NULL, version,
					VMCI_INVALID_HANDLE);
}",0
Detect whether the following code contains vulnerabilities.,"static void vm_completion(ReadLineState *rs, const char *str)

{

    size_t len;

    BlockDriverState *bs;

    BdrvNextIterator *it = NULL;



    len = strlen(str);

    readline_set_completion_index(rs, len);



    while ((it = bdrv_next(it, &bs))) {

        SnapshotInfoList *snapshots, *snapshot;

        AioContext *ctx = bdrv_get_aio_context(bs);

        bool ok = false;



        aio_context_acquire(ctx);

        if (bdrv_can_snapshot(bs)) {

            ok = bdrv_query_snapshot_info_list(bs, &snapshots, NULL) == 0;

        }

        aio_context_release(ctx);

        if (!ok) {

            continue;

        }



        snapshot = snapshots;

        while (snapshot) {

            char *completion = snapshot->value->name;

            if (!strncmp(str, completion, len)) {

                readline_add_completion(rs, completion);

            }

            completion = snapshot->value->id;

            if (!strncmp(str, completion, len)) {

                readline_add_completion(rs, completion);

            }

            snapshot = snapshot->next;

        }

        qapi_free_SnapshotInfoList(snapshots);

    }



}
",1
Detect whether the following code contains vulnerabilities.,"static void debugmem_list_delete(MEMHDR *p)
{
     if (p->mh_next)
     p->mh_next->mh_prev = p->mh_prev;
     if (p->mh_prev)
     p->mh_prev->mh_next = p->mh_next;
     else memlist = p->mh_next;
#ifdef MEM_LIST_DEBUG
     if (stderr)
     Mem_Display(stderr);
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static bool imap_is_valid_tag(const char *tag)
{
	for (; *tag != '\0'; tag++) {
		switch (*tag) {
		case '+':
		/* atom-specials: */
		case '(':
		case ')':
		case '{':
		case '/':
		case ' ':
		/* list-wildcards: */
		case '%':
		case '*':
		/* quoted-specials: */
		case '""':
		case '\\':
			return FALSE;
		default:
			if (*tag < ' ') /* CTL */
				return FALSE;
			break;
		}
	}
	return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"void qemu_iovec_destroy(QEMUIOVector *qiov)

{

    assert(qiov->nalloc != -1);




    g_free(qiov->iov);



}",1
Detect whether the following code contains vulnerabilities.,"send_environment_variable (const char             *key,
                           const char             *value,
                           GdmSessionConversation *conversation)
{
        gdm_dbus_worker_call_set_environment_variable (conversation->worker_proxy,
                                                       key, value,
                                                       NULL, NULL, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"static void youngcollection (lua_State *L, global_State *g) {
  GCObject **psurvival;  /* to point to first non-dead survival object */
  lua_assert(g->gcstate == GCSpropagate);
  markold(g, g->survival, g->reallyold);
  markold(g, g->finobj, g->finobjrold);
  atomic(L);

  /* sweep nursery and get a pointer to its last live element */
  psurvival = sweepgen(L, g, &g->allgc, g->survival);
  /* sweep 'survival' and 'old' */
  sweepgen(L, g, psurvival, g->reallyold);
  g->reallyold = g->old;
  g->old = *psurvival;  /* 'survival' survivals are old now */
  g->survival = g->allgc;  /* all news are survivals */

  /* repeat for 'finobj' lists */
  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);
  /* sweep 'survival' and 'old' */
  sweepgen(L, g, psurvival, g->finobjrold);
  g->finobjrold = g->finobjold;
  g->finobjold = *psurvival;  /* 'survival' survivals are old now */
  g->finobjsur = g->finobj;  /* all news are survivals */

  sweepgen(L, g, &g->tobefnz, NULL);

  finishgencycle(L, g);
}",1
Detect whether the following code contains vulnerabilities.,"static void vmstate_subsection_save(QEMUFile *f, const VMStateDescription *vmsd,

                                    void *opaque)

{

    const VMStateSubsection *sub = vmsd->subsections;



    while (sub && sub->needed) {

        if (sub->needed(opaque)) {

            const VMStateDescription *vmsd = sub->vmsd;

            uint8_t len;



            qemu_put_byte(f, QEMU_VM_SUBSECTION);

            len = strlen(vmsd->name);

            qemu_put_byte(f, len);

            qemu_put_buffer(f, (uint8_t *)vmsd->name, len);

            qemu_put_be32(f, vmsd->version_id);

            assert(!vmsd->subsections);

            vmstate_save_state(f, vmsd, opaque);

        }

        sub++;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void psi_poll_work(struct psi_group *group)
{
	u32 changed_states;
	u64 now;

	mutex_lock(&group->trigger_lock);

	now = sched_clock();

	collect_percpu_times(group, PSI_POLL, &changed_states);

	if (changed_states & group->poll_states) {
		/* Initialize trigger windows when entering polling mode */
		if (now > group->polling_until)
			init_triggers(group, now);

		/*
		 * Keep the monitor active for at least the duration of the
		 * minimum tracking window as long as monitor states are
		 * changing.
		 */
		group->polling_until = now +
			group->poll_min_period * UPDATES_PER_WINDOW;
	}

	if (now > group->polling_until) {
		group->polling_next_update = ULLONG_MAX;
		goto out;
	}

	if (now >= group->polling_next_update)
		group->polling_next_update = update_triggers(group, now);

	psi_schedule_poll_work(group,
		nsecs_to_jiffies(group->polling_next_update - now) + 1);

out:
	mutex_unlock(&group->trigger_lock);
}",0
Detect whether the following code contains vulnerabilities.,"void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */
{
	char *p1, *p2;
	
	if (intern->file_name) {
		efree(intern->file_name);
	}

	intern->file_name = use_copy ? estrndup(path, len) : path;
	intern->file_name_len = len;

	while(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {
		intern->file_name[intern->file_name_len-1] = 0;
		intern->file_name_len--;
	}

	p1 = strrchr(intern->file_name, '/');
#if defined(PHP_WIN32) || defined(NETWARE)
	p2 = strrchr(intern->file_name, '\\');
#else
	p2 = 0;
#endif
	if (p1 || p2) {
		intern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;
	} else {
		intern->_path_len = 0;
	}
	
	if (intern->_path) {
		efree(intern->_path);
	}
	intern->_path = estrndup(path, intern->_path_len);
} /* }}} */",1
Detect whether the following code contains vulnerabilities.,"compileFile (const char *fileName)
{
/*Compile a table file */
  FileInfo nested;
  fileCount++;
  nested.fileName = fileName;
  nested.encoding = noEncoding;
  nested.status = 0;
  nested.lineNumber = 0;
  if ((nested.in = findTable (fileName)))
    {
      while (getALine (&nested))
	compileRule (&nested);
      fclose (nested.in);
    }
  else
    {
      if (fileCount > 1)
	lou_logPrint (""Cannot open table '%s'"", nested.fileName);
      errorCount++;
      return 0;
    }
  return 1;
}",1
Detect whether the following code contains vulnerabilities.,"int read_filesystem_tables_4()
{
	long long directory_table_end, table_start;

	if(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)
		return FALSE;

	if(read_uids_guids(&table_start) == FALSE)
		return FALSE;

	if(parse_exports_table(&table_start) == FALSE)
		return FALSE;

	if(read_fragment_table(&directory_table_end) == FALSE)
		return FALSE;

	if(read_inode_table(sBlk.s.inode_table_start,
				sBlk.s.directory_table_start) == FALSE)
		return FALSE;

	if(read_directory_table(sBlk.s.directory_table_start,
				directory_table_end) == FALSE)
		return FALSE;

	if(no_xattrs)
		sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;

	return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"void memory_region_transaction_commit(void)
{
    AddressSpace *as;
    assert(memory_region_transaction_depth);
    --memory_region_transaction_depth;
    if (!memory_region_transaction_depth) {
        if (memory_region_update_pending) {
            MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                address_space_update_topology(as);
            }
            MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
        } else if (ioeventfd_update_pending) {
            QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                address_space_update_ioeventfds(as);
            }
        }
        memory_region_clear_pending();
   }
}",1
Detect whether the following code contains vulnerabilities.,"eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)
{
    char_u *p = skipwhite(arg);

    *getnext = FALSE;
    if (in_vim9script()
	    && evalarg != NULL
	    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL
								   || *p == NL)
	    && (*p == NUL || *p == NL
			     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))
    {
	char_u *next;

	if (*p == NL)
	    next = newline_skip_comments(p);
	else if (evalarg->eval_cookie != NULL)
	    next = getline_peek_skip_comments(evalarg);
	else
	    next = peek_next_line_from_context(evalarg->eval_cctx);

	if (next != NULL)
	{
	    *getnext = TRUE;
	    return skipwhite(next);
	}
    }
    return p;
}",1
Detect whether the following code contains vulnerabilities.,"print_help(gs_main_instance * minst)
{
    int i, have_rom_device = 0;

    print_revision(minst);
    print_usage(minst);
    print_emulators(minst);
    print_devices(minst);
    print_paths(minst);
    /* Check if we have the %rom device */
    for (i = 0; i < gx_io_device_table_count; i++) {
        const gx_io_device *iodev = gx_io_device_table[i];
        const char *dname = iodev->dname;

        if (dname && strlen(dname) == 5 && !memcmp(""%rom%"", dname, 5)) {
            have_rom_device = 1;
            break;
        }
    }
    if (have_rom_device) {
        outprintf(minst->heap, ""Initialization files are compiled into the executable.\n"");
    }
    print_help_trailer(minst);
}",0
Detect whether the following code contains vulnerabilities.,"NBDExport *nbd_export_new(BlockDriverState *bs, off_t dev_offset,

                          off_t size, uint32_t nbdflags,

                          void (*close)(NBDExport *))

{

    NBDExport *exp = g_malloc0(sizeof(NBDExport));

    exp->refcount = 1;

    QTAILQ_INIT(&exp->clients);

    exp->bs = bs;

    exp->dev_offset = dev_offset;

    exp->nbdflags = nbdflags;

    exp->size = size == -1 ? bdrv_getlength(bs) : size;

    exp->close = close;

    exp->ctx = bdrv_get_aio_context(bs);

    bdrv_ref(bs);

    bdrv_add_aio_context_notifier(bs, bs_aio_attached, bs_aio_detach, exp);







    return exp;

}",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_fcmps(int fccno, TCGv_i32 r_rs1, TCGv_i32 r_rs2)

{

    switch (fccno) {

    case 0:

        gen_helper_fcmps(cpu_env, r_rs1, r_rs2);

        break;

    case 1:

        gen_helper_fcmps_fcc1(cpu_env, r_rs1, r_rs2);

        break;

    case 2:

        gen_helper_fcmps_fcc2(cpu_env, r_rs1, r_rs2);

        break;

    case 3:

        gen_helper_fcmps_fcc3(cpu_env, r_rs1, r_rs2);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int kalman_smoothen(WMAVoiceContext *s, int pitch,

                           const float *in, float *out, int size)

{

    int n;

    float optimal_gain = 0, dot;

    const float *ptr = &in[-FFMAX(s->min_pitch_val, pitch - 3)],

                *end = &in[-FFMIN(s->max_pitch_val, pitch + 3)],

                *best_hist_ptr;



    /* find best fitting point in history */

    do {

        dot = ff_scalarproduct_float_c(in, ptr, size);

        if (dot > optimal_gain) {

            optimal_gain  = dot;

            best_hist_ptr = ptr;

        }

    } while (--ptr >= end);



    if (optimal_gain <= 0)

        return -1;

    dot = ff_scalarproduct_float_c(best_hist_ptr, best_hist_ptr, size);

    if (dot <= 0) // would be 1.0

        return -1;



    if (optimal_gain <= dot) {

        dot = dot / (dot + 0.6 * optimal_gain); // 0.625-1.000

    } else

        dot = 0.625;



    /* actual smoothing */

    for (n = 0; n < size; n++)

        out[n] = best_hist_ptr[n] + dot * (in[n] - best_hist_ptr[n]);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"predefined_fiddle_handle(void *handle)
{
    VALUE obj = rb_fiddle_handle_s_allocate(rb_cHandle);
    struct dl_handle *fiddle_handle = DATA_PTR(obj);

    fiddle_handle->ptr = handle;
    fiddle_handle->open = 1;
    OBJ_FREEZE(obj);
    return obj;
}",0
Detect whether the following code contains vulnerabilities.,"int qemu_global_option(const char *str)

{

    char driver[64], property[64];

    QemuOpts *opts;

    int rc, offset;



    rc = sscanf(str, ""%63[^.].%63[^=]%n"", driver, property, &offset);

    if (rc < 2 || str[offset] != '=') {

        error_report(""can't parse: \""%s\"""", str);

        return -1;

    }



    opts = qemu_opts_create(&qemu_global_opts, NULL, 0);

    qemu_opt_set(opts, ""driver"", driver);

    qemu_opt_set(opts, ""property"", property);

    qemu_opt_set(opts, ""value"", str+offset+1);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"zzip_mem_disk_entry_to_data(ZZIP_MEM_DISK* dir, ZZIP_DISK_ENTRY* entry) {
    return zzip_disk_entry_to_data(dir->disk, entry); }",1
Detect whether the following code contains vulnerabilities.,"void qdev_prop_set_globals(DeviceState *dev)

{

    ObjectClass *class = object_get_class(OBJECT(dev));



    do {

        qdev_prop_set_globals_for_type(dev, object_class_get_name(class));

        class = object_class_get_parent(class);

    } while (class);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(bgr24ToUV_half)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, int width, uint32_t *unused)

{

    int i;

    for (i=0; i<width; i++) {

        int b= src1[6*i + 0] + src1[6*i + 3];

        int g= src1[6*i + 1] + src1[6*i + 4];

        int r= src1[6*i + 2] + src1[6*i + 5];



        dstU[i]= (RU*r + GU*g + BU*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);

        dstV[i]= (RV*r + GV*g + BV*b + (257<<RGB2YUV_SHIFT))>>(RGB2YUV_SHIFT+1);

    }

    assert(src1 == src2);

}
",1
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn bdrv_co_do_readv(BlockDriverState *bs,
    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,
    BdrvRequestFlags flags)
{
    if (nb_sectors < 0 || nb_sectors > (UINT_MAX >> BDRV_SECTOR_BITS)) {
        return -EINVAL;
    }

    return bdrv_co_do_preadv(bs, sector_num << BDRV_SECTOR_BITS,
                             nb_sectors << BDRV_SECTOR_BITS, qiov, flags);
}",0
Detect whether the following code contains vulnerabilities.,static inline int cap_limit_ptraced_target(void) { return 1; },0
Detect whether the following code contains vulnerabilities.,"void altivec_unavailable_exception(struct pt_regs *regs)
{
#if !defined(CONFIG_ALTIVEC)
	if (user_mode(regs)) {
		/* A user program has executed an altivec instruction,
		   but this kernel doesn't support altivec. */
		_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);
		return;
	}
#endif
	printk(KERN_EMERG ""Unrecoverable VMX/Altivec Unavailable Exception ""
			""%lx at %lx\n"", regs->trap, regs->nip);
	die(""Unrecoverable VMX/Altivec Unavailable Exception"", regs, SIGABRT);
}",1
Detect whether the following code contains vulnerabilities.,"static zend_bool php_auto_globals_create_files(const char *name, uint name_len TSRMLS_DC)
{
	zval *vars;

	if (PG(http_globals)[TRACK_VARS_FILES]) {
		vars = PG(http_globals)[TRACK_VARS_FILES];
	} else {
		ALLOC_ZVAL(vars);
		array_init(vars);
		INIT_PZVAL(vars);
		PG(http_globals)[TRACK_VARS_FILES] = vars;
	}

	zend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);
	Z_ADDREF_P(vars);
	
	return 0; /* don't rearm */
}",1
Detect whether the following code contains vulnerabilities.,"static int wanxl_open(struct net_device *dev)
{
	port_t *port = dev_to_port(dev);
	u8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;
	unsigned long timeout;
	int i;

	if (get_status(port)->open) {
		netdev_err(dev, ""port already open\n"");
		return -EIO;
	}
	if ((i = hdlc_open(dev)) != 0)
		return i;

	port->tx_in = port->tx_out = 0;
	for (i = 0; i < TX_BUFFERS; i++)
		get_status(port)->tx_descs[i].stat = PACKET_EMPTY;
	/* signal the card */
	writel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);

	timeout = jiffies + HZ;
	do {
		if (get_status(port)->open) {
			netif_start_queue(dev);
			return 0;
		}
	} while (time_after(timeout, jiffies));

	netdev_err(dev, ""unable to open port\n"");
	/* ask the card to close the port, should it be still alive */
	writel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);
	return -EFAULT;
}",0
Detect whether the following code contains vulnerabilities.,"static int is_userinfo_valid(const char *str, size_t len)
{
	char *valid = ""-._~!$&'()*+,;=:"";
	char *p = str;
	while (p - str < len) {
		if (isalpha(*p) || isdigit(*p) || strchr(valid, *p)) {
			p++;
		} else if (*p == '%' && p - str <= len - 3 && isdigit(*(p+1)) && isxdigit(*(p+2))) {
			p += 3;
		} else {
			return 0;
		}
	}
	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,
                                 const TfLiteTensor* axis,
                                 const TfLiteTensor* input, int num_splits) {
  int axis_value = GetTensorData<int>(axis)[0];
  if (axis_value < 0) {
    axis_value += NumDimensions(input);
  }

  TF_LITE_ENSURE(context, axis_value >= 0);
  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));

  const int input_size = SizeOfDimension(input, axis_value);
  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,
                     ""Not an even split"");
  const int slice_size = input_size / num_splits;

  for (int i = 0; i < NumOutputs(node); ++i) {
    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);
    output_dims->data[axis_value] = slice_size;
    TfLiteTensor* output = GetOutput(context, node, i);
    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));
  }

  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"void ssl3_init_finished_mac(SSL *s)
	{
	if (s->s3->handshake_buffer) BIO_free(s->s3->handshake_buffer);
	if (s->s3->handshake_dgst) ssl3_free_digest_list(s);
    s->s3->handshake_buffer=BIO_new(BIO_s_mem());	
	(void)BIO_set_close(s->s3->handshake_buffer,BIO_CLOSE);
	}",0
Detect whether the following code contains vulnerabilities.,"CMS_ContentInfo *CMS_digest_create(BIO *in, const EVP_MD *md,
                                   unsigned int flags)
{
    CMS_ContentInfo *cms;
    if (!md)
        md = EVP_sha1();
    cms = cms_DigestedData_create(md);
    if (!cms)
        return NULL;

    if (!(flags & CMS_DETACHED)) {
        flags &= ~CMS_STREAM;
        CMS_set_detached(cms, 0);
    }

    if ((flags & CMS_STREAM) || CMS_final(cms, in, NULL, flags))
        return cms;

    CMS_ContentInfo_free(cms);
    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"void qemu_system_suspend_request(void)

{

    if (is_suspended) {

        return;

    }

    suspend_requested = 1;

    cpu_stop_current();

    qemu_notify_event();

}
",0
Detect whether the following code contains vulnerabilities.,"static int udbg_rtascon_getc(void)
{
	int c;

	while ((c = udbg_rtascon_getc_poll()) == -1)
		;

	return c;
}",0
Detect whether the following code contains vulnerabilities.,"decompress_none(tvbuff_t *tvb, packet_info *pinfo _U_, int offset, guint32 length _U_, tvbuff_t **decompressed_tvb, int *decompressed_offset)
{
    *decompressed_tvb = tvb;
    *decompressed_offset = offset;
    return 1;
}",1
Detect whether the following code contains vulnerabilities.," */
PHPAPI char *php_info_html_esc(char *string TSRMLS_DC)
{
	size_t new_len;
	return php_escape_html_entities((unsigned char *) string, strlen(string), &new_len, 0, ENT_QUOTES, NULL TSRMLS_CC);",0
Detect whether the following code contains vulnerabilities.,"ofputil_pull_ofp11_group_mod(struct ofpbuf *msg, enum ofp_version ofp_version,
                             struct ofputil_group_mod *gm)
{
    const struct ofp11_group_mod *ogm;
    enum ofperr error;

    ogm = ofpbuf_pull(msg, sizeof *ogm);
    gm->command = ntohs(ogm->command);
    gm->type = ogm->type;
    gm->group_id = ntohl(ogm->group_id);
    gm->command_bucket_id = OFPG15_BUCKET_ALL;

    error = ofputil_pull_ofp11_buckets(msg, msg->size, ofp_version,
                                       &gm->buckets);

    /* OF1.3.5+ prescribes an error when an OFPGC_DELETE includes buckets. */
    if (!error
        && ofp_version >= OFP13_VERSION
        && gm->command == OFPGC11_DELETE
        && !ovs_list_is_empty(&gm->buckets)) {
        error = OFPERR_OFPGMFC_INVALID_GROUP;
    }

    return error;
}",1
Detect whether the following code contains vulnerabilities.,"cin_iselse(
    char_u  *p)
{
    if (*p == '}')	    // accept ""} else""
	p = cin_skipcomment(p + 1);
    return (STRNCMP(p, ""else"", 4) == 0 && !vim_isIDc(p[4]));
}",0
Detect whether the following code contains vulnerabilities.,"unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs)
{
	unsigned long addr, seg;

	addr = regs->rip;
	seg = regs->cs & 0xffff;

	/*
	 * We'll assume that the code segments in the GDT
	 * are all zero-based. That is largely true: the
	 * TLS segments are used for data, and the PNPBIOS
	 * and APM bios ones we just ignore here.
	 */
	if (seg & LDT_SEGMENT) {
		u32 *desc;
		unsigned long base;

		down(&child->mm->context.sem);
		desc = child->mm->context.ldt + (seg & ~7);
		base = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);

		/* 16-bit code segment? */
		if (!((desc[1] >> 22) & 1))
			addr &= 0xffff;
		addr += base;
		up(&child->mm->context.sem);
	}
	return addr;
}",1
Detect whether the following code contains vulnerabilities.,"
void STDCALL mysql_close(MYSQL *mysql)
{
  DBUG_ENTER(""mysql_close"");
  if (mysql)					/* Some simple safety */
  {
    /* If connection is still up, send a QUIT message */
    if (mysql->net.vio != 0)
    {
      free_old_query(mysql);
      mysql->status=MYSQL_STATUS_READY; /* Force command */
      mysql->reconnect=0;
      simple_command(mysql,COM_QUIT,(uchar*) 0,0,1);
      end_server(mysql);			/* Sets mysql->net.vio= 0 */
    }
    mysql_close_free_options(mysql);
    mysql_close_free(mysql);
    mysql_detach_stmt_list(&mysql->stmts, ""mysql_close"");
#ifndef MYSQL_SERVER
    if (mysql->thd)
      (*mysql->methods->free_embedded_thd)(mysql);
#endif
    if (mysql->extension)
      mysql_extension_free(mysql->extension);
    mysql->extension= NULL;
    if (mysql->free_me)
      my_free(mysql);
  }
  DBUG_VOID_RETURN;",0
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(neon_acgt_f32)(uint32_t a, uint32_t b)

{

    float32 f0 = float32_abs(make_float32(a));

    float32 f1 = float32_abs(make_float32(b));

    if (float32_compare_quiet(f0, f1, NFS) == float_relation_greater) {

        return ~0;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void jas_icccurv_destroy(jas_iccattrval_t *attrval)
{
	jas_icccurv_t *curv = &attrval->data.curv;
	if (curv->ents)
		jas_free(curv->ents);
}",1
Detect whether the following code contains vulnerabilities.,"static void sd_erase(SDState *sd)

{

    int i, start, end;

    if (!sd->erase_start || !sd->erase_end) {

        sd->card_status |= ERASE_SEQ_ERROR;

        return;

    }



    start = sd->erase_start >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);

    end = sd->erase_end >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->csd[14] |= 0x40;



    for (i = start; i <= end; i ++)

        if (sd->wp_groups[i])

            sd->card_status |= WP_ERASE_SKIP;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vhost_vsock_common_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);

    device_class_set_props(dc, vhost_vsock_common_properties);
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->guest_notifier_mask = vhost_vsock_common_guest_notifier_mask;
    vdc->guest_notifier_pending = vhost_vsock_common_guest_notifier_pending;
}",0
Detect whether the following code contains vulnerabilities.,"static unsigned int *generic_get_timeouts(struct net *net)
{
	return &(generic_pernet(net)->timeout);
}",0
Detect whether the following code contains vulnerabilities.,"static void io_wait_on_hash(struct io_wqe *wqe, unsigned int hash)
{
	struct io_wq *wq = wqe->wq;

	spin_lock_irq(&wq->hash->wait.lock);
	if (list_empty(&wqe->wait.entry)) {
		__add_wait_queue(&wq->hash->wait, &wqe->wait);
		if (!test_bit(hash, &wq->hash->map)) {
			__set_current_state(TASK_RUNNING);
			list_del_init(&wqe->wait.entry);
		}
	}
	spin_unlock_irq(&wq->hash->wait.lock);
}",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_synth_filter_init(SynthFilterContext *c)

{

    c->synth_filter_float = synth_filter_float;



    if (ARCH_ARM) ff_synth_filter_init_arm(c);

    if (ARCH_X86) ff_synth_filter_init_x86(c);

}
",0
Detect whether the following code contains vulnerabilities.,"    const CImg<T>& operator()(const unsigned int pos) const {
      return const_cast<CImgList<T>*>(this)->operator()(pos);
    }",0
Detect whether the following code contains vulnerabilities.,"static int rb_head_page_replace(struct buffer_page *old,
				struct buffer_page *new)
{
	unsigned long *ptr = (unsigned long *)&old->list.prev->next;
	unsigned long val;
	unsigned long ret;

	val = *ptr & ~RB_FLAG_MASK;
	val |= RB_PAGE_HEAD;

	ret = cmpxchg(ptr, val, (unsigned long)&new->list);

	return ret == val;
}",0
Detect whether the following code contains vulnerabilities.,"    template<typename to>
    float* _object3dtoCImg3d(const CImg<to>& opacities, float *ptrd) const {
      const to *ptro = opacities._data;
      cimg_foroff(opacities,o) *(ptrd++) = (float)*(ptro++);
      return ptrd;",0
Detect whether the following code contains vulnerabilities.,"irc_server_msgq_add_buffer (struct t_irc_server *server, const char *buffer)
{
    char *pos_cr, *pos_lf;

    while (buffer[0])
    {
        pos_cr = strchr (buffer, '\r');
        pos_lf = strchr (buffer, '\n');

        if (!pos_cr && !pos_lf)
        {
            /* no CR/LF found => add to unterminated and return */
            irc_server_msgq_add_unterminated (server, buffer);
            return;
        }

        if (pos_cr && ((!pos_lf) || (pos_lf > pos_cr)))
        {
            /* found '\r' first => ignore this char */
            pos_cr[0] = '\0';
            irc_server_msgq_add_unterminated (server, buffer);
            buffer = pos_cr + 1;
        }
        else
        {
            /* found: '\n' first => terminate message */
            pos_lf[0] = '\0';
            irc_server_msgq_add_msg (server, buffer);
            buffer = pos_lf + 1;
        }
    }
}",0
Detect whether the following code contains vulnerabilities.,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",0
Detect whether the following code contains vulnerabilities.,"static void test_tco2_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = ""-watchdog-action none"";

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(true);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC * 2);



    val = qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS);

    ret = val & (TCO_SECOND_TO_STS | TCO_BOOT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO2_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO2_STS), ==, 0);

    qtest_end();

}
",0
Detect whether the following code contains vulnerabilities.,"smtp_proceed_noop(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""250 %s Ok"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
}",0
Detect whether the following code contains vulnerabilities.,"static int kvm_iommu_unmap_memslots(struct kvm *kvm)
{
	int idx;
	struct kvm_memslots *slots;
	struct kvm_memory_slot *memslot;

	idx = srcu_read_lock(&kvm->srcu);
	slots = kvm_memslots(kvm);

	kvm_for_each_memslot(memslot, slots)
		kvm_iommu_put_pages(kvm, memslot->base_gfn, memslot->npages);

	srcu_read_unlock(&kvm->srcu, idx);

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t m5208_sys_read(void *opaque, target_phys_addr_t addr,

                               unsigned size)

{

    switch (addr) {

    case 0x110: /* SDCS0 */

        {

            int n;

            for (n = 0; n < 32; n++) {

                if (ram_size < (2u << n))

                    break;

            }

            return (n - 1)  | 0x40000000;

        }

    case 0x114: /* SDCS1 */

        return 0;



    default:

        hw_error(""m5208_sys_read: Bad offset 0x%x\n"", (int)addr);

        return 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
    int ret;
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, ""inflate: allocated\n""));
    strm->state = (struct internal_state FAR *)state;
    state->window = Z_NULL;
    ret = inflateReset2(strm, windowBits);
    if (ret != Z_OK) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
    }
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"void CL_StopVideo_f( void )
{
  CL_CloseAVI( );
}",0
Detect whether the following code contains vulnerabilities.,"static void dmg_close(BlockDriverState *bs)

{

    BDRVDMGState *s = bs->opaque;

    close(s->fd);

    if(s->n_chunks>0) {

	free(s->types);

	free(s->offsets);

	free(s->lengths);

	free(s->sectors);

	free(s->sectorcounts);

    }

    free(s->compressed_chunk);

    free(s->uncompressed_chunk);

    inflateEnd(&s->zstream);

}
",0
Detect whether the following code contains vulnerabilities.,"static void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	dt->size = svm->vmcb->save.idtr.limit;
	dt->address = svm->vmcb->save.idtr.base;
}",0
Detect whether the following code contains vulnerabilities.,"std::unique_ptr<HttpResponse> HttpConnection::receiveResponse()
{
  if (outstandingHttpRequests_.empty()) {
    throw DL_ABORT_EX(EX_NO_HTTP_REQUEST_ENTRY_FOUND);
  }
  if (socketRecvBuffer_->bufferEmpty()) {
    if (socketRecvBuffer_->recv() == 0 && !socket_->wantRead() &&
        !socket_->wantWrite()) {
      throw DL_RETRY_EX(EX_GOT_EOF);
    }
  }

  const auto& proc = outstandingHttpRequests_.front()->getHttpHeaderProcessor();
  if (proc->parse(socketRecvBuffer_->getBuffer(),
                  socketRecvBuffer_->getBufferLength())) {
    A2_LOG_INFO(
        fmt(MSG_RECEIVE_RESPONSE, cuid_, proc->getHeaderString().c_str()));
    auto result = proc->getResult();
    if (result->getStatusCode() / 100 == 1) {
      socketRecvBuffer_->drain(proc->getLastBytesProcessed());
      outstandingHttpRequests_.front()->resetHttpHeaderProcessor();
      return nullptr;
    }

    auto httpResponse = make_unique<HttpResponse>();
    httpResponse->setCuid(cuid_);
    httpResponse->setHttpHeader(std::move(result));
    httpResponse->setHttpRequest(
        outstandingHttpRequests_.front()->popHttpRequest());
    socketRecvBuffer_->drain(proc->getLastBytesProcessed());
    outstandingHttpRequests_.pop_front();
    return httpResponse;
  }

  socketRecvBuffer_->drain(proc->getLastBytesProcessed());
  return nullptr;
}",1
Detect whether the following code contains vulnerabilities.,"static int s390_virtio_blk_init(VirtIOS390Device *s390_dev)

{

    VirtIOBlkS390 *dev = VIRTIO_BLK_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);

    virtio_blk_set_conf(vdev, &(dev->blk));

    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }

    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",1
Detect whether the following code contains vulnerabilities.,"  bool stmt_create_routine_start(const DDL_options_st &options)
  {
    create_info.set(options);
    return main_select_push() || check_create_options(options);
  }",0
Detect whether the following code contains vulnerabilities.,"add_one_chunk(png_bytep list, unsigned int count, png_const_bytep add, int keep)
{
   unsigned int i;

   /* Utility function: update the 'keep' state of a chunk if it is already in
    * the list, otherwise add it to the list.
    */
   for (i=0; i<count; ++i, list += 5)
   {
      if (memcmp(list, add, 4) == 0)
      {
         list[4] = (png_byte)keep;

         return count;
      }
   }

   if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)
   {
      ++count;
      memcpy(list, add, 4);
      list[4] = (png_byte)keep;
   }

   return count;
}",0
Detect whether the following code contains vulnerabilities.,"static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic,

                                const uint8_t *src, int src_size)

{

    int h, w;

    uint8_t *Y, *U, *V;

    int ret;



    if (src_size < avctx->width * avctx->height * 3) {

        av_log(avctx, AV_LOG_ERROR, ""packet too small\n"");

        return AVERROR_INVALIDDATA;

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;

    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    Y = pic->data[0];

    U = pic->data[1];

    V = pic->data[2];

    for (h = 0; h < avctx->height; h++) {

        for (w = 0; w < avctx->width; w++) {

            Y[w] = *src++;

            U[w] = *src++ ^ 0x80;

            V[w] = *src++ ^ 0x80;

        }

        Y += pic->linesize[0];

        U += pic->linesize[1];

        V += pic->linesize[2];

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"EncodeTimezone(char *str, int tz, int style)
{
	int			hour,
				min,
				sec;

	sec = abs(tz);
	min = sec / SECS_PER_MINUTE;
	sec -= min * SECS_PER_MINUTE;
	hour = min / MINS_PER_HOUR;
	min -= hour * MINS_PER_HOUR;

	str += strlen(str);
	/* TZ is negated compared to sign we wish to display ... */
	*str++ = (tz <= 0 ? '+' : '-');

	if (sec != 0)
		sprintf(str, ""%02d:%02d:%02d"", hour, min, sec);
	else if (min != 0 || style == USE_XSD_DATES)
		sprintf(str, ""%02d:%02d"", hour, min);
	else
		sprintf(str, ""%02d"", hour);
}",0
Detect whether the following code contains vulnerabilities.,"static inline int onenand_load_main(OneNANDState *s, int sec, int secn,

                void *dest)

{

    if (s->blk_cur) {

        return blk_read(s->blk_cur, sec, dest, secn) < 0;

    } else if (sec + secn > s->secs_cur) {

        return 1;

    }



    memcpy(dest, s->current + (sec << 9), secn << 9);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
		     rpmpsm psm, int nodigest, int *setmeta,
		     int * firsthardlink)
{
    int rc = 0;
    int numHardlinks = rpmfiFNlink(fi);

    if (numHardlinks > 1) {
	/* Create first hardlinked file empty */
	if (*firsthardlink < 0) {
	    *firsthardlink = rpmfiFX(fi);
	    rc = expandRegular(fi, dest, psm, nodigest, 1);
	} else {
	    /* Create hard links for others */
	    char *fn = rpmfilesFN(files, *firsthardlink);
	    rc = link(fn, dest);
	    if (rc < 0) {
		rc = RPMERR_LINK_FAILED;
	    }
	    free(fn);
	}
    }
    /* Write normal files or fill the last hardlinked (already
       existing) file with content */
    if (numHardlinks<=1) {
	if (!rc)
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
    } else if (rpmfiArchiveHasContent(fi)) {
	if (!rc)
	    rc = expandRegular(fi, dest, psm, nodigest, 0);
	*firsthardlink = -1;
    } else {
	*setmeta = 0;
    }

    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"stream_init(stream_t *stream, get_func get, void *data)
{
    stream->get = get;
    stream->data = data;
    stream->buffer[0] = '\0';
    stream->buffer_pos = 0;

    stream->state = STREAM_STATE_OK;
    stream->line = 1;
    stream->column = 0;
    stream->position = 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)
{
	const struct sched_class *class;

	if (p->sched_class == rq->curr->sched_class) {
		rq->curr->sched_class->check_preempt_curr(rq, p, flags);
	} else {
		for_each_class(class) {
			if (class == rq->curr->sched_class)
				break;
			if (class == p->sched_class) {
				resched_task(rq->curr);
				break;
			}
		}
	}

	/*
	 * A queue event has occurred, and we're going to schedule.  In
	 * this case, we can save a useless back to back clock update.
	 */
	if (test_tsk_need_resched(rq->curr))
		rq->skip_clock_update = 1;
}",1
Detect whether the following code contains vulnerabilities.,"int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    req_wrap_obj->Set(env->context(),
                      env->handle_string(),
                      send_handle_obj).Check();
  }

  StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj);
  SetWriteResult(res);

  return res.err;
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(snmp_get_valueretrieval)
{
	if (zend_parse_parameters_none() == FAILURE) {
		RETURN_FALSE;
	}

	RETURN_LONG(SNMP_G(valueretrieval));
}",0
Detect whether the following code contains vulnerabilities.,"  void from_str(const std::string& str) {
    size_t pos = str.find('$');
    if (pos != std::string::npos) {
      tenant = str.substr(0, pos);
      id = str.substr(pos + 1);
    } else {
      tenant.clear();
      id = str;
    }
  }",0
Detect whether the following code contains vulnerabilities.,"GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)
{
	git_buf *reserved = git_repository__reserved_names_win32;
	size_t reserved_len = git_repository__reserved_names_win32_len;
	size_t start = 0, i;

	if (repo)
		git_repository__reserved_names(&reserved, &reserved_len, repo, true);

	for (i = 0; i < reserved_len; i++) {
		git_buf *r = &reserved[i];

		if (len >= r->size &&
			strncasecmp(path, r->ptr, r->size) == 0) {
			start = r->size;
			break;
		}
	}

	if (!start)
		return true;

	/* Reject paths like "".git\"" */
	if (path[start] == '\\')
		return false;

	/* Reject paths like '.git ' or '.git.' */
	for (i = start; i < len; i++) {
		if (path[i] != ' ' && path[i] != '.')
			return true;
	}

	return false;
}",1
Detect whether the following code contains vulnerabilities.,"static void adb_mouse_reset(DeviceState *dev)

{

    ADBDevice *d = ADB_DEVICE(dev);

    MouseState *s = ADB_MOUSE(dev);



    d->handler = 2;

    d->devaddr = ADB_DEVID_MOUSE;

    s->last_buttons_state = s->buttons_state = 0;

    s->dx = s->dy = s->dz = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int fuse_open_common(struct inode *inode, struct file *file, bool isdir)
{
	struct fuse_conn *fc = get_fuse_conn(inode);
	int err;

	/* VFS checks this, but only _after_ ->open() */
	if (file->f_flags & O_DIRECT)
		return -EINVAL;

	err = generic_file_open(inode, file);
	if (err)
		return err;

	err = fuse_do_open(fc, get_node_id(inode), file, isdir);
	if (err)
		return err;

	fuse_finish_open(inode, file);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"bool SNC_io_parser<EW>::
read_volume(Volume_handle ch) {

  bool OK = true;
  int index;
  char cc;

  in >> index;
  OK = OK && test_string(""{"");

  in >> cc;
  while(isdigit(cc)) {
    in.putback(cc);
    in >> index;
    ch->shell_entry_objects().push_back(make_object(SFace_of[index]));
    in >> cc;
  }
  in >> ch->mark();

  return OK;
}",1
Detect whether the following code contains vulnerabilities.,"static char *ask_new_shell(char *question, char *oldshell)
{
	int len;
	char *ans = NULL;
#ifdef HAVE_LIBREADLINE
	rl_attempted_completion_function = shell_name_completion;
#else
	size_t dummy = 0;
#endif
	if (!oldshell)
		oldshell = """";
	printf(""%s [%s]:"", question, oldshell);
#ifdef HAVE_LIBREADLINE
	if ((ans = readline("" "")) == NULL)
#else
	putchar(' ');
	if (getline(&ans, &dummy, stdin) < 0)
#endif
		return NULL;
	/* remove the newline at the end of ans. */
	ltrim_whitespace((unsigned char *) ans);
	len = rtrim_whitespace((unsigned char *) ans);
	if (len == 0)
		return NULL;
	return ans;
}",1
Detect whether the following code contains vulnerabilities.,"int qcrypto_pbkdf2(QCryptoHashAlgorithm hash G_GNUC_UNUSED,

                   const uint8_t *key G_GNUC_UNUSED,

                   size_t nkey G_GNUC_UNUSED,

                   const uint8_t *salt G_GNUC_UNUSED,

                   size_t nsalt G_GNUC_UNUSED,

                   unsigned int iterations G_GNUC_UNUSED,

                   uint8_t *out G_GNUC_UNUSED,

                   size_t nout G_GNUC_UNUSED,

                   Error **errp)

{

    error_setg_errno(errp, ENOSYS,

                     ""No crypto library supporting PBKDF in this build"");

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *skb_out;
	struct sadb_msg *hdr;

	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_out)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
	hdr->sadb_msg_pid = c->portid;
	hdr->sadb_msg_version = PF_KEY_V2;
	hdr->sadb_msg_errno = (uint8_t) 0;
	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
	return 0;

}",1
Detect whether the following code contains vulnerabilities.,"int udf_add_aext(struct inode *inode, struct extent_position *epos,
		 struct kernel_lb_addr *eloc, uint32_t elen, int inc)
{
	int adsize;
	struct super_block *sb = inode->i_sb;

	if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_SHORT)
		adsize = sizeof(struct short_ad);
	else if (UDF_I(inode)->i_alloc_type == ICBTAG_FLAG_AD_LONG)
		adsize = sizeof(struct long_ad);
	else
		return -EIO;

	if (epos->offset + (2 * adsize) > sb->s_blocksize) {
		int err;
		udf_pblk_t new_block;

		new_block = udf_new_block(sb, NULL,
					  epos->block.partitionReferenceNum,
					  epos->block.logicalBlockNum, &err);
		if (!new_block)
			return -ENOSPC;

		err = udf_setup_indirect_aext(inode, new_block, epos);
		if (err)
			return err;
	}

	return __udf_add_aext(inode, epos, eloc, elen, inc);
}",0
Detect whether the following code contains vulnerabilities.,"QEMUPutMouseEntry *qemu_add_mouse_event_handler(QEMUPutMouseEvent *func,

                                                void *opaque, int absolute,

                                                const char *name)

{

    QEMUPutMouseEntry *s;



    s = g_malloc0(sizeof(QEMUPutMouseEntry));



    s->qemu_put_mouse_event = func;

    s->qemu_put_mouse_event_opaque = opaque;

    s->qemu_put_mouse_event_absolute = absolute;



    s->h.name = name;

    s->h.mask = INPUT_EVENT_MASK_BTN |

        (absolute ? INPUT_EVENT_MASK_ABS : INPUT_EVENT_MASK_REL);

    s->h.event = legacy_mouse_event;

    s->h.sync = legacy_mouse_sync;

    s->s = qemu_input_handler_register((DeviceState *)s,

                                       &s->h);



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"void cgsleep_us_r(cgtimer_t *ts_start, int64_t us)
{
	struct timespec ts_diff;

	us_to_timespec(&ts_diff, us);
	cgsleep_spec(&ts_diff, ts_start);
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t bonito_spciconf_readb(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t pciaddr;

    uint16_t status;



    DPRINTF(""bonito_spciconf_readb ""TARGET_FMT_plx""  \n"", addr);

    pciaddr = bonito_sbridge_pciaddr(s, addr);



    if (pciaddr == 0xffffffff) {

        return 0xff;

    }



    /* set the pci address in s->config_reg */

    s->pcihost->config_reg = (pciaddr) | (1u << 31);



    /* clear PCI_STATUS_REC_MASTER_ABORT and PCI_STATUS_REC_TARGET_ABORT */

    status = pci_get_word(s->dev.config + PCI_STATUS);

    status &= ~(PCI_STATUS_REC_MASTER_ABORT | PCI_STATUS_REC_TARGET_ABORT);

    pci_set_word(s->dev.config + PCI_STATUS, status);



    return pci_data_read(s->pcihost->bus, s->pcihost->config_reg, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static bool balloon_stats_supported(const VirtIOBalloon *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    return vdev->guest_features & (1 << VIRTIO_BALLOON_F_STATS_VQ);

}
",0
Detect whether the following code contains vulnerabilities.,"void ACSequentialScan::Flush(bool)
{
#if ACCUSOFT_CODE
  int i;
  
  m_Coder.Flush();

  for(i = 0;i < m_ucCount;i++) {
    m_lDC[i]    = 0;
    m_lDiff[i]  = 0;
  }
  for(i = 0;i < 4;i++) {
    m_Context[i].Init();
  }
  
  m_Coder.OpenForWrite(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());
#endif
}",0
Detect whether the following code contains vulnerabilities.,"  void setupHCWithUnhealthyThreshold(int value) {
    auto config = createGrpcHealthCheckConfig();
    config.mutable_unhealthy_threshold()->set_value(value);
    allocHealthChecker(config);
    addCompletionCallback();
  }",0
Detect whether the following code contains vulnerabilities.,"void thread_pool_submit(ThreadPool *pool, ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(pool, func, arg, NULL, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void strstore(char **str, const char *newstr)
{
  if(*str)
    free(*str);
  *str = strdup(newstr);
}",0
Detect whether the following code contains vulnerabilities.,"regional_create_custom(size_t size)
{
	struct regional* r = (struct regional*)malloc(size);
	log_assert(sizeof(struct regional) <= size);
	if(!r) return NULL;
	r->first_size = size;
	regional_init(r);
	return r;
}",1
Detect whether the following code contains vulnerabilities.,"static void raw_close(BlockDriverState *bs)

{

}
",0
Detect whether the following code contains vulnerabilities.,"static enum print_line_t print_hex_fmt(struct trace_iterator *iter)
{
	struct trace_array *tr = iter->tr;
	struct trace_seq *s = &iter->seq;
	unsigned char newline = '\n';
	struct trace_entry *entry;
	struct trace_event *event;

	entry = iter->ent;

	if (tr->trace_flags & TRACE_ITER_CONTEXT_INFO) {
		SEQ_PUT_HEX_FIELD(s, entry->pid);
		SEQ_PUT_HEX_FIELD(s, iter->cpu);
		SEQ_PUT_HEX_FIELD(s, iter->ts);
		if (trace_seq_has_overflowed(s))
			return TRACE_TYPE_PARTIAL_LINE;
	}

	event = ftrace_find_event(entry->type);
	if (event) {
		enum print_line_t ret = event->funcs->hex(iter, 0, event);
		if (ret != TRACE_TYPE_HANDLED)
			return ret;
	}

	SEQ_PUT_FIELD(s, newline);

	return trace_handle_return(s);
}",0
Detect whether the following code contains vulnerabilities.,"static int mem_cgroup_swappiness_write(struct cgroup *cgrp, struct cftype *cft,
				       u64 val)
{
	struct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);
	struct mem_cgroup *parent;

	if (val > 100)
		return -EINVAL;

	if (cgrp->parent == NULL)
		return -EINVAL;

	parent = mem_cgroup_from_cont(cgrp->parent);

	cgroup_lock();

	/* If under hierarchy, only empty-root can set this value */
	if ((parent->use_hierarchy) ||
	    (memcg->use_hierarchy && !list_empty(&cgrp->children))) {
		cgroup_unlock();
		return -EINVAL;
	}

	memcg->swappiness = val;

	cgroup_unlock();

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void __exit pf_exit(void)
{
	struct pf_unit *pf;
	int unit;
	unregister_blkdev(major, name);
	for (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {
		if (pf->present)
			del_gendisk(pf->disk);

		blk_cleanup_queue(pf->disk->queue);
		blk_mq_free_tag_set(&pf->tag_set);
		put_disk(pf->disk);

		if (pf->present)
			pi_release(pf->pi);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static int tcp_get_msgfd(CharDriverState *chr)

{

    TCPCharDriver *s = chr->opaque;



    return s->msgfd;

}
",1
Detect whether the following code contains vulnerabilities.,"static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
{
	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
	shm_rmid(ns, shp);
	shm_unlock(shp);
	if (!is_file_hugepages(shp->shm_file))
		shmem_lock(shp->shm_file, 0, shp->mlock_user);
	else if (shp->mlock_user)
		user_shm_unlock(file_inode(shp->shm_file)->i_size,
						shp->mlock_user);
	fput (shp->shm_file);
	ipc_rcu_putref(shp, shm_rcu_free);
}",1
Detect whether the following code contains vulnerabilities.,"static void filter_samples(AVFilterLink *inlink, AVFilterBufferRef *samplesref)

{

    AVFilterContext *ctx = inlink->dst;

    int i;



    for (i = 0; i < ctx->nb_outputs; i++)

        ff_filter_samples(inlink->dst->outputs[i],

                          avfilter_ref_buffer(samplesref, ~AV_PERM_WRITE));


}",1
Detect whether the following code contains vulnerabilities.,"X509 *d2i_X509_AUX(X509 **a, const unsigned char **pp, long length)
{
    const unsigned char *q;
    X509 *ret;
    /* Save start position */
    q = *pp;
    ret = d2i_X509(a, pp, length);
    /* If certificate unreadable then forget it */
    if (!ret)
        return NULL;
    /* update length */
    length -= *pp - q;
    if (!length)
        return ret;
    if (!d2i_X509_CERT_AUX(&ret->aux, pp, length))
        goto err;
    return ret;
 err:
    X509_free(ret);
    return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"int64_t xbzrle_cache_resize(int64_t new_size)

{

    if (new_size < TARGET_PAGE_SIZE) {

        return -1;

    }



    if (XBZRLE.cache != NULL) {

        return cache_resize(XBZRLE.cache, new_size / TARGET_PAGE_SIZE) *

            TARGET_PAGE_SIZE;

    }

    return pow2floor(new_size);

}
",1
Detect whether the following code contains vulnerabilities.,"e1000_can_receive(NetClientState *nc)

{

    E1000State *s = qemu_get_nic_opaque(nc);



    return (s->mac_reg[RCTL] & E1000_RCTL_EN) && e1000_has_rxbufs(s, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"int sqlite3ExprIsVector(Expr *pExpr){
  return sqlite3ExprVectorSize(pExpr)>1;
}",0
Detect whether the following code contains vulnerabilities.,"static int decode_init_thread_copy(AVCodecContext *avctx)

{

    H264Context *h = avctx->priv_data;



    if (!avctx->internal->is_copy)

        return 0;

    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));

    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));




    h->rbsp_buffer[0]      = NULL;

    h->rbsp_buffer[1]      = NULL;

    h->rbsp_buffer_size[0] = 0;

    h->rbsp_buffer_size[1] = 0;

    h->context_initialized = 0;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static int matroska_deliver_packet(MatroskaDemuxContext *matroska,

                                   AVPacket *pkt)

{

    if (matroska->num_packets > 0) {

        memcpy(pkt, matroska->packets[0], sizeof(AVPacket));

        av_free(matroska->packets[0]);

        if (matroska->num_packets > 1) {

            memmove(&matroska->packets[0], &matroska->packets[1],

                    (matroska->num_packets - 1) * sizeof(AVPacket *));

            matroska->packets =

                av_realloc(matroska->packets, (matroska->num_packets - 1) *

                           sizeof(AVPacket *));

        } else {

            av_freep(&matroska->packets);

        }

        matroska->num_packets--;

        return 0;

    }



    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"      static double mp_self_add(_cimg_math_parser& mp) {
        return _mp_arg(1)+=_mp_arg(2);
      }",0
Detect whether the following code contains vulnerabilities.,"flatpak_load_override_keyfile (const char *app_id, gboolean user, GError **error)
{
  g_autofree char *metadata_contents = NULL;
  gsize metadata_size;
  g_autoptr(GKeyFile) metakey = g_key_file_new ();
  g_autoptr(FlatpakDir) dir = NULL;

  dir = user ? flatpak_dir_get_user () : flatpak_dir_get_system_default ();

  metadata_contents = flatpak_dir_load_override (dir, app_id, &metadata_size, error);
  if (metadata_contents == NULL)
    return NULL;

  if (!g_key_file_load_from_data (metakey,
                                  metadata_contents,
                                  metadata_size,
                                  0, error))
    return NULL;

  return g_steal_pointer (&metakey);
}",0
Detect whether the following code contains vulnerabilities.,"mesh_is_udp(struct mesh_reply const* r) {
	return r->query_reply.c->type == comm_udp;
}",0
Detect whether the following code contains vulnerabilities.,"static js_Ast *arrayliteral(js_State *J)
{
	js_Ast *head, *tail;
	if (J->lookahead == ']')
		return NULL;
	head = tail = LIST(arrayelement(J));
	while (jsP_accept(J, ',')) {
		if (J->lookahead != ']')
			tail = tail->b = LIST(arrayelement(J));
	}
	return jsP_list(head);
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t driver_override_store(struct device *_dev,
				     struct device_attribute *attr,
				     const char *buf, size_t count)
{
	struct amba_device *dev = to_amba_device(_dev);
	char *driver_override, *old = dev->driver_override, *cp;

	/* We need to keep extra room for a newline */
	if (count >= (PAGE_SIZE - 1))
		return -EINVAL;

	driver_override = kstrndup(buf, count, GFP_KERNEL);
	if (!driver_override)
		return -ENOMEM;

	cp = strchr(driver_override, '\n');
	if (cp)
		*cp = '\0';

	if (strlen(driver_override)) {
		dev->driver_override = driver_override;
	} else {
	       kfree(driver_override);
	       dev->driver_override = NULL;
	}

	kfree(old);

	return count;
}",1
Detect whether the following code contains vulnerabilities.,"static void vfio_bar_quirk_teardown(VFIOPCIDevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    while (!QLIST_EMPTY(&bar->quirks)) {

        VFIOQuirk *quirk = QLIST_FIRST(&bar->quirks);

        memory_region_del_subregion(&bar->region.mem, &quirk->mem);

        object_unparent(OBJECT(&quirk->mem));

        QLIST_REMOVE(quirk, next);

        g_free(quirk);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"UniqueChars normalize_header_name(JSContext *cx, MutableHandleValue name_val, size_t *name_len,
                                  const char *fun_name) {
  RootedString name_str(cx, JS::ToString(cx, name_val));
  if (!name_str)
    return nullptr;

  size_t len;
  UniqueChars name = encode(cx, name_str, &len);
  if (!name)
    return nullptr;

  if (len == 0) {
    JS_ReportErrorASCII(cx, ""%s: Header name can't be empty"", fun_name);
    return nullptr;
  }

  bool changed = false;

  char *name_chars = name.get();
  for (size_t i = 0; i < len; i++) {
    unsigned char ch = name_chars[i];
    if (ch > 127 || !VALID_NAME_CHARS[ch]) {
      JS_ReportErrorUTF8(cx, ""%s: Invalid header name '%s'"", fun_name, name_chars);
      return nullptr;
    }

    if (ch >= 'A' && ch <= 'Z') {
      name_chars[i] = ch - 'A' + 'a';
      changed = true;
    }
  }

  if (changed) {
    name_str = JS_NewStringCopyN(cx, name_chars, len);
    if (!name_str)
      return nullptr;
  }

  name_val.setString(name_str);
  *name_len = len;
  return name;
}",0
Detect whether the following code contains vulnerabilities.,"static void test_visitor_in_intList(TestInputVisitorData *data,

                                    const void *unused)

{

    int64_t value[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20};

    int16List *res = NULL, *tmp;

    Error *err = NULL;

    Visitor *v;

    int i = 0;



    v = visitor_input_test_init(data, ""1,2,0,2-4,20,5-9,1-8"");



    visit_type_int16List(v, NULL, &res, &error_abort);

    tmp = res;

    while (i < sizeof(value) / sizeof(value[0])) {

        g_assert(tmp);

        g_assert_cmpint(tmp->value, ==, value[i++]);

        tmp = tmp->next;

    }

    g_assert(!tmp);



    tmp = res;

    while (tmp) {

        res = res->next;

        g_free(tmp);

        tmp = res;

    }



    visitor_input_teardown(data, unused);



    v = visitor_input_test_init(data, ""not an int list"");



    visit_type_int16List(v, NULL, &res, &err);

    /* FIXME fix the visitor, then error_free_or_abort(&err) here */

}
",1
Detect whether the following code contains vulnerabilities.,"static int stdio_pclose(void *opaque)

{

    QEMUFileStdio *s = opaque;

    int ret;

    ret = pclose(s->stdio_file);

    if (ret == -1) {

        ret = -errno;

    } else if (!WIFEXITED(ret) || WEXITSTATUS(ret) != 0) {

        /* close succeeded, but non-zero exit code: */

        ret = -EIO; /* fake errno value */

    }

    g_free(s);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"unsigned paravirt_patch_call(void *insnbuf,
			     const void *target, u16 tgt_clobbers,
			     unsigned long addr, u16 site_clobbers,
			     unsigned len)
{
	struct branch *b = insnbuf;
	unsigned long delta = (unsigned long)target - (addr+5);

	if (tgt_clobbers & ~site_clobbers)
		return len;	/* target would clobber too much for this site */
	if (len < 5)
		return len;	/* call too long for patch site */

	b->opcode = 0xe8; /* call */
	b->delta = delta;
	BUILD_BUG_ON(sizeof(*b) != 5);

	return 5;
}",1
Detect whether the following code contains vulnerabilities.,"extract_header_length(uint16_t fc)
{
	int len = 0;

	switch ((fc >> 10) & 0x3) {
	case 0x00:
		if (fc & (1 << 6)) /* intra-PAN with none dest addr */
			return -1;
		break;
	case 0x01:
		return -1;
	case 0x02:
		len += 4;
		break;
	case 0x03:
		len += 10;
		break;
	}

	switch ((fc >> 14) & 0x3) {
	case 0x00:
		break;
	case 0x01:
		return -1;
	case 0x02:
		len += 4;
		break;
	case 0x03:
		len += 10;
		break;
	}

	if (fc & (1 << 6)) {
		if (len < 2)
			return -1;
		len -= 2;
	}

	return len;
}",1
Detect whether the following code contains vulnerabilities.,"static void audio_init (PCIBus *pci_bus)

{

    struct soundhw *c;

    int audio_enabled = 0;



    for (c = soundhw; !audio_enabled && c->name; ++c) {

        audio_enabled = c->enabled;

    }



    if (audio_enabled) {

        AudioState *s;



        s = AUD_init ();

        if (s) {

            for (c = soundhw; c->name; ++c) {

                if (c->enabled)

                    c->init.init_pci (pci_bus, s);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"  void Compute(OpKernelContext* ctx) override {
    const Tensor& handle = ctx->input(0);
    const string& name = handle.scalar<tstring>()();
    OP_REQUIRES_OK(ctx, ctx->session_state()->DeleteTensor(name));
  }",1
Detect whether the following code contains vulnerabilities.,"static int selinux_quotactl(int cmds, int type, int id, struct super_block *sb)
{
	const struct cred *cred = current_cred();
	int rc = 0;

	if (!sb)
		return 0;

	switch (cmds) {
	case Q_SYNC:
	case Q_QUOTAON:
	case Q_QUOTAOFF:
	case Q_SETINFO:
	case Q_SETQUOTA:
		rc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAMOD, NULL);
		break;
	case Q_GETFMT:
	case Q_GETINFO:
	case Q_GETQUOTA:
		rc = superblock_has_perm(cred, sb, FILESYSTEM__QUOTAGET, NULL);
		break;
	default:
		rc = 0;  /* let the kernel handle invalid cmds */
		break;
	}
	return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static void br_multicast_start_querier(struct net_bridge *br)
{
	struct net_bridge_port *port;

	br_multicast_open(br);

	list_for_each_entry(port, &br->port_list, list) {
		if (port->state == BR_STATE_DISABLED ||
		    port->state == BR_STATE_BLOCKING)
			continue;

		__br_multicast_enable_port(port);
	}
}",0
Detect whether the following code contains vulnerabilities.,"static void nf_ct_frag6_evictor(void)
{
	local_bh_disable();
	inet_frag_evictor(&nf_init_frags, &nf_frags);
	local_bh_enable();
}",0
Detect whether the following code contains vulnerabilities.,"static int compute_send_delay(HTTPContext *c)

{

    int datarate = 8 * get_longterm_datarate(&c->datarate, c->data_count); 



    if (datarate > c->stream->bandwidth * 2000) {

        return 1000;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void destroy_super(struct super_block *s)
{
	int i;
	list_lru_destroy(&s->s_dentry_lru);
	list_lru_destroy(&s->s_inode_lru);
#ifdef CONFIG_SMP
	free_percpu(s->s_files);
#endif
	for (i = 0; i < SB_FREEZE_LEVELS; i++)
		percpu_counter_destroy(&s->s_writers.counter[i]);
	security_sb_free(s);
	WARN_ON(!list_empty(&s->s_mounts));
	kfree(s->s_subtype);
	kfree(s->s_options);
	kfree_rcu(s, rcu);
}",1
Detect whether the following code contains vulnerabilities.,"static inline void net_dmaengine_put(void)
{
}",1
Detect whether the following code contains vulnerabilities.,"snmp_reset_var_types(netsnmp_variable_list * vbl, u_char new_type)
{
    while (vbl) {
        snmp_set_var_typed_value(vbl, new_type, NULL, 0);
        vbl = vbl->next_variable;
    }
}",0
Detect whether the following code contains vulnerabilities.,"synthesize_aaaa(const uint8_t prefix_addr[], size_t prefix_addr_len,
	int prefix_net, const uint8_t a[], size_t a_len, uint8_t aaaa[],
	size_t aaaa_len)
{
    size_t i;
    int pos;
    log_assert(prefix_addr_len == 16 && a_len == 4 && aaaa_len == 16);
    log_assert(prefix_net == 32 || prefix_net == 40 || prefix_net == 48 ||
        prefix_net == 56 || prefix_net == 64 || prefix_net == 96);
    (void)prefix_addr_len; (void)a_len; (void)aaaa_len;
    memcpy(aaaa, prefix_addr, 16);
    for(i = 0, pos = prefix_net / 8; i < a_len; i++, pos++) {
        if(pos == 8)
            aaaa[pos++] = 0;
        aaaa[pos] = a[i];
    }
}",0
Detect whether the following code contains vulnerabilities.,"GC_API GC_ATTR_MALLOC void * GC_CALL GC_debug_gcj_malloc(size_t lb,
                void * ptr_to_struct_containing_descr, GC_EXTRA_PARAMS)
{
    void * result;
    DCL_LOCK_STATE;

    /* We're careful to avoid extra calls, which could          */
    /* confuse the backtrace.                                   */
    LOCK();
    maybe_finalize();
    result = GC_generic_malloc_inner(lb + DEBUG_BYTES, GC_gcj_debug_kind);
    if (result == 0) {
        GC_oom_func oom_fn = GC_oom_fn;
        UNLOCK();
        GC_err_printf(""GC_debug_gcj_malloc(%lu, %p) returning NULL (%s:%d)\n"",
                (unsigned long)lb, ptr_to_struct_containing_descr, s, i);
        return((*oom_fn)(lb));
    }
    *((void **)((ptr_t)result + sizeof(oh))) = ptr_to_struct_containing_descr;
    UNLOCK();
    if (!GC_debugging_started) {
        GC_start_debugging();
    }
    ADD_CALL_CHAIN(result, ra);
    return (GC_store_debug_info(result, (word)lb, s, i));
}",1
Detect whether the following code contains vulnerabilities.,"int ssh_scp_response(ssh_scp scp, char **response){
	unsigned char code;
	int r;
	char msg[128];
	if(scp==NULL)
	    return SSH_ERROR;
	r=ssh_channel_read(scp->channel,&code,1,0);
	if(r == SSH_ERROR)
		return SSH_ERROR;
	if(code == 0)
		return 0;
	if(code > 2){
		ssh_set_error(scp->session,SSH_FATAL, ""SCP: invalid status code %ud received"", code);
		scp->state=SSH_SCP_ERROR;
		return SSH_ERROR;
	}
	r=ssh_scp_read_string(scp,msg,sizeof(msg));
	if(r==SSH_ERROR)
		return r;
	/* Warning */
	if(code == 1){
		ssh_set_error(scp->session,SSH_REQUEST_DENIED, ""SCP: Warning: status code 1 received: %s"", msg);
		SSH_LOG(SSH_LOG_RARE,""SCP: Warning: status code 1 received: %s"", msg);
		if(response)
			*response=strdup(msg);
		return 1;
	}
	if(code == 2){
		ssh_set_error(scp->session,SSH_FATAL, ""SCP: Error: status code 2 received: %s"", msg);
		if(response)
			*response=strdup(msg);
		return 2;
	}
	/* Not reached */
	return SSH_ERROR;
}",1
Detect whether the following code contains vulnerabilities.,"static int qxl_init_secondary(PCIDevice *dev)

{

    static int device_id = 1;

    PCIQXLDevice *qxl = DO_UPCAST(PCIQXLDevice, pci, dev);



    qxl->id = device_id++;

    qxl_init_ramsize(qxl, 16);

    memory_region_init_ram(&qxl->vga.vram, ""qxl.vgavram"", qxl->vga.vram_size);

    vmstate_register_ram(&qxl->vga.vram, &qxl->pci.qdev);

    qxl->vga.vram_ptr = memory_region_get_ram_ptr(&qxl->vga.vram);



    return qxl_init_common(qxl);

}
",1
Detect whether the following code contains vulnerabilities.,"R_API ut64 r_bin_java_get_main(RBinJavaObj *bin) {
	if (bin->main_code_attr) {
		return bin->main_code_attr->info.code_attr.code_offset + bin->loadaddr;
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void openpic_load_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_get_be32s(f, &q->queue[i]);



    qemu_get_sbe32s(f, &q->next);

    qemu_get_sbe32s(f, &q->priority);

}
",0
Detect whether the following code contains vulnerabilities.,static void etm_event_read(struct perf_event *event) {},0
Detect whether the following code contains vulnerabilities.,"void setDoNotValidateRouteConfig(
    envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm) {
  auto* route_config = hcm.mutable_route_config();
  route_config->mutable_validate_clusters()->set_value(false);
};",0
Detect whether the following code contains vulnerabilities.,"void vncws_tls_handshake_peek(void *opaque)

{

    VncState *vs = opaque;

    long ret;



    if (!vs->ws_tls.session) {

        char peek[4];

        ret = qemu_recv(vs->csock, peek, sizeof(peek), MSG_PEEK);

        if (ret && (strncmp(peek, ""\x16"", 1) == 0

                    || strncmp(peek, ""\x80"", 1) == 0)) {

            VNC_DEBUG(""TLS Websocket connection recognized"");

            vnc_tls_client_setup(vs, 1);

            vncws_start_tls_handshake(vs);

        } else {

            vncws_handshake_read(vs);

        }

    } else {

        qemu_set_fd_handler2(vs->csock, NULL, vncws_handshake_read, NULL, vs);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void blk_mq_rq_timed_out(struct request *req, bool reserved)
{
	struct blk_mq_ops *ops = req->q->mq_ops;
	enum blk_eh_timer_return ret = BLK_EH_RESET_TIMER;

	/*
	 * We know that complete is set at this point. If STARTED isn't set
	 * anymore, then the request isn't active and the ""timeout"" should
	 * just be ignored. This can happen due to the bitflag ordering.
	 * Timeout first checks if STARTED is set, and if it is, assumes
	 * the request is active. But if we race with completion, then
	 * we both flags will get cleared. So check here again, and ignore
	 * a timeout event with a request that isn't active.
	 */
	if (!test_bit(REQ_ATOM_STARTED, &req->atomic_flags))
		return;

	if (ops->timeout)
		ret = ops->timeout(req, reserved);

	switch (ret) {
	case BLK_EH_HANDLED:
		__blk_mq_complete_request(req);
		break;
	case BLK_EH_RESET_TIMER:
		blk_add_timer(req);
		blk_clear_rq_complete(req);
		break;
	case BLK_EH_NOT_HANDLED:
		break;
	default:
		printk(KERN_ERR ""block: bad eh return: %d\n"", ret);
		break;
	}
}",0
Detect whether the following code contains vulnerabilities.,"int32_t DecimalQuantity::getLowerDisplayMagnitude() const {
    // If this assertion fails, you need to call roundToInfinity() or some other rounding method.
    // See the comment in the header file explaining the ""isApproximate"" field.
    U_ASSERT(!isApproximate);

    int32_t magnitude = scale;
    int32_t result = (rReqPos < magnitude) ? rReqPos : (rOptPos > magnitude) ? rOptPos : magnitude;
    return result;
}",0
Detect whether the following code contains vulnerabilities.,"void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)
{
	WLog_DBG(TAG, ""%s (Len: %""PRIu16"" MaxLen: %""PRIu16"" BufferOffset: %""PRIu32"")"",
	         name, fields->Len, fields->MaxLen, fields->BufferOffset);

	if (fields->Len > 0)
		winpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);
}",1
Detect whether the following code contains vulnerabilities.,"R_API int r_sys_cmd_str_full(const char *cmd, const char *input, char **output, int *len, char **sterr) {
	return r_sys_cmd_str_full_w32 (cmd, input, output, len, sterr);
}",1
Detect whether the following code contains vulnerabilities.,"ff_lseg_merge(struct pnfs_layout_segment *new,
		struct pnfs_layout_segment *old)
{
	u64 new_end, old_end;

	if (test_bit(NFS_LSEG_LAYOUTRETURN, &old->pls_flags))
		return false;
	if (new->pls_range.iomode != old->pls_range.iomode)
		return false;
	old_end = pnfs_calc_offset_end(old->pls_range.offset,
			old->pls_range.length);
	if (old_end < new->pls_range.offset)
		return false;
	new_end = pnfs_calc_offset_end(new->pls_range.offset,
			new->pls_range.length);
	if (new_end < old->pls_range.offset)
		return false;
	if (!ff_lseg_match_mirrors(new, old))
		return false;

	/* Mergeable: copy info from 'old' to 'new' */
	if (new_end < old_end)
		new_end = old_end;
	if (new->pls_range.offset < old->pls_range.offset)
		new->pls_range.offset = old->pls_range.offset;
	new->pls_range.length = pnfs_calc_offset_length(new->pls_range.offset,
			new_end);
	if (test_bit(NFS_LSEG_ROC, &old->pls_flags))
		set_bit(NFS_LSEG_ROC, &new->pls_flags);
	return true;
}",0
Detect whether the following code contains vulnerabilities.,"NIAddSpell(IspellDict *Conf, const char *word, const char *flag)
{
	if (Conf->nspell >= Conf->mspell)
	{
		if (Conf->mspell)
		{
			Conf->mspell *= 2;
			Conf->Spell = (SPELL **) repalloc(Conf->Spell, Conf->mspell * sizeof(SPELL *));
		}
		else
		{
			Conf->mspell = 1024 * 20;
			Conf->Spell = (SPELL **) tmpalloc(Conf->mspell * sizeof(SPELL *));
		}
	}
	Conf->Spell[Conf->nspell] = (SPELL *) tmpalloc(SPELLHDRSZ + strlen(word) + 1);
	strcpy(Conf->Spell[Conf->nspell]->word, word);
	strncpy(Conf->Spell[Conf->nspell]->p.flag, flag, MAXFLAGLEN);
	Conf->nspell++;
}",1
Detect whether the following code contains vulnerabilities.,"void do_POWER_abso (void)

{

    if (T0 == INT32_MIN) {

        T0 = INT32_MAX;

        xer_ov = 1;

        xer_so = 1;

    } else {

        T0 = -T0;

        xer_ov = 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void do_info_trace(Monitor *mon)

{

    st_print_trace((FILE *)mon, &monitor_fprintf);

}
",1
Detect whether the following code contains vulnerabilities.,"mlx5_tx_wseg_init(struct mlx5_txq_data *restrict txq,
		  struct mlx5_txq_local *restrict loc __rte_unused,
		  struct mlx5_wqe *restrict wqe,
		  unsigned int wci,
		  unsigned int olx __rte_unused)
{
	struct mlx5_wqe_qseg *qs;

	qs = RTE_PTR_ADD(wqe, MLX5_WSEG_SIZE);
	qs->max_index = rte_cpu_to_be_32(wci);
	qs->qpn_cqn = rte_cpu_to_be_32(txq->sh->txpp.clock_queue.cq->id);
	qs->reserved0 = RTE_BE32(0);
	qs->reserved1 = RTE_BE32(0);
}",0
Detect whether the following code contains vulnerabilities.,"COMPS_Object* comps_objrtree_get(COMPS_ObjRTree * rt, const char * key) {
    return comps_object_incref(__comps_objrtree_get(rt, key));
}",0
Detect whether the following code contains vulnerabilities.,"static char **mysql_sys_var_str(THD* thd, int offset)
{
  return (char **) intern_sys_var_ptr(thd, offset, true);
}",0
Detect whether the following code contains vulnerabilities.,"static CURLcode read_data(struct connectdata *conn,
                          curl_socket_t fd,
                          struct krb5buffer *buf)
{
  int len;
  CURLcode result;

  result = socket_read(fd, &len, sizeof(len));
  if(result)
    return result;

  if(len) {
    /* only realloc if there was a length */
    len = ntohl(len);
    buf->data = Curl_saferealloc(buf->data, len);
  }
  if(!len || !buf->data)
    return CURLE_OUT_OF_MEMORY;

  result = socket_read(fd, buf->data, len);
  if(result)
    return result;
  buf->size = conn->mech->decode(conn->app_data, buf->data, len,
                                 conn->data_prot, conn);
  buf->index = 0;
  return CURLE_OK;
}",1
Detect whether the following code contains vulnerabilities.,"int early_data_count_ok(SSL *s, size_t length, size_t overhead, int *al)
{
    uint32_t max_early_data = s->max_early_data;

    /*
     * We go with the lowest out of the max early data set in the session
     * and the configured max_early_data.
     */
    if (s->hit && s->session->ext.max_early_data < s->max_early_data)
        max_early_data = s->session->ext.max_early_data;

    if (max_early_data == 0) {
        *al = SSL_AD_UNEXPECTED_MESSAGE;
        SSLerr(SSL_F_EARLY_DATA_COUNT_OK, SSL_R_TOO_MUCH_EARLY_DATA);
        return 0;
    }

    /* If we are dealing with ciphertext we need to allow for the overhead */
    max_early_data += overhead;

    s->early_data_count += length;
    if (s->early_data_count > max_early_data) {
        *al = SSL_AD_UNEXPECTED_MESSAGE;
        SSLerr(SSL_F_EARLY_DATA_COUNT_OK, SSL_R_TOO_MUCH_EARLY_DATA);
        return 0;
    }

    return 1;
}",0
Detect whether the following code contains vulnerabilities.,"cmsUInt32Number CMSEXPORT cmsNamedColorCount(const cmsNAMEDCOLORLIST* NamedColorList)
{
     if (NamedColorList == NULL) return 0;
     return NamedColorList ->nColors;
}",0
Detect whether the following code contains vulnerabilities.,"int ip_options_get_from_user(struct net *net, struct ip_options **optp,
			     unsigned char __user *data, int optlen)
{
	struct ip_options *opt = ip_options_get_alloc(optlen);

	if (!opt)
		return -ENOMEM;
	if (optlen && copy_from_user(opt->__data, data, optlen)) {
		kfree(opt);
		return -EFAULT;
	}
	return ip_options_get_finish(net, optp, opt, optlen);
}",1
Detect whether the following code contains vulnerabilities.,"static void tap_set_sndbuf(TAPState *s, const char *sndbuf_str, Monitor *mon)

{

    if (sndbuf_str) {

        config_error(mon, ""No '-net tap,sndbuf=<nbytes>' support available\n"");

    }

}
",1
Detect whether the following code contains vulnerabilities.,"datetime_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__httpdate(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int X509_get_signature_nid(const X509 *x)
{
	return OBJ_obj2nid(x->sig_alg->algorithm);
}",0
Detect whether the following code contains vulnerabilities.,"int tcp_socket_outgoing_spec(const char *address_and_port)

{

    return inet_connect(address_and_port, true, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"ENCODE_JSON(SByte) {
    char buf[5];
    UA_UInt16 digits = itoaSigned(*src, buf);
    if(ctx->pos + digits > ctx->end)
        return UA_STATUSCODE_BADENCODINGLIMITSEXCEEDED;
    if(!ctx->calcOnly)
        memcpy(ctx->pos, buf, digits);
    ctx->pos += digits;
    return UA_STATUSCODE_GOOD;
}",0
Detect whether the following code contains vulnerabilities.,"void string_output_visitor_cleanup(StringOutputVisitor *sov)

{

    if (sov->string) {

        g_string_free(sov->string, true);

    }



    g_list_foreach(sov->ranges, free_range, NULL);

    g_list_free(sov->ranges);

    g_free(sov);

}
",0
Detect whether the following code contains vulnerabilities.,"aes128_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, size_t length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	return openssl_enc(EVP_aes_128_ecb(), key, iv, input, length, output);
}",0
Detect whether the following code contains vulnerabilities.,"ext4_read_block_bitmap(struct super_block *sb, ext4_group_t block_group)
{
	struct buffer_head *bh;
	int err;

	bh = ext4_read_block_bitmap_nowait(sb, block_group);
	if (IS_ERR(bh))
		return bh;
	err = ext4_wait_block_bitmap(sb, block_group, bh);
	if (err) {
		put_bh(bh);
		return ERR_PTR(err);
	}
	return bh;
}",0
Detect whether the following code contains vulnerabilities.,"TPMI_RH_ENDORSEMENT_Unmarshal(TPMI_RH_ENDORSEMENT *target, BYTE **buffer, INT32 *size, BOOL allowNull)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case TPM_RH_ENDORSEMENT:
	    break;
	  case TPM_RH_NULL:
	    if (allowNull) {
		break;
	    }
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"int rpc_type_of_NPNVariable(int variable)
{
  int type;
  switch (variable) {
  case NPNVjavascriptEnabledBool:
  case NPNVasdEnabledBool:
  case NPNVisOfflineBool:
  case NPNVSupportsXEmbedBool:
  case NPNVSupportsWindowless:
	type = RPC_TYPE_BOOLEAN;
	break;
  case NPNVToolkit:
  case NPNVnetscapeWindow:
	type = RPC_TYPE_UINT32;
	break;
  case NPNVWindowNPObject:
  case NPNVPluginElementNPObject:
	type = RPC_TYPE_NP_OBJECT;
	break;
  default:
	type = RPC_ERROR_GENERIC;
	break;
  }
  return type;
}",1
Detect whether the following code contains vulnerabilities.,"void op_mtc0_ebase (void)

{

    /* vectored interrupts not implemented */

    /* Multi-CPU not implemented */

    env->CP0_EBase = (int32_t)0x80000000 | (T0 & 0x3FFFF000);

    RETURN();

}
",0
Detect whether the following code contains vulnerabilities.,"void WebContents::Invoke(
    bool internal,
    const std::string& channel,
    blink::CloneableMessage arguments,
    electron::mojom::ElectronBrowser::InvokeCallback callback,
    content::RenderFrameHost* render_frame_host) {
  TRACE_EVENT1(""electron"", ""WebContents::Invoke"", ""channel"", channel);
  // webContents.emit('-ipc-invoke', new Event(), internal, channel, arguments);
  EmitWithSender(""-ipc-invoke"", render_frame_host, std::move(callback),
                 internal, channel, std::move(arguments));
}",1
Detect whether the following code contains vulnerabilities.,"static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;
	int ret;

	if (!is_irq_none(vdev))
		return -EINVAL;

	vdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);
	if (!vdev->ctx)
		return -ENOMEM;

	/* return the number of supported vectors if we can't get all: */
	ret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);
	if (ret < nvec) {
		if (ret > 0)
			pci_free_irq_vectors(pdev);
		kfree(vdev->ctx);
		return ret;
	}

	vdev->num_ctx = nvec;
	vdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :
				VFIO_PCI_MSI_IRQ_INDEX;

	if (!msix) {
		/*
		 * Compute the virtual hardware field for max msi vectors -
		 * it is the log base 2 of the number of vectors.
		 */
		vdev->msi_qmax = fls(nvec * 2 - 1) - 1;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"ztype0_adjust_FDepVector(gs_font_type0 * pfont)
{
    gs_memory_t *mem = pfont->memory;
    /* HACK: We know the font was allocated by the interpreter. */
    gs_ref_memory_t *imem = (gs_ref_memory_t *)mem;
    gs_font **pdep = pfont->data.FDepVector;
    ref newdep;
    uint fdep_size = pfont->data.fdep_size;
    ref *prdep;
    uint i;
    int code = gs_alloc_ref_array(imem, &newdep, a_readonly, fdep_size,
                                  ""ztype0_adjust_matrix"");

    if (code < 0)
        return code;
    for (prdep = newdep.value.refs, i = 0; i < fdep_size; i++, prdep++) {
        const ref *pdict = pfont_dict(pdep[i]);

        ref_assign(prdep, pdict);
        r_set_attrs(prdep, imemory_new_mask(imem));
    }
    /*
     * The FDepVector is an existing key in the parent's dictionary,
     * so it's safe to pass NULL as the dstack pointer to dict_put_string.
     */
    return dict_put_string(pfont_dict(pfont), ""FDepVector"", &newdep, NULL);
}",0
Detect whether the following code contains vulnerabilities.,"static int evtchn_fifo_percpu_deinit(unsigned int cpu)
{
	__evtchn_fifo_handle_events(cpu, true);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void imap_mbox_select(struct Mailbox *m)
{
  struct ImapAccountData *adata = imap_adata_get(m);
  struct ImapMboxData *mdata = imap_mdata_get(m);
  if (!adata || !mdata)
    return;

  const char *condstore = NULL;
#ifdef USE_HCACHE
  if ((adata->capabilities & IMAP_CAP_CONDSTORE) && C_ImapCondstore)
    condstore = "" (CONDSTORE)"";
  else
#endif
    condstore = """";

  char buf[PATH_MAX];
  snprintf(buf, sizeof(buf), ""%s %s%s"", m->readonly ? ""EXAMINE"" : ""SELECT"",
           mdata->munge_name, condstore);

  adata->state = IMAP_SELECTED;

  imap_cmd_start(adata, buf);
}",0
Detect whether the following code contains vulnerabilities.,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) quantum);
#else
  if (quantum <= 0.0)
    return(0);
  if ((quantum) >= 4294967295.0)
    return(4294967295);
  return((unsigned int) (quantum+0.5));
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static int xen_host_pci_sysfs_path(const XenHostPCIDevice *d,

                                   const char *name, char *buf, ssize_t size)

{

    int rc;



    rc = snprintf(buf, size, ""/sys/bus/pci/devices/%04x:%02x:%02x.%d/%s"",

                  d->domain, d->bus, d->dev, d->func, name);



    if (rc >= size || rc < 0) {

        /* The output is truncated, or some other error was encountered */

        return -ENODEV;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static double setup_compress_thresh(double threshold)

{

    if ((threshold > DBL_EPSILON) && (threshold < (1.0 - DBL_EPSILON))) {

        double current_threshold = threshold;

        double step_size = 1.0;



        while (step_size > DBL_EPSILON) {

            while ((current_threshold + step_size > current_threshold) &&

                   (bound(current_threshold + step_size, 1.0) <= threshold)) {

                current_threshold += step_size;

            }



            step_size /= 2.0;

        }



        return current_threshold;

    } else {

        return threshold;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
{
	u16 offset = sizeof(struct ipv6hdr);
	unsigned int packet_len = skb_tail_pointer(skb) -
		skb_network_header(skb);
	int found_rhdr = 0;
	*nexthdr = &ipv6_hdr(skb)->nexthdr;

	while (offset <= packet_len) {
		struct ipv6_opt_hdr *exthdr;

		switch (**nexthdr) {

		case NEXTHDR_HOP:
			break;
		case NEXTHDR_ROUTING:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
			if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return offset;
			break;
		default:
			return offset;
		}

		if (offset + sizeof(struct ipv6_opt_hdr) > packet_len)
			return -EINVAL;

		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
						 offset);
		offset += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
	}

	return -EINVAL;
}",1
Detect whether the following code contains vulnerabilities.,"int pep_write(struct sock *sk, struct sk_buff *skb)
{
	struct sk_buff *rskb, *fs;
	int flen = 0;

	if (pep_sk(sk)->aligned)
		return pipe_skb_send(sk, skb);

	rskb = alloc_skb(MAX_PNPIPE_HEADER, GFP_ATOMIC);
	if (!rskb) {
		kfree_skb(skb);
		return -ENOMEM;
	}
	skb_shinfo(rskb)->frag_list = skb;
	rskb->len += skb->len;
	rskb->data_len += rskb->len;
	rskb->truesize += rskb->len;

	/* Avoid nested fragments */
	skb_walk_frags(skb, fs)
		flen += fs->len;
	skb->next = skb_shinfo(skb)->frag_list;
	skb_frag_list_init(skb);
	skb->len -= flen;
	skb->data_len -= flen;
	skb->truesize -= flen;

	skb_reserve(rskb, MAX_PHONET_HEADER + 3);
	return pipe_skb_send(sk, rskb);
}",0
Detect whether the following code contains vulnerabilities.,"void av_opencl_buffer_release(cl_mem *cl_buf)

{

    cl_int status = 0;

    if (!cl_buf)

        return;

    status = clReleaseMemObject(*cl_buf);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not release OpenCL buffer: %s\n"", opencl_errstr(status));

    }

    memset(cl_buf, 0, sizeof(*cl_buf));

}
",0
Detect whether the following code contains vulnerabilities.,"HttpStateData::truncateVirginBody()
{
    assert(flags.headers_parsed);

    HttpReply *vrep = virginReply();
    int64_t clen = -1;
    if (!vrep->expectingBody(request->method, clen) || clen < 0)
        return; // no body or a body of unknown size, including chunked

    if (payloadSeen - payloadTruncated <= clen)
        return; // we did not read too much or already took care of the extras

    if (const int64_t extras = payloadSeen - payloadTruncated - clen) {
        // server sent more that the advertised content length
        debugs(11, 5, ""payloadSeen="" << payloadSeen <<
               "" clen="" << clen << '/' << vrep->content_length <<
               "" trucated="" << payloadTruncated << '+' << extras);

        inBuf.chop(0, inBuf.length() - extras);
        payloadTruncated += extras;
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int getSingletonPos(const char* str)
{
	int result =-1;
	int i=0;
	int len = 0;
	
	if( str && ((len=strlen(str))>0) ){
		for( i=0; i<len ; i++){
			if( isIDSeparator(*(str+i)) ){
				if( i==1){
					/* string is of the form x-avy or a-prv1 */
					result =0;
					break;
				} else {
					/* delimiter found; check for singleton */
					if( isIDSeparator(*(str+i+2)) ){
						/* a singleton; so send the position of separator before singleton */
						result = i+1;
						break;
					}
				}
			}
		}/* end of for */
		
	}
	return result;
}",1
Detect whether the following code contains vulnerabilities.,"static UINT video_data_on_new_channel_connection(IWTSListenerCallback* pListenerCallback,
                                                 IWTSVirtualChannel* pChannel, BYTE* Data,
                                                 BOOL* pbAccept,
                                                 IWTSVirtualChannelCallback** ppCallback)
{
	VIDEO_CHANNEL_CALLBACK* callback;
	VIDEO_LISTENER_CALLBACK* listener_callback = (VIDEO_LISTENER_CALLBACK*)pListenerCallback;

	WINPR_UNUSED(Data);
	WINPR_UNUSED(pbAccept);

	callback = (VIDEO_CHANNEL_CALLBACK*)calloc(1, sizeof(VIDEO_CHANNEL_CALLBACK));
	if (!callback)
	{
		WLog_ERR(TAG, ""calloc failed!"");
		return CHANNEL_RC_NO_MEMORY;
	}

	callback->iface.OnDataReceived = video_data_on_data_received;
	callback->iface.OnClose = video_data_on_close;
	callback->plugin = listener_callback->plugin;
	callback->channel_mgr = listener_callback->channel_mgr;
	callback->channel = pChannel;
	listener_callback->channel_callback = callback;

	*ppCallback = (IWTSVirtualChannelCallback*)callback;

	return CHANNEL_RC_OK;
}",0
Detect whether the following code contains vulnerabilities.,"void validateUrl(absl::string_view raw_url, absl::string_view expected_scheme,
                 absl::string_view expected_host_port, absl::string_view expected_path,
                 uint16_t expected_port) {
  Utility::Url url;
  ASSERT_TRUE(url.initialize(raw_url, /*is_connect=*/false)) << ""Failed to initialize "" << raw_url;
  EXPECT_EQ(url.scheme(), expected_scheme);
  EXPECT_EQ(url.hostAndPort(), expected_host_port);
  EXPECT_EQ(url.pathAndQueryParams(), expected_path);
  EXPECT_EQ(url.port(), expected_port);
}",1
Detect whether the following code contains vulnerabilities.,"static void esp_command_complete(SCSIBus *bus, int reason, uint32_t tag,

                                 uint32_t arg)

{

    ESPState *s = DO_UPCAST(ESPState, busdev.qdev, bus->qbus.parent);



    if (reason == SCSI_REASON_DONE) {

        DPRINTF(""SCSI Command complete\n"");

        if (s->ti_size != 0)

            DPRINTF(""SCSI command completed unexpectedly\n"");

        s->ti_size = 0;

        s->dma_left = 0;

        s->async_len = 0;

        if (arg)

            DPRINTF(""Command failed\n"");

        s->sense = arg;

        s->rregs[ESP_RSTAT] = STAT_ST;

        esp_dma_done(s);

        s->current_dev = NULL;

    } else {

        DPRINTF(""transfer %d/%d\n"", s->dma_left, s->ti_size);

        s->async_len = arg;

        s->async_buf = s->current_dev->info->get_buf(s->current_dev, 0);

        if (s->dma_left) {

            esp_do_dma(s);

        } else if (s->dma_counter != 0 && s->ti_size <= 0) {

            /* If this was the last part of a DMA transfer then the

               completion interrupt is deferred to here.  */

            esp_dma_done(s);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static BlockDriverAIOCB *bdrv_aio_rw_vector(BlockDriverState *bs,

                                            int64_t sector_num,

                                            QEMUIOVector *iov,

                                            int nb_sectors,

                                            BlockDriverCompletionFunc *cb,

                                            void *opaque,

                                            int is_write)



{

    VectorTranslationState *s = qemu_mallocz(sizeof(*s));

    BlockDriverAIOCB *aiocb = qemu_aio_get(bs, cb, opaque);



    s->this_aiocb = aiocb;

    s->iov = iov;

    s->bounce = qemu_memalign(512, nb_sectors * 512);

    s->is_write = is_write;

    if (is_write) {

        qemu_iovec_to_buffer(s->iov, s->bounce);

        s->aiocb = bdrv_aio_write(bs, sector_num, s->bounce, nb_sectors,

                                  bdrv_aio_rw_vector_cb, s);

    } else {

        s->aiocb = bdrv_aio_read(bs, sector_num, s->bounce, nb_sectors,

                                 bdrv_aio_rw_vector_cb, s);

    }

    return aiocb;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool adding_first_cpu(void)

{

    CPUState *cpu;

    size_t count = 0;

    CPU_FOREACH(cpu) {

        count++;

        if (count > 1) {

            return false;

        }

    }

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_hash_speed(const void *opaque)

{

    size_t chunk_size = (size_t)opaque;

    uint8_t *in = NULL, *out = NULL;

    size_t out_len = 0;

    double total = 0.0;

    struct iovec iov;

    int ret;



    in = g_new0(uint8_t, chunk_size);

    memset(in, g_test_rand_int(), chunk_size);



    iov.iov_base = (char *)in;

    iov.iov_len = chunk_size;



    g_test_timer_start();

    do {

        ret = qcrypto_hash_bytesv(QCRYPTO_HASH_ALG_SHA256,

                                  &iov, 1, &out, &out_len,

                                  NULL);

        g_assert(ret == 0);



        total += chunk_size;

    } while (g_test_timer_elapsed() < 5.0);



    total /= 1024 * 1024; /* to MB */

    g_print(""sha256: "");

    g_print(""Testing chunk_size %ld bytes "", chunk_size);

    g_print(""done: %.2f MB in %.2f secs: "", total, g_test_timer_last());

    g_print(""%.2f MB/sec\n"", total / g_test_timer_last());



    g_free(out);

    g_free(in);

}
",1
Detect whether the following code contains vulnerabilities.,"void MongoStatusInfo::fromStatus(JSContext* cx, Status status, JS::MutableHandleValue value) {
    auto scope = getScope(cx);

    JS::RootedValue undef(cx);
    undef.setUndefined();

    JS::AutoValueArray<1> args(cx);
    ValueReader(cx, args[0]).fromStringData(status.reason());
    JS::RootedObject error(cx);
    scope->getProto<ErrorInfo>().newInstance(args, &error);

    JS::RootedObject thisv(cx);
    scope->getProto<MongoStatusInfo>().newObjectWithProto(&thisv, error);
    ObjectWrapper thisvObj(cx, thisv);
    thisvObj.defineProperty(InternedString::code,
                            JSPROP_ENUMERATE,
                            smUtils::wrapConstrainedMethod<Functions::code, false, MongoStatusInfo>,
                            nullptr);

    thisvObj.defineProperty(
        InternedString::reason,
        JSPROP_ENUMERATE,
        smUtils::wrapConstrainedMethod<Functions::reason, false, MongoStatusInfo>,
        nullptr);

    // We intentionally omit JSPROP_ENUMERATE to match how Error.prototype.stack is a non-enumerable
    // property.
    thisvObj.defineProperty(
        InternedString::stack,
        0,
        smUtils::wrapConstrainedMethod<Functions::stack, false, MongoStatusInfo>,
        nullptr);

    JS_SetPrivate(thisv, scope->trackedNew<Status>(std::move(status)));

    value.setObjectOrNull(thisv);
}",1
Detect whether the following code contains vulnerabilities.,"static void qerror_abort(const QError *qerr, const char *fmt, ...)

{

    va_list ap;



    fprintf(stderr, ""qerror: bad call in function '%s':\n"", qerr->func);

    fprintf(stderr, ""qerror: -> "");



    va_start(ap, fmt);

    vfprintf(stderr, fmt, ap);

    va_end(ap);



    fprintf(stderr, ""\nqerror: call at %s:%d\n"", qerr->file, qerr->linenr);

    abort();

}
",0
Detect whether the following code contains vulnerabilities.,"msg_get_seq (struct msg *msg)
{
  assert (msg);
  return ntohl (msg->hdr.msgseq);
}",0
Detect whether the following code contains vulnerabilities.,"setup_secureChannel(void) {
    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);
    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);
    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);

    testingConnection = createDummyConnection(65535, &sentData);
    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);
    testChannel.connection = &testingConnection;

    testChannel.state = UA_SECURECHANNELSTATE_OPEN;
}",1
Detect whether the following code contains vulnerabilities.,"static int split_field_half_ref_list(Picture *dest, int dest_len,

                                     Picture *src,  int src_len,  int parity){

    int same_parity   = 1;

    int same_i        = 0;

    int opp_i         = 0;

    int out_i;

    int field_output;



    for (out_i = 0; out_i < dest_len; out_i += field_output) {

        if (same_parity && same_i < src_len) {

            field_output = split_field_copy(dest + out_i, src + same_i,

                                            parity, 1);

            same_parity = !field_output;

            same_i++;



        } else if (opp_i < src_len) {

            field_output = split_field_copy(dest + out_i, src + opp_i,

                                            PICT_FRAME - parity, 0);

            same_parity = field_output;

            opp_i++;



        } else {

            break;

        }

    }



    return out_i;

}
",0
Detect whether the following code contains vulnerabilities.,"static void nvic_sysreg_write(void *opaque, target_phys_addr_t addr,

                              uint64_t value, unsigned size)

{

    uint32_t offset = addr;

    if (size == 4) {

        nvic_writel(opaque, offset, value);

        return;

    }

    hw_error(""NVIC: Bad write of size %d at offset 0x%x\n"", size, offset);

}
",0
Detect whether the following code contains vulnerabilities.,"static void sdl_grab_start(void)

{

    if (guest_cursor) {

        SDL_SetCursor(guest_sprite);

        SDL_WarpMouse(guest_x, guest_y);

    } else

        sdl_hide_cursor();



    if (SDL_WM_GrabInput(SDL_GRAB_ON) == SDL_GRAB_ON) {

        gui_grab = 1;

        sdl_update_caption();

    } else

        sdl_show_cursor();

}
",0
Detect whether the following code contains vulnerabilities.,"static file_t* _cast_file(const oe_fd_t* desc)
{
    file_t* ret = NULL;
    file_t* file = (file_t*)desc;

    if (file == NULL || file->magic != FILE_MAGIC)
        OE_RAISE_ERRNO(OE_EINVAL);

    ret = file;

done:
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"inline bool IsCharOfType(unsigned char c, SharedCharTypes type) {
  return !!(kSharedCharTypeTable[c] & type);
}",0
Detect whether the following code contains vulnerabilities.,"ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext, u_int item_len _U_,
		const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_SIG)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_SIG)));
	return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static inline u32 ___skb_get_hash(const struct sk_buff *skb,
				  struct flow_keys *keys, u32 keyval)
{
	skb_flow_dissect_flow_keys(skb, keys,
				   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);

	return __flow_hash_from_keys(keys, keyval);
}",1
Detect whether the following code contains vulnerabilities.,"shorten_utf8_string (const char *base, int reduce_by_num_bytes)
{
	int len;
	char *ret;
	const char *p;
	
	len = strlen (base);
	len -= reduce_by_num_bytes;
	
	if (len <= 0) {
		return NULL;
	}

	ret = g_new (char, len + 1);

	p = base;
	while (len) {
		char *next;
		next = g_utf8_next_char (p);
		if (next - p > len || *next == '\0') {
			break;
		}
		
		len -= next - p;
		p = next;
	}
	
	if (p - base == 0) {
		g_free (ret);
		return NULL;
	} else {
		memcpy (ret, base, p - base);
		ret[p - base] = '\0';
		return ret;
	}
}",0
Detect whether the following code contains vulnerabilities.,"bool asn1_write_GeneralString(struct asn1_data *data, const char *s)
{
	asn1_push_tag(data, ASN1_GENERAL_STRING);
	asn1_write_LDAPString(data, s);
	asn1_pop_tag(data);
	return !data->has_error;
}",1
Detect whether the following code contains vulnerabilities.,"static PHP_FUNCTION(libxml_disable_entity_loader)
{
	zend_bool disable = 1;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|b"", &disable) == FAILURE) {
		return;
	}

	RETURN_BOOL(php_libxml_disable_entity_loader(disable TSRMLS_CC));
}",0
Detect whether the following code contains vulnerabilities.,"static PHP_FUNCTION(preg_grep)
{
	char				*regex;			/* Regular expression */
	int				 	 regex_len;
	zval				*input;			/* Input array */
	long				 flags = 0;		/* Match control flags */
	pcre_cache_entry	*pce;			/* Compiled regular expression */

	/* Get arguments and do error checking */
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""sa|l"", &regex, &regex_len,
							  &input, &flags) == FAILURE) {
		return;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}
	
	php_pcre_grep_impl(pce, input, return_value, flags TSRMLS_CC);
}",1
Detect whether the following code contains vulnerabilities.,"static void do_busid_cmd(ESPState *s, uint8_t *buf, uint8_t busid)

{

    int32_t datalen;

    int lun;



    DPRINTF(""do_busid_cmd: busid 0x%x\n"", busid);

    lun = busid & 7;

    datalen = s->current_dev->info->send_command(s->current_dev, 0, buf, lun);

    s->ti_size = datalen;

    if (datalen != 0) {

        s->rregs[ESP_RSTAT] = STAT_TC;

        s->dma_left = 0;

        s->dma_counter = 0;

        if (datalen > 0) {

            s->rregs[ESP_RSTAT] |= STAT_DI;

            s->current_dev->info->read_data(s->current_dev, 0);

        } else {

            s->rregs[ESP_RSTAT] |= STAT_DO;

            s->current_dev->info->write_data(s->current_dev, 0);

        }

    }

    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;

    s->rregs[ESP_RSEQ] = SEQ_CD;

    esp_raise_irq(s);

}
",1
Detect whether the following code contains vulnerabilities.,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->con = graphic_console_init(jazz_led_update_display,

                                  jazz_led_invalidate_display,

                                  NULL,

                                  jazz_led_text_update, s);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t icp_pic_read(void *opaque, target_phys_addr_t offset,

                             unsigned size)

{

    icp_pic_state *s = (icp_pic_state *)opaque;



    switch (offset >> 2) {

    case 0: /* IRQ_STATUS */

        return s->level & s->irq_enabled;

    case 1: /* IRQ_RAWSTAT */

        return s->level;

    case 2: /* IRQ_ENABLESET */

        return s->irq_enabled;

    case 4: /* INT_SOFTSET */

        return s->level & 1;

    case 8: /* FRQ_STATUS */

        return s->level & s->fiq_enabled;

    case 9: /* FRQ_RAWSTAT */

        return s->level;

    case 10: /* FRQ_ENABLESET */

        return s->fiq_enabled;

    case 3: /* IRQ_ENABLECLR */

    case 5: /* INT_SOFTCLR */

    case 11: /* FRQ_ENABLECLR */

    default:

        printf (""icp_pic_read: Bad register offset 0x%x\n"", (int)offset);

        return 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void tm_unavailable(struct pt_regs *regs)
{
	pr_emerg(""Unrecoverable TM Unavailable Exception ""
			""%lx at %lx\n"", regs->trap, regs->nip);
	die(""Unrecoverable TM Unavailable Exception"", regs, SIGABRT);
}",1
Detect whether the following code contains vulnerabilities.,"get16 (const byte *buffer)
{
  ulong a;
  a =  *buffer << 8;
  a |= buffer[1];
  return a;
}",1
Detect whether the following code contains vulnerabilities.,"static void local_mapped_file_attr(int dirfd, const char *name,

                                   struct stat *stbuf)

{

    FILE *fp;

    char buf[ATTR_MAX];

    int map_dirfd;



    map_dirfd = openat(dirfd, VIRTFS_META_DIR,

                       O_RDONLY | O_DIRECTORY | O_NOFOLLOW);

    if (map_dirfd == -1) {

        return;

    }



    fp = local_fopenat(map_dirfd, name, ""r"");

    close_preserve_errno(map_dirfd);

    if (!fp) {

        return;

    }

    memset(buf, 0, ATTR_MAX);

    while (fgets(buf, ATTR_MAX, fp)) {

        if (!strncmp(buf, ""virtfs.uid"", 10)) {

            stbuf->st_uid = atoi(buf+11);

        } else if (!strncmp(buf, ""virtfs.gid"", 10)) {

            stbuf->st_gid = atoi(buf+11);

        } else if (!strncmp(buf, ""virtfs.mode"", 11)) {

            stbuf->st_mode = atoi(buf+12);

        } else if (!strncmp(buf, ""virtfs.rdev"", 11)) {

            stbuf->st_rdev = atoi(buf+12);

        }

        memset(buf, 0, ATTR_MAX);

    }

    fclose(fp);

}
",1
Detect whether the following code contains vulnerabilities.,"peer_interface_vty (struct vty *vty, const char *ip_str, const char *str)
{
  int ret;
  struct peer *peer;

  peer = peer_lookup_vty (vty, ip_str);
  if (! peer)
    return CMD_WARNING;

  if (str)
    ret = peer_interface_set (peer, str);
  else
    ret = peer_interface_unset (peer);

  return CMD_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"static int msvideo1_decode_frame(AVCodecContext *avctx,

                                void *data, int *got_frame,

                                AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    Msvideo1Context *s = avctx->priv_data;

    int ret;



    s->buf = buf;

    s->size = buf_size;



    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)

        return ret;



    if (s->mode_8bit) {

        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);



        if (pal) {

            memcpy(s->pal, pal, AVPALETTE_SIZE);

            s->frame->palette_has_changed = 1;

        }

    }



    if (s->mode_8bit)

        msvideo1_decode_8bit(s);

    else

        msvideo1_decode_16bit(s);



    if ((ret = av_frame_ref(data, s->frame)) < 0)

        return ret;



    *got_frame      = 1;



    /* report that the buffer was completely consumed */

    return buf_size;

}
",0
Detect whether the following code contains vulnerabilities.,"void stl_phys(target_phys_addr_t addr, uint32_t val)

{

    stl_phys_internal(addr, val, DEVICE_NATIVE_ENDIAN);

}
",0
Detect whether the following code contains vulnerabilities.,"static void add_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,

                                 ptrdiff_t line_size)

{

    int i;



    /* read the pixels */

    for (i = 0; i < 8; i++) {

        pixels[0] = av_clip_uint8(pixels[0] + block[0]);

        pixels[1] = av_clip_uint8(pixels[1] + block[1]);

        pixels[2] = av_clip_uint8(pixels[2] + block[2]);

        pixels[3] = av_clip_uint8(pixels[3] + block[3]);

        pixels[4] = av_clip_uint8(pixels[4] + block[4]);

        pixels[5] = av_clip_uint8(pixels[5] + block[5]);

        pixels[6] = av_clip_uint8(pixels[6] + block[6]);

        pixels[7] = av_clip_uint8(pixels[7] + block[7]);

        pixels   += line_size;

        block    += 8;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int pcan_usb_pro_set_ts(struct peak_usb_device *dev, u16 onoff)
{
	struct pcan_usb_pro_msg um;

	pcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);
	pcan_msg_add_rec(&um, PCAN_USBPRO_SETTS, onoff);

	return pcan_usb_pro_send_cmd(dev, &um);
}",0
Detect whether the following code contains vulnerabilities.,"static void fill_note(struct memelfnote *note, const char *name, int type,

                      unsigned int sz, void *data)

{

    unsigned int namesz;



    namesz = strlen(name) + 1;

    note->name = name;

    note->namesz = namesz;

    note->namesz_rounded = roundup(namesz, sizeof (int32_t));

    note->type = type;

    note->datasz = roundup(sz, sizeof (int32_t));;

    note->data = data;



    /*

     * We calculate rounded up note size here as specified by

     * ELF document.

     */

    note->notesz = sizeof (struct elf_note) +

        note->namesz_rounded + note->datasz;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline uint32_t _ring_fwd_done(pmixp_coll_ring_ctx_t *coll_ctx)
{
	return !(coll_ctx->coll->peers_cnt - coll_ctx->forward_cnt - 1);
}",0
Detect whether the following code contains vulnerabilities.,"static int io_recvmsg(struct io_kiocb *req, const struct io_uring_sqe *sqe,
		      struct io_kiocb **nxt, bool force_nonblock)
{
#if defined(CONFIG_NET)
	return io_send_recvmsg(req, sqe, nxt, force_nonblock,
				__sys_recvmsg_sock);
#else
	return -EOPNOTSUPP;
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static inline void libopenjpeg_copy_to_packed16(AVFrame *picture, opj_image_t *image) {

    uint16_t *img_ptr;

    int index, x, y, c;

    int adjust[4];

    for (x = 0; x < image->numcomps; x++)

        adjust[x] = FFMAX(FFMIN(av_pix_fmt_desc_get(picture->format)->comp[x].depth_minus1 + 1 - image->comps[x].prec, 8), 0);



    for (y = 0; y < picture->height; y++) {

        index = y*picture->width;

        img_ptr = (uint16_t*) (picture->data[0] + y*picture->linesize[0]);

        for (x = 0; x < picture->width; x++, index++) {

            for (c = 0; c < image->numcomps; c++) {

                *img_ptr++ = 0x8000 * image->comps[c].sgnd + (image->comps[c].data[index] << adjust[c]);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"time_to_time_t(VALUE time)
{
    return (time_t)NUM2TIMET(rb_Integer(time));
}",0
Detect whether the following code contains vulnerabilities.,"static const char *kallsyms_symbol_name(struct mod_kallsyms *kallsyms, unsigned int symnum)
{
	return kallsyms->strtab + kallsyms->symtab[symnum].st_name;
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(xsl_xsltprocessor_get_parameter)
{
	zval *id;
	int name_len = 0, namespace_len = 0;
	char *name, *namespace;
	zval **value;
	xsl_object *intern;

	DOM_GET_THIS(id);
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss"", &namespace, &namespace_len, &name, &name_len) == FAILURE) {
		RETURN_FALSE;
	}
	intern = (xsl_object *)zend_object_store_get_object(id TSRMLS_CC);
	if ( zend_hash_find(intern->parameter, name, name_len + 1,  (void**) &value) == SUCCESS) {
		convert_to_string_ex(value);
		RETVAL_STRING(Z_STRVAL_PP(value),1);
	} else {
		RETURN_FALSE;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static int normalize_bits(int num, int width)

{

    int i = 0;

    int bits = (width) ? 31 : 15;

    int limit = 1 << (bits - 1);



    if (num) {

        if (num == -1)

            return bits;

        if (num < 0)

            num = ~num;

        for (i = 0; num < limit; i++)

            num <<= 1;

    }

    return i;

}
",0
Detect whether the following code contains vulnerabilities.,"opts_check_struct(Visitor *v, Error **errp)

{

    OptsVisitor *ov = to_ov(v);

    GHashTableIter iter;

    GQueue *any;



    if (ov->depth > 0) {

        return;

    }



    /* we should have processed all (distinct) QemuOpt instances */

    g_hash_table_iter_init(&iter, ov->unprocessed_opts);

    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {

        const QemuOpt *first;



        first = g_queue_peek_head(any);

        error_setg(errp, QERR_INVALID_PARAMETER, first->name);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"
u32 parse_dump_ts(char *arg_val, u32 opt)
{
	dump_timestamps = 1;
	if (arg_val) {
		if (isdigit(arg_val[0])) {
			program_number = parse_u32(arg_val, ""Program"");
		} else {
			return 3;
		}
	}
	return 0;",0
Detect whether the following code contains vulnerabilities.,"    BSONTool::BSONTool( const char * name, DBAccess access , bool objcheck )
        : Tool( name , access , """" , """" , false ) , _objcheck( objcheck ) {

        add_options()
        (""objcheck"" , ""validate object before inserting"" )
        (""filter"" , po::value<string>() , ""filter to apply before inserting"" )
        ;
    }",1
Detect whether the following code contains vulnerabilities.,"int qemu_opt_set_bool(QemuOpts *opts, const char *name, bool val)

{

    QemuOpt *opt;

    const QemuOptDesc *desc = opts->list->desc;

    int i;



    for (i = 0; desc[i].name != NULL; i++) {

        if (strcmp(desc[i].name, name) == 0) {

            break;

        }

    }

    if (desc[i].name == NULL) {

        if (i == 0) {

            /* empty list -> allow any */;

        } else {

            qerror_report(QERR_INVALID_PARAMETER, name);

            return -1;

        }

    }



    opt = g_malloc0(sizeof(*opt));

    opt->name = g_strdup(name);

    opt->opts = opts;

    QTAILQ_INSERT_TAIL(&opts->head, opt, next);

    if (desc[i].name != NULL) {

        opt->desc = desc+i;

    }

    opt->value.boolean = !!val;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static const char *token_get_value(QObject *obj)

{

    return qdict_get_str(qobject_to_qdict(obj), ""token"");

}
",0
Detect whether the following code contains vulnerabilities.,"static void handle_user_command(Monitor *mon, const char *cmdline)

{

    QDict *qdict;

    const mon_cmd_t *cmd;



    qdict = qdict_new();



    cmd = monitor_parse_command(mon, cmdline, 0, mon->cmd_table, qdict);

    if (!cmd)

        goto out;



    if (handler_is_async(cmd)) {

        user_async_cmd_handler(mon, cmd, qdict);

    } else if (handler_is_qobject(cmd)) {

        QObject *data = NULL;



        /* XXX: ignores the error code */

        cmd->mhandler.cmd_new(mon, qdict, &data);

        assert(!monitor_has_error(mon));

        if (data) {

            cmd->user_print(mon, data);

            qobject_decref(data);

        }

    } else {

        cmd->mhandler.cmd(mon, qdict);

    }



out:

    QDECREF(qdict);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virt_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);



    mc->desc = ""ARM Virtual Machine"",

    mc->init = machvirt_init;

    mc->max_cpus = 8;

    mc->has_dynamic_sysbus = true;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline enum fbq_type fbq_classify_group(struct sg_lb_stats *sgs)
{
	return all;
}",0
Detect whether the following code contains vulnerabilities.,"static HotplugHandler *spapr_get_hotpug_handler(MachineState *machine,

                                             DeviceState *dev)

{

    if (object_dynamic_cast(OBJECT(dev), TYPE_PC_DIMM) ||

        object_dynamic_cast(OBJECT(dev), TYPE_SPAPR_CPU_CORE)) {

        return HOTPLUG_HANDLER(machine);

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"  void CoverCheck(HBoundsCheck* new_check,
                  int32_t new_offset) {
    ASSERT(new_check->index()->representation().IsInteger32());
    bool keep_new_check = false;

    if (new_offset > upper_offset_) {
      upper_offset_ = new_offset;
      if (HasSingleCheck()) {
        keep_new_check = true;
        upper_check_ = new_check;
      } else {
        BuildOffsetAdd(upper_check_,
                       &added_upper_index_,
                       &added_upper_offset_,
                       Key()->IndexBase(),
                       new_check->index()->representation(),
                       new_offset);
        upper_check_->SetOperandAt(0, added_upper_index_);
      }
    } else if (new_offset < lower_offset_) {
      lower_offset_ = new_offset;
      if (HasSingleCheck()) {
        keep_new_check = true;
        lower_check_ = new_check;
      } else {
        BuildOffsetAdd(lower_check_,
                       &added_lower_index_,
                       &added_lower_offset_,
                       Key()->IndexBase(),
                       new_check->index()->representation(),
                       new_offset);
        lower_check_->SetOperandAt(0, added_lower_index_);
      }
    } else {
      ASSERT(false);
    }

    if (!keep_new_check) {
      new_check->DeleteAndReplaceWith(NULL);
    }
  }",1
Detect whether the following code contains vulnerabilities.,"func_endswith (struct _ESExp *f,
               gint argc,
               struct _ESExpResult **argv,
               gpointer data)
{
	EBookBackendLDAPSExpData *ldap_data = data;
	ESExpResult *r;

	if (argc == 2
	    && argv[0]->type == ESEXP_RES_STRING
	    && argv[1]->type == ESEXP_RES_STRING) {
		gchar *propname = argv[0]->value.string;
		gchar *str = rfc2254_escape (argv[1]->value.string);
		const gchar *ldap_attr = query_prop_to_ldap (propname, ldap_data->bl->priv->evolutionPersonSupported, ldap_data->bl->priv->calEntrySupported);

		if (ldap_attr)
			ldap_data->list = g_list_prepend (
				ldap_data->list,
				g_strdup_printf (
					""(%s=*%s)"",
					ldap_attr, str));
		g_free (str);
	}

	r = e_sexp_result_new (f, ESEXP_RES_BOOL);
	r->value.boolean = FALSE;

	return r;
}",0
Detect whether the following code contains vulnerabilities.,"int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,
                             uv_buf_t* bufs,
                             size_t count,
                             uv_stream_t* send_handle) {
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  int r;
  if (send_handle == nullptr) {
    r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);
  } else {
    r = w->Dispatch(uv_write2,
                    stream(),
                    bufs,
                    count,
                    send_handle,
                    AfterUvWrite);
  }

  if (!r) {
    size_t bytes = 0;
    for (size_t i = 0; i < count; i++)
      bytes += bufs[i].len;
    if (stream()->type == UV_TCP) {
      NODE_COUNT_NET_BYTES_SENT(bytes);
    } else if (stream()->type == UV_NAMED_PIPE) {
      NODE_COUNT_PIPE_BYTES_SENT(bytes);
    }
  }

  return r;
}",1
Detect whether the following code contains vulnerabilities.,"static bool pcie_has_upstream_port(PCIDevice *dev)

{

    PCIDevice *parent_dev = pci_bridge_get_device(dev->bus);



    /* Device associated with an upstream port.

     * As there are several types of these, it's easier to check the

     * parent device: upstream ports are always connected to

     * root or downstream ports.

     */

    return parent_dev &&

        pci_is_express(parent_dev) &&

        parent_dev->exp.exp_cap &&

        (pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_ROOT_PORT ||

         pcie_cap_get_type(parent_dev) == PCI_EXP_TYPE_DOWNSTREAM);

}
",0
Detect whether the following code contains vulnerabilities.,"static int crc_write_header(struct AVFormatContext *s)

{

    CRCState *crc = s->priv_data;



    /* init CRC */

    crc->crcval = adler32(0, NULL, 0);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,
			     struct snd_rawmidi_params * params)
{
	char *newbuf;
	struct snd_rawmidi_runtime *runtime = substream->runtime;

	snd_rawmidi_drain_input(substream);
	if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {
		return -EINVAL;
	}
	if (params->avail_min < 1 || params->avail_min > params->buffer_size) {
		return -EINVAL;
	}
	if (params->buffer_size != runtime->buffer_size) {
		newbuf = krealloc(runtime->buffer, params->buffer_size,
				  GFP_KERNEL);
		if (!newbuf)
			return -ENOMEM;
		runtime->buffer = newbuf;
		runtime->buffer_size = params->buffer_size;
	}
	runtime->avail_min = params->avail_min;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void vfio_disable_msix(VFIODevice *vdev)
{
    msix_unset_vector_notifiers(&vdev->pdev);
    if (vdev->nr_vectors) {
        vfio_disable_irqindex(vdev, VFIO_PCI_MSIX_IRQ_INDEX);
    vfio_disable_msi_common(vdev);
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);",1
Detect whether the following code contains vulnerabilities.,"ex_put(exarg_T *eap)
{
    // "":0put"" works like "":1put!"".
    if (eap->line2 == 0)
    {
	eap->line2 = 1;
	eap->forceit = TRUE;
    }
    curwin->w_cursor.lnum = eap->line2;
    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,
						       PUT_LINE|PUT_CURSLINE);
}",1
Detect whether the following code contains vulnerabilities.,"static int rprobe(AVFormatContext *s, uint8_t *enc_header, const uint8_t *r_val)

{

    OMAContext *oc = s->priv_data;

    unsigned int pos;

    struct AVDES av_des;



    if (!enc_header || !r_val)

        return -1;



    /* m_val */

    av_des_init(&av_des, r_val, 192, 1);

    av_des_crypt(&av_des, oc->m_val, &enc_header[48], 1, NULL, 1);



    /* s_val */

    av_des_init(&av_des, oc->m_val, 64, 0);

    av_des_crypt(&av_des, oc->s_val, NULL, 1, NULL, 0);



    /* sm_val */

    pos = OMA_ENC_HEADER_SIZE + oc->k_size + oc->e_size;

    av_des_init(&av_des, oc->s_val, 64, 0);

    av_des_mac(&av_des, oc->sm_val, &enc_header[pos], (oc->i_size >> 3));



    pos += oc->i_size;



    return memcmp(&enc_header[pos], oc->sm_val, 8) ? -1 : 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_metadata_size(const uint8_t *buf, int buf_size)

{

    int metadata_last, metadata_size;

    const uint8_t *buf_end = buf + buf_size;



    buf += 4;

    do {

        ff_flac_parse_block_header(buf, &metadata_last, NULL, &metadata_size);

        buf += 4;

        if (buf + metadata_size > buf_end) {

            /* need more data in order to read the complete header */

            return 0;

        }

        buf += metadata_size;

    } while (!metadata_last);



    return buf_size - (buf_end - buf);

}
",1
Detect whether the following code contains vulnerabilities.,"static int check_shm_size(IVShmemState *s, int fd) {

    /* check that the guest isn't going to try and map more memory than the

     * the object has allocated return -1 to indicate error */



    struct stat buf;



    fstat(fd, &buf);



    if (s->ivshmem_size > buf.st_size) {

        fprintf(stderr,

                ""IVSHMEM ERROR: Requested memory size greater""

                "" than shared object size (%"" PRIu64 "" > %"" PRIu64"")\n"",

                s->ivshmem_size, (uint64_t)buf.st_size);

        return -1;

    } else {

        return 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,  virtual bool exists2in_processor(void *arg) { return 0; },0
Detect whether the following code contains vulnerabilities.,"void MD5::update(unsigned char *input,
		 unsigned int inputLen)
{
    unsigned int i, index, partLen;

    // Compute number of bytes mod 64
    index = static_cast<unsigned int>((count[0] >> 3) & 0x3f);

    // Update number of bits
    if ((count[0] += (static_cast<UINT4>(inputLen) << 3)) <
        (static_cast<UINT4>(inputLen) << 3))
	count[1]++;
    count[1] += (static_cast<UINT4>(inputLen) >> 29);

    partLen = 64 - index;

    // Transform as many times as possible.

    if (inputLen >= partLen) {
	memcpy(&buffer[index], input, partLen);
	transform(state, buffer);

	for (i = partLen; i + 63 < inputLen; i += 64)
	    transform(state, &input[i]);

	index = 0;
    }
    else
	i = 0;

    // Buffer remaining input
    memcpy(&buffer[index], &input[i], inputLen-i);
}",1
Detect whether the following code contains vulnerabilities.,"static void openpic_set_irq(void *opaque, int n_IRQ, int level)

{

    OpenPICState *opp = opaque;

    IRQSource *src;



    if (n_IRQ >= MAX_IRQ) {

        fprintf(stderr, ""%s: IRQ %d out of range\n"", __func__, n_IRQ);

        abort();

    }



    src = &opp->src[n_IRQ];

    DPRINTF(""openpic: set irq %d = %d ivpr=0x%08x\n"",

            n_IRQ, level, src->ivpr);

    if (src->level) {

        /* level-sensitive irq */

        src->pending = level;

        if (!level) {

            src->ivpr &= ~IVPR_ACTIVITY_MASK;

        }

    } else {

        /* edge-sensitive irq */

        if (level) {

            src->pending = 1;

        }

    }

    openpic_update_irq(opp, n_IRQ);

}
",0
Detect whether the following code contains vulnerabilities.,"ofputil_put_async_config__(const struct ofputil_async_cfg *ac,
                           struct ofpbuf *buf, bool tlv,
                           enum ofp_version version, uint32_t oams)
{
    if (!tlv) {
        struct nx_async_config *msg = ofpbuf_put_zeros(buf, sizeof *msg);
        encode_legacy_async_masks(ac, OAM_PACKET_IN, version,
                                  msg->packet_in_mask);
        encode_legacy_async_masks(ac, OAM_PORT_STATUS, version,
                                  msg->port_status_mask);
        encode_legacy_async_masks(ac, OAM_FLOW_REMOVED, version,
                                  msg->flow_removed_mask);
    } else {
        FOR_EACH_ASYNC_PROP (ap) {
            if (oams & (1u << ap->oam)) {
                size_t ofs = buf->size;
                ofpprop_put_be32(buf, ap->prop_type,
                                 encode_async_mask(ac, ap, version));

                /* For experimenter properties, we need to use type 0xfffe for
                 * master and 0xffff for slaves. */
                if (ofpprop_is_experimenter(ap->prop_type)) {
                    struct ofp_prop_experimenter *ope
                        = ofpbuf_at_assert(buf, ofs, sizeof *ope);
                    ope->type = ap->master ? htons(0xffff) : htons(0xfffe);
                }
            }
        }
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int resize_peers(IVShmemState *s, int new_min_size)

{



    int j, old_size;



    /* limit number of max peers */

    if (new_min_size <= 0 || new_min_size > IVSHMEM_MAX_PEERS) {

        return -1;

    }

    if (new_min_size <= s->nb_peers) {

        return 0;

    }



    old_size = s->nb_peers;

    s->nb_peers = new_min_size;



    IVSHMEM_DPRINTF(""bumping storage to %d peers\n"", s->nb_peers);



    s->peers = g_realloc(s->peers, s->nb_peers * sizeof(Peer));



    for (j = old_size; j < s->nb_peers; j++) {

        s->peers[j].eventfds = g_new0(EventNotifier, s->vectors);

        s->peers[j].nb_eventfds = 0;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static RList* sections(RBinFile* bf) {
	RList* ret = NULL;
	RBinSection* sect = NULL;
	psxexe_header psxheader = {0};
	ut64 sz = 0;

	if (!(ret = r_list_new ())) {
		return NULL;
	}

	if (!(sect = R_NEW0 (RBinSection))) {
		r_list_free (ret);
		return NULL;
	}

	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) < sizeof (psxexe_header)) {
		eprintf (""Truncated Header\n"");
		free (sect);
		r_list_free (ret);
		return NULL;
	}

	sz = r_buf_size (bf->buf);

	sect->name = strdup (""TEXT"");
	sect->paddr = PSXEXE_TEXTSECTION_OFFSET;
	sect->size = sz - PSXEXE_TEXTSECTION_OFFSET;
	sect->vaddr = psxheader.t_addr;
	sect->vsize = psxheader.t_size;
	sect->perm = R_PERM_RX;
	sect->add = true;
	sect->has_strings = true;

	r_list_append (ret, sect);
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void cdrom_change_cb(void *opaque, int reason)

{

    IDEState *s = opaque;

    uint64_t nb_sectors;



    if (!(reason & CHANGE_MEDIA)) {

        return;

    }



    bdrv_get_geometry(s->bs, &nb_sectors);

    s->nb_sectors = nb_sectors;



    s->sense_key = SENSE_UNIT_ATTENTION;

    s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;

    s->cdrom_changed = 1;

    s->events.new_media = true;

    ide_set_irq(s->bus);

}
",1
Detect whether the following code contains vulnerabilities.,"struct dst_entry *inet6_csk_route_req(const struct sock *sk,
				      struct flowi6 *fl6,
				      const struct request_sock *req,
				      u8 proto)
{
	struct inet_request_sock *ireq = inet_rsk(req);
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct in6_addr *final_p, final;
	struct dst_entry *dst;

	memset(fl6, 0, sizeof(*fl6));
	fl6->flowi6_proto = proto;
	fl6->daddr = ireq->ir_v6_rmt_addr;
	final_p = fl6_update_dst(fl6, np->opt, &final);
	fl6->saddr = ireq->ir_v6_loc_addr;
	fl6->flowi6_oif = ireq->ir_iif;
	fl6->flowi6_mark = ireq->ir_mark;
	fl6->fl6_dport = ireq->ir_rmt_port;
	fl6->fl6_sport = htons(ireq->ir_num);
	security_req_classify_flow(req, flowi6_to_flowi(fl6));

	dst = ip6_dst_lookup_flow(sk, fl6, final_p);
	if (IS_ERR(dst))
		return NULL;

	return dst;
}",1
Detect whether the following code contains vulnerabilities.,"static void h264_v_loop_filter_chroma_c(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0)

{

    h264_loop_filter_chroma_c(pix, stride, 1, alpha, beta, tc0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int __init init_root_keyring(void)
{
	return install_user_keyrings();
}",0
Detect whether the following code contains vulnerabilities.,"static void init_multbl2(uint8_t tbl[1024], const int c[4],

                         const uint8_t *log8, const uint8_t *alog8,

                         const uint8_t *sbox)

{

    int i, j;



    for (i = 0; i < 1024; i++) {

        int x = sbox[i >> 2];

        if (x)

            tbl[i] = alog8[log8[x] + log8[c[i & 3]]];

    }

#if !CONFIG_SMALL

    for (j = 256; j < 1024; j++)

        for (i = 0; i < 4; i++)

            tbl[4*j + i] = tbl[4*j + ((i - 1) & 3) - 1024];

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx)

{

    MXFIndexTableSegment *seg;

    switch ((*ctx)->type) {

    case Descriptor:

        av_freep(&((MXFDescriptor *)*ctx)->extradata);

        break;

    case MultipleDescriptor:

        av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs);

        break;

    case Sequence:

        av_freep(&((MXFSequence *)*ctx)->structural_components_refs);

        break;

    case EssenceGroup:

        av_freep(&((MXFEssenceGroup *)*ctx)->structural_components_refs);

        break;

    case SourcePackage:

    case MaterialPackage:

        av_freep(&((MXFPackage *)*ctx)->tracks_refs);

        av_freep(&((MXFPackage *)*ctx)->name);


        break;

    case TaggedValue:

        av_freep(&((MXFTaggedValue *)*ctx)->name);

        av_freep(&((MXFTaggedValue *)*ctx)->value);

        break;

    case IndexTableSegment:

        seg = (MXFIndexTableSegment *)*ctx;

        av_freep(&seg->temporal_offset_entries);

        av_freep(&seg->flag_entries);

        av_freep(&seg->stream_offset_entries);

    default:

        break;

    }

    if (freectx)

    av_freep(ctx);

}",1
Detect whether the following code contains vulnerabilities.,"static int __init cpia2_init(void)
{
	LOG(""%s v%s\n"",
	    ABOUT, CPIA_VERSION);
	check_parameters();
	cpia2_usb_init();
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static SSL_METHOD *ssl23_get_server_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
	if (ver == SSL2_VERSION)
		return(SSLv2_server_method());
#endif
	if (ver == SSL3_VERSION)
		return(SSLv3_server_method());
	else if (ver == TLS1_VERSION)
		return(TLSv1_server_method());
	else
		return(NULL);
	}",1
Detect whether the following code contains vulnerabilities.,"rb_str_start_with(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    int i;
    long pos;
    VALUE pat;

    for (i=0; i<argc; i++) {
	VALUE prefix = rb_check_string_type(argv[i]);
	if (NIL_P(prefix)) continue;
	if (RSTRING(str)->len < RSTRING(prefix)->len) continue;
        pat = get_arg_pat(prefix);
        if (rb_reg_search(pat, str, 0, 1) >= 0)
	    return Qtrue;
    }
    return Qfalse;
}",0
Detect whether the following code contains vulnerabilities.,"static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)

{

    Object *pci_host;

    QObject *o;



    pci_host = acpi_get_i386_pci_host();

    g_assert(pci_host);



    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);

    if (!o) {

        return false;

    }

    mcfg->mcfg_base = qnum_get_int(qobject_to_qnum(o));

    qobject_decref(o);



    o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);

    assert(o);

    mcfg->mcfg_size = qnum_get_int(qobject_to_qnum(o));

    qobject_decref(o);

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline AIOReq *alloc_aio_req(BDRVSheepdogState *s, SheepdogAIOCB *acb,

                                    uint64_t oid, unsigned int data_len,

                                    uint64_t offset, uint8_t flags,

                                    uint64_t base_oid, unsigned int iov_offset)

{

    AIOReq *aio_req;



    aio_req = g_malloc(sizeof(*aio_req));

    aio_req->aiocb = acb;

    aio_req->iov_offset = iov_offset;

    aio_req->oid = oid;

    aio_req->base_oid = base_oid;

    aio_req->offset = offset;

    aio_req->data_len = data_len;

    aio_req->flags = flags;

    aio_req->id = s->aioreq_seq_num++;



    acb->nr_pending++;

    return aio_req;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_iret_real(int shift)

{

    uint32_t sp, new_cs, new_eip, new_eflags, new_esp;

    uint8_t *ssp;

    int eflags_mask;

    

    sp = env->regs[R_ESP] & 0xffff;

    ssp = env->segs[R_SS].base + sp;

    if (shift == 1) {

        /* 32 bits */

        new_eflags = ldl(ssp + 8);

        new_cs = ldl(ssp + 4) & 0xffff;

        new_eip = ldl(ssp) & 0xffff;

    } else {

        /* 16 bits */

        new_eflags = lduw(ssp + 4);

        new_cs = lduw(ssp + 2);

        new_eip = lduw(ssp);

    }

    new_esp = sp + (6 << shift);

    env->regs[R_ESP] = (env->regs[R_ESP] & 0xffff0000) | 

        (new_esp & 0xffff);

    load_seg_vm(R_CS, new_cs);

    env->eip = new_eip;

    eflags_mask = FL_UPDATE_CPL0_MASK;

    if (shift == 0)

        eflags_mask &= 0xffff;

    load_eflags(new_eflags, eflags_mask);

}
",0
Detect whether the following code contains vulnerabilities.,"void vmalloc_sync_all(void)
{
	unsigned long address;

	if (SHARED_KERNEL_PMD)
		return;

	for (address = VMALLOC_START & PMD_MASK;
	     address >= TASK_SIZE && address < FIXADDR_TOP;
	     address += PMD_SIZE) {
		struct page *page;

		spin_lock(&pgd_lock);
		list_for_each_entry(page, &pgd_list, lru) {
			spinlock_t *pgt_lock;
			pmd_t *ret;

			/* the pgt_lock only for Xen */
			pgt_lock = &pgd_page_get_mm(page)->page_table_lock;

			spin_lock(pgt_lock);
			ret = vmalloc_sync_one(page_address(page), address);
			spin_unlock(pgt_lock);

			if (!ret)
				break;
		}
		spin_unlock(&pgd_lock);
	}
}",0
Detect whether the following code contains vulnerabilities.,"static inline void __fuse_dentry_settime(struct dentry *entry, u64 time)
{
	entry->d_fsdata = (void *) time;
}",0
Detect whether the following code contains vulnerabilities.,"static void free_schro_frame(SchroFrame *frame, void *priv)

{

    AVFrame *p_pic = priv;

    av_frame_free(&p_pic);

}
",1
Detect whether the following code contains vulnerabilities.,"static bool consume_encoded_name_new(RBuffer *b, ut64 bound, ut32 *len_out, char **str_out) {
	ut32 len;
	char *orig = NULL;
	if (!consume_str_new (b, bound, &len, &orig)) {
		return false;
	}

	// room for even every character getting encoded
	size_t maxsize = (len * 4) + 2;
	char *sout = malloc (maxsize);
	if (!sout) {
		free (orig);
		return false;
	}

	size_t i, oi = 0;
	for (i = 0; i < len && oi + 4 < maxsize; i++) {
		if (WASM_IS_OK (orig, i, len)) {
			sout[oi++] = orig[i];
		} else {
			oi += snprintf (sout + oi, maxsize - oi, ""_%02x_"", orig[i]);
		}
	}
	sout[oi++] = '\0';
	free (orig);

	char *tmp = realloc (sout, oi);
	if (!tmp) {
		free (sout);
		free (tmp);
		return false;
	}
	*str_out = tmp;
	if (len_out) {
		*len_out = len;
	}
	return true;
}",1
Detect whether the following code contains vulnerabilities.,"static void read_storage_element0_info(SCLPDevice *sclp, SCCB *sccb)

{

    int i, assigned;

    int subincrement_id = SCLP_STARTING_SUBINCREMENT_ID;

    ReadStorageElementInfo *storage_info = (ReadStorageElementInfo *) sccb;

    sclpMemoryHotplugDev *mhd = get_sclp_memory_hotplug_dev();



    assert(mhd);



    if ((ram_size >> mhd->increment_size) >= 0x10000) {

        sccb->h.response_code = cpu_to_be16(SCLP_RC_SCCB_BOUNDARY_VIOLATION);

        return;

    }



    /* Return information regarding core memory */

    storage_info->max_id = cpu_to_be16(mhd->standby_mem_size ? 1 : 0);

    assigned = ram_size >> mhd->increment_size;

    storage_info->assigned = cpu_to_be16(assigned);



    for (i = 0; i < assigned; i++) {

        storage_info->entries[i] = cpu_to_be32(subincrement_id);

        subincrement_id += SCLP_INCREMENT_UNIT;

    }

    sccb->h.response_code = cpu_to_be16(SCLP_RC_NORMAL_READ_COMPLETION);

}
",0
Detect whether the following code contains vulnerabilities.,"check_owner_password_V4(std::string& user_password,
                        std::string const& owner_password,
                        QPDF::EncryptionData const& data)
{
    // Algorithm 3.7 from the PDF 1.7 Reference Manual

    unsigned char key[OU_key_bytes_V4];
    compute_O_rc4_key(user_password, owner_password, data, key);
    unsigned char O_data[key_bytes];
    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);
    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),
                (data.getR() >= 3) ? 20 : 1, true);
    std::string new_user_password =
        std::string(reinterpret_cast<char*>(O_data), key_bytes);
    bool result = false;
    if (check_user_password(new_user_password, data))
    {
        result = true;
        user_password = new_user_password;
    }
    return result;
}",1
Detect whether the following code contains vulnerabilities.,"static void print_splits(IRC_SERVER_REC *server, const char *channel)
{
	TEMP_SPLIT_REC temp;
	GSList *servers;

	printing_splits = TRUE;

	servers = g_slist_copy(server->split_servers);
	while (servers != NULL) {
		NETSPLIT_SERVER_REC *sserver = servers->data;

		/* get all the splitted servers that have the same
		   source server */
                temp.servers = get_source_servers(sserver->server, &servers);
                temp.server_rec = server;
		temp.channels = NULL;

		g_hash_table_foreach(server->splits,
				     (GHFunc) get_server_splits, &temp);
		print_server_splits(server, &temp, channel);

		g_slist_foreach(temp.channels,
				(GFunc) temp_split_chan_free, NULL);
		g_slist_free(temp.servers);
		g_slist_free(temp.channels);
	}

	printing_splits = FALSE;
}",1
Detect whether the following code contains vulnerabilities.,"static int rc4_hmac_md5_get_ctx_params(void *vctx, OSSL_PARAM params[])
{
    PROV_RC4_HMAC_MD5_CTX *ctx = (PROV_RC4_HMAC_MD5_CTX *)vctx;
    OSSL_PARAM *p;

    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_KEYLEN);
    if (p != NULL && !OSSL_PARAM_set_size_t(p, ctx->base.keylen)) {
        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
        return 0;
    }

    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_IVLEN);
    if (p != NULL && !OSSL_PARAM_set_size_t(p, ctx->base.ivlen)) {
        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
        return 0;
    }
    p = OSSL_PARAM_locate(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD_PAD);
    if (p != NULL && !OSSL_PARAM_set_size_t(p, ctx->tls_aad_pad_sz)) {
        ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_SET_PARAMETER);
        return 0;
    }
    return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static int pin_to_kill(struct inotify_handle *ih, struct inotify_watch *watch)
{
	struct super_block *sb = watch->inode->i_sb;
	s32 wd = watch->wd;

	spin_lock(&sb_lock);
	if (sb->s_count >= S_BIAS) {
		atomic_inc(&sb->s_active);
		spin_unlock(&sb_lock);
		get_inotify_watch(watch);
		mutex_unlock(&ih->mutex);
		return 1;	/* the best outcome */
	}
	sb->s_count++;
	spin_unlock(&sb_lock);
	mutex_unlock(&ih->mutex); /* can't grab ->s_umount under it */
	down_read(&sb->s_umount);
	if (likely(!sb->s_root)) {
		/* fs is already shut down; the watch is dead */
		drop_super(sb);
		return 0;
	}
	/* raced with the final deactivate_super() */
	mutex_lock(&ih->mutex);
	if (idr_find(&ih->idr, wd) != watch || watch->inode->i_sb != sb) {
		/* the watch is dead */
		mutex_unlock(&ih->mutex);
		drop_super(sb);
		return 0;
	}
	/* still alive or freed and reused with the same sb and wd; kill */
	get_inotify_watch(watch);
	mutex_unlock(&ih->mutex);
	return 2;
}",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_vp9dsp_init(VP9DSPContext *dsp)

{

    vp9dsp_intrapred_init(dsp);

    vp9dsp_itxfm_init(dsp);

    vp9dsp_loopfilter_init(dsp);

    vp9dsp_mc_init(dsp);





    if (ARCH_X86)

        ff_vp9dsp_init_x86(dsp);

}",1
Detect whether the following code contains vulnerabilities.,"vu_queue_flush(VuDev *dev, VuVirtq *vq, unsigned int count)

{

    uint16_t old, new;



    if (unlikely(dev->broken)) {

        return;

    }



    /* Make sure buffer is written before we update index. */

    smp_wmb();



    old = vq->used_idx;

    new = old + count;

    vring_used_idx_set(dev, vq, new);

    vq->inuse -= count;

    if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old))) {

        vq->signalled_used_valid = false;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t available_instances_show(struct mdev_type *mtype,
					struct mdev_type_attribute *attr,
					char *buf)
{
	const struct mbochs_type *type =
		&mbochs_types[mtype_get_type_group_id(mtype)];
	int count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;

	return sprintf(buf, ""%d\n"", count);
}",1
Detect whether the following code contains vulnerabilities.,"virSecuritySELinuxSetImageLabelRelative(virSecurityManager *mgr,
                                        virDomainDef *def,
                                        virStorageSource *src,
                                        virStorageSource *parent,
                                        virSecurityDomainImageLabelFlags flags)
{
    virStorageSource *n;

    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {
        const bool isChainTop = flags & VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;

        if (virSecuritySELinuxSetImageLabelInternal(mgr, def, n, parent, isChainTop) < 0)
            return -1;

        if (!(flags & VIR_SECURITY_DOMAIN_IMAGE_LABEL_BACKING_CHAIN))
            break;

        flags &= ~VIR_SECURITY_DOMAIN_IMAGE_PARENT_CHAIN_TOP;
    }

    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void rstrip_spaces_buf(AVBPrint *buf)

{

    while (buf->len > 0 && buf->str[buf->len - 1] == ' ')

        buf->str[--buf->len] = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)
{
	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
	    copy_from_user(kp, up, offsetof(struct v4l2_create_buffers32, format)))
		return -EFAULT;
	return __get_v4l2_format32(&kp->format, &up->format);
}",1
Detect whether the following code contains vulnerabilities.,"  bool is_booting() const {
    return state == STATE_BOOTING;
  }",0
Detect whether the following code contains vulnerabilities.,"static int64_t mpegps_read_dts(AVFormatContext *s, int stream_index,

                               int64_t *ppos, int64_t pos_limit)

{

    int len, startcode;

    int64_t pos, pts, dts;



    pos = *ppos;

#ifdef DEBUG_SEEK

    printf(""read_dts: pos=0x%""PRIx64"" next=%d -> "", pos, find_next);

#endif

    url_fseek(s->pb, pos, SEEK_SET);

    for(;;) {

        len = mpegps_read_pes_header(s, &pos, &startcode, &pts, &dts);

        if (len < 0) {

#ifdef DEBUG_SEEK

            printf(""none (ret=%d)\n"", len);

#endif

            return AV_NOPTS_VALUE;

        }

        if (startcode == s->streams[stream_index]->id &&

            dts != AV_NOPTS_VALUE) {

            break;

        }

        url_fskip(s->pb, len);

    }

#ifdef DEBUG_SEEK

    printf(""pos=0x%""PRIx64"" dts=0x%""PRIx64"" %0.3f\n"", pos, dts, dts / 90000.0);

#endif

    *ppos = pos;

    return dts;

}
",0
Detect whether the following code contains vulnerabilities.,"xmlRelaxNGDocumentPop(xmlRelaxNGParserCtxtPtr ctxt)
{
    xmlRelaxNGDocumentPtr ret;

    if (ctxt->docNr <= 0)
        return (NULL);
    ctxt->docNr--;
    if (ctxt->docNr > 0)
        ctxt->doc = ctxt->docTab[ctxt->docNr - 1];
    else
        ctxt->doc = NULL;
    ret = ctxt->docTab[ctxt->docNr];
    ctxt->docTab[ctxt->docNr] = NULL;
    return (ret);
}",0
Detect whether the following code contains vulnerabilities.,"static unsigned int selinux_ipv6_forward(unsigned int hooknum,
					 struct sk_buff *skb,
					 const struct net_device *in,
					 const struct net_device *out,
					 int (*okfn)(struct sk_buff *))
{
	return selinux_ip_forward(skb, in->ifindex, PF_INET6);
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t pxa2xx_pm_read(void *opaque, target_phys_addr_t addr)

{

    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;

    if (addr > s->pm_base + PCMD31) {

        /* Special case: PWRI2C registers appear in the same range.  */

        return pxa2xx_i2c_read(s->i2c[1], addr);

    }

    addr -= s->pm_base;



    switch (addr) {

    case PMCR ... PCMD31:

        if (addr & 3)

            goto fail;



        return s->pm_regs[addr >> 2];

    default:

    fail:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void StreamTcpPacketSetState(Packet *p, TcpSession *ssn,
                                           uint8_t state)
{
    if (state == ssn->state || PKT_IS_PSEUDOPKT(p))
        return;

    ssn->state = state;

    /* update the flow state */
    switch(ssn->state) {
        case TCP_ESTABLISHED:
        case TCP_FIN_WAIT1:
        case TCP_FIN_WAIT2:
        case TCP_CLOSING:
        case TCP_CLOSE_WAIT:
            FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED);
            break;
        case TCP_LAST_ACK:
        case TCP_TIME_WAIT:
        case TCP_CLOSED:
            FlowUpdateState(p->flow, FLOW_STATE_CLOSED);
            break;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static int get_uint64_equal(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    uint64_t v2;

    qemu_get_be64s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vgacon_flush_scrollback(struct vc_data *c)
{
}",1
Detect whether the following code contains vulnerabilities.,"Status renameTargetCollectionToTmp(OperationContext* opCtx,
                                   const NamespaceString& sourceNs,
                                   const UUID& sourceUUID,
                                   Database* const targetDB,
                                   const NamespaceString& targetNs,
                                   const UUID& targetUUID) {
    repl::UnreplicatedWritesBlock uwb(opCtx);

    auto tmpNameResult = targetDB->makeUniqueCollectionNamespace(opCtx, ""tmp%%%%%.rename"");
    if (!tmpNameResult.isOK()) {
        return tmpNameResult.getStatus().withContext(
            str::stream() << ""Cannot generate a temporary collection name for the target ""
                          << targetNs
                          << "" (""
                          << targetUUID
                          << "") so that the source""
                          << sourceNs
                          << "" (""
                          << sourceUUID
                          << "") could be renamed to ""
                          << targetNs);
    }
    const auto& tmpName = tmpNameResult.getValue();
    const bool stayTemp = true;
    return writeConflictRetry(opCtx, ""renameCollection"", targetNs.ns(), [&] {
        WriteUnitOfWork wunit(opCtx);
        auto status = targetDB->renameCollection(opCtx, targetNs.ns(), tmpName.ns(), stayTemp);
        if (!status.isOK())
            return status;

        wunit.commit();

        log() << ""Successfully renamed the target "" << targetNs << "" ("" << targetUUID << "") to ""
              << tmpName << "" so that the source "" << sourceNs << "" ("" << sourceUUID
              << "") could be renamed to "" << targetNs;

        return Status::OK();
    });
}",0
Detect whether the following code contains vulnerabilities.,"static int vhost_user_set_vring_addr(struct vhost_dev *dev,

                                     struct vhost_vring_addr *addr)

{

    VhostUserMsg msg = {

        .request = VHOST_USER_SET_VRING_ADDR,

        .flags = VHOST_USER_VERSION,

        .payload.addr = *addr,

        .size = sizeof(msg.payload.addr),

    };



    vhost_user_write(dev, &msg, NULL, 0);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_divq_EAX_T0(void)

{

    uint64_t r0, r1;

    if (T0 == 0) {

        raise_exception(EXCP00_DIVZ);

    }

    r0 = EAX;

    r1 = EDX;

    div64(&r0, &r1, T0);

    EAX = r0;

    EDX = r1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void io_mem_init(void)

{

    cpu_register_io_memory(IO_MEM_ROM >> IO_MEM_SHIFT, error_mem_read, unassigned_mem_write, NULL);

    cpu_register_io_memory(IO_MEM_UNASSIGNED >> IO_MEM_SHIFT, unassigned_mem_read, unassigned_mem_write, NULL);

    cpu_register_io_memory(IO_MEM_NOTDIRTY >> IO_MEM_SHIFT, error_mem_read, notdirty_mem_write, NULL);

    io_mem_nb = 5;







    /* alloc dirty bits array */

    phys_ram_dirty = qemu_vmalloc(phys_ram_size >> TARGET_PAGE_BITS);

    memset(phys_ram_dirty, 0xff, phys_ram_size >> TARGET_PAGE_BITS);

}",1
Detect whether the following code contains vulnerabilities.,"int Server::getUserID(const QString &name) {
	if (qhUserIDCache.contains(name))
		return qhUserIDCache.value(name);
	int id = -2;
	emit nameToIdSig(id, name);
	if (id != -2) {
		qhUserIDCache.insert(name, id);
		qhUserNameCache.insert(id, name);
		return id;
	}
	TransactionHolder th;

	QSqlQuery &query = *th.qsqQuery;
	SQLPREP(""SELECT `user_id` FROM `%1users` WHERE `server_id` = ? AND `name` like ?"");
	query.addBindValue(iServerNum);
	query.addBindValue(name);
	SQLEXEC();
	if (query.next()) {
		id = query.value(0).toInt();
		qhUserIDCache.insert(name, id);
		qhUserNameCache.insert(id, name);
	}
	return id;
}",1
Detect whether the following code contains vulnerabilities.,"dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,
			  proto_tree *tree, guint8 *drep _U_, char **data,
			  int hf_name)
{
	gint len, remaining;
	char *text;

	if (offset % 2)
		offset += 2 - (offset % 2);

	/* Get remaining data in buffer as a string */

	remaining = tvb_captured_length_remaining(tvb, offset);
	if (remaining <= 0) {
		if (data)
			*data = g_strdup("""");
		return offset;
	}

	text = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);
	len = (int)strlen(text);

	proto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);

	if (data)
		*data = text;
	else
		g_free(text);

	return offset + (len + 1) * 2;
}",1
Detect whether the following code contains vulnerabilities.,"int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
{
    int ret, flush = 0;
    if (pkt) {
        AVStream *st = s->streams[pkt->stream_index];
        //FIXME/XXX/HACK drop zero sized packets
        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && pkt->size == 0)
            return 0;
        av_dlog(s, ""av_interleaved_write_frame size:%d dts:%"" PRId64 "" pts:%"" PRId64 ""\n"",
                pkt->size, pkt->dts, pkt->pts);
        if ((ret = compute_pkt_fields2(s, st, pkt)) < 0 && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))
        if (pkt->dts == AV_NOPTS_VALUE && !(s->oformat->flags & AVFMT_NOTIMESTAMPS))
            return AVERROR(EINVAL);
    } else {
        av_dlog(s, ""av_interleaved_write_frame FLUSH\n"");
        flush = 1;
    }
    for (;; ) {
        AVPacket opkt;
        int ret = interleave_packet(s, &opkt, pkt, flush);
        if (ret <= 0) //FIXME cleanup needed for ret<0 ?
        ret = write_packet(s, &opkt);
        if (ret >= 0)
            s->streams[opkt.stream_index]->nb_frames++;
        av_free_packet(&opkt);
        pkt = NULL;
    }
}",1
Detect whether the following code contains vulnerabilities.,"int ssl2_put_cipher_by_char(const SSL_CIPHER *c, unsigned char *p)
{
    long l;

    if (p != NULL) {
        l = c->id;
        if ((l & 0xff000000) != 0x02000000 && l != SSL3_CK_FALLBACK_SCSV)
            return (0);
        p[0] = ((unsigned char)(l >> 16L)) & 0xFF;
        p[1] = ((unsigned char)(l >> 8L)) & 0xFF;
        p[2] = ((unsigned char)(l)) & 0xFF;
    }
    return (3);
}",0
Detect whether the following code contains vulnerabilities.,"static void tricore_cpu_initfn(Object *obj)

{

    CPUState *cs = CPU(obj);

    TriCoreCPU *cpu = TRICORE_CPU(obj);

    CPUTriCoreState *env = &cpu->env;



    cs->env_ptr = env;

    cpu_exec_init(cs, &error_abort);



    if (tcg_enabled()) {

        tricore_tcg_init();

    }

}
",1
Detect whether the following code contains vulnerabilities.,"cleanup_environment()
{
if (!keep_environment || *keep_environment == '\0')
  clearenv();
else if (Ustrcmp(keep_environment, ""*"") != 0)
  {
  uschar **p;
  if (environ) for (p = USS environ; *p; /* see below */)
    {
    uschar *name = string_copyn(*p, US Ustrchr(*p, '=') - *p);

    if (OK != match_isinlist(name, CUSS &keep_environment,
        0, NULL, NULL, MCL_NOEXPAND, FALSE, NULL))
      if (unsetenv(CS name) < 0) return FALSE;
      else /* nothing */;
    else
      p++;

    store_reset(name);
    }
  }
if (add_environment)
  {
    uschar *p;
    int sep = 0;
    const uschar* envlist = add_environment;
    while ((p = string_nextinlist(&envlist, &sep, NULL, 0)))
        putenv(CS p);
  }

  return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"static int qio_channel_socket_listen_worker(QIOTask *task,

                                            Error **errp,

                                            gpointer opaque)

{

    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(qio_task_get_source(task));

    SocketAddress *addr = opaque;

    int ret;



    ret = qio_channel_socket_listen_sync(ioc,

                                         addr,

                                         errp);



    object_unref(OBJECT(ioc));

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int checkSettingSecurity(lua_State* L, const std::string &name)
{
	if (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, ""secure."") == 0)
		throw LuaError(""Attempt to set secure setting."");

	bool is_mainmenu = false;
#ifndef SERVER
	is_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;
#endif
	if (!is_mainmenu && (name == ""mg_name"" || name == ""mg_flags"")) {
		errorstream << ""Tried to set global setting "" << name << "", ignoring. ""
			""minetest.set_mapgen_setting() should be used instead."" << std::endl;
		infostream << script_get_backtrace(L) << std::endl;
		return -1;
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void ConnectionManagerImpl::checkForDeferredClose() {
  if (drain_state_ == DrainState::Closing && streams_.empty() && !codec_->wantsToWrite()) {
    doConnectionClose(Network::ConnectionCloseType::FlushWriteAndDelay, absl::nullopt,
                      StreamInfo::ResponseCodeDetails::get().DownstreamLocalDisconnect);
  }
}",0
Detect whether the following code contains vulnerabilities.,"static void opt_frame_pad_top(const char *arg)

{

    frame_padtop = atoi(arg);

    if (frame_padtop < 0) {

        fprintf(stderr, ""Incorrect top pad size\n"");

        av_exit(1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int seek_to_sector(BlockDriverState *bs, int64_t sector_num)

{

    BDRVParallelsState *s = bs->opaque;

    uint32_t index, offset, position;



    index = sector_num / s->tracks;

    offset = sector_num % s->tracks;



    // not allocated

    if ((index > s->catalog_size) || (s->catalog_bitmap[index] == 0))

	return -1;



    position = (s->catalog_bitmap[index] + offset) * 512;



//    fprintf(stderr, ""sector: %llx index=%x offset=%x pointer=%x position=%x\n"",

//	sector_num, index, offset, s->catalog_bitmap[index], position);



    if (lseek(s->fd, position, SEEK_SET) != position)

	return -1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {
	int i;

	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)
		return 0;

	for (i = 0; i < bin->nsegs; ++i)
		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)
			return bin->segs[i].vmaddr;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"struct vhost_net *vhost_net_init(VLANClientState *backend, int devfd,

                                 bool force)

{


    return NULL;

}",1
Detect whether the following code contains vulnerabilities.,"static void nbd_close(BlockDriverState *bs)
{
    nbd_teardown_connection(bs);
}",1
Detect whether the following code contains vulnerabilities.,"DeviceState *i2c_create_slave(i2c_bus *bus, const char *name, uint8_t addr)

{

    DeviceState *dev;



    dev = qdev_create(&bus->qbus, name);

    qdev_prop_set_uint8(dev, ""address"", addr);

    qdev_init(dev);

    return dev;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_write_ms_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    avio_wb32(pb, 0);

    avio_wl32(pb, track->tag); // store it byteswapped

    track->enc->codec_tag = av_bswap16(track->tag >> 16);

    ff_put_wav_header(pb, track->enc, 0);

    return update_size(pb, pos);

}
",0
Detect whether the following code contains vulnerabilities.,"      DSA_Verification_Operation(const DSA_PublicKey& dsa,
                                 const std::string& emsa) :
         PK_Ops::Verification_with_EMSA(emsa),
         m_group(dsa.get_group()),
         m_y(dsa.get_y()),
         m_mod_q(dsa.group_q())
         {}",1
Detect whether the following code contains vulnerabilities.,"static void handle_mrs(DisasContext *s, uint32_t insn, unsigned int op0,

                       unsigned int op1, unsigned int op2,

                       unsigned int crn, unsigned int crm, unsigned int rt)

{

    unsupported_encoding(s, insn);

}
",0
Detect whether the following code contains vulnerabilities.,"static void terminate_event_chain(int flags)
{
    if (g_expert_mode)
        return;

    hide_next_step_button();
    if ((flags & TERMINATE_WITH_RERUN))
        return;

    free(g_event_selected);
    g_event_selected = NULL;

    g_list_free_full(g_auto_event_list, free);
    g_auto_event_list = NULL;
}",0
Detect whether the following code contains vulnerabilities.,"int my_redel(const char *org_name, const char *tmp_name,
             time_t backup_time_stamp, myf MyFlags)
{
  int error=1;
  DBUG_ENTER(""my_redel"");
  DBUG_PRINT(""my"",(""org_name: '%s' tmp_name: '%s'  MyFlags: %d"",
		   org_name,tmp_name,MyFlags));

  if (my_copystat(org_name,tmp_name,MyFlags) < 0)
    goto end;
  if (MyFlags & MY_REDEL_MAKE_BACKUP)
  {
    char name_buff[FN_REFLEN + MY_BACKUP_NAME_EXTRA_LENGTH];    
    my_create_backup_name(name_buff, org_name, backup_time_stamp);
    if (my_rename(org_name, name_buff, MyFlags))
      goto end;
  }
  else if (my_delete(org_name, MyFlags))
      goto end;
  if (my_rename(tmp_name,org_name,MyFlags))
    goto end;

  error=0;
end:
  DBUG_RETURN(error);
} /* my_redel */",1
Detect whether the following code contains vulnerabilities.,"static inline int is_arm_mapping_symbol(const char *str)
{
	if (str[0] == '.' && str[1] == 'L')
		return true;
	return str[0] == '$' && strchr(""axtd"", str[1])
	       && (str[2] == '\0' || str[2] == '.');
}",0
Detect whether the following code contains vulnerabilities.,"qf_stack_empty(qf_info_T *qi)
{
    return qi == NULL || qi->qf_listcount <= 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int post_msg(struct pptp_conn_t *conn, void *buf, int size)
{
	int n;
	if (conn->out_size) {
		log_error(""pptp: buffer is not empty\n"");
		return -1;
	}

again:
	n=write(conn->hnd.fd, buf, size);
	if (n < 0) {
		if (errno == EINTR)
			goto again;
		else if (errno == EAGAIN)
			n = 0;
		else {
			if (errno != EPIPE) {
				if (conf_verbose)
					log_ppp_info2(""pptp: write: %s\n"", strerror(errno));
				return -1;
			}
		}
	}

	if ( n<size ) {
		memcpy(conn->out_buf, (uint8_t *)buf + n, size - n);
		triton_md_enable_handler(&conn->hnd, MD_MODE_WRITE);
	}

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"clear_diffin(diffin_T *din)
{
    if (din->din_fname == NULL)
    {
	vim_free(din->din_mmfile.ptr);
	din->din_mmfile.ptr = NULL;
    }
    else
	mch_remove(din->din_fname);
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold int ra144_decode_init(AVCodecContext * avctx)
{
    RA144Context *ractx = avctx->priv_data;
    ractx->avctx = avctx;
    ractx->lpc_coef[0] = ractx->lpc_tables[0];
    ractx->lpc_coef[1] = ractx->lpc_tables[1];
    avctx->channels       = 1;
    avctx->channel_layout = AV_CH_LAYOUT_MONO;
    avctx->sample_fmt     = AV_SAMPLE_FMT_S16;
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int __init lp_setup (char *str)
{
	static int parport_ptr;
	int x;

	if (get_option(&str, &x)) {
		if (x == 0) {
			/* disable driver on ""lp="" or ""lp=0"" */
			parport_nr[0] = LP_PARPORT_OFF;
		} else {
			printk(KERN_WARNING ""warning: 'lp=0x%x' is deprecated, ignored\n"", x);
			return 0;
		}
	} else if (!strncmp(str, ""parport"", 7)) {
		int n = simple_strtoul(str+7, NULL, 10);
		if (parport_ptr < LP_NO)
			parport_nr[parport_ptr++] = n;
		else
			printk(KERN_INFO ""lp: too many ports, %s ignored.\n"",
			       str);
	} else if (!strcmp(str, ""auto"")) {
		parport_nr[0] = LP_PARPORT_AUTO;
	} else if (!strcmp(str, ""none"")) {
		parport_nr[parport_ptr++] = LP_PARPORT_NONE;
	} else if (!strcmp(str, ""reset"")) {
		reset = 1;
	}
	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"static void svm_write_tsc_multiplier(struct kvm_vcpu *vcpu, u64 multiplier)
{
	__svm_write_tsc_multiplier(multiplier);
}",0
Detect whether the following code contains vulnerabilities.,"int vfs_lstat_smb_fname(struct connection_struct *conn, const char *fname,
			SMB_STRUCT_STAT *psbuf)
{
	struct smb_filename *smb_fname = NULL;
	NTSTATUS status;
	int ret;

	status = create_synthetic_smb_fname_split(talloc_tos(), fname, NULL,
						  &smb_fname);
	if (!NT_STATUS_IS_OK(status)) {
		errno = map_errno_from_nt_status(status);
		return -1;
	}

	ret = SMB_VFS_LSTAT(conn, smb_fname);
	if (ret != -1) {
		*psbuf = smb_fname->st;
	}

	TALLOC_FREE(smb_fname);
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"void aio_notify(AioContext *ctx)

{

    /* Write e.g. bh->scheduled before reading ctx->notify_me.  Pairs

     * with atomic_or in aio_ctx_prepare or atomic_add in aio_poll.

     */

    smp_mb();

    if (ctx->notify_me) {

        event_notifier_set(&ctx->notifier);

        atomic_mb_set(&ctx->notified, true);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"DeepTiledInputFile::DeepTiledInputFile (InputPartData* part) :
    _data (new Data (part->numThreads))
{
    _data->_deleteStream=false;
    multiPartInitialize(part);
}",1
Detect whether the following code contains vulnerabilities.,"void ieee80211_csa_finish(struct ieee80211_vif *vif)
{
	struct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);

	ieee80211_queue_work(&sdata->local->hw,
			     &sdata->csa_finalize_work);
}",0
Detect whether the following code contains vulnerabilities.,"bool general_log_write(THD *thd, enum enum_server_command command,
                       const char *query, uint query_length)
{
  /* Write the message to the log if we want to log this king of commands */
  if (logger.log_command(thd, command))
    return logger.general_log_write(thd, command, query, query_length);

  return FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"static int gen_set_psr_im(DisasContext *s, uint32_t mask, int spsr, uint32_t val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_movi_i32(tmp, val);

    return gen_set_psr(s, mask, spsr, tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"static QemuOpt *qemu_opt_find(QemuOpts *opts, const char *name)

{

    QemuOpt *opt;



    TAILQ_FOREACH(opt, &opts->head, next) {

        if (strcmp(opt->name, name) != 0)

            continue;

        return opt;

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"void ffv1_clear_slice_state(FFV1Context *f, FFV1Context *fs)

{

    int i, j;



    for (i = 0; i < f->plane_count; i++) {

        PlaneContext *p = &fs->plane[i];



        p->interlace_bit_state[0] = 128;

        p->interlace_bit_state[1] = 128;



        if (fs->ac) {

            if (f->initial_states[p->quant_table_index]) {

                memcpy(p->state, f->initial_states[p->quant_table_index],

                       CONTEXT_SIZE * p->context_count);

            } else

                memset(p->state, 128, CONTEXT_SIZE * p->context_count);

        } else {

            for (j = 0; j < p->context_count; j++) {

                p->vlc_state[j].drift     = 0;

                p->vlc_state[j].error_sum = 4;    //FFMAX((RANGE + 32)/64, 2);

                p->vlc_state[j].bias      = 0;

                p->vlc_state[j].count     = 1;

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"vmxnet3_dump_tx_descr(struct Vmxnet3_TxDesc *descr)

{

    VMW_PKPRN(""TX DESCR: ""

              ""addr %"" PRIx64 "", len: %d, gen: %d, rsvd: %d, ""

              ""dtype: %d, ext1: %d, msscof: %d, hlen: %d, om: %d, ""

              ""eop: %d, cq: %d, ext2: %d, ti: %d, tci: %d"",

              le64_to_cpu(descr->addr), descr->len, descr->gen, descr->rsvd,

              descr->dtype, descr->ext1, descr->msscof, descr->hlen, descr->om,

              descr->eop, descr->cq, descr->ext2, descr->ti, descr->tci);

}
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(linkinfo)
{
	char *link;
	size_t link_len;
	zend_stat_t sb;
	int ret;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p"", &link, &link_len) == FAILURE) {
		return;
	}

	ret = VCWD_STAT(link, &sb);
	if (ret == -1) {
		php_error_docref(NULL, E_WARNING, ""%s"", strerror(errno));
		RETURN_LONG(Z_L(-1));
	}

	RETURN_LONG((zend_long) sb.st_dev);
}",1
Detect whether the following code contains vulnerabilities.,"static void ivshmem_check_memdev_is_busy(Object *obj, const char *name,

                                         Object *val, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), &error_abort);

    if (memory_region_is_mapped(mr)) {

        char *path = object_get_canonical_path_component(val);

        error_setg(errp, ""can't use already busy memdev: %s"", path);

        g_free(path);

    } else {

        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
		const void *data, size_t datalen)
{
	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;

	if (*pdata == ctx->from) {
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {
        /* our verify callback function */
    SSL *ssl;
    CLI *c;

    /* retrieve application specific data */
    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,
        SSL_get_ex_data_X509_STORE_CTX_idx());
    c=SSL_get_ex_data(ssl, index_ssl_cli);

    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {
        s_log(LOG_INFO, ""Certificate verification disabled"");
        return 1; /* accept */
    }
    if(verify_checks(c, preverify_ok, callback_ctx)) {
        SSL_SESSION *sess=SSL_get1_session(c->ssl);
        if(sess) {
            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,
                (void *)(-1));
            SSL_SESSION_free(sess);
            if(!ok) {
                sslerror(""SSL_SESSION_set_ex_data"");
                return 0; /* reject */
            }
        }
        return 1; /* accept */
    }
    if(c->opt->option.client || c->opt->protocol)
        return 0; /* reject */
    if(c->opt->redirect_addr.names)
        return 1; /* accept */
    return 0; /* reject */
}",1
Detect whether the following code contains vulnerabilities.,"static void handle_s_without_atn(ESPState *s)
{
    int32_t cmdlen;

    if (s->dma && !s->dma_enabled) {
        s->dma_cb = handle_s_without_atn;
        return;
    }
    s->pdma_cb = s_without_satn_pdma_cb;
    cmdlen = get_cmd(s, ESP_CMDFIFO_SZ);
    if (cmdlen > 0) {
        s->cmdfifo_cdb_offset = 0;
        do_busid_cmd(s, 0);
    } else if (cmdlen == 0) {
        s->do_cmd = 1;
        /* Target present, but no cmd yet - switch to command phase */
        s->rregs[ESP_RSEQ] = SEQ_CD;
        s->rregs[ESP_RSTAT] = STAT_CD;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void  opj_j2k_write_float_to_float64(const void * p_src_data,
        void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
    OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
    OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
    OPJ_UINT32 i;
    OPJ_FLOAT64 l_temp;

    for (i = 0; i < p_nb_elem; ++i) {
        l_temp = (OPJ_FLOAT64) * (l_src_data++);

        opj_write_double(l_dest_data, l_temp);

        l_dest_data += sizeof(OPJ_FLOAT64);
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int decode_init_thread_copy(AVCodecContext *avctx)

{

    H264Context *h = avctx->priv_data;

    int ret;



    if (!avctx->internal->is_copy)

        return 0;

    memset(h->sps_buffers, 0, sizeof(h->sps_buffers));

    memset(h->pps_buffers, 0, sizeof(h->pps_buffers));



    ret = h264_init_context(avctx, h);

    if (ret < 0)

        return ret;



    h->context_initialized = 0;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static struct tree_entry *new_tree_entry(void)
{
	struct tree_entry *e;

	if (!avail_tree_entry) {
		unsigned int n = tree_entry_alloc;
		total_allocd += n * sizeof(struct tree_entry);
		avail_tree_entry = e = xmalloc(n * sizeof(struct tree_entry));
		while (n-- > 1) {
			*((void**)e) = e + 1;
			e++;
		}
		*((void**)e) = NULL;
	}

	e = avail_tree_entry;
	avail_tree_entry = *((void**)e);
	return e;
}",0
Detect whether the following code contains vulnerabilities.,"check_restricted(void)
{
    if (restricted)
    {
	emsg(_(""E145: Shell commands not allowed in rvim""));
	return TRUE;
    }
    return FALSE;
}",1
Detect whether the following code contains vulnerabilities.,"static void phys_page_set_level(PhysPageEntry *lp, target_phys_addr_t *index,

                                target_phys_addr_t *nb, uint16_t leaf,

                                int level)

{

    PhysPageEntry *p;

    int i;

    target_phys_addr_t step = (target_phys_addr_t)1 << (level * L2_BITS);



    if (!lp->is_leaf && lp->ptr == PHYS_MAP_NODE_NIL) {

        lp->ptr = phys_map_node_alloc();

        p = phys_map_nodes[lp->ptr];

        if (level == 0) {

            for (i = 0; i < L2_SIZE; i++) {

                p[i].is_leaf = 1;

                p[i].ptr = phys_section_unassigned;

            }

        }

    } else {

        p = phys_map_nodes[lp->ptr];

    }

    lp = &p[(*index >> (level * L2_BITS)) & (L2_SIZE - 1)];



    while (*nb && lp < &p[L2_SIZE]) {

        if ((*index & (step - 1)) == 0 && *nb >= step) {

            lp->is_leaf = true;

            lp->ptr = leaf;

            *index += step;

            *nb -= step;

        } else {

            phys_page_set_level(lp, index, nb, leaf, level - 1);

        }

        ++lp;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"    void Image::clearMetadata()
    {
        clearExifData();
        clearIptcData();
        clearXmpPacket();
        clearXmpData();
        clearComment();
        clearIccProfile();
    }",0
Detect whether the following code contains vulnerabilities.,"int bdrv_save_vmstate(BlockDriverState *bs, const uint8_t *buf,

                      int64_t pos, int size)

{

    QEMUIOVector qiov;

    struct iovec iov = {

        .iov_base   = (void *) buf,

        .iov_len    = size,

    };



    qemu_iovec_init_external(&qiov, &iov, 1);

    return bdrv_writev_vmstate(bs, &qiov, pos);

}
",0
Detect whether the following code contains vulnerabilities.,"static void mark_core_ids(struct mdesc_handle *hp, u64 mp,
			  int core_id)
{
	find_back_node_value(hp, mp, ""cpu"", __mark_core_id, core_id, 10);
}",0
Detect whether the following code contains vulnerabilities.,"SwsVector *sws_allocVec(int length)

{

    SwsVector *vec = av_malloc(sizeof(SwsVector));

    if (!vec)

        return NULL;

    vec->length = length;

    vec->coeff  = av_malloc(sizeof(double) * length);

    if (!vec->coeff)

        av_freep(&vec);

    return vec;

}
",0
Detect whether the following code contains vulnerabilities.,"static int finish_send (lua_State *L, int status, lua_KContext ctx) {
    if (lua_toboolean(L, -2))
        return 0;
    else
        return lua_error(L); /* uses idx 6 */
}",0
Detect whether the following code contains vulnerabilities.,"static int dummy_ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len)
{
	return -EAFNOSUPPORT;
}",1
Detect whether the following code contains vulnerabilities.,"int kvmppc_fixup_cpu(PowerPCCPU *cpu)

{

    CPUState *cs = CPU(cpu);

    int smt;



    /* Adjust cpu index for SMT */

    smt = kvmppc_smt_threads();

    cs->cpu_index = (cs->cpu_index / smp_threads) * smt

        + (cs->cpu_index % smp_threads);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);

	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;

		/* Zero header length */
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
		dev->netdev_ops = &tap_netdev_ops;
		/* Ethernet TAP Device */
		ether_setup(dev);

		random_ether_addr(dev->dev_addr);

		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}",1
Detect whether the following code contains vulnerabilities.,"
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype)
{
	struct sock_exterr_skb *serr;
	int err;

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);",1
Detect whether the following code contains vulnerabilities.,"static void phys_section_destroy(MemoryRegion *mr)
{
    bool have_sub_page = mr->subpage;

    if (have_sub_page) {
        subpage_t *subpage = container_of(mr, subpage_t, iomem);
        // object_unref(OBJECT(&subpage->iomem));
        g_free(subpage);
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int cr8_write_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	u8 cr8_prev = kvm_get_cr8(&svm->vcpu);
	/* instruction emulation calls kvm_set_cr8() */
	emulate_instruction(&svm->vcpu, 0, 0, 0);
	if (irqchip_in_kernel(svm->vcpu.kvm)) {
		svm->vmcb->control.intercept_cr_write &= ~INTERCEPT_CR8_MASK;
		return 1;
	}
	if (cr8_prev <= kvm_get_cr8(&svm->vcpu))
		return 1;
	kvm_run->exit_reason = KVM_EXIT_SET_TPR;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void do_notify_resume(struct pt_regs *regs, unsigned long orig_i0, unsigned long thread_info_flags)
{
	if (thread_info_flags & _TIF_SIGPENDING)
		do_signal(regs, orig_i0);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(regs);
	}
}",1
Detect whether the following code contains vulnerabilities.,"int do_netdev_del(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    const char *id = qdict_get_str(qdict, ""id"");

    VLANClientState *vc;



    vc = qemu_find_netdev(id);

    if (!vc || vc->info->type == NET_CLIENT_TYPE_NIC) {

        qerror_report(QERR_DEVICE_NOT_FOUND, id);

        return -1;

    }

    if (vc->peer) {

        qerror_report(QERR_DEVICE_IN_USE, id);

        return -1;

    }

    qemu_del_vlan_client(vc);

    qemu_opts_del(qemu_opts_find(&qemu_netdev_opts, id));

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gicv3_cpuif_el_change_hook(ARMCPU *cpu, void *opaque)

{

    /* Do nothing for now. */

}
",0
Detect whether the following code contains vulnerabilities.,"xmlSchemaNewValidCtxt(xmlSchemaPtr schema)
{
    xmlSchemaValidCtxtPtr ret;

    ret = (xmlSchemaValidCtxtPtr) xmlMalloc(sizeof(xmlSchemaValidCtxt));
    if (ret == NULL) {
        xmlSchemaVErrMemory(NULL, ""allocating validation context"", NULL);
        return (NULL);
    }
    memset(ret, 0, sizeof(xmlSchemaValidCtxt));
    ret->type = XML_SCHEMA_CTXT_VALIDATOR;
    ret->dict = xmlDictCreate();
    ret->nodeQNames = xmlSchemaItemListCreate();
    ret->schema = schema;
    return (ret);
}",0
Detect whether the following code contains vulnerabilities.,"static void *data_plane_thread(void *opaque)

{

    VirtIOBlockDataPlane *s = opaque;



    do {

        event_poll(&s->event_poll);

    } while (s->started || s->num_reqs > 0);

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void spapr_reset_htab(sPAPRMachineState *spapr)

{

    long shift;

    int index;



    shift = kvmppc_reset_htab(spapr->htab_shift);

    if (shift < 0) {

        error_setg(&error_abort, ""Failed to reset HTAB"");

    } else if (shift > 0) {

        if (shift != spapr->htab_shift) {

            error_setg(&error_abort, ""Requested HTAB allocation failed during reset"");

        }



        /* Tell readers to update their file descriptor */

        if (spapr->htab_fd >= 0) {

            spapr->htab_fd_stale = true;

        }

    } else {

        memset(spapr->htab, 0, HTAB_SIZE(spapr));



        for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {

            DIRTY_HPTE(HPTE(spapr->htab, index));

        }

    }



    /* Update the RMA size if necessary */

    if (spapr->vrma_adjust) {

        spapr->rma_size = kvmppc_rma_size(spapr_node0_size(),

                                          spapr->htab_shift);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_rfmci(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    /* Restore CPU state */

    gen_helper_rfmci(cpu_env);

    gen_sync_exception(ctx);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_jwt_rs_token(void)
{
	const char *error;

	if (skip_dcrypt)
		return;

	test_begin(""JWT RSA token"");
	/* write public key to file */
	oauth2_validation_key_cache_evict(key_cache, ""default"");
	save_key(""RS256"", rsa_public_key);

	buffer_t *tokenbuf = create_jwt_token(""RS256"");

	/* sign token */
	buffer_t *sig = t_buffer_create(64);
	struct dcrypt_private_key *key;
	if (!dcrypt_key_load_private(&key, rsa_private_key, NULL, NULL,
				     &error) ||
	    !dcrypt_sign(key, ""sha256"", DCRYPT_SIGNATURE_FORMAT_DSS,
			 tokenbuf->data, tokenbuf->used, sig,
			 DCRYPT_PADDING_RSA_PKCS1, &error)) {
		i_error(""dcrypt signing failed: %s"", error);
		lib_exit(1);
	}
	dcrypt_key_unref_private(&key);

	/* convert to base64 */
	buffer_append(tokenbuf, ""."", 1);
	base64url_encode(BASE64_ENCODE_FLAG_NO_PADDING, SIZE_MAX,
			 sig->data, sig->used, tokenbuf);

	test_jwt_token(str_c(tokenbuf));

	test_end();
}",0
Detect whether the following code contains vulnerabilities.,"static inline void clear_soft_dirty(struct vm_area_struct *vma,
		unsigned long addr, pte_t *pte)
{
}",0
Detect whether the following code contains vulnerabilities.,"static int grackle_pci_host_init(PCIDevice *d)

{

    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);

    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_MPC106);

    d->config[0x08] = 0x00; // revision

    d->config[0x09] = 0x01;

    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"isdn_net_addphone(isdn_net_ioctl_phone * phone)
{
	isdn_net_dev *p = isdn_net_findif(phone->name);
	isdn_net_phone *n;

	if (p) {
		if (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))
			return -ENOMEM;
		strcpy(n->num, phone->phone);
		n->next = p->local->phone[phone->outgoing & 1];
		p->local->phone[phone->outgoing & 1] = n;
		return 0;
	}
	return -ENODEV;
}",1
Detect whether the following code contains vulnerabilities.,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (16843009UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((16843009.0*quantum) >= 4294967295.0)
    return(4294967295UL);
  return((unsigned int) (16843009.0*quantum+0.5));
#endif
}",1
Detect whether the following code contains vulnerabilities.,"findoprnd(ITEM *ptr, int32 *pos)
{
#ifdef BS_DEBUG
	elog(DEBUG3, (ptr[*pos].type == OPR) ?
		 ""%d  %c"" : ""%d  %d"", *pos, ptr[*pos].val);
#endif
	if (ptr[*pos].type == VAL)
	{
		ptr[*pos].left = 0;
		(*pos)--;
	}
	else if (ptr[*pos].val == (int32) '!')
	{
		ptr[*pos].left = -1;
		(*pos)--;
		findoprnd(ptr, pos);
	}
	else
	{
		ITEM	   *curitem = &ptr[*pos];
		int32		tmp = *pos;

		(*pos)--;
		findoprnd(ptr, pos);
		curitem->left = *pos - tmp;
		findoprnd(ptr, pos);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static void avc_h_loop_filter_chroma422_mbaff_msa(uint8_t *src,

                                                  int32_t stride,

                                                  int32_t alpha_in,

                                                  int32_t beta_in,

                                                  int8_t *tc0)

{

    int32_t col, tc_val;

    int16_t out0, out1;

    v16u8 alpha, beta, res;



    alpha = (v16u8) __msa_fill_b(alpha_in);

    beta = (v16u8) __msa_fill_b(beta_in);



    for (col = 0; col < 4; col++) {

        tc_val = (tc0[col] - 1) + 1;



        if (tc_val <= 0) {

            src += 4 * stride;

            continue;

        }



        AVC_LPF_H_2BYTE_CHROMA_422(src, stride, tc_val, alpha, beta, res);



        out0 = __msa_copy_s_h((v8i16) res, 0);

        out1 = __msa_copy_s_h((v8i16) res, 1);



        STORE_HWORD((src - 1), out0);

        src += stride;

        STORE_HWORD((src - 1), out1);

        src += stride;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)

{

    unsigned int hash = kvm_hash_msi(msg.data);

    KVMMSIRoute *route;



    QTAILQ_FOREACH(route, &s->msi_hashtab[hash], entry) {

        if (route->kroute.u.msi.address_lo == (uint32_t)msg.address &&

            route->kroute.u.msi.address_hi == (msg.address >> 32) &&

            route->kroute.u.msi.data == msg.data) {

            return route;

        }

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"lua_call_throttle::~lua_call_throttle()
{
    if (!--lua->mixed_call_depth)
        lua_map.erase(lua->state());
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t _hostsock_recv(
    oe_fd_t* sock_,
    void* buf,
    size_t count,
    int flags)
{
    ssize_t ret = -1;
    sock_t* sock = _cast_sock(sock_);

    oe_errno = 0;

    if (!sock || (count && !buf))
        OE_RAISE_ERRNO(OE_EINVAL);

    if (buf)
    {
        if (oe_memset_s(buf, count, 0, count) != OE_OK)
            OE_RAISE_ERRNO(OE_EINVAL);
    }

    if (oe_syscall_recv_ocall(&ret, sock->host_fd, buf, count, flags) != OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"bgp_capability_as4 (struct peer *peer, struct capability_header *hdr)
{
  as_t as4 = stream_getl (BGP_INPUT(peer));
  
  if (BGP_DEBUG (as4, AS4))
    zlog_debug (""%s [AS4] about to set cap PEER_CAP_AS4_RCV, got as4 %u"",
                peer->host, as4);
  SET_FLAG (peer->cap, PEER_CAP_AS4_RCV);
  
  return as4;
}",1
Detect whether the following code contains vulnerabilities.,"void cpu_physical_memory_reset_dirty(ram_addr_t start, ram_addr_t end,

                                     int dirty_flags)

{

    CPUState *env;

    unsigned long length, start1;

    int i;



    start &= TARGET_PAGE_MASK;

    end = TARGET_PAGE_ALIGN(end);



    length = end - start;

    if (length == 0)

        return;

    cpu_physical_memory_mask_dirty_range(start, length, dirty_flags);



    /* we modify the TLB cache so that the dirty bit will be set again

       when accessing the range */

    start1 = (unsigned long)qemu_safe_ram_ptr(start);

    /* Chek that we don't span multiple blocks - this breaks the

       address comparisons below.  */

    if ((unsigned long)qemu_safe_ram_ptr(end - 1) - start1

            != (end - 1) - start) {

        abort();

    }



    for(env = first_cpu; env != NULL; env = env->next_cpu) {

        int mmu_idx;

        for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {

            for(i = 0; i < CPU_TLB_SIZE; i++)

                tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],

                                      start1, length);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t qio_channel_command_readv(QIOChannel *ioc,

                                         const struct iovec *iov,

                                         size_t niov,

                                         int **fds,

                                         size_t *nfds,

                                         Error **errp)

{

    QIOChannelCommand *cioc = QIO_CHANNEL_COMMAND(ioc);

    ssize_t ret;



 retry:

    ret = readv(cioc->readfd, iov, niov);

    if (ret < 0) {

        if (errno == EAGAIN ||

            errno == EWOULDBLOCK) {

            return QIO_CHANNEL_ERR_BLOCK;

        }

        if (errno == EINTR) {

            goto retry;

        }



        error_setg_errno(errp, errno,

                         ""Unable to read from command"");

        return -1;

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"srs_get_secret(srs_t *srs, int idx)
{
	if (idx < srs->numsecrets)
		return srs->secrets[idx];
	return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"int ff_lzw_decode_init(LZWState *p, int csize, uint8_t *buf, int buf_size, int mode)

{

    struct LZWState *s = (struct LZWState *)p;



    if(csize < 1 || csize > LZW_MAXBITS)

        return -1;

    /* read buffer */

    s->eob_reached = 0;

    s->pbuf = buf;

    s->ebuf = s->pbuf + buf_size;

    s->bbuf = 0;

    s->bbits = 0;

    s->bs = 0;



    /* decoder */

    s->codesize = csize;

    s->cursize = s->codesize + 1;

    s->curmask = mask[s->cursize];

    s->top_slot = 1 << s->cursize;

    s->clear_code = 1 << s->codesize;

    s->end_code = s->clear_code + 1;

    s->slot = s->newcodes = s->clear_code + 2;

    s->oc = s->fc = 0;

    s->sp = s->stack;



    s->mode = mode;

    switch(s->mode){

    case FF_LZW_GIF:

        s->extra_slot= 0;

        break;

    case FF_LZW_TIFF:

        s->extra_slot= 1;

        break;

    default:

        return -1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void count_usage(uint8_t *src, int width,

                        int height, uint32_t *counts)

{

    int i, j;



    for (j = 0; j < height; j++) {

        for (i = 0; i < width; i++) {

            counts[src[i]]++;

        }

        src += width;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int mxf_read_content_storage(MXFContext *mxf, ByteIOContext *pb, int tag)

{

    switch (tag) {

    case 0x1901:

        mxf->packages_count = get_be32(pb);

        if (mxf->packages_count >= UINT_MAX / sizeof(UID))

            return -1;

        mxf->packages_refs = av_malloc(mxf->packages_count * sizeof(UID));

        if (!mxf->packages_refs)

            return -1;

        url_fskip(pb, 4); /* useless size of objects, always 16 according to specs */

        get_buffer(pb, (uint8_t *)mxf->packages_refs, mxf->packages_count * sizeof(UID));

        break;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"allocsymkey(
	symkey **	bucket,
	keyid_t		id,
	u_short		flags,
	u_short		type,
	u_long		lifetime,
	u_short		secretsize,
	u_char *	secret
	)
{
	symkey *	sk;

	if (authnumfreekeys < 1)
		auth_moremem(-1);
	UNLINK_HEAD_SLIST(sk, authfreekeys, llink.f);
	DEBUG_ENSURE(sk != NULL);
	sk->keyid = id;
	sk->flags = flags;
	sk->type = type;
	sk->secretsize = secretsize;
	sk->secret = secret;
	sk->lifetime = lifetime;
	LINK_SLIST(*bucket, sk, hlink);
	LINK_TAIL_DLIST(key_listhead, sk, llink);
	authnumfreekeys--;
	authnumkeys++;
}",1
Detect whether the following code contains vulnerabilities.,"GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;

	if (ptr->size) {
		ptr->location = (char*)gf_malloc((u32) ptr->size);
		if (! ptr->location) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->location, (u32)ptr->size);
	}
	return GF_OK;
}",1
Detect whether the following code contains vulnerabilities.,"  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,
                            bufferlist& authorizer, bufferlist& authorizer_reply,
                            bool& isvalid, CryptoKey& session_key) override {
    isvalid = true;
    return true;
  }",1
Detect whether the following code contains vulnerabilities.,"TEST_F(ConnectionManagerUtilityTest, UseRemoteAddressWhenLocalHostRemoteAddress) {
  connection_.stream_info_.downstream_address_provider_->setRemoteAddress(
      std::make_shared<Network::Address::Ipv4Instance>(""127.0.0.1""));
  Network::Address::Ipv4Instance local_address(""10.3.2.1"");
  ON_CALL(config_, useRemoteAddress()).WillByDefault(Return(true));
  ON_CALL(config_, localAddress()).WillByDefault(ReturnRef(local_address));
  TestRequestHeaderMapImpl headers;

  EXPECT_EQ((MutateRequestRet{""127.0.0.1:0"", true, Tracing::Reason::NotTraceable}),
            callMutateRequestHeaders(headers, Protocol::Http2));
  EXPECT_EQ(local_address.ip()->addressAsString(), headers.get_(Headers::get().ForwardedFor));
}",0
Detect whether the following code contains vulnerabilities.,"static TCGv neon_load_scratch(int scratch)

{

    TCGv tmp = new_tmp();

    tcg_gen_ld_i32(tmp, cpu_env, offsetof(CPUARMState, vfp.scratch[scratch]));

    return tmp;

}
",1
Detect whether the following code contains vulnerabilities.,"allow_user_function (GDBusAuthObserver *observer,
                     GIOStream         *stream,
                     GCredentials      *credentials,
                     GdmSession        *self)
{
        uid_t client_uid;
        GPid  pid_of_client;

        client_uid = g_credentials_get_unix_user (credentials, NULL);
        if (client_uid == self->priv->allowed_user) {
                return TRUE;
        }

        g_debug (""GdmSession: User not allowed"");

        pid_of_client = g_credentials_get_unix_pid (credentials, NULL);
        g_signal_emit (G_OBJECT (self),
                       signals [CLIENT_REJECTED],
                       0,
                       credentials,
                       (guint)
                       pid_of_client);


        return FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"yuv2planeX_16_c_template(const int16_t *filter, int filterSize,

                         const int32_t **src, uint16_t *dest, int dstW,

                         int big_endian, int output_bits)

{

    int i;

    int shift = 15;

    av_assert0(output_bits == 16);



    for (i = 0; i < dstW; i++) {

        int val = 1 << (shift - 1);

        int j;



        /* range of val is [0,0x7FFFFFFF], so 31 bits, but with lanczos/spline

         * filters (or anything with negative coeffs, the range can be slightly

         * wider in both directions. To account for this overflow, we subtract

         * a constant so it always fits in the signed range (assuming a

         * reasonable filterSize), and re-add that at the end. */

        val -= 0x40000000;

        for (j = 0; j < filterSize; j++)

            val += src[j][i] * filter[j];



        output_pixel(&dest[i], val, 0x8000, int);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"R_API st64 r_buf_append_string(RBuffer *b, const char *str) {
	r_return_val_if_fail (b && str && !b->readonly, false);
	return r_buf_append_bytes (b, (const ut8 *)str, strlen (str));
}",0
Detect whether the following code contains vulnerabilities.,"bool CModule::LoadRegistry() {
    // CString sPrefix = (m_pUser) ? m_pUser->GetUserName() : "".global"";
    return (m_mssRegistry.ReadFromDisk(GetSavePath() + ""/.registry"") ==
            MCString::MCS_SUCCESS);
}",0
Detect whether the following code contains vulnerabilities.,"utf32le_mbc_to_code(const UChar* p, const UChar* end ARG_UNUSED)
{
  return (OnigCodePoint )(((p[3] * 256 + p[2]) * 256 + p[1]) * 256 + p[0]);
}",1
Detect whether the following code contains vulnerabilities.,"static void scalar32_min_max_xor(struct bpf_reg_state *dst_reg,
				 struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->s32_min_value;

	/* Assuming scalar64_min_max_xor will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get both minimum and maximum from the var32_off. */
	dst_reg->u32_min_value = var32_off.value;
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;

	if (dst_reg->s32_min_value >= 0 && smin_val >= 0) {
		/* XORing two positive sign numbers gives a positive,
		 * so safe to cast u32 result into s32.
		 */
		dst_reg->s32_min_value = dst_reg->u32_min_value;
		dst_reg->s32_max_value = dst_reg->u32_max_value;
	} else {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	}
}",1
Detect whether the following code contains vulnerabilities.,"int HtmlOutputDev::getOutlinePageNum(OutlineItem *item)
{
    const LinkAction *action   = item->getAction();
    const LinkGoTo   *link     = nullptr;
    LinkDest   *linkdest = nullptr;
    int         pagenum  = -1;

    if (!action || action->getKind() != actionGoTo)
        return pagenum;

    link = dynamic_cast<const LinkGoTo*>(action);

    if (!link || !link->isOk())
        return pagenum;

    if (link->getDest())
        linkdest = link->getDest()->copy();
    else if (link->getNamedDest())
        linkdest = catalog->findDest(link->getNamedDest());

    if (!linkdest)
        return pagenum;

    if (linkdest->isPageRef()) {
        Ref pageref = linkdest->getPageRef();
        pagenum = catalog->findPage(pageref.num, pageref.gen);
    } else {
        pagenum = linkdest->getPageNum();
    }

    delete linkdest;
    return pagenum;
}",0
Detect whether the following code contains vulnerabilities.,"copytoks (int tindex, int ntokens)
{
  int i;

  for (i = 0; i < ntokens; ++i)
    {
      addtok(dfa->tokens[tindex + i]);
      /* Update index into multibyte csets.  */
      if (MB_CUR_MAX > 1 && dfa->tokens[tindex + i] == MBCSET)
        dfa->multibyte_prop[dfa->tindex - 1] = dfa->multibyte_prop[tindex + i];
    }
}",1
Detect whether the following code contains vulnerabilities.,"mm_answer_sesskey(int sock, Buffer *m)
{
	BIGNUM *p;
	int rsafail;

	/* Turn off permissions */
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSKEY, 0);

	if ((p = BN_new()) == NULL)
		fatal(""%s: BN_new"", __func__);

	buffer_get_bignum2(m, p);

	rsafail = ssh1_session_key(p);

	buffer_clear(m);
	buffer_put_int(m, rsafail);
	buffer_put_bignum2(m, p);

	BN_clear_free(p);

	mm_request_send(sock, MONITOR_ANS_SESSKEY, m);

	/* Turn on permissions for sessid passing */
	monitor_permit(mon_dispatch, MONITOR_REQ_SESSID, 1);

	return (0);
}",0
Detect whether the following code contains vulnerabilities.,"Item_type_holder::Item_type_holder(THD *thd, Item *item)
  :Item(thd, item), enum_set_typelib(0), fld_type(get_real_type(item))
{
  DBUG_ASSERT(item->fixed);
  maybe_null= item->maybe_null;
  collation.set(item->collation);
  get_full_info(item);
  /* fix variable decimals which always is NOT_FIXED_DEC */
  if (Field::result_merge_type(fld_type) == INT_RESULT)
    decimals= 0;
  prev_decimal_int_part= item->decimal_int_part();
#ifdef HAVE_SPATIAL
  if (item->field_type() == MYSQL_TYPE_GEOMETRY)
    geometry_type= item->get_geometry_type();
#endif /* HAVE_SPATIAL */
}",0
Detect whether the following code contains vulnerabilities.,"static int avrcp_controller_probe(struct btd_service *service)
{
	struct btd_device *dev = btd_service_get_device(service);

	DBG(""path %s"", device_get_path(dev));

	return control_init_remote(service);
}",0
Detect whether the following code contains vulnerabilities.,"void qdev_prop_set_drive(DeviceState *dev, const char *name,

                         BlockBackend *value, Error **errp)

{

    object_property_set_str(OBJECT(dev), value ? blk_name(value) : """",

                            name, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"GF_Err schm_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *)s;

	ISOM_DECREASE_SIZE(ptr, 8);
	ptr->scheme_type = gf_bs_read_u32(bs);
	ptr->scheme_version = gf_bs_read_u32(bs);

	if (ptr->size && (ptr->flags & 0x000001)) {
		u32 len = (u32) (ptr->size);
		ptr->URI = (char*)gf_malloc(sizeof(char)*len);
		if (!ptr->URI) return GF_OUT_OF_MEM;
		gf_bs_read_data(bs, ptr->URI, len);
	}
	return GF_OK;
}",1
Detect whether the following code contains vulnerabilities.,"void palette8tobgr32(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

	{

		#ifdef WORDS_BIGENDIAN

			dst[3]= palette[ src[i]*4+0 ];

			dst[2]= palette[ src[i]*4+1 ];

			dst[1]= palette[ src[i]*4+2 ];

		#else

			//FIXME slow?

			dst[0]= palette[ src[i]*4+0 ];

			dst[1]= palette[ src[i]*4+1 ];

			dst[2]= palette[ src[i]*4+2 ];

			//dst[3]= 0; /* do we need this cleansing? */

		#endif



		dst+= 4;

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static int delete_path(const char *dump_dir_name)
{
    /* If doesn't start with ""g_settings_dump_location/""... */
    if (!dir_is_in_dump_location(dump_dir_name))
    {
        /* Then refuse to operate on it (someone is attacking us??) */
        error_msg(""Bad problem directory name '%s', should start with: '%s'"", dump_dir_name, g_settings_dump_location);
        return 400; /* Bad Request */
    }
    if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))
    {
        if (errno == ENOTDIR)
        {
            error_msg(""Path '%s' isn't problem directory"", dump_dir_name);
            return 404; /* Not Found */
        }
        error_msg(""Problem directory '%s' can't be accessed by user with uid %ld"", dump_dir_name, (long)client_uid);
        return 403; /* Forbidden */
    }

    delete_dump_dir(dump_dir_name);

    return 0; /* success */
}",1
Detect whether the following code contains vulnerabilities.,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}",1
Detect whether the following code contains vulnerabilities.,"path_poly(PG_FUNCTION_ARGS)
{
	PATH	   *path = PG_GETARG_PATH_P(0);
	POLYGON    *poly;
	int			size;
	int			i;

	/* This is not very consistent --- other similar cases return NULL ... */
	if (!path->closed)
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""open path cannot be converted to polygon"")));

	size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;
	poly = (POLYGON *) palloc(size);

	SET_VARSIZE(poly, size);
	poly->npts = path->npts;

	for (i = 0; i < path->npts; i++)
	{
		poly->p[i].x = path->p[i].x;
		poly->p[i].y = path->p[i].y;
	}

	make_bound_box(poly);

	PG_RETURN_POLYGON_P(poly);
}",1
Detect whether the following code contains vulnerabilities.,"  Component(int b, int l) : begin(b), len(l) {}",0
Detect whether the following code contains vulnerabilities.,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (unsigned long)opaque;

    QEMUFile *f;

    int c, ret;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        return;

    }



    f = qemu_fopen_socket(c);

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    ret = qemu_loadvm_state(f);

    if (ret < 0) {

        fprintf(stderr, ""load of migration failed\n"");

        goto out_fopen;

    }

    qemu_announce_self();

    DPRINTF(""successfully loaded vm state\n"");



    /* we've successfully migrated, close the server socket */

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    close(s);

    if (autostart)

        vm_start();



out_fopen:

    qemu_fclose(f);

out:

    close(c);

}
",0
Detect whether the following code contains vulnerabilities.,"MagickExport void DisassociateBlob(Image *image)
{
  BlobInfo
    *magick_restrict blob_info,
    *clone_info;

  MagickBooleanType
    clone;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->signature == MagickCoreSignature);
  blob_info=image->blob;
  clone=MagickFalse;
  LockSemaphoreInfo(blob_info->semaphore);
  assert(blob_info->reference_count >= 0);
  if (blob_info->reference_count > 1)
    clone=MagickTrue;
  UnlockSemaphoreInfo(blob_info->semaphore);
  if (clone == MagickFalse)
    return;
  clone_info=CloneBlobInfo(blob_info);
  DestroyBlob(image);
  image->blob=clone_info;
}",0
Detect whether the following code contains vulnerabilities.,"int qtree_scan_dquots(struct quota_handle *h,
		      int (*process_dquot) (struct dquot *, void *),
		      void *data)
{
	char *bitmap;
	struct v2_mem_dqinfo *v2info = &h->qh_info.u.v2_mdqi;
	struct qtree_mem_dqinfo *info = &v2info->dqi_qtree;
	struct dquot *dquot = get_empty_dquot();

	if (!dquot)
		return -1;

	dquot->dq_h = h;
	if (ext2fs_get_memzero((info->dqi_blocks + 7) >> 3, &bitmap)) {
		ext2fs_free_mem(&dquot);
		return -1;
	}
	v2info->dqi_used_entries = report_tree(dquot, QT_TREEOFF, 0, bitmap,
					       process_dquot, data);
	v2info->dqi_data_blocks = find_set_bits(bitmap, info->dqi_blocks);
	ext2fs_free_mem(&bitmap);
	ext2fs_free_mem(&dquot);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void xdr_buf_pages_copy_right(const struct xdr_buf *buf,
				     unsigned int base, unsigned int len,
				     unsigned int shift)
{
	const struct kvec *tail = buf->tail;
	unsigned int to = base + shift;
	unsigned int pglen = 0;
	unsigned int talen = 0, tato = 0;

	if (base >= buf->page_len)
		return;
	if (len > buf->page_len - base)
		len = buf->page_len - base;
	if (to >= buf->page_len) {
		tato = to - buf->page_len;
		if (tail->iov_len >= len + tato)
			talen = len;
		else if (tail->iov_len > tato)
			talen = tail->iov_len - tato;
	} else if (len + to >= buf->page_len) {
		pglen = buf->page_len - to;
		talen = len - pglen;
		if (talen > tail->iov_len)
			talen = tail->iov_len;
	} else
		pglen = len;

	_copy_from_pages(tail->iov_base + tato, buf->pages,
			 buf->page_base + base + pglen, talen);
	_shift_data_right_pages(buf->pages, buf->page_base + to,
				buf->page_base + base, pglen);
}",0
Detect whether the following code contains vulnerabilities.,  uint32_t get_canvas_width() const { return m_width; },0
Detect whether the following code contains vulnerabilities.,"void notify_other(int fd) {
	FILE* stream;
	int newfd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
	if (newfd == -1)
		errExit(""fcntl"");
	stream = fdopen(newfd, ""w"");
	fprintf(stream, ""arg_noroot=%d\n"", arg_noroot);
	fflush(stream);
	fclose(stream);
}",0
Detect whether the following code contains vulnerabilities.,"static void migration_bitmap_sync_range(ram_addr_t start, ram_addr_t length)

{

    migration_dirty_pages +=

        cpu_physical_memory_sync_dirty_bitmap(migration_bitmap, start, length);

}
",0
Detect whether the following code contains vulnerabilities.,"void tee_putc(int c, FILE *file)
{
#ifdef _WIN32
  if (my_win_is_console_cached(file))
    my_win_console_putc(charset_info, c);
  else
#endif
  putc(c, file);
  if (opt_outfile)
    putc(c, OUTFILE);
}",0
Detect whether the following code contains vulnerabilities.,"static int get_uint8_equal(QEMUFile *f, void *pv, size_t size,

                           VMStateField *field)

{

    uint8_t *v = pv;

    uint8_t v2;

    qemu_get_8s(f, &v2);



    if (*v == v2) {

        return 0;


    error_report(""%x != %x"", *v, v2);




    return -EINVAL;
",1
Detect whether the following code contains vulnerabilities.,"void comps_objrtree_data_destroy(COMPS_ObjRTreeData * rtd) {
    free(rtd->key);
    comps_object_destroy(rtd->data);
    comps_hslist_destroy(&rtd->subnodes);
    free(rtd);
}",0
Detect whether the following code contains vulnerabilities.,"static void bad_flp_intr(void)
{
	int err_count;

	if (probing) {
		drive_state[current_drive].probed_format++;
		if (!next_valid_format(current_drive))
			return;
	}
	err_count = ++(*errors);
	INFBOUND(write_errors[current_drive].badness, err_count);
	if (err_count > drive_params[current_drive].max_errors.abort)
		cont->done(0);
	if (err_count > drive_params[current_drive].max_errors.reset)
		fdc_state[current_fdc].reset = 1;
	else if (err_count > drive_params[current_drive].max_errors.recal)
		drive_state[current_drive].track = NEED_2_RECAL;
}",1
Detect whether the following code contains vulnerabilities.,"longlong Item_func_ge::val_int()
{
  DBUG_ASSERT(fixed == 1);
  int value= cmp.compare();
  return value >= 0 ? 1 : 0;
}",0
Detect whether the following code contains vulnerabilities.,"int LibarchivePlugin::extractionFlags() const
{
    int result = ARCHIVE_EXTRACT_TIME;
    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;

    // TODO: Don't use arksettings here
    /*if ( ArkSettings::preservePerms() )
    {
        result &= ARCHIVE_EXTRACT_PERM;
    }

    if ( !ArkSettings::extractOverwrite() )
    {
        result &= ARCHIVE_EXTRACT_NO_OVERWRITE;
    }*/

    return result;
}",1
Detect whether the following code contains vulnerabilities.,"static int __mincore_unmapped_range(unsigned long addr, unsigned long end,
				struct vm_area_struct *vma, unsigned char *vec)
{
	unsigned long nr = (end - addr) >> PAGE_SHIFT;
	int i;

	if (vma->vm_file) {
		pgoff_t pgoff;

		pgoff = linear_page_index(vma, addr);
		for (i = 0; i < nr; i++, pgoff++)
			vec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);
	} else {
		for (i = 0; i < nr; i++)
			vec[i] = 0;
	}
	return nr;
}",1
Detect whether the following code contains vulnerabilities.,"bool Server::MatchViewOrStatic(const std::string& method,
                               const std::string& url, bool* stream) {
  if (Router::MatchView(method, url, stream)) {
    return true;
  }

  // Try to match a static file.
  if (method == methods::kGet && !doc_root_.empty()) {
    fs::path path = doc_root_ / url;

    fs::error_code ec;
    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {
      return true;
    }
  }

  return false;
}",1
Detect whether the following code contains vulnerabilities.,"static void park_frame_worker_threads(FrameThreadContext *fctx, int thread_count)

{

    int i;



    for (i = 0; i < thread_count; i++) {

        PerThreadContext *p = &fctx->threads[i];



        if (p->state != STATE_INPUT_READY) {

            pthread_mutex_lock(&p->progress_mutex);

            while (p->state != STATE_INPUT_READY)

                pthread_cond_wait(&p->output_cond, &p->progress_mutex);

            pthread_mutex_unlock(&p->progress_mutex);

        }


    }

}",1
Detect whether the following code contains vulnerabilities.,"  void set_repertoire_from_value()
  {
    collation.repertoire= my_string_repertoire(str_value.charset(),
                                               str_value.ptr(),
                                               str_value.length());
  }",0
Detect whether the following code contains vulnerabilities.,"static av_always_inline int get_decoded_frame(AVFormatContext *fmt_ctx,

                                              AVFrame *frame, int *got_frame,

                                              AVPacket *pkt)

{

    AVCodecContext *dec_ctx = fmt_ctx->streams[pkt->stream_index]->codec;

    int ret = 0;



    *got_frame = 0;

    if (dec_ctx->codec) {

    switch (dec_ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

        ret = avcodec_decode_video2(dec_ctx, frame, got_frame, pkt);

        break;



    case AVMEDIA_TYPE_AUDIO:

        ret = avcodec_decode_audio4(dec_ctx, frame, got_frame, pkt);

        break;





    return ret;
",1
Detect whether the following code contains vulnerabilities.,"NTSTATUS smb2cli_session_encryption_on(struct smbXcli_session *session)
{
	if (session->smb2->should_encrypt) {
		return NT_STATUS_OK;
	}

	if (session->conn->protocol < PROTOCOL_SMB2_24) {
		return NT_STATUS_NOT_SUPPORTED;
	}

	if (session->conn->smb2.server.cipher == 0) {
		return NT_STATUS_NOT_SUPPORTED;
	}

	if (session->smb2->signing_key.data == NULL) {
		return NT_STATUS_NOT_SUPPORTED;
	}
	session->smb2->should_encrypt = true;
	return NT_STATUS_OK;
}",1
Detect whether the following code contains vulnerabilities.,"static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)

{

    struct ibv_port_attr port;



    if (ibv_query_port(verbs, 1, &port)) {

        fprintf(stderr, ""FAILED TO QUERY PORT INFORMATION!\n"");

        return;

    }



    printf(""%s RDMA Device opened: kernel name %s ""

           ""uverbs device name %s, ""

           ""infiniband_verbs class device path %s, ""

           ""infiniband class device path %s, ""

           ""transport: (%d) %s\n"",

                who,

                verbs->device->name,

                verbs->device->dev_name,

                verbs->device->dev_path,

                verbs->device->ibdev_path,

                port.link_layer,

                (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? ""Infiniband"" :

                 ((port.link_layer == IBV_LINK_LAYER_ETHERNET) 

                    ? ""Ethernet"" : ""Unknown""));

}
",1
Detect whether the following code contains vulnerabilities.,"grammar_current_rule_prec_set (symbol *precsym, location loc)
{
  /* POSIX says that any identifier is a nonterminal if it does not
     appear on the LHS of a grammar rule and is not defined by %token
     or by one of the directives that assigns precedence to a token.
     We ignore this here because the only kind of identifier that
     POSIX allows to follow a %prec is a token and because assuming
     it's a token now can produce more logical error messages.
     Nevertheless, grammar_rule_check_and_complete does obey what we
     believe is the real intent of POSIX here: that an error be
     reported for any identifier that appears after %prec but that is
     not defined separately as a token.  */
  symbol_class_set (precsym, token_sym, loc, false);
  if (current_rule->ruleprec)
    duplicate_rule_directive (""%prec"",
                              current_rule->ruleprec->location, loc);
  else
    current_rule->ruleprec = precsym;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t mp_dacl_getxattr(FsContext *ctx, const char *path,

                                const char *name, void *value, size_t size)

{

    char *buffer;

    ssize_t ret;



    buffer = rpath(ctx, path);

    ret = lgetxattr(buffer, MAP_ACL_DEFAULT, value, size);

    g_free(buffer);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"int coroutine_fn bdrv_is_allocated(BlockDriverState *bs, int64_t offset,

                                   int64_t bytes, int64_t *pnum)

{

    BlockDriverState *file;

    int64_t sector_num = offset >> BDRV_SECTOR_BITS;

    int nb_sectors = bytes >> BDRV_SECTOR_BITS;

    int64_t ret;

    int psectors;



    assert(QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE));

    assert(QEMU_IS_ALIGNED(bytes, BDRV_SECTOR_SIZE) && bytes < INT_MAX);

    ret = bdrv_get_block_status(bs, sector_num, nb_sectors, &psectors,

                                &file);

    if (ret < 0) {

        return ret;

    }

    if (pnum) {

        *pnum = psectors * BDRV_SECTOR_SIZE;

    }

    return !!(ret & BDRV_BLOCK_ALLOCATED);

}
",0
Detect whether the following code contains vulnerabilities.,"using_utf8 (void)
{
  static int utf8 = -1;
  if (utf8 == -1)
    {
#if defined HAVE_LANGINFO_CODESET && MBS_SUPPORT
      utf8 = (STREQ (nl_langinfo (CODESET), ""UTF-8""));
#else
      utf8 = 0;
#endif
    }

  return utf8;
}",0
Detect whether the following code contains vulnerabilities.,"static krb5_error_code hdb_samba4_create(krb5_context context, struct HDB **db, const char *arg)
{
	NTSTATUS nt_status;
	void *ptr = NULL;
	struct samba_kdc_base_context *base_ctx = NULL;

	if (sscanf(arg, ""&%p"", &ptr) != 1) {
		return EINVAL;
	}

	base_ctx = talloc_get_type_abort(ptr, struct samba_kdc_base_context);

	/* The global kdc_mem_ctx and kdc_lp_ctx, Disgusting, ugly hack, but it means one less private hook */
	nt_status = hdb_samba4_create_kdc(base_ctx, context, db);

	if (NT_STATUS_IS_OK(nt_status)) {
		return 0;
	} else if (NT_STATUS_EQUAL(nt_status, NT_STATUS_ERROR_DS_INCOMPATIBLE_VERSION)) {
		return EINVAL;
	} else if (NT_STATUS_EQUAL(nt_status, NT_STATUS_CANT_ACCESS_DOMAIN_INFO)) {
		
		krb5_set_error_message(context, EINVAL, ""Failed to open Samba4 LDB at %s"", lpcfg_private_path(base_ctx, base_ctx->lp_ctx, ""sam.ldb""));
	} else {
		krb5_set_error_message(context, EINVAL, ""Failed to connect to Samba4 DB: %s (%s)"", get_friendly_nt_error_msg(nt_status), nt_errstr(nt_status));
	}

	return EINVAL;
}",1
Detect whether the following code contains vulnerabilities.,"static int get_stats(AVCodecContext *avctx, int eos)

{

#ifdef TH_ENCCTL_2PASS_OUT

    TheoraContext *h = avctx->priv_data;

    uint8_t *buf;

    int bytes;



    bytes = th_encode_ctl(h->t_state, TH_ENCCTL_2PASS_OUT, &buf, sizeof(buf));

    if (bytes < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting first pass stats\n"");

        return AVERROR_EXTERNAL;

    }

    if (!eos) {

        void *tmp = av_fast_realloc(h->stats, &h->stats_size,

                                   h->stats_offset + bytes);

        if (!tmp)


        h->stats = tmp;

        memcpy(h->stats + h->stats_offset, buf, bytes);

        h->stats_offset += bytes;

    } else {

        int b64_size = AV_BASE64_SIZE(h->stats_offset);

        // libtheora generates a summary header at the end

        memcpy(h->stats, buf, bytes);

        avctx->stats_out = av_malloc(b64_size);



        av_base64_encode(avctx->stats_out, b64_size, h->stats, h->stats_offset);

    }

    return 0;

#else

    av_log(avctx, AV_LOG_ERROR, ""libtheora too old to support 2pass\n"");

    return AVERROR(ENOSUP);

#endif

}",1
Detect whether the following code contains vulnerabilities.,"int Field_blob::store(double nr)
{
  CHARSET_INFO *cs=charset();
  value.set_real(nr, NOT_FIXED_DEC, cs);
  return Field_blob::store(value.ptr(),(uint) value.length(), cs);
}",0
Detect whether the following code contains vulnerabilities.,"static void i82374_isa_realize(DeviceState *dev, Error **errp)

{

    ISAi82374State *isa = I82374(dev);

    I82374State *s = &isa->state;

    PortioList *port_list = g_new(PortioList, 1);



    portio_list_init(port_list, OBJECT(isa), i82374_portio_list, s, ""i82374"");

    portio_list_add(port_list, isa_address_space_io(&isa->parent_obj),

                    isa->iobase);



    i82374_realize(s, errp);



    qdev_init_gpio_out(dev, &s->out, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"int mysql_real_query_for_lazy(const char *buf, int length)
{
  for (uint retry=0;; retry++)
  {
    int error;
    if (!mysql_real_query(&mysql,buf,length))
      return 0;
    error= put_error(&mysql);
    if (mysql_errno(&mysql) != CR_SERVER_GONE_ERROR || retry > 1 ||
        !opt_reconnect)
      return error;
    if (reconnect())
      return error;
  }
}",0
Detect whether the following code contains vulnerabilities.,"static inline int nl_portid_hash_dilute(struct nl_portid_hash *hash, int len)
{
	int avg = hash->entries >> hash->shift;

	if (unlikely(avg > 1) && nl_portid_hash_rehash(hash, 1))
		return 1;

	if (unlikely(len > avg) && time_after(jiffies, hash->rehash_time)) {
		nl_portid_hash_rehash(hash, 0);
		return 1;
	}

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void gain_compensate(COOKContext *q, cook_gains *gains_ptr,

                            float* previous_buffer)

{

    const float fc = q->pow2tab[gains_ptr->previous[0] + 63];

    float *buffer = q->mono_mdct_output;

    int i;



    /* Overlap with the previous block. */

    for(i=0 ; i<q->samples_per_channel ; i++) {

        buffer[i] *= fc;

        buffer[i] += previous_buffer[i];

    }



    /* Apply gain profile */

    for (i = 0; i < 8; i++) {

        if (gains_ptr->now[i] || gains_ptr->now[i + 1])

            interpolate(q, &buffer[q->gain_size_factor * i],

                        gains_ptr->now[i], gains_ptr->now[i + 1]);

    }



    /* Save away the current to be previous block. */

    memcpy(previous_buffer, buffer+q->samples_per_channel,

           sizeof(float)*q->samples_per_channel);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline const u32 *flow_keys_hash_start(const struct flow_keys *flow)
{
	const void *p = flow;

	BUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));
	return (const u32 *)(p + FLOW_KEYS_HASH_OFFSET);
}",1
Detect whether the following code contains vulnerabilities.,"static int rtw_wx_set_freq(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu, char *extra)
{
	RT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, (""+%s\n"", __func__));
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void in_asm_used_var_warning_killer()

{

 volatile int i= yCoeff+vrCoeff+ubCoeff+vgCoeff+ugCoeff+bF8+bFC+w400+w80+w10+

 bm00001111+bm00000111+bm11111000+b16Mask+g16Mask+r16Mask+b15Mask+g15Mask+r15Mask+asm_yalpha1+ asm_uvalpha1+

 M24A+M24B+M24C+w02 + b5Dither+g5Dither+r5Dither+g6Dither+dither4[0]+dither8[0];

 if(i) i=0;

}
",0
Detect whether the following code contains vulnerabilities.,"_hb_ot_layout_init (hb_face_t *face)
{
  hb_ot_layout_t *layout = &face->ot_layout;

  layout->gdef_blob = Sanitizer<GDEF>::sanitize (hb_face_get_table (face, HB_OT_TAG_GDEF));
  layout->gdef = &Sanitizer<GDEF>::lock_instance (layout->gdef_blob);

  layout->gsub_blob = Sanitizer<GSUB>::sanitize (hb_face_get_table (face, HB_OT_TAG_GSUB));
  layout->gsub = &Sanitizer<GSUB>::lock_instance (layout->gsub_blob);

  layout->gpos_blob = Sanitizer<GPOS>::sanitize (hb_face_get_table (face, HB_OT_TAG_GPOS));
  layout->gpos = &Sanitizer<GPOS>::lock_instance (layout->gpos_blob);
}",1
Detect whether the following code contains vulnerabilities.,"DLLEXPORT unsigned long tjBufSize(int width, int height, int jpegSubsamp)
{
  unsigned long retval = 0;
  int mcuw, mcuh, chromasf;

  if (width < 1 || height < 1 || jpegSubsamp < 0 || jpegSubsamp >= NUMSUBOPT)
    THROWG(""tjBufSize(): Invalid argument"");

  /* This allows for rare corner cases in which a JPEG image can actually be
     larger than the uncompressed input (we wouldn't mention it if it hadn't
     happened before.) */
  mcuw = tjMCUWidth[jpegSubsamp];
  mcuh = tjMCUHeight[jpegSubsamp];
  chromasf = jpegSubsamp == TJSAMP_GRAY ? 0 : 4 * 64 / (mcuw * mcuh);
  retval = PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;

bailout:
  return retval;
}",1
Detect whether the following code contains vulnerabilities.,"static void imc_get_coeffs(AVCodecContext *avctx,

                           IMCContext *q, IMCChannel *chctx)

{

    int i, j, cw_len, cw;



    for (i = 0; i < BANDS; i++) {

        if (!chctx->sumLenArr[i])

            continue;

        if (chctx->bandFlagsBuf[i] || chctx->bandWidthT[i]) {

            for (j = band_tab[i]; j < band_tab[i + 1]; j++) {

                cw_len = chctx->CWlengthT[j];

                cw = 0;



                if (cw_len && (!chctx->bandFlagsBuf[i] || !chctx->skipFlags[j])) {

                    if (get_bits_count(&q->gb) + cw_len > 512) {

                        av_log(avctx, AV_LOG_WARNING,

                            ""Potential problem on band %i, coefficient %i""

                            "": cw_len=%i\n"", i, j, cw_len);

                    }



                    cw = get_bits(&q->gb, cw_len);

                }



                chctx->codewords[j] = cw;

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"flatpak_proxy_client_init (FlatpakProxyClient *client)
{
  init_side (client, &client->client_side);
  init_side (client, &client->bus_side);

  client->auth_end_offset = AUTH_END_INIT_OFFSET;
  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t last_change_ms_show(struct device *dev,
				   struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);

	return sprintf(buf, ""%lld\n"", ktime_to_ms(ws->last_time));
}",1
Detect whether the following code contains vulnerabilities.,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;

    int64_t expire_time;



    pmsts = get_pmsts(s);

    sci_level = (((pmsts & s->pmen) &

                  (RTC_EN | PWRBTN_EN | GBL_EN | TMROF_EN)) != 0);

    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    if ((s->pmen & TMROF_EN) && !(pmsts & TMROF_EN)) {

        expire_time = muldiv64(s->tmr_overflow_time, ticks_per_sec, PM_FREQ);

        qemu_mod_timer(s->tmr_timer, expire_time);

        s->tmr_overflow_time += 0x800000;

    } else {

        qemu_del_timer(s->tmr_timer);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"PHP_METHOD(Phar, offsetExists)
{
	char *fname;
	size_t fname_len;
	phar_entry_info *entry;

	PHAR_ARCHIVE_OBJECT();

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"", &fname, &fname_len) == FAILURE) {
		return;
	}

	if (zend_hash_str_exists(&phar_obj->archive->manifest, fname, (uint) fname_len)) {
		if (NULL != (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, fname, (uint) fname_len))) {
			if (entry->is_deleted) {
				/* entry is deleted, but has not been flushed to disk yet */
				RETURN_FALSE;
			}
		}

		if (fname_len >= sizeof("".phar"")-1 && !memcmp(fname, "".phar"", sizeof("".phar"")-1)) {
			/* none of these are real files, so they don't exist */
			RETURN_FALSE;
		}
		RETURN_TRUE;
	} else {
		if (zend_hash_str_exists(&phar_obj->archive->virtual_dirs, fname, (uint) fname_len)) {
			RETURN_TRUE;
		}
		RETURN_FALSE;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static int vt_disallocate(unsigned int vc_num)
{
	struct vc_data *vc = NULL;
	int ret = 0;

	console_lock();
	if (vt_busy(vc_num))
		ret = -EBUSY;
	else if (vc_num)
		vc = vc_deallocate(vc_num);
	console_unlock();

	if (vc && vc_num >= MIN_NR_CONSOLES) {
		tty_port_destroy(&vc->port);
		kfree(vc);
	}

	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"
static void io_sq_thread_parkme(struct io_sq_data *sqd)
{
	for (;;) {
		/*
		 * TASK_PARKED is a special state; we must serialize against
		 * possible pending wakeups to avoid store-store collisions on
		 * task->state.
		 *
		 * Such a collision might possibly result in the task state
		 * changin from TASK_PARKED and us failing the
		 * wait_task_inactive() in kthread_park().
		 */
		set_special_state(TASK_PARKED);
		if (!test_bit(IO_SQ_THREAD_SHOULD_PARK, &sqd->state))
			break;

		/*
		 * Thread is going to call schedule(), do not preempt it,
		 * or the caller of kthread_park() may spend more time in
		 * wait_task_inactive().
		 */
		preempt_disable();
		complete(&sqd->completion);
		schedule_preempt_disabled();
		preempt_enable();
	}
	__set_current_state(TASK_RUNNING);",0
Detect whether the following code contains vulnerabilities.,"static apr_status_t unschedule_slow_tasks(h2_mplx *m) 
{
    h2_stream *stream;
    int n;
    
    /* Try to get rid of streams that occupy workers. Look for safe requests
     * that are repeatable. If none found, fail the connection.
     */
    n = (m->tasks_active - m->limit_active - (int)h2_ihash_count(m->sredo));
    while (n > 0 && (stream = get_latest_repeatable_unsubmitted_stream(m))) {
        h2_task_rst(stream->task, H2_ERR_CANCEL);
        h2_ihash_add(m->sredo, stream);
        --n;
    }
    
    if ((m->tasks_active - h2_ihash_count(m->sredo)) > m->limit_active) {
        stream = get_timed_out_busy_stream(m);
        if (stream) {
            /* Too many busy workers, unable to cancel enough streams
             * and with a busy, timed out stream, we tell the client
             * to go away... */
            return APR_TIMEUP;
        }
    }
    return APR_SUCCESS;
}",1
Detect whether the following code contains vulnerabilities.,"static bool cmd_read_pio(IDEState *s, uint8_t cmd)

{

    bool lba48 = (cmd == WIN_READ_EXT);



    if (s->drive_kind == IDE_CD) {

        ide_set_signature(s); /* odd, but ATA4 8.27.5.2 requires it */

        ide_abort_command(s);

        return true;

    }



    if (!s->bs) {

        ide_abort_command(s);

        return true;

    }



    ide_cmd_lba48_transform(s, lba48);

    s->req_nb_sectors = 1;

    ide_sector_read(s);



    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_balloon_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);

    dc->exit = virtio_balloon_device_exit;

    dc->props = virtio_balloon_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->init = virtio_balloon_device_init;

    vdc->get_config = virtio_balloon_get_config;

    vdc->set_config = virtio_balloon_set_config;

    vdc->get_features = virtio_balloon_get_features;

}
",1
Detect whether the following code contains vulnerabilities.,"int security_sem_alloc(struct sem_array *sma)
{
	return security_ops->sem_alloc_security(sma);
}",0
Detect whether the following code contains vulnerabilities.,"static coroutine_fn int qemu_gluster_co_flush_to_disk(BlockDriverState *bs)

{

    int ret;

    GlusterAIOCB acb;

    BDRVGlusterState *s = bs->opaque;



    acb.size = 0;

    acb.ret = 0;

    acb.coroutine = qemu_coroutine_self();

    acb.aio_context = bdrv_get_aio_context(bs);



    ret = glfs_fsync_async(s->fd, gluster_finish_aiocb, &acb);

    if (ret < 0) {

        return -errno;

    }



    qemu_coroutine_yield();

    return acb.ret;

}
",1
Detect whether the following code contains vulnerabilities.,"TEST_F(OwnedImplTest, PrependBuffer) {
  std::string suffix = ""World!"", prefix = ""Hello, "";
  Buffer::OwnedImpl buffer;
  buffer.add(suffix);
  Buffer::OwnedImpl prefixBuffer;
  prefixBuffer.add(prefix);

  buffer.prepend(prefixBuffer);

  EXPECT_EQ(suffix.size() + prefix.size(), buffer.length());
  EXPECT_EQ(prefix + suffix, buffer.toString());
  EXPECT_EQ(0, prefixBuffer.length());
}",0
Detect whether the following code contains vulnerabilities.,"	if(pvals == NULL) {
		LogError(0, RS_RET_MISSING_CNFPARAMS,
			        ""imhttp: required parameter are missing\n"");
		ABORT_FINALIZE(RS_RET_MISSING_CNFPARAMS);
	}",0
Detect whether the following code contains vulnerabilities.,"static void gen_abso(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    int l3 = gen_new_label();

    /* Start with XER OV disabled, the most likely case */

    tcg_gen_movi_tl(cpu_ov, 0);

    tcg_gen_brcondi_tl(TCG_COND_GE, cpu_gpr[rA(ctx->opcode)], 0, l2);

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_gpr[rA(ctx->opcode)], 0x80000000, l1);

    tcg_gen_movi_tl(cpu_ov, 1);

    tcg_gen_movi_tl(cpu_so, 1);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l3);

    gen_set_label(l2);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    gen_set_label(l3);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);

}
",0
Detect whether the following code contains vulnerabilities.,"QEMUTimerList *qemu_clock_get_main_loop_timerlist(QEMUClockType type)

{

    return main_loop_tlg.tl[type];

}
",0
Detect whether the following code contains vulnerabilities.,"FileSpec::FileSpec(const Object *fileSpecA)
{
  ok = true;
  fileName = nullptr;
  platformFileName = nullptr;
  embFile = nullptr;
  desc = nullptr;
  fileSpec = fileSpecA->copy();

  Object obj1 = getFileSpecName(fileSpecA);
  if (!obj1.isString()) {
    ok = false;
    error(errSyntaxError, -1, ""Invalid FileSpec"");
    return;
  }

  fileName = obj1.getString()->copy();

  if (fileSpec.isDict()) {
    obj1 = fileSpec.dictLookup(""EF"");
    if (obj1.isDict()) {
      fileStream = obj1.dictLookupNF(""F"");
      if (!fileStream.isRef()) {
        ok = false;
        fileStream.setToNull();
        error(errSyntaxError, -1, ""Invalid FileSpec: Embedded file stream is not an indirect reference"");
        return;
      }
    }
  }

  obj1 = fileSpec.dictLookup(""Desc"");
  if (obj1.isString())
    desc = obj1.getString()->copy();
}",1
Detect whether the following code contains vulnerabilities.,"static int rndis_keepalive_response(struct rndis_params *params,
				    rndis_keepalive_msg_type *buf)
{
	rndis_keepalive_cmplt_type *resp;
	rndis_resp_t *r;

	/* host ""should"" check only in RNDIS_DATA_INITIALIZED state */

	r = rndis_add_response(params, sizeof(rndis_keepalive_cmplt_type));
	if (!r)
		return -ENOMEM;
	resp = (rndis_keepalive_cmplt_type *)r->buf;

	resp->MessageType = cpu_to_le32(RNDIS_MSG_KEEPALIVE_C);
	resp->MessageLength = cpu_to_le32(16);
	resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
	resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);

	params->resp_avail(params->v);
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold int common_init(AVCodecContext *avctx){

    FFV1Context *s = avctx->priv_data;



    s->avctx= avctx;

    s->flags= avctx->flags;



    avcodec_get_frame_defaults(&s->picture);



    ff_dsputil_init(&s->dsp, avctx);



    s->width = avctx->width;

    s->height= avctx->height;



    assert(s->width && s->height);

    //defaults

    s->num_h_slices=1;

    s->num_v_slices=1;





    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"have_createrole_privilege(void)
{
	return has_createrole_privilege(GetUserId());
}",0
Detect whether the following code contains vulnerabilities.,"int ssh_scp_accept_request(ssh_scp scp){
  char buffer[]={0x00};
  int err;
  if(scp==NULL)
      return SSH_ERROR;
  if(scp->state != SSH_SCP_READ_REQUESTED){
    ssh_set_error(scp->session,SSH_FATAL,""ssh_scp_deny_request called under invalid state"");
    return SSH_ERROR;
  }
  err=ssh_channel_write(scp->channel,buffer,1);
  if(err==SSH_ERROR) {
    return SSH_ERROR;
  }
  if(scp->request_type==SSH_SCP_REQUEST_NEWFILE)
    scp->state=SSH_SCP_READ_READING;
  else
    scp->state=SSH_SCP_READ_INITED;
  return SSH_OK;
}",1
Detect whether the following code contains vulnerabilities.,"iscsi_synccache10_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status != 0) {

        if (status == SCSI_STATUS_CHECK_CONDITION

            && acb->task->sense.key == SCSI_SENSE_UNIT_ATTENTION

            && acb->retries-- > 0) {

            if (acb->task != NULL) {

                scsi_free_scsi_task(acb->task);

                acb->task = NULL;

            }

            if (iscsi_aio_flush_acb(acb) == 0) {

                iscsi_set_events(acb->iscsilun);

                return;

            }

        }

        error_report(""Failed to sync10 data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
",0
Detect whether the following code contains vulnerabilities.,"TEST_P(SdsDynamicDownstreamIntegrationTest, WrongSecretFirst) {
  on_server_init_function_ = [this]() {
    createSdsStream(*(fake_upstreams_[1]));
    sendSdsResponse(getWrongSecret(server_cert_));
  };
  initialize();

  codec_client_ = makeRawHttpConnection(makeSslClientConnection());
  // the connection state is not connected.
  EXPECT_FALSE(codec_client_->connected());
  codec_client_->connection()->close(Network::ConnectionCloseType::NoFlush);

  sendSdsResponse(getServerSecret());

  // Wait for ssl_context_updated_by_sds counter.
  test_server_->waitForCounterGe(
      listenerStatPrefix(""server_ssl_socket_factory.ssl_context_update_by_sds""), 1);

  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {
    return makeSslClientConnection();
  };
  testRouterHeaderOnlyRequestAndResponse(&creator);
}",1
Detect whether the following code contains vulnerabilities.,"static void migrate_fd_monitor_suspend(MigrationState *s, Monitor *mon)

{

    if (monitor_suspend(mon) == 0) {

        DPRINTF(""suspending monitor\n"");

    } else {

        monitor_printf(mon, ""terminal does not allow synchronous ""

                       ""migration, continuing detached\n"");

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(rgb24ToY)(uint8_t *dst, const uint8_t *src, long width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_RGB24);

#else

    int i;

    for (i=0; i<width; i++) {

        int r= src[i*3+0];

        int g= src[i*3+1];

        int b= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
{
	memcpy(&p->id, &x->id, sizeof(p->id));
	memcpy(&p->sel, &x->sel, sizeof(p->sel));
	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}",1
Detect whether the following code contains vulnerabilities.,"static void ahci_irq_raise(AHCIState *s, AHCIDevice *dev)

{

    AHCIPCIState *d = container_of(s, AHCIPCIState, ahci);

    PCIDevice *pci_dev =

        (PCIDevice *)object_dynamic_cast(OBJECT(d), TYPE_PCI_DEVICE);



    DPRINTF(0, ""raise irq\n"");



    if (pci_dev && msi_enabled(pci_dev)) {

        msi_notify(pci_dev, 0);

    } else {

        qemu_irq_raise(s->irq);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"MemoryRegionSection *phys_page_find(target_phys_addr_t index)

{

    PhysPageEntry lp = phys_map;

    PhysPageEntry *p;

    int i;

    uint16_t s_index = phys_section_unassigned;



    for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) {

        if (lp.ptr == PHYS_MAP_NODE_NIL) {

            goto not_found;

        }

        p = phys_map_nodes[lp.ptr];

        lp = p[(index >> (i * L2_BITS)) & (L2_SIZE - 1)];

    }



    s_index = lp.ptr;

not_found:

    return &phys_sections[s_index];

}
",0
Detect whether the following code contains vulnerabilities.,"static void nvme_set_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);

    int32_t boot_index;

    Error *local_err = NULL;



    visit_type_int32(v, &boot_index, name, &local_err);

    if (local_err) {

        goto out;

    }

    /* check whether bootindex is present in fw_boot_order list  */

    check_boot_index(boot_index, &local_err);

    if (local_err) {

        goto out;

    }

    /* change bootindex to a new one */

    s->conf.bootindex = boot_index;



out:

    if (local_err) {

        error_propagate(errp, local_err);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"TEST(Url, ParsingForConnectTest) {
  validateConnectUrl(""host.com:443"", ""host.com:443"", 443);
  validateConnectUrl(""host.com:80"", ""host.com:80"", 80);
}",1
Detect whether the following code contains vulnerabilities.,"void rtnl_kfree_skbs(struct sk_buff *head, struct sk_buff *tail)
{
	if (head && tail) {
		tail->next = defer_kfree_skb_list;
		defer_kfree_skb_list = head;
	}
}",0
Detect whether the following code contains vulnerabilities.,"static inline int sym_quant(int c, int e, int levels)

{

    int v = ((((levels * c) >> (24 - e)) + 1) >> 1) + (levels >> 1);

    av_assert2(v >= 0 && v < levels);

    return v;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int m101_decode_init(AVCodecContext *avctx)

{

    if (avctx->extradata_size < 6*4)

        return AVERROR_INVALIDDATA;



    if (avctx->extradata[2*4] == 10)

        avctx->pix_fmt = AV_PIX_FMT_YUV422P10;

    else

        avctx->pix_fmt = AV_PIX_FMT_YUYV422;





    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}",0
Detect whether the following code contains vulnerabilities.,"void clamp_mv(VP8Context *s, VP56mv *dst, const VP56mv *src)

{

    dst->x = av_clip(src->x, s->mv_min.x, s->mv_max.x);

    dst->y = av_clip(src->y, s->mv_min.y, s->mv_max.y);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_vp3_v_loop_filter_c(uint8_t *first_pixel, int stride, int *bounding_values)

{

    unsigned char *end;

    int filter_value;

    const int nstride= -stride;



    for (end= first_pixel + 8; first_pixel < end; first_pixel++) {

        filter_value =

            (first_pixel[2 * nstride] - first_pixel[ stride])

         +3*(first_pixel[0          ] - first_pixel[nstride]);

        filter_value = bounding_values[(filter_value + 4) >> 3];

        first_pixel[nstride] = av_clip_uint8(first_pixel[nstride] + filter_value);

        first_pixel[0] = av_clip_uint8(first_pixel[0] - filter_value);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"pdf_t *pdf_new(const char *name)
{
    const char *n;
    pdf_t      *pdf;
   
    pdf = calloc(1, sizeof(pdf_t));

    if (name)
    {
        /* Just get the file name (not path) */
        if ((n = strrchr(name, '/')))
          ++n;
        else
          n = name;

        pdf->name = malloc(strlen(n) + 1);
        strcpy(pdf->name, n);
    }
    else /* !name */
    {
        pdf->name = malloc(strlen(""Unknown"") + 1);
        strcpy(pdf->name, ""Unknown"");
    }

    return pdf;
}",1
Detect whether the following code contains vulnerabilities.,"QPDF::writeHGeneric(BitWriter& w, HGeneric& t)
{
    w.writeBits(t.first_object, 32);			    // 1
    w.writeBits(t.first_object_offset, 32);		    // 2
    w.writeBits(t.nobjects, 32);			    // 3
    w.writeBits(t.group_length, 32);			    // 4
}",1
Detect whether the following code contains vulnerabilities.,"int bdrv_check(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix)

{




    if (bs->drv->bdrv_check == NULL) {

        return -ENOTSUP;




    memset(res, 0, sizeof(*res));

    return bs->drv->bdrv_check(bs, res, fix);
",1
Detect whether the following code contains vulnerabilities.,"static bool check_client_passwd(PgSocket *client, const char *passwd)
{
	char md5[MD5_PASSWD_LEN + 1];
	const char *correct;
	PgUser *user = client->auth_user;

	/* disallow empty passwords */
	if (!*passwd || !*user->passwd)
		return false;

	switch (cf_auth_type) {
	case AUTH_PLAIN:
		return strcmp(user->passwd, passwd) == 0;
	case AUTH_CRYPT:
		correct = crypt(user->passwd, (char *)client->tmp_login_salt);
		return correct && strcmp(correct, passwd) == 0;
	case AUTH_MD5:
		if (strlen(passwd) != MD5_PASSWD_LEN)
			return false;
		if (!isMD5(user->passwd))
			pg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);
		pg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);
		return strcmp(md5, passwd) == 0;
	}
	return false;
}",1
Detect whether the following code contains vulnerabilities.,"sort_page_names (gconstpointer a,
                 gconstpointer b)
{
	const char *name_1, *name_2;
	gchar *key_1, *key_2;
	gboolean sort_last_1, sort_last_2;
	int compare;

	name_1 = * (const char **) a;
	name_2 = * (const char **) b;

	#define SORT_LAST_CHAR1 '.'
	#define SORT_LAST_CHAR2 '#'

	sort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;
	sort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;

	#undef SORT_LAST_CHAR1
	#undef SORT_LAST_CHAR2

	if (sort_last_1 && !sort_last_2)
	{
		compare = +1;
	}
	else if (!sort_last_1 && sort_last_2)
	{
		compare = -1;
	} 
	else
	{
		key_1 = g_utf8_collate_key_for_filename (name_1, -1);
		key_2 = g_utf8_collate_key_for_filename (name_2, -1);

		compare = strcmp (key_1, key_2);

		g_free (key_1);
		g_free (key_2);
	}

	return compare;
}",0
Detect whether the following code contains vulnerabilities.,"static void snmp6_free_dev(struct inet6_dev *idev)
{
	kfree(idev->stats.icmpv6msgdev);
	kfree(idev->stats.icmpv6dev);
	free_percpu(idev->stats.ipv6);
}",0
Detect whether the following code contains vulnerabilities.,"PJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,
				   const void *pkt,
				   pj_size_t size)
{
    pj_uint8_t *p, *p_end;

    p = (pj_uint8_t*)pkt;
    p_end = p + size;
    while (p < p_end) {
	pjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;
	unsigned len;

	len = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;
	if (p + len > p_end)
	    break;

	switch(common->pt) {
	case RTCP_SR:
	case RTCP_RR:
	case RTCP_XR:
	    parse_rtcp_report(sess, p, len);
	    break;
	case RTCP_SDES:
	    parse_rtcp_sdes(sess, p, len);
	    break;
	case RTCP_BYE:
	    parse_rtcp_bye(sess, p, len);
	    break;
	case RTCP_RTPFB:
	case RTCP_PSFB:
	    parse_rtcp_fb(sess, p, len);
	    break;
	default:
	    /* Ignore unknown RTCP */
	    TRACE_((sess->name, ""Received unknown RTCP packet type=%d"",
		    common->pt));
	    break;
	}

	p += len;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void aarch64_cpu_class_init(ObjectClass *oc, void *data)

{

    CPUClass *cc = CPU_CLASS(oc);




    cc->dump_state = aarch64_cpu_dump_state;

    cc->set_pc = aarch64_cpu_set_pc;

    cc->gdb_read_register = aarch64_cpu_gdb_read_register;

    cc->gdb_write_register = aarch64_cpu_gdb_write_register;

    cc->gdb_num_core_regs = 34;

    cc->gdb_core_xml_file = ""aarch64-core.xml"";

}",1
Detect whether the following code contains vulnerabilities.,"static bool pc_machine_get_aligned_dimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->enforce_aligned_dimm;

}
",0
Detect whether the following code contains vulnerabilities.,"Visitor *qapi_dealloc_get_visitor(QapiDeallocVisitor *v)

{

    return &v->visitor;

}
",0
Detect whether the following code contains vulnerabilities.,"static int nvdec_h264_decode_init(AVCodecContext *avctx)

{

    const H264Context *h = avctx->priv_data;

    const SPS       *sps = h->ps.sps;

    return ff_nvdec_decode_init(avctx, sps->ref_frame_count + sps->num_reorder_frames);

}
",0
Detect whether the following code contains vulnerabilities.,"rend_service_free(rend_service_t *service)
{
  if (!service)
    return;

  tor_free(service->directory);
  if (service->ports) {
    SMARTLIST_FOREACH(service->ports, rend_service_port_config_t*, p,
                      rend_service_port_config_free(p));
    smartlist_free(service->ports);
  }
  if (service->private_key)
    crypto_pk_free(service->private_key);
  if (service->intro_nodes) {
    SMARTLIST_FOREACH(service->intro_nodes, rend_intro_point_t *, intro,
      rend_intro_point_free(intro););
    smartlist_free(service->intro_nodes);
  }
  if (service->expiring_nodes) {
    SMARTLIST_FOREACH(service->expiring_nodes, rend_intro_point_t *, intro,
                      rend_intro_point_free(intro););
    smartlist_free(service->expiring_nodes);
  }

  rend_service_descriptor_free(service->desc);
  if (service->clients) {
    SMARTLIST_FOREACH(service->clients, rend_authorized_client_t *, c,
      rend_authorized_client_free(c););
    smartlist_free(service->clients);
  }
  if (service->accepted_intro_dh_parts) {
    replaycache_free(service->accepted_intro_dh_parts);
  }
  tor_free(service);
}",0
Detect whether the following code contains vulnerabilities.,"set_keep_msg_from_hist(void)
{
    if (keep_msg == NULL && last_msg_hist != NULL && msg_scrolled == 0
						      && (State & MODE_NORMAL))
	set_keep_msg(last_msg_hist->msg, last_msg_hist->attr);
}",0
Detect whether the following code contains vulnerabilities.,"get_filesystem_type (const char *path)
{
        GFile      *file;
        GFileInfo  *file_info;
        GError     *error;
        char       *filesystem_type;

        file = g_file_new_for_path (path);
        error = NULL;
        file_info = g_file_query_filesystem_info (file,
                                                  G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,
                                                  NULL,
                                                  &error);
        if (file_info == NULL) {
                g_warning (""Unable to query filesystem type for %s: %s"", path, error->message);
                g_error_free (error);
                g_object_unref (file);
                return NULL;
        }

        filesystem_type = g_strdup (g_file_info_get_attribute_string (file_info,
                                                                      G_FILE_ATTRIBUTE_FILESYSTEM_TYPE));
        if (filesystem_type == NULL) {
                g_warning (""GIO returned NULL filesystem type for %s"", path);
        }

        g_object_unref (file);
        g_object_unref (file_info);

        return filesystem_type;
}",0
Detect whether the following code contains vulnerabilities.,"static void cirrus_bitblt_rop_nop(CirrusVGAState *s,

                                  uint8_t *dst,const uint8_t *src,

                                  int dstpitch,int srcpitch,

                                  int bltwidth,int bltheight)

{

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_add_data_offset(DisasContext *s, unsigned int insn,

                                       TCGv var)

{

    int val, rm, shift, shiftop;

    TCGv offset;



    if (!(insn & (1 << 25))) {

        /* immediate */

        val = insn & 0xfff;

        if (!(insn & (1 << 23)))

            val = -val;

        if (val != 0)

            tcg_gen_addi_i32(var, var, val);

    } else {

        /* shift/register */

        rm = (insn) & 0xf;

        shift = (insn >> 7) & 0x1f;

        shiftop = (insn >> 5) & 3;

        offset = load_reg(s, rm);

        gen_arm_shift_im(offset, shiftop, shift, 0);

        if (!(insn & (1 << 23)))

            tcg_gen_sub_i32(var, var, offset);

        else

            tcg_gen_add_i32(var, var, offset);

        dead_tmp(offset);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmgenid_realize(DeviceState *dev, Error **errp)

{

    VmGenIdState *vms = VMGENID(dev);



    if (!vms->write_pointer_available) {

        error_setg(errp, ""%s requires DMA write support in fw_cfg, ""

                   ""which this machine type does not provide"", VMGENID_DEVICE);

        return;

    }



    /* Given that this function is executing, there is at least one VMGENID

     * device. Check if there are several.

     */

    if (!find_vmgenid_dev()) {

        error_setg(errp, ""at most one %s device is permitted"", VMGENID_DEVICE);

        return;

    }



    qemu_register_reset(vmgenid_handle_reset, vms);

}
",1
Detect whether the following code contains vulnerabilities.,"print_buffer(Pl_Buffer* bp)
{
    bp->finish();
    Buffer* b = bp->getBuffer();
    unsigned char const* p = b->getBuffer();
    size_t l = b->getSize();
    for (unsigned long i = 0; i < l; ++i)
    {
	printf(""%02x%s"", static_cast<unsigned int>(p[i]),
	       (i == l - 1) ? ""\n"" : "" "");
    }
    printf(""\n"");
    delete b;
}",1
Detect whether the following code contains vulnerabilities.,"static int jas_iccprof_gettagtab(jas_stream_t *in, jas_icctagtab_t *tagtab)
{
	int i;
	jas_icctagtabent_t *tagtabent;

	if (tagtab->ents) {
		jas_free(tagtab->ents);
		tagtab->ents = 0;
	}
	if (jas_iccgetuint32(in, &tagtab->numents))
		goto error;
	if (!(tagtab->ents = jas_malloc(tagtab->numents *
	  sizeof(jas_icctagtabent_t))))
		goto error;
	tagtabent = tagtab->ents;
	for (i = 0; i < JAS_CAST(long, tagtab->numents); ++i) {
		if (jas_iccgetuint32(in, &tagtabent->tag) ||
		jas_iccgetuint32(in, &tagtabent->off) ||
		jas_iccgetuint32(in, &tagtabent->len))
			goto error;
		++tagtabent;
	}
	return 0;
error:
	if (tagtab->ents) {
		jas_free(tagtab->ents);
		tagtab->ents = 0;
	}
	return -1;
}",1
Detect whether the following code contains vulnerabilities.,"Item_param::set_value(THD *thd, sp_rcontext *ctx, Item **it)
{
  Item *arg= *it;
  struct st_value tmp;
  /*
    The OUT parameter is bound to some data type.
    It's important not to touch m_type_handler,
    to make sure the next mysql_stmt_execute()
    correctly fetches the value from the client-server protocol,
    using set_param_func().
  */
  if (arg->save_in_value(&tmp) ||
      set_value(thd, arg, &tmp, arg->type_handler()))
  {
    set_null();
    return false;
  }
  /* It is wrapper => other set_* shoud set null_value */
  DBUG_ASSERT(null_value == false);
  return false;
}",0
Detect whether the following code contains vulnerabilities.,"decode_NXAST_RAW_OUTPUT_REG2(const struct nx_action_output_reg2 *naor,
                             enum ofp_version ofp_version OVS_UNUSED,
                             const struct vl_mff_map *vl_mff_map,
                             uint64_t *tlv_bitmap, struct ofpbuf *out)
{
    struct ofpact_output_reg *output_reg;
    enum ofperr error;

    output_reg = ofpact_put_OUTPUT_REG(out);
    output_reg->ofpact.raw = NXAST_RAW_OUTPUT_REG2;
    output_reg->src.ofs = nxm_decode_ofs(naor->ofs_nbits);
    output_reg->src.n_bits = nxm_decode_n_bits(naor->ofs_nbits);
    output_reg->max_len = ntohs(naor->max_len);

    struct ofpbuf b = ofpbuf_const_initializer(naor, ntohs(naor->len));
    ofpbuf_pull(&b, OBJECT_OFFSETOF(naor, pad));

    error = mf_vl_mff_nx_pull_header(&b, vl_mff_map, &output_reg->src.field,
                                     NULL, tlv_bitmap);
    if (error) {
        return error;
    }

    if (!is_all_zeros(b.data, b.size)) {
        return OFPERR_NXBRC_MUST_BE_ZERO;
    }

    return mf_check_src(&output_reg->src, NULL);
}",0
Detect whether the following code contains vulnerabilities.,"    template<typename t>
    CImg<_cimg_Tt> get_mul(const CImg<t>& img) const {
      return CImg<_cimg_Tt>(*this,false).mul(img);",0
Detect whether the following code contains vulnerabilities.,"static void gen_slbmfee(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    gen_helper_load_slb_esid(cpu_gpr[rS(ctx->opcode)], cpu_env,

                             cpu_gpr[rB(ctx->opcode)]);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )
{
  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );

  /* output = b/(a^x) mod p */
  gcry_mpi_powm( t1, a, skey->x, skey->p );
  mpi_invm( t1, t1, skey->p );
  mpi_mulm( output, b, t1, skey->p );
#if 0
  if( DBG_CIPHER )
    {
      log_mpidump(""elg decrypted x= "", skey->x);
      log_mpidump(""elg decrypted p= "", skey->p);
      log_mpidump(""elg decrypted a= "", a);
      log_mpidump(""elg decrypted b= "", b);
      log_mpidump(""elg decrypted M= "", output);
    }
#endif
  mpi_free(t1);
}",1
Detect whether the following code contains vulnerabilities.,"PHPAPI char *php_lookup_class_name(zval *object, zend_uint *nlen)
{
	zval **val;
	char *retval = NULL;
	HashTable *object_properties;
	TSRMLS_FETCH();

	object_properties = Z_OBJPROP_P(object);

	if (zend_hash_find(object_properties, MAGIC_MEMBER, sizeof(MAGIC_MEMBER), (void **) &val) == SUCCESS) {
		retval = estrndup(Z_STRVAL_PP(val), Z_STRLEN_PP(val));

		if (nlen) {
			*nlen = Z_STRLEN_PP(val);
		}
	}

	return retval;
}",1
Detect whether the following code contains vulnerabilities.,    void ms_handle_fast_accept(Connection *con) override {},0
Detect whether the following code contains vulnerabilities.,"void HEnvironment::AddIncomingEdge(HBasicBlock* block, HEnvironment* other) {
  ASSERT(!block->IsLoopHeader());
  ASSERT(values_.length() == other->values_.length());

  int length = values_.length();
  for (int i = 0; i < length; ++i) {
    HValue* value = values_[i];
    if (value != NULL && value->IsPhi() && value->block() == block) {
      // There is already a phi for the i'th value.
      HPhi* phi = HPhi::cast(value);
      // Assert index is correct and that we haven't missed an incoming edge.
      ASSERT(phi->merged_index() == i);
      ASSERT(phi->OperandCount() == block->predecessors()->length());
      phi->AddInput(other->values_[i]);
    } else if (values_[i] != other->values_[i]) {
      // There is a fresh value on the incoming edge, a phi is needed.
      ASSERT(values_[i] != NULL && other->values_[i] != NULL);
      HPhi* phi = new(zone()) HPhi(i, zone());
      HValue* old_value = values_[i];
      for (int j = 0; j < block->predecessors()->length(); j++) {
        phi->AddInput(old_value);
      }
      phi->AddInput(other->values_[i]);
      this->values_[i] = phi;
      block->AddPhi(phi);
    }
  }
}",0
Detect whether the following code contains vulnerabilities.,"static void commit_tree(struct mount *mnt, struct mount *shadows)
{
	struct mount *parent = mnt->mnt_parent;
	struct mount *m;
	LIST_HEAD(head);
	struct mnt_namespace *n = parent->mnt_ns;

	BUG_ON(parent == mnt);

	list_add_tail(&head, &mnt->mnt_list);
	list_for_each_entry(m, &head, mnt_list)
		m->mnt_ns = n;

	list_splice(&head, n->list.prev);

	attach_shadowed(mnt, parent, shadows);
	touch_mnt_namespace(n);
}",1
Detect whether the following code contains vulnerabilities.,"static int mxf_read_material_package(void *arg, AVIOContext *pb, int tag, int size, UID uid)

{

    MXFPackage *package = arg;

    switch(tag) {

    case 0x4403:

        package->tracks_count = avio_rb32(pb);

        if (package->tracks_count >= UINT_MAX / sizeof(UID))

            return -1;

        package->tracks_refs = av_malloc(package->tracks_count * sizeof(UID));

        if (!package->tracks_refs)

            return -1;

        avio_skip(pb, 4); /* useless size of objects, always 16 according to specs */

        avio_read(pb, (uint8_t *)package->tracks_refs, package->tracks_count * sizeof(UID));

        break;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"SAPI_API void sapi_startup(sapi_module_struct *sf)
{
#ifdef ZEND_SIGNALS
	zend_signal_startup();
#endif

	sf->ini_entries = NULL;
	sapi_module = *sf;

#ifdef ZTS
	ts_allocate_id(&sapi_globals_id, sizeof(sapi_globals_struct), (ts_allocate_ctor) sapi_globals_ctor, (ts_allocate_dtor) sapi_globals_dtor);
# ifdef PHP_WIN32
	_configthreadlocale(_ENABLE_PER_THREAD_LOCALE);
# endif
#else
	sapi_globals_ctor(&sapi_globals);
#endif

	virtual_cwd_startup(); /* Could use shutdown to free the main cwd but it would just slow it down for CGI */

#ifdef PHP_WIN32
	tsrm_win32_startup();
#endif

	reentrancy_startup();
}",0
Detect whether the following code contains vulnerabilities.,"u32 __skb_get_hash_symmetric(const struct sk_buff *skb)
{
	struct flow_keys keys;

	__flow_hash_secret_init();

	memset(&keys, 0, sizeof(keys));
	__skb_flow_dissect(NULL, skb, &flow_keys_dissector_symmetric,
			   &keys, NULL, 0, 0, 0,
			   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);

	return __flow_hash_from_keys(&keys, hashrnd);
}",1
Detect whether the following code contains vulnerabilities.,"static void serial_update_parameters(SerialState *s)
{
    int speed, parity, data_bits, stop_bits, frame_size;
    QEMUSerialSetParams ssp;

    if (s->divider == 0)
        return;

    /* Start bit. */
    frame_size = 1;
    if (s->lcr & 0x08) {
        /* Parity bit. */
        frame_size++;
        if (s->lcr & 0x10)
            parity = 'E';
        else
            parity = 'O';
    } else {
            parity = 'N';
    }
    if (s->lcr & 0x04)
        stop_bits = 2;
    else
        stop_bits = 1;

    data_bits = (s->lcr & 0x03) + 5;
    frame_size += data_bits + stop_bits;
    speed = s->baudbase / s->divider;
    ssp.speed = speed;
    ssp.parity = parity;
    ssp.data_bits = data_bits;
    ssp.stop_bits = stop_bits;
    s->char_transmit_time =  (NANOSECONDS_PER_SECOND / speed) * frame_size;
    qemu_chr_fe_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);

    DPRINTF(""speed=%d parity=%c data=%d stop=%d\n"",
           speed, parity, data_bits, stop_bits);
}",1
Detect whether the following code contains vulnerabilities.,"static void *qpa_audio_init (void)

{

    return &conf;

}
",1
Detect whether the following code contains vulnerabilities.,"static void set_irq_level(void *opaque, int n, int level)

{

    NVICState *s = opaque;

    VecInfo *vec;



    n += NVIC_FIRST_IRQ;



    assert(n >= NVIC_FIRST_IRQ && n < s->num_irq);



    trace_nvic_set_irq_level(n, level);



    /* The pending status of an external interrupt is

     * latched on rising edge and exception handler return.

     *

     * Pulsing the IRQ will always run the handler

     * once, and the handler will re-run until the

     * level is low when the handler completes.

     */

    vec = &s->vectors[n];

    if (level != vec->level) {

        vec->level = level;

        if (level) {

            armv7m_nvic_set_pending(s, n);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"STATIC GC_bool GC_alloc_reclaim_list(struct obj_kind *kind)
{
    struct hblk ** result = (struct hblk **)
                GC_scratch_alloc((MAXOBJGRANULES+1) * sizeof(struct hblk *));
    if (result == 0) return(FALSE);
    BZERO(result, (MAXOBJGRANULES+1)*sizeof(struct hblk *));
    kind -> ok_reclaim_list = result;
    return(TRUE);
}",0
Detect whether the following code contains vulnerabilities.,"static int vhost_user_set_log_base(struct vhost_dev *dev, uint64_t base,

                                   struct vhost_log *log)

{

    int fds[VHOST_MEMORY_MAX_NREGIONS];

    size_t fd_num = 0;

    bool shmfd = virtio_has_feature(dev->protocol_features,

                                    VHOST_USER_PROTOCOL_F_LOG_SHMFD);

    VhostUserMsg msg = {

        .request = VHOST_USER_SET_LOG_BASE,

        .flags = VHOST_USER_VERSION,

        .u64 = base,

        .size = sizeof(m.u64),

    };



    if (shmfd && log->fd != -1) {

        fds[fd_num++] = log->fd;

    }



    vhost_user_write(dev, &msg, fds, fd_num);



    if (shmfd) {

        msg.size = 0;

        if (vhost_user_read(dev, &msg) < 0) {

            return 0;

        }



        if (msg.request != VHOST_USER_SET_LOG_BASE) {

            error_report(""Received unexpected msg type. ""

                         ""Expected %d received %d"",

                         VHOST_USER_SET_LOG_BASE, msg.request);

            return -1;

        }

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int cinepak_encode_end(AVCodecContext *avctx)

{

    CinepakEncContext *s = avctx->priv_data;

    int x;



    av_free(s->codebook_input);

    av_free(s->codebook_closest);

    av_free(s->strip_buf);

    av_free(s->frame_buf);

    av_free(s->mb);

#ifdef CINEPAKENC_DEBUG

    av_free(s->best_mb);

#endif



    for(x = 0; x < 3; x++)

        av_free(s->pict_bufs[x]);



    av_log(avctx, AV_LOG_INFO, ""strip coding stats: %i V1 mode, %i V4 mode, %i MC mode (%i V1 encs, %i V4 encs, %i skips)\n"",

        s->num_v1_mode, s->num_v4_mode, s->num_mc_mode, s->num_v1_encs, s->num_v4_encs, s->num_skips);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)
{
	struct nfs4_state *newstate;
	int ret;

	opendata->o_arg.open_flags = openflags;
	memset(&opendata->o_res, 0, sizeof(opendata->o_res));
	memset(&opendata->c_res, 0, sizeof(opendata->c_res));
	nfs4_init_opendata_res(opendata);
	ret = _nfs4_proc_open(opendata);
	if (ret != 0)
		return ret; 
	newstate = nfs4_opendata_to_nfs4_state(opendata);
	if (IS_ERR(newstate))
		return PTR_ERR(newstate);
	nfs4_close_state(&opendata->path, newstate, openflags);
	*res = newstate;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static int imap_path_pretty(char *buf, size_t buflen, const char *folder)
{
  if (!buf || !folder)
    return -1;

  imap_pretty_mailbox(buf, buflen, folder);
  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int qemu_savevm_state(QEMUFile *f, Error **errp)

{

    int ret;

    MigrationParams params = {

        .blk = 0,

        .shared = 0

    };

    MigrationState *ms = migrate_init(&params);

    ms->to_dst_file = f;



    if (qemu_savevm_state_blocked(errp)) {

        return -EINVAL;

    }



    qemu_mutex_unlock_iothread();

    qemu_savevm_state_header(f);

    qemu_savevm_state_begin(f, &params);

    qemu_mutex_lock_iothread();



    while (qemu_file_get_error(f) == 0) {

        if (qemu_savevm_state_iterate(f, false) > 0) {

            break;

        }

    }



    ret = qemu_file_get_error(f);

    if (ret == 0) {

        qemu_savevm_state_complete_precopy(f, false);

        ret = qemu_file_get_error(f);

    }

    qemu_savevm_state_cleanup();

    if (ret != 0) {

        error_setg_errno(errp, -ret, ""Error while writing VM state"");

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"int compare_order_lists(SQL_I_List<ORDER> *part_list1,
                        SQL_I_List<ORDER> *part_list2)
{
  if (part_list1 == part_list2)
    return CMP_EQ;
  ORDER *elem1= part_list1->first;
  ORDER *elem2= part_list2->first;
  for ( ; elem1 && elem2; elem1= elem1->next, elem2= elem2->next)
  {
    int cmp;
    // remove all constants as we don't need them for comparision
    while(elem1 && ((*elem1->item)->real_item())->const_item())
    {
      elem1= elem1->next;
      continue;
    }

    while(elem2 && ((*elem2->item)->real_item())->const_item())
    {
      elem2= elem2->next;
      continue;
    }

    if (!elem1 || !elem2)
      break;

    if ((cmp= compare_order_elements(elem1, elem2)))
      return cmp;
  }
  if (elem1)
    return CMP_GT_C;
  if (elem2)
    return CMP_LT_C;
  return CMP_EQ;
}",1
Detect whether the following code contains vulnerabilities.,"TPMI_DH_PCR_Unmarshal(TPMI_DH_PCR *target, BYTE **buffer, INT32 *size, BOOL allowNull)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_HANDLE_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	BOOL isNotPcr = (*target > PCR_LAST);
	BOOL isNotLegalNull = (*target != TPM_RH_NULL) || !allowNull;
	if (isNotPcr &&
	    isNotLegalNull) {
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"AioContext *aio_context_new(void)

{

    return (AioContext *) g_source_new(&aio_source_funcs, sizeof(AioContext));

}
",0
Detect whether the following code contains vulnerabilities.,"Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){
  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);
  if( p ){
    struct SrcList_item *pItem = &pSrc->a[iSrc];
    p->y.pTab = pItem->pTab;
    p->iTable = pItem->iCursor;
    if( p->y.pTab->iPKey==iCol ){
      p->iColumn = -1;
    }else{
      p->iColumn = (ynVar)iCol;
      testcase( iCol==BMS );
      testcase( iCol==BMS-1 );
      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);
    }
  }
  return p;
}",1
Detect whether the following code contains vulnerabilities.,"static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,
					  struct ceph_authorizer *a, size_t len)
{
	struct ceph_x_authorizer *au = (void *)a;
	struct ceph_x_ticket_handler *th;
	int ret = 0;
	struct ceph_x_authorize_reply reply;
	void *p = au->reply_buf;
	void *end = p + sizeof(au->reply_buf);

	th = get_ticket_handler(ac, au->service);
	if (IS_ERR(th))
		return PTR_ERR(th);
	ret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));
	if (ret < 0)
		return ret;
	if (ret != sizeof(reply))
		return -EPERM;

	if (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))
		ret = -EPERM;
	else
		ret = 0;
	dout(""verify_authorizer_reply nonce %llx got %llx ret %d\n"",
	     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  const int num_elements = NumElements(input);
  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));
  switch (input->type) {
    case kTfLiteInt64:
      return copyToTensor(context, input->data.i64, output, num_elements);
    case kTfLiteInt32:
      return copyToTensor(context, input->data.i32, output, num_elements);
    case kTfLiteUInt8:
      return copyToTensor(context, input->data.uint8, output, num_elements);
    case kTfLiteFloat32:
      return copyToTensor(context, GetTensorData<float>(input), output,
                          num_elements);
    case kTfLiteBool:
      return copyToTensor(context, input->data.b, output, num_elements);
    case kTfLiteComplex64:
      return copyToTensor(
          context, reinterpret_cast<std::complex<float>*>(input->data.c64),
          output, num_elements);
    default:
      // Unsupported type.
      TF_LITE_UNSUPPORTED_TYPE(context, input->type, ""Cast"");
  }
  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)
{
    for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {
        unsigned const symnum = get_te64(&rela->r_info) >> 32;
        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;
        if (0==strcmp(symnam, ""__libc_start_main"")  // glibc
        ||  0==strcmp(symnam, ""__libc_init"")  // Android
        ||  0==strcmp(symnam, ""__uClibc_main"")
        ||  0==strcmp(symnam, ""__uClibc_start_main""))
            return true;
    }
    return false;
}",1
Detect whether the following code contains vulnerabilities.,"LogFilePrep(const char *fname, const char *backup, const char *idstring)
{
    char *logFileName = NULL;

    if (asprintf(&logFileName, fname, idstring) == -1)
        FatalError(""Cannot allocate space for the log file name\n"");

    if (backup && *backup) {
        struct stat buf;

        if (!stat(logFileName, &buf) && S_ISREG(buf.st_mode)) {
            char *suffix;
            char *oldLog;

            if ((asprintf(&suffix, backup, idstring) == -1) ||
                (asprintf(&oldLog, ""%s%s"", logFileName, suffix) == -1)) {
                FatalError(""Cannot allocate space for the log file name\n"");
            }
            free(suffix);

            if (rename(logFileName, oldLog) == -1) {
                FatalError(""Cannot move old log file \""%s\"" to \""%s\""\n"",
                           logFileName, oldLog);
            }
            free(oldLog);
        }
    }
    else {
        if (remove(logFileName) != 0 && errno != ENOENT) {
            FatalError(""Cannot remove old log file \""%s\"": %s\n"",
                       logFileName, strerror(errno));
        }
    }

    return logFileName;
}",1
Detect whether the following code contains vulnerabilities.,"setGraphAttr(Agraph_t * g, char *name, char *value, userdata_t * ud)
{
    Agsym_t *ap;

    if ((g == root) && !strcmp(name, ""strict"") && !strcmp(value, ""true"")) {
	g->desc.strict = 1;
    } else if (strcmp(name, ""name"") == 0)
	setName(ud->nameMap, (Agobj_t *) g, value);
    else {
	ap = agattr(root, AGRAPH, name, 0);
	if (ap)
	    agxset(g, ap, value);
	else if (g == root)
	    agattr(root, AGRAPH, name, value);
	else {
	    ap = agattr(root, AGRAPH, name, defval);
	    agxset(g, ap, value);
	}
    }
}",0
Detect whether the following code contains vulnerabilities.,"GF_Err ccst_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_CodingConstraintsBox *ptr = (GF_CodingConstraintsBox *)s;

	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->all_ref_pics_intra = gf_bs_read_int(bs, 1);
	ptr->intra_pred_used = gf_bs_read_int(bs, 1);
	ptr->max_ref_per_pic = gf_bs_read_int(bs, 4);
	ptr->reserved = gf_bs_read_int(bs, 26);
	return GF_OK;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)

{

    deblocking_filter_CTB(s, x, y);

    if (s->sps->sao_enabled) {

        int x_end = x >= s->sps->width  - ctb_size;

        int y_end = y >= s->sps->height - ctb_size;

        if (y && x)

            sao_filter_CTB(s, x - ctb_size, y - ctb_size);

        if (x && y_end)

            sao_filter_CTB(s, x - ctb_size, y);

        if (y && x_end) {

            sao_filter_CTB(s, x, y - ctb_size);

            if (s->threads_type & FF_THREAD_FRAME )

                ff_thread_report_progress(&s->ref->tf, y - ctb_size, 0);

        }

        if (x_end && y_end) {

            sao_filter_CTB(s, x , y);

            if (s->threads_type & FF_THREAD_FRAME )

                ff_thread_report_progress(&s->ref->tf, y, 0);

        }

    } else {

        if (y && x >= s->sps->width - ctb_size)

            if (s->threads_type & FF_THREAD_FRAME )

                ff_thread_report_progress(&s->ref->tf, y, 0);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void *postcopy_get_tmp_page(MigrationIncomingState *mis)

{

    if (!mis->postcopy_tmp_page) {

        mis->postcopy_tmp_page = mmap(NULL, getpagesize(),

                             PROT_READ | PROT_WRITE, MAP_PRIVATE |

                             MAP_ANONYMOUS, -1, 0);

        if (!mis->postcopy_tmp_page) {

            error_report(""%s: %s"", __func__, strerror(errno));

            return NULL;

        }

    }



    return mis->postcopy_tmp_page;

}
",1
Detect whether the following code contains vulnerabilities.,"static void opt_frame_pad_bottom(const char *arg)

{

    frame_padbottom = atoi(arg);

    if (frame_padbottom < 0) {

        fprintf(stderr, ""Incorrect bottom pad size\n"");

        av_exit(1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"rsvg_desc_handler_characters (RsvgSaxHandler * self, const char *ch, int len)
{
    RsvgSaxHandlerDesc *z = (RsvgSaxHandlerDesc *) self;
    RsvgHandle *ctx = z->ctx;

    /* This isn't quite the correct behavior - in theory, any graphics
       element may contain a title or desc element */

    if (!ch || !len)
        return;

    if (!g_utf8_validate ((char *) ch, len, NULL)) {
        char *utf8;
        utf8 = rsvg_make_valid_utf8 ((char *) ch, len);
        g_string_append (ctx->priv->desc, utf8);
        g_free (utf8);
    } else {
        g_string_append_len (ctx->priv->desc, (char *) ch, len);
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)
{
	int error;
	struct l2tp_tunnel *tunnel;
	struct l2tp_session *session;
	struct pppol2tp_session *ps;

	tunnel = l2tp_tunnel_find(net, tunnel_id);

	/* Error if we can't find the tunnel */
	error = -ENOENT;
	if (tunnel == NULL)
		goto out;

	/* Error if tunnel socket is not prepped */
	if (tunnel->sock == NULL)
		goto out;

	/* Default MTU values. */
	if (cfg->mtu == 0)
		cfg->mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;
	if (cfg->mru == 0)
		cfg->mru = cfg->mtu;

	/* Allocate and initialize a new session context. */
	session = l2tp_session_create(sizeof(struct pppol2tp_session),
				      tunnel, session_id,
				      peer_session_id, cfg);
	if (IS_ERR(session)) {
		error = PTR_ERR(session);
		goto out;
	}

	ps = l2tp_session_priv(session);
	ps->tunnel_sock = tunnel->sock;

	l2tp_info(session, L2TP_MSG_CONTROL, ""%s: created\n"",
		  session->name);

	error = 0;

out:
	return error;
}",1
Detect whether the following code contains vulnerabilities.,"void selinux_netlbl_err(struct sk_buff *skb, int error, int gateway)
{
	netlbl_skbuff_err(skb, error, gateway);
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t rgb_to_yuv(uint32_t rgb)
{
    uint8_t r, g, b;
    int y, cb, cr;

    r = (rgb >> 16) & 0xFF;
    g = (rgb >>  8) & 0xFF;
    b = (rgb      ) & 0xFF;

    y  = av_clip_uint8(( 16000 +  257 * r + 504 * g +  98 * b)/1000);
    cb = av_clip_uint8((128000 -  148 * r - 291 * g + 439 * b)/1000);
    cr = av_clip_uint8((128000 +  439 * r - 368 * g -  71 * b)/1000);

    return (y << 16) | (cr << 8) | cb;
}",0
Detect whether the following code contains vulnerabilities.,"Opal::Call::OnEstablished (OpalConnection & connection)
{
  RTP_Session *session = NULL; 
  OpalMediaStreamPtr stream;

  NoAnswerTimer.Stop (false);

  if (!PIsDescendant(&connection, OpalPCSSConnection)) {

    parse_info (connection);
    Ekiga::Runtime::run_in_main (boost::bind (&Opal::Call::emit_established_in_main, this));
  }

  if (PIsDescendant(&connection, OpalRTPConnection)) {

    stream = connection.GetMediaStream (OpalMediaType::Audio (), false);
    if (stream != NULL) {

      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());
      if (session) {
      
        session->SetIgnorePayloadTypeChanges (TRUE);
        session->SetRxStatisticsInterval(50);
        session->SetTxStatisticsInterval(50);
      }
    }

    stream = connection.GetMediaStream (OpalMediaType::Video (), false);
    if (stream != NULL) { 

      session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());
      if (session) {

        session->SetIgnorePayloadTypeChanges (TRUE);
        session->SetRxStatisticsInterval(50);
        session->SetTxStatisticsInterval(50);
      }
    }
  }
  
  return OpalCall::OnEstablished (connection);
}",1
Detect whether the following code contains vulnerabilities.,"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)
{
    if (!dynsym || !dynstr) {
        return false;
    }
    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {
        unsigned const symnum = get_te64(&rela->r_info) >> 32;
        char const *const symnam = get_dynsym_name(symnum, relnum);
        if (0==strcmp(symnam, ""__libc_start_main"")  // glibc
        ||  0==strcmp(symnam, ""__libc_init"")  // Android
        ||  0==strcmp(symnam, ""__uClibc_main"")
        ||  0==strcmp(symnam, ""__uClibc_start_main""))
            return true;
    }
    return false;
}",1
Detect whether the following code contains vulnerabilities.,"static void gen_exception_return(DisasContext *s, TCGv pc)

{

    TCGv tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, 0xffffffff);

    dead_tmp(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_handshake_io(void *opaque) {

    struct VncState *vs = (struct VncState *)opaque;



    VNC_DEBUG(""Handshake IO continue\n"");

    vnc_continue_handshake(vs);

}
",0
Detect whether the following code contains vulnerabilities.,"
static inline struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)
{
	return &skb_shinfo(skb)->hwtstamps;",0
Detect whether the following code contains vulnerabilities.,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_malloc(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



    avcodec_get_frame_defaults(frame);



    return frame;

}
",1
Detect whether the following code contains vulnerabilities.,"utf_iscomposing_uint(UINT32_T c)
{
    return utf_iscomposing((int)c);
}",0
Detect whether the following code contains vulnerabilities.,"static VALUE read_memory(VALUE klass, VALUE content)
{
  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(
      (const char *)StringValuePtr(content),
      (int)RSTRING_LEN(content)
  );
  xmlRelaxNGPtr schema;
  VALUE errors = rb_ary_new();
  VALUE rb_schema;

  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS
  xmlRelaxNGSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  schema = xmlRelaxNGParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlRelaxNGFreeParserCtxt(ctx);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, ""Could not parse document"");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, ""@errors"", errors);

  return rb_schema;
}",1
Detect whether the following code contains vulnerabilities.,"[[noreturn]] void TProtocolException::throwTruncatedData() {
  throw TProtocolException(
      TProtocolException::INVALID_DATA,
      ""Not enough bytes to read the entire message, the data appears to be ""
      ""truncated"");
}",0
Detect whether the following code contains vulnerabilities.,"static struct tcf_block *tcf_block_find(struct net *net, struct Qdisc **q,
					u32 *parent, unsigned long *cl,
					int ifindex, u32 block_index,
					struct netlink_ext_ack *extack)
{
	struct tcf_block *block;
	int err = 0;

	ASSERT_RTNL();

	err = __tcf_qdisc_find(net, q, parent, ifindex, true, extack);
	if (err)
		goto errout;

	err = __tcf_qdisc_cl_find(*q, *parent, cl, ifindex, extack);
	if (err)
		goto errout_qdisc;

	block = __tcf_block_find(net, *q, *cl, ifindex, block_index, extack);
	if (IS_ERR(block)) {
		err = PTR_ERR(block);
		goto errout_qdisc;
	}

	return block;

errout_qdisc:
	if (*q)
		qdisc_put(*q);
errout:
	*q = NULL;
	return ERR_PTR(err);
}",0
Detect whether the following code contains vulnerabilities.,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)
{
    streamIterator si;
    int64_t numfields;
    streamIteratorStart(&si,s,NULL,NULL,!first);
    si.skip_tombstones = skip_tombstones;
    int found = streamIteratorGetID(&si,edge_id,&numfields);
    if (!found) {
        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
        *edge_id = first ? max_id : min_id;
    }

}",1
Detect whether the following code contains vulnerabilities.,"nautilus_file_get_boolean_metadata (NautilusFile *file,
				    const char   *key,
				    gboolean      default_metadata)
{
	g_return_val_if_fail (key != NULL, default_metadata);
	g_return_val_if_fail (key[0] != '\0', default_metadata);
	if (file == NULL) {
		return default_metadata;
	}
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), default_metadata);

	return nautilus_directory_get_boolean_file_metadata
		(file->details->directory,
		 get_metadata_name (file),
		 key,
		 default_metadata);
}",0
Detect whether the following code contains vulnerabilities.,"static int kvm_put_vcpu_events(CPUState *env, int level)

{

    struct kvm_vcpu_events events;



    if (!kvm_has_vcpu_events()) {

        return 0;

    }



    events.exception.injected = (env->exception_injected >= 0);

    events.exception.nr = env->exception_injected;

    events.exception.has_error_code = env->has_error_code;

    events.exception.error_code = env->error_code;




    events.interrupt.injected = (env->interrupt_injected >= 0);

    events.interrupt.nr = env->interrupt_injected;

    events.interrupt.soft = env->soft_interrupt;



    events.nmi.injected = env->nmi_injected;

    events.nmi.pending = env->nmi_pending;

    events.nmi.masked = !!(env->hflags2 & HF2_NMI_MASK);

    events.nmi.pad = 0;



    events.sipi_vector = env->sipi_vector;



    events.flags = 0;

    if (level >= KVM_PUT_RESET_STATE) {

        events.flags |=

            KVM_VCPUEVENT_VALID_NMI_PENDING | KVM_VCPUEVENT_VALID_SIPI_VECTOR;

    }



    return kvm_vcpu_ioctl(env, KVM_SET_VCPU_EVENTS, &events);

}",1
Detect whether the following code contains vulnerabilities.,"int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator, const BIGNUM *order, const BIGNUM *cofactor)
	{
	if (generator == NULL)
		{
		ECerr(EC_F_EC_GROUP_SET_GENERATOR, ERR_R_PASSED_NULL_PARAMETER);
		return 0   ;
		}

	if (group->generator == NULL)
		{
		group->generator = EC_POINT_new(group);
		if (group->generator == NULL) return 0;
		}
	if (!EC_POINT_copy(group->generator, generator)) return 0;

	if (order != NULL)
		{ if (!BN_copy(&group->order, order)) return 0; }	
	else
		BN_zero(&group->order);

	if (cofactor != NULL)
		{ if (!BN_copy(&group->cofactor, cofactor)) return 0; }	
	else
		BN_zero(&group->cofactor);

	return 1;
	}",1
Detect whether the following code contains vulnerabilities.,"tcf_action_dump_1(struct sk_buff *skb, struct tc_action *a, int bind, int ref)
{
	int err = -EINVAL;
	unsigned char *b = skb_tail_pointer(skb);
	struct nlattr *nest;

	if (nla_put_string(skb, TCA_KIND, a->ops->kind))
		goto nla_put_failure;
	if (tcf_action_copy_stats(skb, a, 0))
		goto nla_put_failure;
	nest = nla_nest_start(skb, TCA_OPTIONS);
	if (nest == NULL)
		goto nla_put_failure;
	err = tcf_action_dump_old(skb, a, bind, ref);
	if (err > 0) {
		nla_nest_end(skb, nest);
		return err;
	}

nla_put_failure:
	nlmsg_trim(skb, b);
	return -1;
}",0
Detect whether the following code contains vulnerabilities.,"static int acpi_pcihp_get_bsel(PCIBus *bus)

{

    QObject *o = object_property_get_qobject(OBJECT(bus),

                                             ACPI_PCIHP_PROP_BSEL, NULL);

    int64_t bsel = -1;

    if (o) {

        bsel = qint_get_int(qobject_to_qint(o));

    }

    if (bsel < 0) {

        return -1;

    }

    return bsel;

}
",1
Detect whether the following code contains vulnerabilities.,"dfafree (struct dfa *d)
{
  size_t i;
  struct dfamust *dm, *ndm;

  free(d->charclasses);
  free(d->tokens);

  if (d->mb_cur_max > 1)
    free_mbdata(d);

  for (i = 0; i < d->sindex; ++i) {
    free(d->states[i].elems.elems);
    if (MBS_SUPPORT)
      free(d->states[i].mbps.elems);
  }
  free(d->states);
  for (i = 0; i < d->tindex; ++i)
    free(d->follows[i].elems);
  free(d->follows);
  for (i = 0; i < d->tralloc; ++i)
    {
      free(d->trans[i]);
      free(d->fails[i]);
    }
  free(d->realtrans);
  free(d->fails);
  free(d->newlines);
  free(d->success);
  for (dm = d->musts; dm; dm = ndm)
    {
      ndm = dm->next;
      free(dm->must);
      free(dm);
    }
}",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_cmpbge(uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 8; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb) {

            res |= 1 << i;

        }

    }

    return res;

}
",0
Detect whether the following code contains vulnerabilities.,"rsvg_pop_def_group (RsvgHandle * ctx)
{
    if (ctx->priv->currentnode != NULL)
        ctx->priv->currentnode = ctx->priv->currentnode->parent;
}",1
Detect whether the following code contains vulnerabilities.,"tiffsep_device_finalize(const gs_memory_t *cmem, void *vpdev)
{
    /* We need to deallocate the names. */
    devn_free_params((gx_device*) vpdev);
    gx_device_finalize(cmem, vpdev);
}",0
Detect whether the following code contains vulnerabilities.,"static int kvm_s390_check_enable_cmma(KVMState *s)

{

    struct kvm_device_attr attr = {

        .group = KVM_S390_VM_MEM_CTRL,

        .attr = KVM_S390_VM_MEM_ENABLE_CMMA,

    };



    return kvm_vm_ioctl(s, KVM_HAS_DEVICE_ATTR, &attr);

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_notify_work(struct work_struct *work)
{
	struct capictr_event *event =
		container_of(work, struct capictr_event, work);

	switch (event->type) {
	case CAPICTR_UP:
		notify_up(event->controller);
		break;
	case CAPICTR_DOWN:
		notify_down(event->controller);
		break;
	}

	kfree(event);
}",0
Detect whether the following code contains vulnerabilities.,"SwapCreateRegister(xRecordRegisterClientsReq * stuff)
{
    int i;
    XID *pClientID;

    swapl(&stuff->context);
    swapl(&stuff->nClients);
    swapl(&stuff->nRanges);
    pClientID = (XID *) &stuff[1];
    if (stuff->nClients >
        stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq))
        return BadLength;
    for (i = 0; i < stuff->nClients; i++, pClientID++) {
        swapl(pClientID);
    }
    if (stuff->nRanges >
        stuff->length - bytes_to_int32(sz_xRecordRegisterClientsReq)
        - stuff->nClients)
        return BadLength;
    RecordSwapRanges((xRecordRange *) pClientID, stuff->nRanges);
    return Success;
}                               /* SwapCreateRegister */",1
Detect whether the following code contains vulnerabilities.,"int register_ftrace_command(struct ftrace_func_command *cmd)
{
	struct ftrace_func_command *p;
	int ret = 0;

	mutex_lock(&ftrace_cmd_mutex);
	list_for_each_entry(p, &ftrace_commands, list) {
		if (strcmp(cmd->name, p->name) == 0) {
			ret = -EBUSY;
			goto out_unlock;
		}
	}
	list_add(&cmd->list, &ftrace_commands);
 out_unlock:
	mutex_unlock(&ftrace_cmd_mutex);

	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static int bufsize_v4l2_buffer(struct v4l2_buffer32 __user *up, u32 *size)
{
	u32 type;
	u32 length;

	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||
	    get_user(type, &up->type) ||
	    get_user(length, &up->length))
		return -EFAULT;

	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {
		if (length > VIDEO_MAX_PLANES)
			return -EINVAL;

		/*
		 * We don't really care if userspace decides to kill itself
		 * by passing a very big length value
		 */
		*size = length * sizeof(struct v4l2_plane);
	} else {
		*size = 0;
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"psutil_pid_exists(PyObject *self, PyObject *args) {
    long pid;
    int status;

    if (! PyArg_ParseTuple(args, ""l"", &pid))
        return NULL;

    status = psutil_pid_is_running(pid);
    if (-1 == status)
        return NULL; // exception raised in psutil_pid_is_running()
    return PyBool_FromLong(status);
}",0
Detect whether the following code contains vulnerabilities.,"DISAS_INSN(divw)

{

    TCGv reg;

    TCGv tmp;

    TCGv src;

    int sign;



    sign = (insn & 0x100) != 0;

    reg = DREG(insn, 9);

    if (sign) {

        tcg_gen_ext16s_i32(QREG_DIV1, reg);

    } else {

        tcg_gen_ext16u_i32(QREG_DIV1, reg);

    }

    SRC_EA(env, src, OS_WORD, sign, NULL);

    tcg_gen_mov_i32(QREG_DIV2, src);

    if (sign) {

        gen_helper_divs(cpu_env, tcg_const_i32(1));

    } else {

        gen_helper_divu(cpu_env, tcg_const_i32(1));

    }



    tmp = tcg_temp_new();

    src = tcg_temp_new();

    tcg_gen_ext16u_i32(tmp, QREG_DIV1);

    tcg_gen_shli_i32(src, QREG_DIV2, 16);

    tcg_gen_or_i32(reg, tmp, src);



    set_cc_op(s, CC_OP_FLAGS);

}
",1
Detect whether the following code contains vulnerabilities.,"static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
		unsigned long address, pte_t *page_table, pmd_t *pmd,
		unsigned int flags, pte_t orig_pte)
{
	pgoff_t pgoff = (((address & PAGE_MASK)
			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	pte_unmap(page_table);
	if (!(flags & FAULT_FLAG_WRITE))
		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	if (!(vma->vm_flags & VM_SHARED))
		return do_cow_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	return do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
}",1
Detect whether the following code contains vulnerabilities.,"static struct dirent *local_readdir(FsContext *ctx, V9fsFidOpenState *fs)

{

    struct dirent *entry;



again:

    entry = readdir(fs->dir.stream);

    if (!entry) {

        return NULL;

    }



    if (ctx->export_flags & V9FS_SM_MAPPED) {

        entry->d_type = DT_UNKNOWN;

    } else if (ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        if (!strcmp(entry->d_name, VIRTFS_META_DIR)) {

            /* skp the meta data directory */

            goto again;

        }

        entry->d_type = DT_UNKNOWN;

    }



    return entry;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_update_rect(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    int line;

    int bypl;

    int width;

    int start;

    uint8_t *src;

    uint8_t *dst;



    if (x + w > s->width) {

        fprintf(stderr, ""%s: update width too large x: %d, w: %d\n"",

                        __FUNCTION__, x, w);

        x = MIN(x, s->width);

        w = s->width - x;

    }



    if (y + h > s->height) {

        fprintf(stderr, ""%s: update height too large y: %d, h: %d\n"",

                        __FUNCTION__, y, h);

        y = MIN(y, s->height);

        h = s->height - y;

    }



    line = h;

    bypl = s->bypp * s->width;

    width = s->bypp * w;

    start = s->bypp * x + bypl * y;

    src = s->vga.vram_ptr + start;

    dst = ds_get_data(s->vga.ds) + start;



    for (; line > 0; line --, src += bypl, dst += bypl)

        memcpy(dst, src, width);



    dpy_gfx_update(s->vga.ds, x, y, w, h);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ev_stream_closed(h2_session *session, h2_stream *stream)
{
    apr_bucket *b;
    
    if (H2_STREAM_CLIENT_INITIATED(stream->id)
        && (stream->id > session->local.completed_max)) {
        session->local.completed_max = stream->id;
    }
    switch (session->state) {
        case H2_SESSION_ST_IDLE:
            if (session->open_streams == 0) {
                /* enter keepalive timeout, since we no longer have streams */
                session->idle_until = (session->s->keep_alive_timeout
                                       + apr_time_now());
            }
            break;
        default:
            break;
    }
    
    /* The stream might have data in the buffers of the main connection.
     * We can only free the allocated resources once all had been written.
     * Send a special buckets on the connection that gets destroyed when
     * all preceding data has been handled. On its destruction, it is safe
     * to purge all resources of the stream. */
    b = h2_bucket_eos_create(session->c->bucket_alloc, stream);
    APR_BRIGADE_INSERT_TAIL(session->bbtmp, b);
    h2_conn_io_pass(&session->io, session->bbtmp);
    apr_brigade_cleanup(session->bbtmp);
}",1
Detect whether the following code contains vulnerabilities.,"get_settings (NMExportedConnection *exported)
{
	NMConnection *connection;
	GHashTable *settings;

	connection = nm_exported_connection_get_connection (exported);

	utils_fill_connection_certs (connection);
	settings = nm_connection_to_hash (connection);
	utils_clear_filled_connection_certs (connection);

	return settings;
}",1
Detect whether the following code contains vulnerabilities.,"void run_on_cpu(CPUState *env, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_self(env)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    if (!env->queued_work_first)

        env->queued_work_first = &wi;

    else

        env->queued_work_last->next = &wi;

    env->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(env);

    while (!wi.done) {

        CPUState *self_env = cpu_single_env;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        cpu_single_env = self_env;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int php_snmp_write_max_oids(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)
{
	zval ztmp;
	int ret = SUCCESS;

	if (Z_TYPE_P(newval) == IS_NULL) {
		snmp_object->max_oids = 0;
		return ret;
	}

	if (Z_TYPE_P(newval) != IS_LONG) {
		ztmp = *newval;
		zval_copy_ctor(&ztmp);
		convert_to_long(&ztmp);
		newval = &ztmp;
	}

	if (Z_LVAL_P(newval) > 0) {
		snmp_object->max_oids = Z_LVAL_P(newval);
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""max_oids should be positive integer or NULL, got %ld"", Z_LVAL_P(newval));
	}
	
	if (newval == &ztmp) {
		zval_dtor(newval);
	}

	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void discard_vq_data(VirtQueue *vq, VirtIODevice *vdev)

{

    VirtQueueElement elem;



    if (!virtio_queue_ready(vq)) {

        return;

    }

    while (virtqueue_pop(vq, &elem)) {

        virtqueue_push(vq, &elem, 0);

    }

    virtio_notify(vdev, vq);

}
",0
Detect whether the following code contains vulnerabilities.,"static int zl100313_frontend_attach(struct dvb_usb_adapter *d)
{
	d->fe_adap[0].fe = dvb_attach(mt312_attach, &zl313_config,
			&d->dev->i2c_adap);
	if (d->fe_adap[0].fe != NULL) {
		if (dvb_attach(zl10039_attach, d->fe_adap[0].fe, 0x60,
				&d->dev->i2c_adap)) {
			d->fe_adap[0].fe->ops.set_voltage = dw210x_set_voltage;
			info(""Attached zl100313+zl10039!"");
			return 0;
		}
	}

	return -EIO;
}",0
Detect whether the following code contains vulnerabilities.,"check_never_users(uid_t uid, uid_t *nusers)
{
int i;
if (!nusers) return FALSE;
for (i = 1; i <= (int)(nusers[0]); i++) if (nusers[i] == uid) return TRUE;
return FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(xml_parser_free)
{
	zval *pind;
	xml_parser *parser;
	zend_resource *res;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""r"", &pind) == FAILURE) {
		return;
	}

	if ((parser = (xml_parser *)zend_fetch_resource(Z_RES_P(pind), ""XML Parser"", le_xml_parser)) == NULL) {
		RETURN_FALSE;
	}

	if (parser->isparsing == 1) {
		php_error_docref(NULL, E_WARNING, ""Parser cannot be freed while it is parsing."");
		RETURN_FALSE;
	}

	res = Z_RES(parser->index);
	ZVAL_UNDEF(&parser->index);
	zend_list_close(res);
	RETURN_TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"void tcp_start_outgoing_migration(MigrationState *s,

                                  const char *host_port,

                                  Error **errp)

{

    Error *err = NULL;

    SocketAddress *saddr = tcp_build_address(host_port, &err);

    if (!err) {

        socket_start_outgoing_migration(s, saddr, &err);

    }

    error_propagate(errp, err);

}
",0
Detect whether the following code contains vulnerabilities.,"static int index_search_timestamp(AVIndexEntry *entries, 

                                  int nb_entries, int wanted_timestamp)

{

    int a, b, m;

    int64_t timestamp;



    if (nb_entries <= 0)

        return -1;

    

    a = 0;

    b = nb_entries - 1;

    while (a <= b) {

        m = (a + b) >> 1;

        timestamp = entries[m].timestamp;

        if (timestamp == wanted_timestamp)

            goto found;

        else if (timestamp > wanted_timestamp) {

            b = m - 1;

        } else {

            a = m + 1;

        }

    }

    m = a;

    if (m > 0)

        m--;

 found:

    return m;

}
",0
Detect whether the following code contains vulnerabilities.,"mesalink_shutdown(struct Curl_easy *data,
                  struct connectdata *conn, int sockindex)
{
  int retval = 0;
  struct ssl_connect_data *connssl = &conn->ssl[sockindex];

  (void) data;

  if(BACKEND->handle) {
    SSL_free(BACKEND->handle);
    BACKEND->handle = NULL;
  }
  return retval;
}",0
Detect whether the following code contains vulnerabilities.,"void 
mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)
{",1
Detect whether the following code contains vulnerabilities.,"static void test_cursor_command(void)
{
    RedMemSlotInfo mem_info;
    RedCursorCmd *red_cursor_cmd;
    QXLCursorCmd cursor_cmd;
    QXLCursor *cursor;

    init_meminfo(&mem_info);

    /* test base cursor with no problems */
    memset(&cursor_cmd, 0, sizeof(cursor_cmd));
    cursor_cmd.type = QXL_CURSOR_SET;

    cursor = create_chunk(SPICE_OFFSETOF(QXLCursor, chunk), 128 * 128 * 4, NULL, 0xaa);
    cursor->header.unique = 1;
    cursor->header.width = 128;
    cursor->header.height = 128;
    cursor->data_size = 128 * 128 * 4;

    cursor_cmd.u.set.shape = to_physical(cursor);

    red_cursor_cmd = red_cursor_cmd_new(NULL, &mem_info, 0, to_physical(&cursor_cmd));
    g_assert_nonnull(red_cursor_cmd);
    red_cursor_cmd_unref(red_cursor_cmd);
    g_free(cursor);
    memslot_info_destroy(&mem_info);
}",0
Detect whether the following code contains vulnerabilities.,"uchar *getMSG(msg_t *pM)
{
	uchar *ret;
	if(pM == NULL)
		ret = UCHAR_CONSTANT("""");
	else {
		if(pM->iLenMSG == 0)
			ret = UCHAR_CONSTANT("""");
		else
			ret = pM->pszRawMsg + pM->offMSG;
	}
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"unsigned paravirt_patch_call(void *insnbuf,
			     const void *target, u16 tgt_clobbers,
			     unsigned long addr, u16 site_clobbers,
			     unsigned len)
{
	struct branch *b = insnbuf;
	unsigned long delta = (unsigned long)target - (addr+5);

	if (len < 5) {
#ifdef CONFIG_RETPOLINE
		WARN_ONCE(""Failing to patch indirect CALL in %ps\n"", (void *)addr);
#endif
		return len;	/* call too long for patch site */
	}

	b->opcode = 0xe8; /* call */
	b->delta = delta;
	BUILD_BUG_ON(sizeof(*b) != 5);

	return 5;
}",0
Detect whether the following code contains vulnerabilities.,"selaGetCombName(SELA    *sela,
                l_int32  size,
                l_int32  direction)
{
char    *selname;
char     combname[L_BUF_SIZE];
l_int32  i, nsels, sx, sy, found;
SEL     *sel;

    PROCNAME(""selaGetCombName"");

    if (!sela)
        return (char *)ERROR_PTR(""sela not defined"", procName, NULL);
    if (direction != L_HORIZ && direction != L_VERT)
        return (char *)ERROR_PTR(""invalid direction"", procName, NULL);

        /* Derive the comb name we're looking for */
    if (direction == L_HORIZ)
        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dh"", size);
    else  /* direction == L_VERT */
        snprintf(combname, L_BUF_SIZE, ""sel_comb_%dv"", size);

    found = FALSE;
    nsels = selaGetCount(sela);
    for (i = 0; i < nsels; i++) {
        sel = selaGetSel(sela, i);
        selGetParameters(sel, &sy, &sx, NULL, NULL);
        if (sy != 1 && sx != 1)  /* 2-D; not a comb */
            continue;
        selname = selGetName(sel);
        if (!strcmp(selname, combname)) {
            found = TRUE;
            break;
        }
    }

    if (found)
        return stringNew(selname);
    else
        return (char *)ERROR_PTR(""sel not found"", procName, NULL);
}",1
Detect whether the following code contains vulnerabilities.,"static int parse_line(char *str)
{
	uint8_t array[256];
	uint16_t value, pskey, length = 0;
	char *off, *end;

	pskey = strtol(str + 1, NULL, 16);
	off = strstr(str, ""="");
	if (!off)
		return -EIO;

	off++;

	while (1) {
		value = strtol(off, &end, 16);
		if (value == 0 && off == end)
			break;

		array[length++] = value & 0xff;
		array[length++] = value >> 8;

		if (*end == '\0')
			break;

		off = end + 1;
	}

	return psr_put(pskey, array, length);
}",1
Detect whether the following code contains vulnerabilities.,"pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,
			int atomic)
{
	unsigned long copy;

	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);

		if (atomic) {
			if (__copy_from_user_inatomic(to, iov->iov_base, copy))
				return -EFAULT;
		} else {
			if (copy_from_user(to, iov->iov_base, copy))
				return -EFAULT;
		}
		to += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"onig_new_without_alloc(regex_t* reg,
                       const UChar* pattern, const UChar* pattern_end,
                       OnigOptionType option, OnigEncoding enc,
                       OnigSyntaxType* syntax, OnigErrorInfo* einfo)
{
  int r;

  r = onig_reg_init(reg, option, ONIGENC_CASE_FOLD_DEFAULT, enc, syntax);
  if (r != 0) return r;

  r = onig_compile(reg, pattern, pattern_end, einfo);
  return r;
}",0
Detect whether the following code contains vulnerabilities.,"static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)
{
	UINT32 Length;
	UINT64 Offset;
	rdpPrintJob* printjob = NULL;
	UINT error = CHANNEL_RC_OK;
	Stream_Read_UINT32(irp->input, Length);
	Stream_Read_UINT64(irp->input, Offset);
	Stream_Seek(irp->input, 20); /* Padding */

	if (printer_dev->printer)
		printjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);

	if (!printjob)
	{
		irp->IoStatus = STATUS_UNSUCCESSFUL;
		Length = 0;
	}
	else
	{
		error = printjob->Write(printjob, Stream_Pointer(irp->input), Length);
	}

	if (error)
	{
		WLog_ERR(TAG, ""printjob->Write failed with error %"" PRIu32 ""!"", error);
		return error;
	}

	Stream_Write_UINT32(irp->output, Length);
	Stream_Write_UINT8(irp->output, 0); /* Padding */
	return irp->Complete(irp);
}",1
Detect whether the following code contains vulnerabilities.,"write_vector_int(BitWriter& w, int nitems, std::vector<T>& vec,
		 int bits, int_type T::*field)
{
    // nitems times, write bits bits from the given field of the ith
    // vector to the given bit writer.

    for (size_t i = 0; i < QIntC::to_size(nitems); ++i)
    {
	w.writeBits(QIntC::to_ulonglong(vec.at(i).*field),
                    QIntC::to_size(bits));
    }
    // The PDF spec says that each hint table starts at a byte
    // boundary.  Each ""row"" actually must start on a byte boundary.
    w.flush();
}",0
Detect whether the following code contains vulnerabilities.,"    DRW_TableEntry(const DRW_TableEntry& e) {
        tType = e.tType;
        handle = e.handle;
        parentHandle = e.parentHandle;
        name = e.name;
        flags = e.flags;
        numReactors = e.numReactors;
        xDictFlag = e.xDictFlag;
        curr = e.curr;
        for (std::vector<DRW_Variant*>::const_iterator it=e.extData.begin(); it!=e.extData.end(); ++it){
            extData.push_back(new DRW_Variant(*(*it)));
        }
    }",1
Detect whether the following code contains vulnerabilities.,"static void fd_chr_close(struct CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        g_io_channel_unref(s->fd_in);

    }

    if (s->fd_out) {

        g_io_channel_unref(s->fd_out);

    }



    g_free(s);

    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);

}
",1
Detect whether the following code contains vulnerabilities.,"void* OwnedImpl::linearize(uint32_t size) {
  RELEASE_ASSERT(size <= length(), ""Linearize size exceeds buffer size"");
  if (slices_.empty()) {
    return nullptr;
  }
  uint64_t linearized_size = 0;
  uint64_t num_slices_to_linearize = 0;
  for (const auto& slice : slices_) {
    num_slices_to_linearize++;
    linearized_size += slice->dataSize();
    if (linearized_size >= size) {
      break;
    }
  }
  if (num_slices_to_linearize > 1) {
    auto new_slice = OwnedSlice::create(linearized_size);
    uint64_t bytes_copied = 0;
    Slice::Reservation reservation = new_slice->reserve(linearized_size);
    ASSERT(reservation.mem_ != nullptr);
    ASSERT(reservation.len_ == linearized_size);
    auto dest = static_cast<uint8_t*>(reservation.mem_);
    do {
      uint64_t data_size = slices_.front()->dataSize();
      memcpy(dest, slices_.front()->data(), data_size);
      bytes_copied += data_size;
      dest += data_size;
      slices_.pop_front();
    } while (bytes_copied < linearized_size);
    ASSERT(dest == static_cast<const uint8_t*>(reservation.mem_) + linearized_size);
    new_slice->commit(reservation);
    slices_.emplace_front(std::move(new_slice));
  }
  return slices_.front()->data();
}",1
Detect whether the following code contains vulnerabilities.,"static char *parse_tmp_evals(RCore *core, const char *str) {
	char *res = NULL;
	RStrBuf *buf;
	char *s = strdup (str);
	buf = r_strbuf_new ("""");
	int i, argc = r_str_split (s, ',');
	for (i = 0; i < argc; i++) {
		char *eq, *kv = (char *)r_str_word_get0 (s, i);
		if (!kv) {
			break;
		}
		eq = strchr (kv, '=');
		if (eq) {
			*eq = 0;
			const char *ov = r_config_get (core->config, kv);
			r_strbuf_appendf (buf, ""e %s=%s;"", kv, ov);
			r_config_set (core->config, kv, eq + 1);
			*eq = '=';
		} else {
			eprintf (""Missing '=' in e: expression (%s)\n"", kv);
		}
	}
	res = r_strbuf_drain (buf);
	free (s);
	return res;
}",0
Detect whether the following code contains vulnerabilities.,"AVEvalExpr * ff_parse(const char *s, const char * const *const_name,

               double (**func1)(void *, double), const char **func1_name,

               double (**func2)(void *, double, double), const char **func2_name,

               const char **error){

    Parser p;

    AVEvalExpr * e;

    char w[strlen(s) + 1], * wp = w;



    while (*s)

        if (!isspace(*s++)) *wp++ = s[-1];

    *wp++ = 0;



    p.stack_index=100;

    p.s= w;

    p.const_name = const_name;

    p.func1      = func1;

    p.func1_name = func1_name;

    p.func2      = func2;

    p.func2_name = func2_name;

    p.error= error;



    e = parse_expr(&p);

    if (!verify_expr(e)) {

        ff_eval_free(e);

        return NULL;

    }

    return e;

}
",1
Detect whether the following code contains vulnerabilities.,"int ecryptfs_get_lower_file(struct dentry *dentry, struct inode *inode)
{
	struct ecryptfs_inode_info *inode_info;
	int count, rc = 0;

	inode_info = ecryptfs_inode_to_private(inode);
	mutex_lock(&inode_info->lower_file_mutex);
	count = atomic_inc_return(&inode_info->lower_file_count);
	if (WARN_ON_ONCE(count < 1))
		rc = -EINVAL;
	else if (count == 1) {
		rc = ecryptfs_init_lower_file(dentry,
					      &inode_info->lower_file);
		if (rc)
			atomic_set(&inode_info->lower_file_count, 0);
	}
	mutex_unlock(&inode_info->lower_file_mutex);
	return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static bool bdrv_drain_one(BlockDriverState *bs)

{

    bool bs_busy;



    bdrv_flush_io_queue(bs);

    bdrv_start_throttled_reqs(bs);

    bs_busy = bdrv_requests_pending(bs);

    bs_busy |= aio_poll(bdrv_get_aio_context(bs), bs_busy);

    return bs_busy;

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_arch_set_tsc_khz(CPUState *cs)

{

    X86CPU *cpu = X86_CPU(cs);

    CPUX86State *env = &cpu->env;

    int r;



    if (!env->tsc_khz) {

        return 0;

    }



    r = kvm_check_extension(cs->kvm_state, KVM_CAP_TSC_CONTROL) ?

        kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :

        -ENOTSUP;

    if (r < 0) {

        /* When KVM_SET_TSC_KHZ fails, it's an error only if the current

         * TSC frequency doesn't match the one we want.

         */

        int cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?

                       kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :

                       -ENOTSUP;

        if (cur_freq <= 0 || cur_freq != env->tsc_khz) {

            error_report(""warning: TSC frequency mismatch between ""

                         ""VM (%"" PRId64 "" kHz) and host (%d kHz), ""

                         ""and TSC scaling unavailable"",

                         env->tsc_khz, cur_freq);

            return r;

        }

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"BlockAIOCB *dma_bdrv_io(

    BlockDriverState *bs, QEMUSGList *sg, uint64_t sector_num,

    DMAIOFunc *io_func, BlockCompletionFunc *cb,

    void *opaque, DMADirection dir)

{

    DMAAIOCB *dbs = qemu_aio_get(&dma_aiocb_info, bs, cb, opaque);



    trace_dma_bdrv_io(dbs, bs, sector_num, (dir == DMA_DIRECTION_TO_DEVICE));



    dbs->acb = NULL;

    dbs->bs = bs;

    dbs->sg = sg;

    dbs->sector_num = sector_num;

    dbs->sg_cur_index = 0;

    dbs->sg_cur_byte = 0;

    dbs->dir = dir;

    dbs->io_func = io_func;

    dbs->bh = NULL;

    qemu_iovec_init(&dbs->iov, sg->nsg);

    dma_bdrv_cb(dbs, 0);

    return &dbs->common;

}
",0
Detect whether the following code contains vulnerabilities.,"void mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,
		       int frag_count)
{

	struct sk_buff *skb;

	PRINTK(""entering mac_drv_clear_rxd\n"");

	if (frag_count != 1)	// This is not allowed to happen.

		printk(""fddi: Multi-fragment clear!\n"");

	for (; frag_count > 0; frag_count--) {
		skb = rxd->rxd_os.skb;
		if (skb != NULL) {
			skfddi_priv *bp = &smc->os;
			int MaxFrameSize = bp->MaxFrameSize;

			pci_unmap_single(&bp->pdev, rxd->rxd_os.dma_addr,
					 MaxFrameSize, PCI_DMA_FROMDEVICE);

			dev_kfree_skb(skb);
			rxd->rxd_os.skb = NULL;
		}
		rxd = rxd->rxd_next;	// Next RXD.

	}
}				// mac_drv_clear_rxd",0
Detect whether the following code contains vulnerabilities.,"static abi_long do_sendto(int fd, abi_ulong msg, size_t len, int flags,

                          abi_ulong target_addr, socklen_t addrlen)

{

    void *addr;

    void *host_msg;

    abi_long ret;



    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)

        return -TARGET_EINVAL;



    host_msg = lock_user(VERIFY_READ, msg, len, 1);

    if (!host_msg)

        return -TARGET_EFAULT;

    if (target_addr) {

        addr = alloca(addrlen);

        target_to_host_sockaddr(addr, target_addr, addrlen);

        ret = get_errno(sendto(fd, host_msg, len, flags, addr, addrlen));

    } else {

        ret = get_errno(send(fd, host_msg, len, flags));

    }

    unlock_user(host_msg, msg, 0);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void io_watch_poll_finalize(GSource *source)

{

    IOWatchPoll *iwp = io_watch_poll_from_source(source);

    if (iwp->src) {

        g_source_destroy(iwp->src);

        g_source_unref(iwp->src);

        iwp->src = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int	special(DviContext *dvi, int opcode)
{
	char	*s;
	Int32	arg;
	
	arg = dugetn(dvi, opcode - DVI_XXX1 + 1);
	s = mdvi_malloc(arg + 1);
	dread(dvi, s, arg);
	s[arg] = 0;
	mdvi_do_special(dvi, s);
	SHOWCMD((dvi, ""XXXX"", opcode - DVI_XXX1 + 1,
		""[%s]"", s));
	mdvi_free(s);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t dchip_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    /* Skip this.  It's all related to DRAM timing and setup.  */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoul_full_correct(void)

{

    const char *str = ""123"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

}
",0
Detect whether the following code contains vulnerabilities.,"gst_aac_parse_adts_get_frame_len (const guint8 * data)
{
  return ((data[3] & 0x03) << 11) | (data[4] << 3) | ((data[5] & 0xe0) >> 5);
}",0
Detect whether the following code contains vulnerabilities.,"static int chr_can_read(void *opaque)

{

    int can_read;

    SCLPConsole *scon = opaque;



    can_read = SIZE_BUFFER_VT220 - scon->iov_data_len;



    return can_read;

}
",1
Detect whether the following code contains vulnerabilities.,"int outwrite(const gs_memory_t *mem, const char *str, int len)
{
    int code;
    gs_lib_ctx_t *pio = mem->gs_lib_ctx;
    gs_lib_ctx_core_t *core = pio->core;

    if (len == 0)
        return 0;
    if (core->stdout_is_redirected) {
        if (core->stdout_to_stderr)
            return errwrite(mem, str, len);
        code = gp_fwrite(str, 1, len, core->fstdout2);
        gp_fflush(core->fstdout2);
    } else if (core->stdout_fn) {
        return (*core->stdout_fn)(core->std_caller_handle, str, len);
    } else {
        code = fwrite(str, 1, len, core->fstdout);
        fflush(core->fstdout);
    }
    return code;
}",0
Detect whether the following code contains vulnerabilities.,"void qemu_system_guest_panicked(GuestPanicInformation *info)
{
    if (current_cpu) {
        current_cpu->crash_occurred = true;
    }
    qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_PAUSE,
                                   !!info, info, &error_abort);
    vm_stop(RUN_STATE_GUEST_PANICKED);
    if (!no_shutdown) {
        qapi_event_send_guest_panicked(GUEST_PANIC_ACTION_POWEROFF,
                                       !!info, info, &error_abort);
        qemu_system_shutdown_request();
    }
    if (info) {
        if (info->type == GUEST_PANIC_INFORMATION_KIND_HYPER_V) {
            qemu_log_mask(LOG_GUEST_ERROR, ""HV crash parameters: (%#""PRIx64
                          "" %#""PRIx64"" %#""PRIx64"" %#""PRIx64"" %#""PRIx64"")\n"",
                          info->u.hyper_v.data->arg1,
                          info->u.hyper_v.data->arg2,
                          info->u.hyper_v.data->arg3,
                          info->u.hyper_v.data->arg4,
                          info->u.hyper_v.data->arg5);
        }
        qapi_free_GuestPanicInformation(info);
    }
}",1
Detect whether the following code contains vulnerabilities.,"_asn1_extract_der_octet (asn1_node node, const unsigned char *der,
			 int der_len)
{
  int len2, len3;
  int counter2, counter_end;

  len2 = asn1_get_length_der (der, der_len, &len3);
  if (len2 < -1)
    return ASN1_DER_ERROR;

  counter2 = len3 + 1;

  if (len2 == -1)
    counter_end = der_len - 2;
  else
    counter_end = der_len;

  while (counter2 < counter_end)
    {
      len2 = asn1_get_length_der (der + counter2, der_len - counter2, &len3);

      if (len2 < -1)
	return ASN1_DER_ERROR;

      if (len2 > 0)
	{
	  _asn1_append_value (node, der + counter2 + len3, len2);
	}
      else
	{			/* indefinite */

	  len2 =
	    _asn1_extract_der_octet (node, der + counter2 + len3,
				     der_len - counter2 - len3);
	  if (len2 < 0)
	    return len2;
	}

      counter2 += len2 + len3 + 1;
    }

  return ASN1_SUCCESS;
}",1
Detect whether the following code contains vulnerabilities.,"char *get_boot_devices_list(uint32_t *size)

{

    FWBootEntry *i;

    uint32_t total = 0;

    char *list = NULL;



    QTAILQ_FOREACH(i, &fw_boot_order, link) {

        char *devpath = NULL, *bootpath;

        int len;



        if (i->dev) {

            devpath = qdev_get_fw_dev_path(i->dev);

            assert(devpath);

        }



        if (i->suffix && devpath) {

            bootpath = qemu_malloc(strlen(devpath) + strlen(i->suffix) + 1);

            sprintf(bootpath, ""%s%s"", devpath, i->suffix);

            qemu_free(devpath);

        } else if (devpath) {

            bootpath = devpath;

        } else {

            bootpath = strdup(i->suffix);

            assert(bootpath);

        }



        if (total) {

            list[total-1] = '\n';

        }

        len = strlen(bootpath) + 1;

        list = qemu_realloc(list, total + len);

        memcpy(&list[total], bootpath, len);

        total += len;

        qemu_free(bootpath);

    }



    *size = total;



    return list;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ehci_async_complete_packet(USBPort *port, USBPacket *packet)

{

    EHCIQueue *q;

    EHCIState *s = port->opaque;

    uint32_t portsc = s->portsc[port->index];



    if (portsc & PORTSC_POWNER) {

        USBPort *companion = s->companion_ports[port->index];

        companion->ops->complete(companion, packet);

        return;

    }



    q = container_of(packet, EHCIQueue, packet);

    trace_usb_ehci_queue_action(q, ""wakeup"");

    assert(q->async == EHCI_ASYNC_INFLIGHT);

    q->async = EHCI_ASYNC_FINISHED;

    q->usb_status = packet->len;

}
",1
Detect whether the following code contains vulnerabilities.,"static void peripheral_device_del_completion(ReadLineState *rs,

                                             const char *str, size_t len)

{

    Object *peripheral;

    GSList *list = NULL, *item;



    peripheral = object_resolve_path(""/machine/peripheral/"", NULL);

    if (peripheral == NULL) {

        return;

    }



    object_child_foreach(peripheral, qdev_build_hotpluggable_device_list,

                         &list);



    for (item = list; item; item = g_slist_next(item)) {

        DeviceState *dev = item->data;



        if (dev->id && !strncmp(str, dev->id, len)) {

            readline_add_completion(rs, dev->id);

        }

    }



    g_slist_free(list);

}
",1
Detect whether the following code contains vulnerabilities.,"Item_name_const::Item_name_const(THD *thd, Item *name_arg, Item *val):
  Item(thd), value_item(val), name_item(name_arg)
{
  StringBuffer<128> name_buffer;
  String *name_str;
  Item::maybe_null= TRUE;
  valid_args= true;
  if (!name_item->basic_const_item() ||
      !(name_str= name_item->val_str(&name_buffer))) // Can't have a NULL name
    goto err;
  set_name(thd, name_str->ptr(), name_str->length(), name_str->charset());

  if (value_item->basic_const_item())
    return; // ok

  if (value_item->type() == FUNC_ITEM)
  {
    Item_func *value_func= (Item_func *) value_item;
    if (value_func->functype() != Item_func::COLLATE_FUNC &&
        value_func->functype() != Item_func::NEG_FUNC)
      goto err;

    if (value_func->key_item()->basic_const_item())
      return; // ok
  }

err:
  valid_args= false;
  my_error(ER_WRONG_ARGUMENTS, MYF(0), ""NAME_CONST"");
}",0
Detect whether the following code contains vulnerabilities.,"int RGWGetACLs::verify_permission()
{
  bool perm;
  if (!s->object.empty()) {
    auto iam_action = s->object.instance.empty() ?
      rgw::IAM::s3GetObjectAcl :
      rgw::IAM::s3GetObjectVersionAcl;

    if (s->iam_policy && s->iam_policy->has_partial_conditional(S3_EXISTING_OBJTAG)){
      rgw_obj obj = rgw_obj(s->bucket, s->object);
      rgw_iam_add_existing_objtags(store, s, obj, iam_action);
    }

    perm = verify_object_permission(s, iam_action);
  } else {
    perm = verify_bucket_permission(s, rgw::IAM::s3GetBucketAcl);
  }
  if (!perm)
    return -EACCES;

  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)

{

    Error *local_err = NULL;

    char *dirpath;

    int dirfd;

    char *buf;

    GuestMemoryBlockInfo *info;



    dirpath = g_strdup_printf(""/sys/devices/system/memory/"");

    dirfd = open(dirpath, O_RDONLY | O_DIRECTORY);

    if (dirfd == -1) {

        error_setg_errno(errp, errno, ""open(\""%s\"")"", dirpath);

        g_free(dirpath);

        return NULL;

    }

    g_free(dirpath);



    buf = g_malloc0(20);

    ga_read_sysfs_file(dirfd, ""block_size_bytes"", buf, 20, &local_err);


    if (local_err) {

        g_free(buf);

        error_propagate(errp, local_err);

        return NULL;

    }



    info = g_new0(GuestMemoryBlockInfo, 1);

    info->size = strtol(buf, NULL, 16); /* the unit is bytes */



    g_free(buf);



    return info;

}",1
Detect whether the following code contains vulnerabilities.,"delete_port(struct seq_oss_devinfo *dp)
{
	if (dp->port < 0)
		return 0;

	debug_printk((""delete_port %i\n"", dp->port));
	return snd_seq_event_port_detach(dp->cseq, dp->port);
}",1
Detect whether the following code contains vulnerabilities.,"unsigned int s390_cpu_set_state(uint8_t cpu_state, S390CPU *cpu)

 {

    trace_cpu_set_state(CPU(cpu)->cpu_index, cpu_state);



    switch (cpu_state) {

    case CPU_STATE_STOPPED:

    case CPU_STATE_CHECK_STOP:

        /* halt the cpu for common infrastructure */

        s390_cpu_halt(cpu);

        break;

    case CPU_STATE_OPERATING:

    case CPU_STATE_LOAD:

        /* unhalt the cpu for common infrastructure */

        s390_cpu_unhalt(cpu);

        break;

    default:

        error_report(""Requested CPU state is not a valid S390 CPU state: %u"",

                     cpu_state);

        exit(1);





    cpu->env.cpu_state = cpu_state;



    return s390_count_running_cpus();
",1
Detect whether the following code contains vulnerabilities.,"static int net_socket_mcast_init(NetClientState *peer,

                                 const char *model,

                                 const char *name,

                                 const char *host_str,

                                 const char *localaddr_str)

{

    NetSocketState *s;

    int fd;

    struct sockaddr_in saddr;

    struct in_addr localaddr, *param_localaddr;



    if (parse_host_port(&saddr, host_str) < 0)

        return -1;



    if (localaddr_str != NULL) {

        if (inet_aton(localaddr_str, &localaddr) == 0)

            return -1;

        param_localaddr = &localaddr;

    } else {

        param_localaddr = NULL;

    }



    fd = net_socket_mcast_create(&saddr, param_localaddr);

    if (fd < 0)

        return -1;



    s = net_socket_fd_init(peer, model, name, fd, 0);

    if (!s)

        return -1;



    s->dgram_dst = saddr;



    snprintf(s->nc.info_str, sizeof(s->nc.info_str),

             ""socket: mcast=%s:%d"",

             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));

    return 0;



}
",1
Detect whether the following code contains vulnerabilities.,"void ff_mpegts_parse_close(MpegTSContext *ts)

{

    int i;



    for(i=0;i<NB_PID_MAX;i++)

        av_free(ts->pids[i]);

    av_free(ts);

}
",1
Detect whether the following code contains vulnerabilities.,"static int key_exchange_expected(SSL *s)
{
    long alg_k = s->s3->tmp.new_cipher->algorithm_mkey;

    /*
     * Can't skip server key exchange if this is an ephemeral
     * ciphersuite or for SRP
     */
    if (alg_k & (SSL_kDHE | SSL_kECDHE | SSL_kDHEPSK | SSL_kECDHEPSK
                 | SSL_kSRP)) {
        return 1;
    }

    return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_vorbis_ready_floor1_list(vorbis_floor1_entry * list, int values)

{

    int i;

    list[0].sort = 0;

    list[1].sort = 1;

    for (i = 2; i < values; i++) {

        int j;

        list[i].low  = 0;

        list[i].high = 1;

        list[i].sort = i;

        for (j = 2; j < i; j++) {

            int tmp = list[j].x;

            if (tmp < list[i].x) {

                if (tmp > list[list[i].low].x)

                    list[i].low  =  j;

            } else {

                if (tmp < list[list[i].high].x)

                    list[i].high = j;

            }

        }

    }

    for (i = 0; i < values - 1; i++) {

        int j;

        for (j = i + 1; j < values; j++) {

            if (list[list[i].sort].x > list[list[j].sort].x) {

                int tmp = list[i].sort;

                list[i].sort = list[j].sort;

                list[j].sort = tmp;

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"uint16_t mesg_id (void) {
	static uint16_t id = 0;

	if (!id) {
		srandom (time (NULL));
		id = random ();
	}
	id++;

	if (T.debug > 4)
		syslog (LOG_DEBUG, ""mesg_id() = %d"", id);
	return id;
}",1
Detect whether the following code contains vulnerabilities.,"static inline void clear_evtchn(evtchn_port_t port)
{
	evtchn_ops->clear_pending(port);
}",0
Detect whether the following code contains vulnerabilities.,"void ff_h264_remove_all_refs(H264Context *h)

{

    int i;



    for (i = 0; i < 16; i++) {

        remove_long(h, i, 0);

    }

    assert(h->long_ref_count == 0);



    ff_h264_unref_picture(h, &h->last_pic_for_ec);

    if (h->short_ref_count)

        ff_h264_ref_picture(h, &h->last_pic_for_ec, h->short_ref[0]);



    for (i = 0; i < h->short_ref_count; i++) {

        unreference_pic(h, h->short_ref[i], 0);

        h->short_ref[i] = NULL;

    }

    h->short_ref_count = 0;



    memset(h->default_ref_list, 0, sizeof(h->default_ref_list));

    memset(h->ref_list, 0, sizeof(h->ref_list));

}
",0
Detect whether the following code contains vulnerabilities.,"OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size ( opj_j2k_t *p_j2k,
                                                                        OPJ_UINT32 p_tile_no,
                                                                        OPJ_UINT32 p_comp_no )
{
        OPJ_UINT32 l_num_bands;

        opj_cp_t *l_cp = 00;
        opj_tcp_t *l_tcp = 00;
        opj_tccp_t *l_tccp = 00;

        /* preconditions */
        assert(p_j2k != 00);

        l_cp = &(p_j2k->m_cp);
        l_tcp = &l_cp->tcps[p_tile_no];
        l_tccp = &l_tcp->tccps[p_comp_no];

        /* preconditions again */
        assert(p_tile_no < l_cp->tw * l_cp->th);
        assert(p_comp_no < p_j2k->m_private_image->numcomps);

        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);

        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {
                return 1 + l_num_bands;
        }
        else {
                return 1 + 2*l_num_bands;
        }
}",0
Detect whether the following code contains vulnerabilities.,"psutil_ppid_map(PyObject *self, PyObject *args) {
    PyObject *py_pid = NULL;
    PyObject *py_ppid = NULL;
    PyObject *py_retdict = PyDict_New();
    HANDLE handle = NULL;
    PROCESSENTRY32 pe = {0};
    pe.dwSize = sizeof(PROCESSENTRY32);

    if (py_retdict == NULL)
        return NULL;
    handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (handle == INVALID_HANDLE_VALUE) {
        PyErr_SetFromWindowsErr(0);
        Py_DECREF(py_retdict);
        return NULL;
    }

    if (Process32First(handle, &pe)) {
        do {
            py_pid = Py_BuildValue(""I"", pe.th32ProcessID);
            if (py_pid == NULL)
                goto error;
            py_ppid = Py_BuildValue(""I"", pe.th32ParentProcessID);
            if (py_ppid == NULL)
                goto error;
            if (PyDict_SetItem(py_retdict, py_pid, py_ppid))
                goto error;
            Py_DECREF(py_pid);
            Py_DECREF(py_ppid);
        } while (Process32Next(handle, &pe));
    }

    CloseHandle(handle);
    return py_retdict;

error:
    Py_XDECREF(py_pid);
    Py_XDECREF(py_ppid);
    Py_DECREF(py_retdict);
    CloseHandle(handle);
    return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"int perf_event_task_enable(void)
{
	struct perf_event *event;

	mutex_lock(&current->perf_event_mutex);
	list_for_each_entry(event, &current->perf_event_list, owner_entry)
		perf_event_for_each_child(event, perf_event_enable);
	mutex_unlock(&current->perf_event_mutex);

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"  For_Obj Parser::parse_for_directive()
  {
    stack.push_back(Scope::Control);
    ParserState for_source_position = pstate;
    bool root = block_stack.back()->is_root();
    lex_variable();
    std::string var(Util::normalize_underscores(lexed));
    if (!lex< kwd_from >()) error(""expected 'from' keyword in @for directive"");
    Expression_Obj lower_bound = parse_expression();
    bool inclusive = false;
    if (lex< kwd_through >()) inclusive = true;
    else if (lex< kwd_to >()) inclusive = false;
    else                  error(""expected 'through' or 'to' keyword in @for directive"");
    Expression_Obj upper_bound = parse_expression();
    Block_Obj body = parse_block(root);
    stack.pop_back();
    return SASS_MEMORY_NEW(For, for_source_position, var, lower_bound, upper_bound, body, inclusive);
  }",0
Detect whether the following code contains vulnerabilities.,"void ff_thread_await_progress(ThreadFrame *f, int n, int field)

{

    PerThreadContext *p;

    atomic_int *progress = f->progress ? (atomic_int*)f->progress->data : NULL;



    if (!progress ||

        atomic_load_explicit(&progress[field], memory_order_acquire) >= n)

        return;



    p = f->owner[field]->internal->thread_ctx;



    pthread_mutex_lock(&p->progress_mutex);

    if (f->owner[field]->debug&FF_DEBUG_THREADS)

        av_log(f->owner[field], AV_LOG_DEBUG,

               ""thread awaiting %d field %d from %p\n"", n, field, progress);

    while (atomic_load_explicit(&progress[field], memory_order_relaxed) < n)

        pthread_cond_wait(&p->progress_cond, &p->progress_mutex);

    pthread_mutex_unlock(&p->progress_mutex);

}
",1
Detect whether the following code contains vulnerabilities.,"static void savecursor(VTermState *state, int save)
{
  if(save) {
    state->saved.pos = state->pos;
    state->saved.mode.cursor_visible = state->mode.cursor_visible;
    state->saved.mode.cursor_blink   = state->mode.cursor_blink;
    state->saved.mode.cursor_shape   = state->mode.cursor_shape;

    vterm_state_savepen(state, 1);
  }
  else {
    VTermPos oldpos = state->pos;

    state->pos = state->saved.pos;

    settermprop_bool(state, VTERM_PROP_CURSORVISIBLE, state->saved.mode.cursor_visible);
    settermprop_bool(state, VTERM_PROP_CURSORBLINK,   state->saved.mode.cursor_blink);
    settermprop_int (state, VTERM_PROP_CURSORSHAPE,   state->saved.mode.cursor_shape);

    vterm_state_savepen(state, 0);

    updatecursor(state, &oldpos, 1);
  }
}",0
Detect whether the following code contains vulnerabilities.,"static void virtio_net_add_queue(VirtIONet *n, int index)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    n->vqs[index].rx_vq = virtio_add_queue(vdev, n->net_conf.rx_queue_size,
                                           virtio_net_handle_rx);

    if (n->net_conf.tx && !strcmp(n->net_conf.tx, ""timer"")) {
        n->vqs[index].tx_vq =
            virtio_add_queue(vdev, n->net_conf.tx_queue_size,
                             virtio_net_handle_tx_timer);
        n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                                              virtio_net_tx_timer,
                                              &n->vqs[index]);
    } else {
        n->vqs[index].tx_vq =
            virtio_add_queue(vdev, n->net_conf.tx_queue_size,
                             virtio_net_handle_tx_bh);
        n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);
    }

    n->vqs[index].tx_waiting = 0;
    n->vqs[index].n = n;
}",0
Detect whether the following code contains vulnerabilities.,"void json_start_object(QJSON *json, const char *name)

{

    json_emit_element(json, name);

    qstring_append(json->str, ""{ "");

    json->omit_comma = true;

}
",0
Detect whether the following code contains vulnerabilities.," */
xmlNodePtr
xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt, xmlNodePtr cur) {
    if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if (cur != NULL && cur->children != NULL)
        return cur->children ;
    if (cur == NULL) cur = ctxt->context->node;
    if (cur == NULL) return(NULL) ; /* ERROR */
    if (cur->next != NULL) return(cur->next) ;
    do {
        cur = cur->parent;
        if (cur == NULL) break;
        if (cur == (xmlNodePtr) ctxt->context->doc) return(NULL);
        if (cur->next != NULL) return(cur->next);
    } while (cur != NULL);",1
Detect whether the following code contains vulnerabilities.,"static uint32_t qvirtio_pci_config_readl(QVirtioDevice *d, uint64_t off)

{

    QVirtioPCIDevice *dev = (QVirtioPCIDevice *)d;

    uint32_t value;



    value = qpci_io_readl(dev->pdev, CONFIG_BASE(dev) + off);

    if (qvirtio_is_big_endian(d)) {

        value = bswap32(value);

    }

    return value;

}
",1
Detect whether the following code contains vulnerabilities.,"void bdrv_debug_event(BlockDriverState *bs, BlkDebugEvent event)

{

    if (!bs || !bs->drv || !bs->drv->bdrv_debug_event) {

        return;

    }



    bs->drv->bdrv_debug_event(bs, event);

}
",0
Detect whether the following code contains vulnerabilities.,"static void perf_lifecycle(void)

{

    Coroutine *coroutine;

    unsigned int i, max;

    double duration;



    max = 1000000;



    g_test_timer_start();

    for (i = 0; i < max; i++) {

        coroutine = qemu_coroutine_create(empty_coroutine);

        qemu_coroutine_enter(coroutine, NULL);

    }

    duration = g_test_timer_elapsed();



    g_test_message(""Lifecycle %u iterations: %f s\n"", max, duration);

}
",1
Detect whether the following code contains vulnerabilities.,"int check_intra_pred4x4_mode_emuedge(int mode, int mb_x, int mb_y, int *copy_buf)

{

    switch (mode) {

    case VERT_PRED:

        if (!mb_x && mb_y) {

            *copy_buf = 1;

            return mode;

        }

        /* fall-through */

    case DIAG_DOWN_LEFT_PRED:

    case VERT_LEFT_PRED:

        return !mb_y ? DC_127_PRED : mode;

    case HOR_PRED:

        if (!mb_y) {

            *copy_buf = 1;

            return mode;

        }

        /* fall-through */

    case HOR_UP_PRED:

        return !mb_x ? DC_129_PRED : mode;

    case TM_VP8_PRED:

        return check_tm_pred4x4_mode(mode, mb_x, mb_y);

    case DC_PRED: /* 4x4 DC doesn't use the same ""H.264-style"" exceptions

                   * as 16x16/8x8 DC */

    case DIAG_DOWN_RIGHT_PRED:

    case VERT_RIGHT_PRED:

    case HOR_DOWN_PRED:

        if (!mb_y || !mb_x)

            *copy_buf = 1;

        return mode;

    }

    return mode;

}
",1
Detect whether the following code contains vulnerabilities.,"static int csrhci_write(struct CharDriverState *chr,

                const uint8_t *buf, int len)

{

    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;

    int plen = s->in_len;



    if (!s->enable)

        return 0;



    s->in_len += len;

    memcpy(s->inpkt + plen, buf, len);



    while (1) {

        if (s->in_len >= 2 && plen < 2)

            s->in_hdr = csrhci_header_len(s->inpkt) + 1;



        if (s->in_len >= s->in_hdr && plen < s->in_hdr)

            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;



        if (s->in_len >= s->in_data) {

            csrhci_in_packet(s, s->inpkt);



            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);

            s->in_len -= s->in_data;

            s->in_hdr = INT_MAX;

            s->in_data = INT_MAX;

            plen = 0;

        } else

            break;

    }



    return len;

}
",1
Detect whether the following code contains vulnerabilities.,"static int find_sys_file(struct mschm_decompressor_p *self,
			 struct mschmd_sec_mscompressed *sec,
			 struct mschmd_file **f_ptr, const char *name)
{
    struct mspack_system *sys = self->system;
    struct mschmd_file result;

    /* already loaded */
    if (*f_ptr) return MSPACK_ERR_OK;

    /* try using fast_find to find the file - return DATAFORMAT error if
     * it fails, or successfully doesn't find the file */
    if (chmd_fast_find((struct mschm_decompressor *) self, sec->base.chm,
		       name, &result, (int)sizeof(result)) || !result.section)
    {
	return MSPACK_ERR_DATAFORMAT;
    }

    if (!(*f_ptr = (struct mschmd_file *) sys->alloc(sys, sizeof(result)))) {
	return MSPACK_ERR_NOMEMORY;
    }

    /* copy result */
    *(*f_ptr) = result;
    (*f_ptr)->filename = (char *) name;

    /* link file into sysfiles list */
    (*f_ptr)->next = sec->base.chm->sysfiles;
    sec->base.chm->sysfiles = *f_ptr;
    return MSPACK_ERR_OK;
}",0
Detect whether the following code contains vulnerabilities.,"static int gss_iakerbmechglue_init(void)
{
    struct gss_mech_config mech_iakerb;
    struct gss_config iakerb_mechanism = krb5_mechanism;

    /* IAKERB mechanism mirrors krb5, but with different context SPIs */
    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;
    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;
    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;
    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;
    iakerb_mechanism.gssspi_acquire_cred_with_password
                                    = iakerb_gss_acquire_cred_with_password;

    memset(&mech_iakerb, 0, sizeof(mech_iakerb));
    mech_iakerb.mech = &iakerb_mechanism;

    mech_iakerb.mechNameStr = ""iakerb"";
    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;
    gssint_register_mechinfo(&mech_iakerb);

    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"sofcantsendmore(struct socket *so)

{

	if ((so->so_state & SS_NOFDREF) == 0) {

            shutdown(so->s,1);           /* send FIN to fhost */

            if (global_readfds) {

                FD_CLR(so->s,global_readfds);

            }

            if (global_xfds) {

                FD_CLR(so->s,global_xfds);

            }

	}

	so->so_state &= ~(SS_ISFCONNECTING);

	if (so->so_state & SS_FCANTRCVMORE) {

	   so->so_state &= SS_PERSISTENT_MASK;

	   so->so_state |= SS_NOFDREF; /* as above */

	} else {

	   so->so_state |= SS_FCANTSENDMORE;

	}

}
",0
Detect whether the following code contains vulnerabilities.,"target_ulong helper_sub_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 - t2;

    return suov32(env, result);

}
",1
Detect whether the following code contains vulnerabilities.,"utfc_char2bytes(int off, char_u *buf)
{
    int		len;
    int		i;

    len = utf_char2bytes(ScreenLinesUC[off], buf);
    for (i = 0; i < Screen_mco; ++i)
    {
	if (ScreenLinesC[i][off] == 0)
	    break;
	len += utf_char2bytes(ScreenLinesC[i][off], buf + len);
    }
    return len;
}",0
Detect whether the following code contains vulnerabilities.,"static void sctp_cmd_setup_t2(sctp_cmd_seq_t *cmds,
			      struct sctp_association *asoc,
			      struct sctp_chunk *chunk)
{
	struct sctp_transport *t;

	if (chunk->transport)
		t = chunk->transport;
	else {
		t = sctp_assoc_choose_alter_transport(asoc,
					      asoc->shutdown_last_sent_to);
		chunk->transport = t;
	}
	asoc->shutdown_last_sent_to = t;
	asoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = t->rto;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t flush_buf(VirtIOSerialPort *port,
                         const uint8_t *buf, ssize_t len)
{
    VirtConsole *vcon = VIRTIO_CONSOLE(port);
    ssize_t ret;
    if (!vcon->chr) {
        /* If there's no backend, we can just say we consumed all data. */
        return len;
    }
    ret = qemu_chr_fe_write(vcon->chr, buf, len);
    trace_virtio_console_flush_buf(port->id, len, ret);
    if (ret < len) {
        VirtIOSerialPortClass *k = VIRTIO_SERIAL_PORT_GET_CLASS(port);
        /*
         * Ideally we'd get a better error code than just -1, but
         * that's what the chardev interface gives us right now.  If
         * we had a finer-grained message, like -EPIPE, we could close
         * this connection.
        if (ret < 0)
            ret = 0;
        if (!k->is_console) {
            virtio_serial_throttle_port(port, true);
            if (!vcon->watch) {
                vcon->watch = qemu_chr_fe_add_watch(vcon->chr,
                                                    G_IO_OUT|G_IO_HUP,
                                                    chr_write_unblocked, vcon);
            }
        }
    }
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void cirrus_mem_writeb_mode4and5_8bpp(CirrusVGAState * s,
					     unsigned mode,
					     unsigned offset,
					     uint32_t mem_value)
{
    int x;
    unsigned val = mem_value;
    uint8_t *dst;

    dst = s->vram_ptr + offset;
    for (x = 0; x < 8; x++) {
	if (val & 0x80) {
	    *dst = s->cirrus_shadow_gr1;
	} else if (mode == 5) {
	    *dst = s->cirrus_shadow_gr0;
	}
	val <<= 1;
	dst++;
    }
    cpu_physical_memory_set_dirty(s->vram_offset + offset);
    cpu_physical_memory_set_dirty(s->vram_offset + offset + 7);
}",1
Detect whether the following code contains vulnerabilities.,"    bool is_resized() const {
      return _is_resized;
    }",0
Detect whether the following code contains vulnerabilities.,  ~RGWGetBucketLocation() override {},0
Detect whether the following code contains vulnerabilities.,"static int update_add_entry(struct libmnt_update *upd, struct libmnt_lock *lc)
{
	struct libmnt_table *tb;
	int rc = 0, u_lc = -1;

	assert(upd);
	assert(upd->fs);

	DBG(UPDATE, mnt_debug_h(upd, ""%s: add entry"", upd->filename));

	if (lc)
		mnt_lock_file(lc);
	else if (upd->userspace_only)
		u_lc = utab_lock(upd->filename);

	tb = __mnt_new_table_from_file(upd->filename,
			upd->userspace_only ? MNT_FMT_UTAB : MNT_FMT_MTAB);
	if (tb) {
		struct libmnt_fs *fs = mnt_copy_fs(NULL, upd->fs);
		if (!fs)
			rc = -ENOMEM;
		else {
			mnt_table_add_fs(tb, fs);
			rc = update_table(upd, tb);
		}
	}

	if (lc)
		mnt_unlock_file(lc);
	else if (u_lc != -1)
		utab_unlock(u_lc);

	mnt_free_table(tb);
	return rc;
}",1
Detect whether the following code contains vulnerabilities.,"static int32_t scalarproduct_and_madd_int16_c(int16_t *v1, const int16_t *v2,

                                              const int16_t *v3,

                                              int order, int mul)

{

    int res = 0;



    while (order--) {

        res   += *v1 * *v2++;

        *v1++ += mul * *v3++;

    }

    return res;

}
",1
Detect whether the following code contains vulnerabilities.,"void ElectronBrowserClient::RegisterBrowserInterfaceBindersForFrame(
    content::RenderFrameHost* render_frame_host,
    mojo::BinderMapWithContext<content::RenderFrameHost*>* map) {
  map->Add<network_hints::mojom::NetworkHintsHandler>(
      base::BindRepeating(&BindNetworkHintsHandler));
  map->Add<blink::mojom::BadgeService>(
      base::BindRepeating(&badging::BadgeManager::BindFrameReceiver));
  map->Add<electron::mojom::ElectronBrowser>(
      base::BindRepeating(&BindElectronBrowser));
#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)
  map->Add<extensions::mime_handler::MimeHandlerService>(
      base::BindRepeating(&BindMimeHandlerService));
  map->Add<extensions::mime_handler::BeforeUnloadControl>(
      base::BindRepeating(&BindBeforeUnloadControl));

  content::WebContents* web_contents =
      content::WebContents::FromRenderFrameHost(render_frame_host);
  if (!web_contents)
    return;

  const GURL& site = render_frame_host->GetSiteInstance()->GetSiteURL();
  if (!site.SchemeIs(extensions::kExtensionScheme))
    return;

  content::BrowserContext* browser_context =
      render_frame_host->GetProcess()->GetBrowserContext();
  auto* extension = extensions::ExtensionRegistry::Get(browser_context)
                        ->enabled_extensions()
                        .GetByID(site.host());
  if (!extension)
    return;
  extensions::ExtensionsBrowserClient::Get()
      ->RegisterBrowserInterfaceBindersForFrame(map, render_frame_host,
                                                extension);
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static void test_qga_fsfreeze_and_thaw(gconstpointer fix)

{

    const TestFixture *fixture = fix;

    QDict *ret;

    const gchar *status;



    ret = qmp_fd(fixture->fd, ""{'execute': 'guest-fsfreeze-freeze'}"");

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);

    QDECREF(ret);



    ret = qmp_fd(fixture->fd, ""{'execute': 'guest-fsfreeze-status'}"");

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);

    status = qdict_get_try_str(ret, ""return"");

    g_assert_cmpstr(status, ==, ""frozen"");

    QDECREF(ret);



    ret = qmp_fd(fixture->fd, ""{'execute': 'guest-fsfreeze-thaw'}"");

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);

    QDECREF(ret);

}
",1
Detect whether the following code contains vulnerabilities.,"true_always(node *tree)
{
  switch (nint(tree->car)) {
  case NODE_TRUE:
  case NODE_INT:
  case NODE_STR:
  case NODE_SYM:
    return TRUE;
  default:
    return FALSE;
  }
}",0
Detect whether the following code contains vulnerabilities.,"xmlXPtrNewCollapsedRange(xmlNodePtr start) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = NULL;
    ret->index2 = -1;
    return(ret);
}",1
Detect whether the following code contains vulnerabilities.,"static abi_long do_getpeername(int fd, abi_ulong target_addr,

                               abi_ulong target_addrlen_addr)

{

    socklen_t addrlen;

    void *addr;

    abi_long ret;



    if (get_user_u32(addrlen, target_addrlen_addr))

        return -TARGET_EFAULT;



    if (addrlen < 0 || addrlen > MAX_SOCK_ADDR)

        return -TARGET_EINVAL;



    addr = alloca(addrlen);



    ret = get_errno(getpeername(fd, addr, &addrlen));

    if (!is_error(ret)) {

        host_to_target_sockaddr(target_addr, addr, addrlen);

        if (put_user_u32(addrlen, target_addrlen_addr))

            ret = -TARGET_EFAULT;

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)
{
	enum ctx_state prev_state;

	prev_state = exception_enter();
	if (notify_die(DIE_TRAP, ""stack segment"", regs, error_code,
		       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {
		preempt_conditional_sti(regs);
		do_trap(X86_TRAP_SS, SIGBUS, ""stack segment"", regs, error_code, NULL);
		preempt_conditional_cli(regs);
	}
	exception_exit(prev_state);
}",1
Detect whether the following code contains vulnerabilities.,"static int snd_rawmidi_info_select_user(struct snd_card *card,
					struct snd_rawmidi_info __user *_info)
{
	int err;
	struct snd_rawmidi_info info;
	if (get_user(info.device, &_info->device))
		return -EFAULT;
	if (get_user(info.stream, &_info->stream))
		return -EFAULT;
	if (get_user(info.subdevice, &_info->subdevice))
		return -EFAULT;
	if ((err = snd_rawmidi_info_select(card, &info)) < 0)
		return err;
	if (copy_to_user(_info, &info, sizeof(struct snd_rawmidi_info)))
		return -EFAULT;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void do_4xx_tlbsx_ (void)

{

    int tmp = xer_ov;



    T0 = ppcemb_tlb_search(env, T0, env->spr[SPR_40x_PID]);

    if (T0 != -1)

        tmp |= 0x02;

    env->crf[0] = tmp;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int __get_file_write_access(struct inode *inode,
					  struct vfsmount *mnt)
{
	int error;
	error = get_write_access(inode);
	if (error)
		return error;
	/*
	 * Do not take mount writer counts on
	 * special files since no writes to
	 * the mount itself will occur.
	 */
	if (!special_file(inode->i_mode)) {
		/*
		 * Balanced in __fput()
		 */
		error = __mnt_want_write(mnt);
		if (error)
			put_write_access(inode);
	}
	return error;
}",0
Detect whether the following code contains vulnerabilities.,"    string_255 typeName() const
    {
        return type_name_;
    }",1
Detect whether the following code contains vulnerabilities.,"dns_zone_addnsec3chain(dns_zone_t *zone, dns_rdata_nsec3param_t *nsec3param) {
	isc_result_t result;
	char salt[255*2+1];

	REQUIRE(DNS_ZONE_VALID(zone));

	result = dns_nsec3param_salttotext(nsec3param, salt, sizeof(salt));
	RUNTIME_CHECK(result == ISC_R_SUCCESS);
	dnssec_log(zone, ISC_LOG_NOTICE,
		   ""dns_zone_addnsec3chain(hash=%u, iterations=%u, salt=%s)"",
		   nsec3param->hash, nsec3param->iterations, salt);
	LOCK_ZONE(zone);
	result = zone_addnsec3chain(zone, nsec3param);
	UNLOCK_ZONE(zone);

	return (result);
}",0
Detect whether the following code contains vulnerabilities.,"TEST_P(DownstreamProtocolIntegrationTest, ComputedHealthCheck) {
  config_helper_.addFilter(R""EOF(
name: health_check
typed_config:
    ""@type"": type.googleapis.com/envoy.extensions.filters.http.health_check.v3.HealthCheck
    pass_through_mode: false
    cluster_min_healthy_percentages:
        example_cluster_name: { value: 75 }
)EOF"");
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));
  auto response = codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
      {"":method"", ""GET""}, {"":path"", ""/healthcheck""}, {"":scheme"", ""http""}, {"":authority"", ""host""}});
  ASSERT_TRUE(response->waitForEndStream());

  EXPECT_TRUE(response->complete());
  EXPECT_EQ(""503"", response->headers().getStatusValue());
}",0
Detect whether the following code contains vulnerabilities.,"static int is_git_directory(const char *suspect)
{
	char path[PATH_MAX];
	size_t len = strlen(suspect);

	strcpy(path, suspect);
	if (getenv(DB_ENVIRONMENT)) {
		if (access(getenv(DB_ENVIRONMENT), X_OK))
			return 0;
	}
	else {
		strcpy(path + len, ""/objects"");
		if (access(path, X_OK))
			return 0;
	}

	strcpy(path + len, ""/refs"");
	if (access(path, X_OK))
		return 0;

	strcpy(path + len, ""/HEAD"");
	if (validate_headref(path))
		return 0;

	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value, bool set_connect = false) {
    headers_.setHost(host_value);
    if (set_connect) {
      headers_.setMethod(Http::Headers::get().MethodValues.Connect);
    }
    return *headers_.Host();
  }",0
Detect whether the following code contains vulnerabilities.,"static int mp_pacl_removexattr(FsContext *ctx,

                               const char *path, const char *name)

{

    int ret;

    char *buffer;



    buffer = rpath(ctx, path);

    ret  = lremovexattr(buffer, MAP_ACL_ACCESS);

    if (ret == -1 && errno == ENODATA) {

        /*

         * We don't get ENODATA error when trying to remove a

         * posix acl that is not present. So don't throw the error

         * even in case of mapped security model

         */

        errno = 0;

        ret = 0;

    }

    g_free(buffer);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"_outFieldSelect(StringInfo str, const FieldSelect *node)
{
	WRITE_NODE_TYPE(""FIELDSELECT"");

	WRITE_NODE_FIELD(arg);
	WRITE_INT_FIELD(fieldnum);
	WRITE_OID_FIELD(resulttype);
	WRITE_INT_FIELD(resulttypmod);
	WRITE_OID_FIELD(resultcollid);
}",0
Detect whether the following code contains vulnerabilities.,"static int nbd_co_send_request(BDRVNBDState *s, struct nbd_request *request,

                               struct iovec *iov, int offset)

{

    int rc, ret;



    qemu_co_mutex_lock(&s->send_mutex);

    s->send_coroutine = qemu_coroutine_self();

    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, nbd_restart_write,

                            nbd_have_request, NULL, s);

    rc = nbd_send_request(s->sock, request);

    if (rc >= 0 && iov) {

        ret = qemu_co_sendv(s->sock, iov, request->len, offset);

        if (ret != request->len) {

            errno = -EIO;

            rc = -1;

        }

    }

    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,

                            nbd_have_request, NULL, s);

    s->send_coroutine = NULL;

    qemu_co_mutex_unlock(&s->send_mutex);

    return rc;

}
",0
Detect whether the following code contains vulnerabilities.,"Debug(const char *fmtstr,
      va_list args)
{
   /* Ignored */
#ifdef VMX86_DEBUG
   sLog(log_debug, ""Debug callback invoked. \n"");
#endif
}",1
Detect whether the following code contains vulnerabilities.,"eb_relocate_vma_slow(struct i915_execbuffer *eb, struct i915_vma *vma)
{
	const struct drm_i915_gem_exec_object2 *entry = exec_entry(eb, vma);
	struct drm_i915_gem_relocation_entry *relocs =
		u64_to_ptr(typeof(*relocs), entry->relocs_ptr);
	unsigned int i;
	int err;

	for (i = 0; i < entry->relocation_count; i++) {
		u64 offset = eb_relocate_entry(eb, vma, &relocs[i]);

		if ((s64)offset < 0) {
			err = (int)offset;
			goto err;
		}
	}
	err = 0;
err:
	reloc_cache_reset(&eb->reloc_cache);
	return err;
}",0
Detect whether the following code contains vulnerabilities.,"static int skcipher_next_fast(struct skcipher_walk *walk)
{
	unsigned long diff;

	walk->src.phys.page = scatterwalk_page(&walk->in);
	walk->src.phys.offset = offset_in_page(walk->in.offset);
	walk->dst.phys.page = scatterwalk_page(&walk->out);
	walk->dst.phys.offset = offset_in_page(walk->out.offset);

	if (walk->flags & SKCIPHER_WALK_PHYS)
		return 0;

	diff = walk->src.phys.offset - walk->dst.phys.offset;
	diff |= walk->src.virt.page - walk->dst.virt.page;

	skcipher_map_src(walk);
	walk->dst.virt.addr = walk->src.virt.addr;

	if (diff) {
		walk->flags |= SKCIPHER_WALK_DIFF;
		skcipher_map_dst(walk);
	}

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"xmlXPtrEvalXPointer(xmlXPathParserContextPtr ctxt) {
    if (ctxt->valueTab == NULL) {
	/* Allocate the value stack */
	ctxt->valueTab = (xmlXPathObjectPtr *) 
			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
	if (ctxt->valueTab == NULL) {
	    xmlXPtrErrMemory(""allocating evaluation context"");
	    return;
	}
	ctxt->valueNr = 0;
	ctxt->valueMax = 10;
	ctxt->value = NULL;
    }
    SKIP_BLANKS;
    if (CUR == '/') {
	xmlXPathRoot(ctxt);
        xmlXPtrEvalChildSeq(ctxt, NULL);
    } else {
	xmlChar *name;

	name = xmlXPathParseName(ctxt);
	if (name == NULL)
	    XP_ERROR(XPATH_EXPR_ERROR);
	if (CUR == '(') {
	    xmlXPtrEvalFullXPtr(ctxt, name);
	    /* Short evaluation */
	    return;
	} else {
	    /* this handle both Bare Names and Child Sequences */
	    xmlXPtrEvalChildSeq(ctxt, name);
	}
    }
    SKIP_BLANKS;
    if (CUR != 0)
	XP_ERROR(XPATH_EXPR_ERROR);
}",1
Detect whether the following code contains vulnerabilities.,"void slavio_serial_ms_kbd_init(target_phys_addr_t base, qemu_irq irq,

                               int disabled, int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", disabled);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", NULL);

    qdev_prop_set_chr(dev, ""chrA"", NULL);

    qdev_prop_set_uint32(dev, ""chnBtype"", mouse);

    qdev_prop_set_uint32(dev, ""chnAtype"", kbd);

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_connect_irq(s, 1, irq);

    sysbus_mmio_map(s, 0, base);

}
",0
Detect whether the following code contains vulnerabilities.,"printableStringValidate(
	Syntax *syntax,
	struct berval *val )
{
	ber_len_t i;

	if( BER_BVISEMPTY( val ) ) return LDAP_INVALID_SYNTAX;

	for(i=0; i < val->bv_len; i++) {
		if( !SLAP_PRINTABLE(val->bv_val[i]) ) {
			return LDAP_INVALID_SYNTAX;
		}
	}

	return LDAP_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"static int xa_read_packet(AVFormatContext *s,

                          AVPacket *pkt)

{

    MaxisXADemuxContext *xa = s->priv_data;

    AVStream *st = s->streams[0];

    ByteIOContext *pb = s->pb;

    unsigned int packet_size;

    int ret;



    if(xa->sent_bytes > xa->out_size)

        return AVERROR(EIO);

    /* 1 byte header and 14 bytes worth of samples * number channels per block */

    packet_size = 15*st->codec->channels;



    ret = av_get_packet(pb, pkt, packet_size);

    if(ret != packet_size)

        return AVERROR(EIO);



    pkt->stream_index = st->index;

    xa->sent_bytes += packet_size;

    pkt->pts = xa->audio_frame_counter;

    /* 14 bytes Samples per channel with 2 samples per byte */

    xa->audio_frame_counter += 28 * st->codec->channels;



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"      return get_split(axis,nb).move_to(*this);
    }

    //! Return a list where each image has been split along the specified axis \newinstance.
    CImgList<T> get_split(const char axis, const int nb=-1) const {",0
Detect whether the following code contains vulnerabilities.,"static void dw_reader(struct dw_spi *dws)
{
	u32 max = rx_max(dws);
	u16 rxw;

	while (max--) {
		rxw = dw_read_io_reg(dws, DW_SPI_DR);
		/* Care rx only if the transfer's original ""rx"" is not null */
		if (dws->rx_end - dws->len) {
			if (dws->n_bytes == 1)
				*(u8 *)(dws->rx) = rxw;
			else
				*(u16 *)(dws->rx) = rxw;
		}
		dws->rx += dws->n_bytes;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static void rc4030_unrealize(DeviceState *dev, Error **errp)

{

    rc4030State *s = RC4030(dev);

    int i;



    timer_free(s->periodic_timer);



    address_space_destroy(&s->dma_as);

    object_unparent(OBJECT(&s->dma_tt));

    object_unparent(OBJECT(&s->dma_tt_alias));

    object_unparent(OBJECT(&s->dma_mr));

    for (i = 0; i < MAX_TL_ENTRIES; ++i) {

        memory_region_del_subregion(&s->dma_mr, &s->dma_mrs[i]);

        object_unparent(OBJECT(&s->dma_mrs[i]));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"directory_exists (dirname)
     const char *dirname;
{
  char *new_dirname;
  int dirlen, r;
  struct stat sb;

  /* First, dequote the directory name */
  new_dirname = bash_dequote_filename ((char *)dirname, rl_completion_quote_character);
  dirlen = STRLEN (new_dirname);
  if (new_dirname[dirlen - 1] == '/')
    new_dirname[dirlen - 1] = '\0';
#if defined (HAVE_LSTAT)
  r = lstat (new_dirname, &sb) == 0;
#else
  r = stat (new_dirname, &sb) == 0;
#endif
  free (new_dirname);
  return (r);
}",1
Detect whether the following code contains vulnerabilities.,"lldpd_started_by_upstart()
{
#ifdef HOST_OS_LINUX
	const char *upstartjob = getenv(""UPSTART_JOB"");
	if (!(upstartjob && !strcmp(upstartjob, ""lldpd"")))
		return 0;
	log_debug(""main"", ""running with upstart, don't fork but stop"");
	raise(SIGSTOP);
	unsetenv(""UPSTART_JOB"");
	return 1;
#else
	return 0;
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static int ogg_save(AVFormatContext *s)

{

    struct ogg *ogg = s->priv_data;

    struct ogg_state *ost =

        av_malloc(sizeof (*ost) + (ogg->nstreams-1) * sizeof (*ogg->streams));

    int i;

    ost->pos = avio_tell (s->pb);

    ost->curidx = ogg->curidx;

    ost->next = ogg->state;

    ost->nstreams = ogg->nstreams;

    memcpy(ost->streams, ogg->streams, ogg->nstreams * sizeof(*ogg->streams));



    for (i = 0; i < ogg->nstreams; i++){

        struct ogg_stream *os = ogg->streams + i;

        os->buf = av_malloc (os->bufsize);

        memset (os->buf, 0, os->bufsize);

        memcpy (os->buf, ost->streams[i].buf, os->bufpos);

    }



    ogg->state = ost;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int ipc_has_perm(struct kern_ipc_perm *ipc_perms,
			u32 perms)
{
	struct ipc_security_struct *isec;
	struct common_audit_data ad;
	struct selinux_audit_data sad = {0,};
	u32 sid = current_sid();

	isec = ipc_perms->security;

	COMMON_AUDIT_DATA_INIT(&ad, IPC);
	ad.selinux_audit_data = &sad;
	ad.u.ipc_id = ipc_perms->key;

	return avc_has_perm(sid, isec->sid, isec->sclass, perms, &ad);
}",0
Detect whether the following code contains vulnerabilities.,"pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
		      int atomic)
{
	unsigned long copy;

	while (len > 0) {
		while (!iov->iov_len)
			iov++;
		copy = min_t(unsigned long, len, iov->iov_len);

		if (atomic) {
			if (__copy_to_user_inatomic(iov->iov_base, from, copy))
				return -EFAULT;
		} else {
			if (copy_to_user(iov->iov_base, from, copy))
				return -EFAULT;
		}
		from += copy;
		len -= copy;
		iov->iov_base += copy;
		iov->iov_len -= copy;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static PHP_NAMED_FUNCTION(zif_zip_entry_read)
{
	zval * zip_entry;
	zend_long len = 0;
	zip_read_rsrc * zr_rsrc;
	zend_string *buffer;
	int n = 0;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""r|l"", &zip_entry, &len) == FAILURE) {
		return;
	}

	if ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {
		RETURN_FALSE;
	}

	if (len <= 0) {
		len = 1024;
	}

	if (zr_rsrc->zf) {
		buffer = zend_string_alloc(len, 0);
		n = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));
		if (n > 0) {
			ZSTR_VAL(buffer)[n] = '\0';
			ZSTR_LEN(buffer) = n;
			RETURN_NEW_STR(buffer);
		} else {
			zend_string_free(buffer);
			RETURN_EMPTY_STRING()
		}
	} else {
		RETURN_FALSE;
	}
}",1
Detect whether the following code contains vulnerabilities.,"void ProtocolV2::append_keepalive() {
  ldout(cct, 10) << __func__ << dendl;
  auto keepalive_frame = KeepAliveFrame::Encode();
  connection->outgoing_bl.append(keepalive_frame.get_buffer(session_stream_handlers));
}",1
Detect whether the following code contains vulnerabilities.,"generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,
			  loff_t *ppos, size_t len, unsigned int flags)
{
	struct address_space *mapping = out->f_mapping;
	ssize_t ret;

	ret = splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_file);
	if (ret > 0) {
		struct inode *inode = mapping->host;

		*ppos += ret;

		/*
		 * If file or inode is SYNC and we actually wrote some data,
		 * sync it.
		 */
		if (unlikely((out->f_flags & O_SYNC) || IS_SYNC(inode))) {
			int err;

			mutex_lock(&inode->i_mutex);
			err = generic_osync_inode(inode, mapping,
						  OSYNC_METADATA|OSYNC_DATA);
			mutex_unlock(&inode->i_mutex);

			if (err)
				ret = err;
		}
	}

	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"opts_start_list(Visitor *v, const char *name, Error **errp)

{

    OptsVisitor *ov = to_ov(v);



    /* we can't traverse a list in a list */

    assert(ov->list_mode == LM_NONE);

    ov->repeated_opts = lookup_distinct(ov, name, errp);

    if (ov->repeated_opts != NULL) {

        ov->list_mode = LM_STARTED;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ServerDB::setSUPW(int srvnum, const QString &pw) {
	TransactionHolder th;

	QCryptographicHash hash(QCryptographicHash::Sha1);
	hash.addData(pw.toUtf8());

	QSqlQuery &query = *th.qsqQuery;

	SQLPREP(""SELECT `user_id` FROM `%1users` WHERE `server_id` = ? AND `user_id` = ?"");
	query.addBindValue(srvnum);
	query.addBindValue(0);
	SQLEXEC();
	if (! query.next()) {
		SQLPREP(""INSERT INTO `%1users` (`server_id`, `user_id`, `name`) VALUES (?, ?, ?)"");
		query.addBindValue(srvnum);
		query.addBindValue(0);
		query.addBindValue(QLatin1String(""SuperUser""));
		SQLEXEC();
	}

	SQLPREP(""UPDATE `%1users` SET `pw`=? WHERE `server_id` = ? AND `user_id`=?"");
	query.addBindValue(QString::fromLatin1(hash.result().toHex()));
	query.addBindValue(srvnum);
	query.addBindValue(0);
	SQLEXEC();
}",0
Detect whether the following code contains vulnerabilities.,"static void print_value(int output, int num, const char *devname,
			const char *value, const char *name, size_t valsz)
{
	if (output & OUTPUT_VALUE_ONLY) {
		fputs(value, stdout);
		fputc('\n', stdout);

	} else if (output & OUTPUT_UDEV_LIST) {
		print_udev_format(name, value);

	} else if (output & OUTPUT_EXPORT_LIST) {
		if (num == 1 && devname)
			printf(""DEVNAME=%s\n"", devname);
		fputs(name, stdout);
		fputs(""="", stdout);
		safe_print(value, valsz, "" \\\""'$`<>"");
		fputs(""\n"", stdout);

	} else {
		if (num == 1 && devname)
			printf(""%s:"", devname);
		fputs("" "", stdout);
		fputs(name, stdout);
		fputs(""=\"""", stdout);
		safe_print(value, valsz, ""\""\\"");
		fputs(""\"""", stdout);
	}
}",0
Detect whether the following code contains vulnerabilities.,"struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {
	struct addr_t *entry;
	int i;

	if (!bin->entry && !bin->sects) {
		return NULL;
	}
	if (!(entry = calloc (1, sizeof (struct addr_t)))) {
		return NULL;
	}

	if (bin->entry) {
		entry->addr = entry_to_vaddr (bin);
		entry->offset = addr_to_offset (bin, entry->addr);
		entry->haddr = sdb_num_get (bin->kv, ""mach0.entry.offset"", 0);
	}

	if (!bin->entry || entry->offset == 0) {
		// XXX: section name doesnt matters at all.. just check for exec flags
		for (i = 0; i < bin->nsects; i++) {
			if (!strncmp (bin->sects[i].sectname, ""__text"", 6)) {
				entry->offset = (ut64)bin->sects[i].offset;
				sdb_num_set (bin->kv, ""mach0.entry"", entry->offset, 0);
				entry->addr = (ut64)bin->sects[i].addr;
				if (!entry->addr) { // workaround for object files
					entry->addr = entry->offset;
				}
				break;
			}
		}
		bin->entry = entry->addr;
	}

	return entry;
}",1
Detect whether the following code contains vulnerabilities.,"EXPORT const Dwg_RGB_Palette *dwg_rgb_palette (void)
{
  return rgb_palette;
}",0
Detect whether the following code contains vulnerabilities.,"static int sctp_setsockopt_hmac_ident(struct sock *sk,
				      char __user *optval,
				      unsigned int optlen)
{
	struct net *net = sock_net(sk);
	struct sctp_hmacalgo *hmacs;
	u32 idents;
	int err;

	if (!net->sctp.auth_enable)
		return -EACCES;

	if (optlen < sizeof(struct sctp_hmacalgo))
		return -EINVAL;

	hmacs= memdup_user(optval, optlen);
	if (IS_ERR(hmacs))
		return PTR_ERR(hmacs);

	idents = hmacs->shmac_num_idents;
	if (idents == 0 || idents > SCTP_AUTH_NUM_HMACS ||
	    (idents * sizeof(u16)) > (optlen - sizeof(struct sctp_hmacalgo))) {
		err = -EINVAL;
		goto out;
	}

	err = sctp_auth_ep_set_hmacs(sctp_sk(sk)->ep, hmacs);
out:
	kfree(hmacs);
	return err;
}",0
Detect whether the following code contains vulnerabilities.,"static uint64_t hpet_get_ticks(void)

{

    uint64_t ticks;

    ticks = ns_to_ticks(qemu_get_clock(vm_clock) + hpet_statep->hpet_offset);

    return ticks;

}
",1
Detect whether the following code contains vulnerabilities.,"void *jas_malloc(size_t size)
{
#if defined(MEMALLOC_ALIGN2)
	void *ptr;
abort();
	if (posix_memalign(&ptr, MEMALLOC_ALIGNMENT, size)) {
		return 0;
	}
	return ptr;
#endif
	return malloc(size);
}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t cirrus_linear_bitblt_read(void *opaque,

                                          target_phys_addr_t addr,

                                          unsigned size)

{

    CirrusVGAState *s = opaque;

    uint32_t ret;



    /* XXX handle bitblt */

    (void)s;

    ret = 0xff;

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"  Router::RouteConfigProvider* routeConfigProvider() override {
    if (use_srds_) {
      return nullptr;
    }
    return &route_config_provider_;
  }",0
Detect whether the following code contains vulnerabilities.,"const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,
                                    socklen_t size) {
  if (!src || !dst) {
    errno = EFAULT;
    return nullptr;
  }
  size_t src_size = 0;
  if (af == AF_INET) {
    src_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    src_size = sizeof(struct in6_addr);
  } else {
    errno = EAFNOSUPPORT;
    return nullptr;
  }

  MessageWriter input;
  input.Push<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});
  input.Push(size);
  MessageReader output;

  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetNtopHandler, &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_ntop"", 2);

  auto result = output.next();
  int klinux_errno = output.next<int>();
  if (result.empty()) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return nullptr;
  }

  memcpy(dst, result.data(),
         std::min(static_cast<size_t>(size),
                  static_cast<size_t>(INET6_ADDRSTRLEN)));
  return dst;
}",1
Detect whether the following code contains vulnerabilities.,"static sPAPRDRConnector *spapr_phb_get_pci_drc(sPAPRPHBState *phb,

                                               PCIDevice *pdev)

{

    uint32_t busnr = pci_bus_num(PCI_BUS(qdev_get_parent_bus(DEVICE(pdev))));

    return spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_PCI,

                                    (phb->index << 16) |

                                    (busnr << 8) |

                                    pdev->devfn);

}
",1
Detect whether the following code contains vulnerabilities.,"bool asn1_write_OctetString(struct asn1_data *data, const void *p, size_t length)
{
	asn1_push_tag(data, ASN1_OCTET_STRING);
	asn1_write(data, p, length);
	asn1_pop_tag(data);
	return !data->has_error;
}",1
Detect whether the following code contains vulnerabilities.,"Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){
  Token s;
  assert( zC!=0 );
  sqlite3TokenInit(&s, (char*)zC);
  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void phys_page_set(target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_chr_fe_add_watch(CharDriverState *s, GIOCondition cond,

                          GIOFunc func, void *user_data)

{

    GSource *src;

    guint tag;



    if (s->chr_add_watch == NULL) {

        return -ENOSYS;

    }



    src = s->chr_add_watch(s, cond);

    if (!src) {

        return -EINVAL;

    }



    g_source_set_callback(src, (GSourceFunc)func, user_data, NULL);

    tag = g_source_attach(src, NULL);

    g_source_unref(src);



    return tag;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int indeo3_decode_end(AVCodecContext *avctx)
{
    Indeo3DecodeContext *s = avctx->priv_data;
    iv_free_func(s);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"dotraplinkage void __kprobes do_int3(struct pt_regs *regs, long error_code)
{
#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP
	if (kgdb_ll_trap(DIE_INT3, ""int3"", regs, error_code, 3, SIGTRAP)
			== NOTIFY_STOP)
		return;
#endif /* CONFIG_KGDB_LOW_LEVEL_TRAP */
#ifdef CONFIG_KPROBES
	if (notify_die(DIE_INT3, ""int3"", regs, error_code, 3, SIGTRAP)
			== NOTIFY_STOP)
		return;
#else
	if (notify_die(DIE_TRAP, ""int3"", regs, error_code, 3, SIGTRAP)
			== NOTIFY_STOP)
		return;
#endif

	preempt_conditional_sti(regs);
	do_trap(3, SIGTRAP, ""int3"", regs, error_code, NULL);
	preempt_conditional_cli(regs);
}",1
Detect whether the following code contains vulnerabilities.,"extract_lladdr_from_llao_aligned(uip_lladdr_t *dest) {
  if(dest != NULL && nd6_opt_llao != NULL) {
    memcpy(dest, &nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET], UIP_LLADDR_LEN);
    return 1;
  }
  return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void gen_dcbz(DisasContext *ctx)

{

    TCGv tcgv_addr;

    TCGv_i32 tcgv_is_dcbzl;

    int is_dcbzl = ctx->opcode & 0x00200000 ? 1 : 0;



    gen_set_access_type(ctx, ACCESS_CACHE);

    tcgv_addr = tcg_temp_new();

    tcgv_is_dcbzl = tcg_const_i32(is_dcbzl);



    gen_addr_reg_index(ctx, tcgv_addr);

    gen_helper_dcbz(cpu_env, tcgv_addr, tcgv_is_dcbzl);



    tcg_temp_free(tcgv_addr);

    tcg_temp_free_i32(tcgv_is_dcbzl);

}
",1
Detect whether the following code contains vulnerabilities.,"static void setup_nofile_rlimit(unsigned long rlimit_nofile)
{
    struct rlimit rlim = {
        .rlim_cur = rlimit_nofile,
        .rlim_max = rlimit_nofile,
    };

    if (rlimit_nofile == 0) {
        return; /* nothing to do */
    }

    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
        /* Ignore SELinux denials */
        if (errno == EPERM) {
            return;
        }

        fuse_log(FUSE_LOG_ERR, ""setrlimit(RLIMIT_NOFILE): %m\n"");
        exit(1);
    }
}",0
Detect whether the following code contains vulnerabilities.,"static int find_optimal_param(uint32_t sum, int n)

{

    int k, k_opt;

    uint32_t nbits[MAX_RICE_PARAM+1];



    k_opt = 0;

    nbits[0] = UINT32_MAX;

    for(k=0; k<=MAX_RICE_PARAM; k++) {

        nbits[k] = rice_encode_count(sum, n, k);

        if(nbits[k] < nbits[k_opt]) {

            k_opt = k;

        }

    }

    return k_opt;

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,
			       int fast_rexmit)
{
	struct tcp_sock *tp = tcp_sk(sk);
	int sndcnt = 0;
	int delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);
	int newly_acked_sacked = prior_unsacked -
				 (tp->packets_out - tp->sacked_out);

	tp->prr_delivered += newly_acked_sacked;
	if (tcp_packets_in_flight(tp) > tp->snd_ssthresh) {
		u64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +
			       tp->prior_cwnd - 1;
		sndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;
	} else {
		sndcnt = min_t(int, delta,
			       max_t(int, tp->prr_delivered - tp->prr_out,
				     newly_acked_sacked) + 1);
	}

	sndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));
	tp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;
}",0
Detect whether the following code contains vulnerabilities.,"int dsa_test()
{
    Source source;
    FileSource(""../certs/dsa1024.der"", source);
    if (source.size() == 0) {
        FileSource(""../../certs/dsa1024.der"", source);  // for testsuite
        if (source.size() == 0) {
            FileSource(""../../../certs/dsa1024.der"", source); // win32 Debug dir
            if (source.size() == 0)
                err_sys(""where's your certs dir?"", -89);
        }
    }

    const char msg[] = ""this is the message"";
    byte signature[40];

    DSA_PrivateKey priv(source);
    DSA_Signer signer(priv);

    SHA sha;
    byte digest[SHA::DIGEST_SIZE];
    sha.Update((byte*)msg, sizeof(msg));
    sha.Final(digest);

    signer.Sign(digest, signature, rng);

    byte encoded[sizeof(signature) + 6];
    byte decoded[40];

    word32 encSz = EncodeDSA_Signature(signer.GetR(), signer.GetS(), encoded);
    DecodeDSA_Signature(decoded, encoded, encSz);

    DSA_PublicKey pub(priv);
    DSA_Verifier verifier(pub);

    if (!verifier.Verify(digest, decoded))
        return -90;

    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"udisks_log (UDisksLogLevel     level,
            const gchar       *function,
            const gchar       *location,
            const gchar       *format,
            ...)
{
  va_list var_args;
  gchar *message;

  va_start (var_args, format);
  message = g_strdup_vprintf (format, var_args);
  va_end (var_args);

#if GLIB_CHECK_VERSION(2, 50, 0)
  g_log_structured (""udisks"", (GLogLevelFlags) level,
                    ""MESSAGE"", message, ""THREAD_ID"", ""%d"", (gint) syscall (SYS_gettid),
                    ""CODE_FUNC"", function, ""CODE_FILE"", location);
#else
  g_log (""udisks"", level, ""[%d]: %s [%s, %s()]"", (gint) syscall (SYS_gettid), message, location, function);
#endif

  g_free (message);
}",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  output->type = input->type;

  return context->ResizeTensor(context, output,
                               TfLiteIntArrayCopy(input->dims));
}",1
Detect whether the following code contains vulnerabilities.,"QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head)

{

    Error *local_err = NULL;

    Object *obj;

    uint32_t h;

    int i;



    for (i = 0; i < nb_consoles; i++) {

        if (!consoles[i]) {

            continue;

        }

        obj = object_property_get_link(OBJECT(consoles[i]),

                                       ""device"", &local_err);

        if (DEVICE(obj) != dev) {

            continue;

        }

        h = object_property_get_int(OBJECT(consoles[i]),

                                    ""head"", &local_err);

        if (h != head) {

            continue;

        }

        return consoles[i];

    }

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"cmd_pipe_pane_error_callback(__unused struct bufferevent *bufev,
    __unused short what, void *data)
{
	struct window_pane	*wp = data;

	log_debug(""%%%u pipe error"", wp->id);

	bufferevent_free(wp->pipe_event);
	close(wp->pipe_fd);
	wp->pipe_fd = -1;

	if (window_pane_destroy_ready(wp))
		server_destroy_pane(wp, 1);
}",0
Detect whether the following code contains vulnerabilities.,"BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)
{
	rdpGlyph* prevGlyph;

	if (id > 9)
	{
		WLog_ERR(TAG, ""invalid glyph cache id: %"" PRIu32 """", id);
		return FALSE;
	}

	if (index > glyphCache->glyphCache[id].number)
	{
		WLog_ERR(TAG, ""invalid glyph cache index: %"" PRIu32 "" in cache id: %"" PRIu32 """", index, id);
		return FALSE;
	}

	WLog_Print(glyphCache->log, WLOG_DEBUG, ""GlyphCachePut: id: %"" PRIu32 "" index: %"" PRIu32 """", id,
	           index);
	prevGlyph = glyphCache->glyphCache[id].entries[index];

	if (prevGlyph)
		prevGlyph->Free(glyphCache->context, prevGlyph);

	glyphCache->glyphCache[id].entries[index] = glyph;
	return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"passIsKeyword(const char *token, CharsString *passLine, int *passLinepos) {
	int k;
	int length = (int)strlen(token);
	int ch = passLine->chars[*passLinepos + length + 1];
	if (((ch | 32) >= 'a' && (ch | 32) <= 'z') || (ch >= '0' && ch <= '9')) return 0;
	for (k = 0; k < length && passLine->chars[*passLinepos + k + 1] == (widechar)token[k];
			k++)
		;
	if (k == length) {
		*passLinepos += length + 1;
		return 1;
	}
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"proxy_C_DecryptVerifyUpdate (CK_X_FUNCTION_LIST *self,
                             CK_SESSION_HANDLE handle,
                             CK_BYTE_PTR enc_part,
                             CK_ULONG enc_part_len,
                             CK_BYTE_PTR part,
                             CK_ULONG_PTR part_len)
{
	State *state = (State *)self;
	Mapping map;
	CK_RV rv;

	rv = map_session_to_real (state->px, &handle, &map, NULL);
	if (rv != CKR_OK)
		return rv;
	return (map.funcs->C_DecryptVerifyUpdate) (handle, enc_part, enc_part_len, part, part_len);
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t k90_show_current_profile(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	int ret;
	struct usb_interface *usbif = to_usb_interface(dev->parent);
	struct usb_device *usbdev = interface_to_usbdev(usbif);
	int current_profile;
	char data[8];

	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
			      K90_REQUEST_STATUS,
			      USB_DIR_IN | USB_TYPE_VENDOR |
			      USB_RECIP_DEVICE, 0, 0, data, 8,
			      USB_CTRL_SET_TIMEOUT);
	if (ret < 0) {
		dev_warn(dev, ""Failed to get K90 initial state (error %d).\n"",
			 ret);
		return -EIO;
	}
	current_profile = data[7];
	if (current_profile < 1 || current_profile > 3) {
		dev_warn(dev, ""Read invalid current profile: %02hhx.\n"",
			 data[7]);
		return -EIO;
	}

	return snprintf(buf, PAGE_SIZE, ""%d\n"", current_profile);
}",1
Detect whether the following code contains vulnerabilities.,"int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)
{
  int rc;

  rc = cmd_start(adata, cmdstr, flags);
  if (rc < 0)
  {
    cmd_handle_fatal(adata);
    return IMAP_EXEC_FATAL;
  }

  if (flags & IMAP_CMD_QUEUE)
    return IMAP_EXEC_SUCCESS;

  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&
      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))
  {
    mutt_error(_(""Connection to %s timed out""), adata->conn->account.host);
    cmd_handle_fatal(adata);
    return IMAP_EXEC_FATAL;
  }

  /* Allow interruptions, particularly useful if there are network problems. */
  mutt_sig_allow_interrupt(true);
  do
  {
    rc = imap_cmd_step(adata);
  } while (rc == IMAP_RES_CONTINUE);
  mutt_sig_allow_interrupt(false);

  if (rc == IMAP_RES_NO)
    return IMAP_EXEC_ERROR;
  if (rc != IMAP_RES_OK)
  {
    if (adata->status != IMAP_FATAL)
      return IMAP_EXEC_ERROR;

    mutt_debug(LL_DEBUG1, ""command failed: %s\n"", adata->buf);
    return IMAP_EXEC_FATAL;
  }

  return IMAP_EXEC_SUCCESS;
}",1
Detect whether the following code contains vulnerabilities.,"uint64_t qpci_io_readq(QPCIDevice *dev, void *data)

{

    uintptr_t addr = (uintptr_t)data;



    if (addr < QPCI_PIO_LIMIT) {

        return dev->bus->pio_readq(dev->bus, addr);

    } else {

        uint64_t val;

        dev->bus->memread(dev->bus, addr, &val, sizeof(val));

        return le64_to_cpu(val);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void pc_dimm_check_memdev_is_busy(Object *obj, const char *name,

                                      Object *val, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(val), errp);

    if (memory_region_is_mapped(mr)) {

        char *path = object_get_canonical_path_component(val);

        error_setg(errp, ""can't use already busy memdev: %s"", path);

        g_free(path);

    } else {

        qdev_prop_allow_set_link_before_realize(obj, name, val, errp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_jref_idct_add(uint8_t *dest, ptrdiff_t line_size, int16_t *block)

{

    ff_j_rev_dct(block);

    ff_add_pixels_clamped(block, dest, line_size);

}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned int io_uring_nommu_mmap_capabilities(struct file *file)
{
	return NOMMU_MAP_DIRECT | NOMMU_MAP_READ | NOMMU_MAP_WRITE;
}",0
Detect whether the following code contains vulnerabilities.,"SAPI_POST_HANDLER_FUNC(php_mb_post_handler)
{
	const mbfl_encoding *detected;
	php_mb_encoding_handler_info_t info;

	MBSTRG(http_input_identify_post) = NULL;

	info.data_type              = PARSE_POST;
	info.separator              = ""&"";
	info.report_errors          = 0;
	info.to_encoding            = MBSTRG(internal_encoding);
	info.to_language            = MBSTRG(language);
	info.from_encodings         = MBSTRG(http_input_list);
	info.num_from_encodings     = MBSTRG(http_input_list_size); 
	info.from_language          = MBSTRG(language);

	detected = _php_mb_encoding_handler_ex(&info, arg, SG(request_info).post_data TSRMLS_CC);

	MBSTRG(http_input_identify) = detected;
	if (detected) {
		MBSTRG(http_input_identify_post) = detected;
	}
}",1
Detect whether the following code contains vulnerabilities.,"void bdrv_dirty_iter_init(BlockDriverState *bs,
                          BdrvDirtyBitmap *bitmap, HBitmapIter *hbi)
{
    hbitmap_iter_init(hbi, bitmap->bitmap, 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void qemu_kvm_start_vcpu(CPUState *env)

{

    env->thread = g_malloc0(sizeof(QemuThread));

    env->halt_cond = g_malloc0(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, qemu_kvm_cpu_thread_fn, env,

                       QEMU_THREAD_DETACHED);

    while (env->created == 0) {

        qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_parse_path(void)

{

    g_test_trap_subprocess (""/logging/parse_path/subprocess"", 0, 0);

    g_test_trap_assert_passed();

    g_test_trap_assert_stdout("""");

    g_test_trap_assert_stderr("""");

}
",1
Detect whether the following code contains vulnerabilities.,"rsvg_mask_parse (const RsvgDefs * defs, const char *str)
{
    char *name;

    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);

        if (val && RSVG_NODE_TYPE (val) == RSVG_NODE_TYPE_MASK)
            return val;
    }
    return NULL;
}",1
Detect whether the following code contains vulnerabilities.,"static void handle_satn_stop(ESPState *s)

{

    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn_stop;

        return;

    }

    s->cmdlen = get_cmd(s, s->cmdbuf);

    if (s->cmdlen) {

        trace_esp_handle_satn_stop(s->cmdlen);

        s->do_cmd = 1;

        s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;

        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;

        s->rregs[ESP_RSEQ] = SEQ_CD;

        esp_raise_irq(s);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void tqi_calculate_qtable(TqiContext *t, int quant)

{

    const int qscale = (215 - 2*quant)*5;

    int i;



    t->intra_matrix[0] = (ff_inv_aanscales[0] * ff_mpeg1_default_intra_matrix[0]) >> 11;

    for(i=1; i<64; i++)

        t->intra_matrix[i] = (ff_inv_aanscales[i] * ff_mpeg1_default_intra_matrix[i] * qscale + 32) >> 14;

}
",1
Detect whether the following code contains vulnerabilities.,"static int uio_mmap(struct file *filep, struct vm_area_struct *vma)
{
	struct uio_listener *listener = filep->private_data;
	struct uio_device *idev = listener->dev;
	int mi;
	unsigned long requested_pages, actual_pages;
	int ret = 0;

	if (vma->vm_end < vma->vm_start)
		return -EINVAL;

	vma->vm_private_data = idev;

	mi = uio_find_mem_index(vma);
	if (mi < 0)
		return -EINVAL;

	requested_pages = vma_pages(vma);
	actual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)
			+ idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;
	if (requested_pages > actual_pages)
		return -EINVAL;

	if (idev->info->mmap) {
		ret = idev->info->mmap(idev->info, vma);
		return ret;
	}

	switch (idev->info->mem[mi].memtype) {
		case UIO_MEM_PHYS:
			return uio_mmap_physical(vma);
		case UIO_MEM_LOGICAL:
		case UIO_MEM_VIRTUAL:
			return uio_mmap_logical(vma);
		default:
			return -EINVAL;
	}
}",0
Detect whether the following code contains vulnerabilities.,"static int null_draw_slice(AVFilterLink *link, int y, int h, int slice_dir) { return 0; }
",0
Detect whether the following code contains vulnerabilities.,"static inline pid_t getppid(void)
{ return 1; }",0
Detect whether the following code contains vulnerabilities.,"static int fuse_update_get_attr(struct inode *inode, struct file *file,
				struct kstat *stat, u32 request_mask,
				unsigned int flags)
{
	struct fuse_inode *fi = get_fuse_inode(inode);
	int err = 0;
	bool sync;

	if (flags & AT_STATX_FORCE_SYNC)
		sync = true;
	else if (flags & AT_STATX_DONT_SYNC)
		sync = false;
	else if (request_mask & READ_ONCE(fi->inval_mask))
		sync = true;
	else
		sync = time_before64(fi->i_time, get_jiffies_64());

	if (sync) {
		forget_all_cached_acls(inode);
		err = fuse_do_getattr(inode, stat, file);
	} else if (stat) {
		generic_fillattr(inode, stat);
		stat->mode = fi->orig_i_mode;
		stat->ino = fi->orig_ino;
	}

	return err;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void VectorCopy44(const DDSVector4 source,
  DDSVector4 *destination)
{
  destination->x = source.x;
  destination->y = source.y;
  destination->z = source.z;
  destination->w = source.w;
}",0
Detect whether the following code contains vulnerabilities.,"void cpu_breakpoint_remove_by_ref(CPUState *env, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    TAILQ_REMOVE(&env->breakpoints, breakpoint, entry);



    breakpoint_invalidate(env, breakpoint->pc);



    qemu_free(breakpoint);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static void arm_cpu_register_types(void)

{

    int i;



    type_register_static(&arm_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(arm_cpus); i++) {

        cpu_register(&arm_cpus[i]);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline u16 kvm_read_fs(void)
{
	u16 seg;
	asm(""mov %%fs, %0"" : ""=g""(seg));
	return seg;
}",1
Detect whether the following code contains vulnerabilities.,"void *memalign_array(size_t el_size, size_t align, unsigned int count)
{
	if (count*el_size >= MAX_MALLOC_SIZE) {
		return NULL;
	}

	return memalign(align, el_size*count);
}",0
Detect whether the following code contains vulnerabilities.,"static void dequantization_int_97(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        for (i = 0; i < w; ++i)

            datap[i] = (src[i] * band->i_stepsize + (1<<14)) >> 15;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  int num_inputs = NumInputs(node);
  TF_LITE_ENSURE(context, num_inputs >= 2);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);

  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  output->type = input1->type;

  // Check that all input tensors have the same shape and type.
  for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {
    const TfLiteTensor* input = GetInput(context, node, i);
    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));
    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);
  }

  // Use the first input node's dimension to be the dimension of the output
  // node.
  TfLiteIntArray* input1_dims = input1->dims;
  TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input1_dims);
  return context->ResizeTensor(context, output, output_dims);
}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t error_mem_read(void *opaque, target_phys_addr_t addr,

                               unsigned size)

{

    abort();

}
",0
Detect whether the following code contains vulnerabilities.,"set_y_current(yankreg_T *yreg)
{
    y_current = yreg;
}",0
Detect whether the following code contains vulnerabilities.,"static int vtd_int_remap(X86IOMMUState *iommu, MSIMessage *src,

                         MSIMessage *dst, uint16_t sid)

{

    return vtd_interrupt_remap_msi(INTEL_IOMMU_DEVICE(iommu), src, dst);

}
",0
Detect whether the following code contains vulnerabilities.,"TEST_CASE(""Visit test"", ""[general]"")
{
    Definition ROOT, TAG, TAG_NAME, WS;

    ROOT     <= seq(WS, zom(TAG));
    TAG      <= seq(chr('['), TAG_NAME, chr(']'), WS);
    TAG_NAME <= oom(seq(npd(chr(']')), dot()));
    WS       <= zom(cls("" \t""));

    AssignIDToDefinition defIds;
    ROOT.accept(defIds);

    REQUIRE(defIds.ids.size() == 4);
}",1
Detect whether the following code contains vulnerabilities.,"int security_file_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return security_ops->file_fcntl(file, cmd, arg);
}",0
Detect whether the following code contains vulnerabilities.,"DEFUN (neighbor_strict_capability,
       neighbor_strict_capability_cmd,
       NEIGHBOR_CMD ""strict-capability-match"",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       ""Strict capability negotiation match\n"")
{
  return peer_flag_set_vty (vty, argv[0], PEER_FLAG_STRICT_CAP_MATCH);
}",0
Detect whether the following code contains vulnerabilities.,"static int ahci_dma_prepare_buf(IDEDMA *dma, int is_write)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    IDEState *s = &ad->port.ifs[0];

    ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset);
    s->io_buffer_size = s->sg.size;

    DPRINTF(ad->port_no, ""len=%#x\n"", s->io_buffer_size);
    return s->io_buffer_size != 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void cryptodev_builtin_cleanup(

             CryptoDevBackend *backend,

             Error **errp)

{

    CryptoDevBackendBuiltin *builtin =

                      CRYPTODEV_BACKEND_BUILTIN(backend);

    size_t i;

    int queues = backend->conf.peers.queues;

    CryptoDevBackendClient *cc;



    for (i = 0; i < MAX_NUM_SESSIONS; i++) {

        if (builtin->sessions[i] != NULL) {

            cryptodev_builtin_sym_close_session(

                    backend, i, 0, errp);

        }

    }



    assert(queues == 1);



    for (i = 0; i < queues; i++) {

        cc = backend->conf.peers.ccs[i];

        if (cc) {

            cryptodev_backend_free_client(cc);

            backend->conf.peers.ccs[i] = NULL;

        }

    }



    cryptodev_backend_set_ready(backend, false);

}
",0
Detect whether the following code contains vulnerabilities.,  uint64_t crop_left() const { return crop_left_; },0
Detect whether the following code contains vulnerabilities.,"static inline int compress_coeffs(int *coef, int order, int c_bits)

{

    int i, res = 0;

    const int low_idx   = c_bits ?  4 : 2;

    const int shift_val = c_bits ?  8 : 4;

    const int high_idx  = c_bits ? 11 : 5;

    for (i = 0; i < order; i++)

        if (coef[i] < low_idx || coef[i] > high_idx)

            res++;

    if (res == order)

        for (i = 0; i < order; i++)

            coef[i] -= (coef[i] > high_idx) ? shift_val : 0;

    return res == order;

}
",0
Detect whether the following code contains vulnerabilities.,"void *qemu_malloc(size_t size)

{

    if (!size && !allow_zero_malloc()) {

        abort();

    }

    return oom_check(malloc(size ? size : 1));

}
",1
Detect whether the following code contains vulnerabilities.,"        void stop()
        {
#ifdef CROW_ENABLE_SSL
            if (ssl_used_)
            {
                if (ssl_server_) { ssl_server_->stop(); }
            }
            else
#endif
            {
                std::vector<crow::websocket::connection*> websockets_to_close = websockets_;
                for (auto websocket : websockets_to_close)
                {
                    CROW_LOG_INFO << ""Quitting Websocket: "" << websocket;
                    websocket->close(""Server Application Terminated"");
                }
                if (server_) { server_->stop(); }
            }
        }",1
Detect whether the following code contains vulnerabilities.,"static void process_read_by_type(struct async_read_op *op)
{
	struct bt_gatt_server *server = op->server;
	uint8_t ecode;
	struct gatt_db_attribute *attr;

	attr = queue_pop_head(op->db_data);

	if (op->done || !attr) {
		bt_att_chan_send_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_RSP,
						op->pdu, op->pdu_len);
		async_read_op_destroy(op);
		return;
	}

	ecode = check_permissions(server, attr, BT_ATT_PERM_READ |
						BT_ATT_PERM_READ_AUTHEN |
						BT_ATT_PERM_READ_ENCRYPT);
	if (ecode)
		goto error;

	if (gatt_db_attribute_read(attr, 0, op->opcode, server->att,
					read_by_type_read_complete_cb, op))
		return;

	ecode = BT_ATT_ERROR_UNLIKELY;

error:
	bt_att_chan_send_error_rsp(op->chan, BT_ATT_OP_READ_BY_TYPE_REQ,
				gatt_db_attribute_get_handle(attr), ecode);
	async_read_op_destroy(op);
}",1
Detect whether the following code contains vulnerabilities.,"static void nvme_req_clear(NvmeRequest *req)
{
    req->ns = NULL;
    req->opaque = NULL;
    req->aiocb = NULL;
    memset(&req->cqe, 0x0, sizeof(req->cqe));
    req->status = NVME_SUCCESS;
}",0
Detect whether the following code contains vulnerabilities.,"static ut64 r_rebase_offset_to_paddr(RKernelCacheObj *obj, struct section_t *sections, ut64 offset) {
	ut64 vaddr = obj->rebase_info->kernel_base + offset;
	int i = 0;
	for (; !sections[i].last; i++) {
		if (sections[i].addr <= vaddr && vaddr < (sections[i].addr + sections[i].vsize)) {
			return sections[i].offset + (vaddr - sections[i].addr);
		}
	}
	return offset;
}",0
Detect whether the following code contains vulnerabilities.,"int fit_image_check_type(const void *fit, int noffset, uint8_t type)
{
	uint8_t image_type;

	if (fit_image_get_type(fit, noffset, &image_type))
		return 0;
	return (type == image_type);
}",0
Detect whether the following code contains vulnerabilities.,"  Router::RouteConfigProvider* routeConfigProvider() override {
    return route_config_provider2_.get();
  }",0
Detect whether the following code contains vulnerabilities.,"static void filter_edges(void *dst1, void *prev1, void *cur1, void *next1,

                         int w, int prefs, int mrefs, int parity, int mode)

{

    uint8_t *dst  = dst1;

    uint8_t *prev = prev1;

    uint8_t *cur  = cur1;

    uint8_t *next = next1;

    int x;

    uint8_t *prev2 = parity ? prev : cur ;

    uint8_t *next2 = parity ? cur  : next;



    /* Only edge pixels need to be processed here.  A constant value of false

     * for is_not_edge should let the compiler ignore the whole branch. */

    FILTER(0, 3, 0)



    dst  = (uint8_t*)dst1  + w - 3;

    prev = (uint8_t*)prev1 + w - 3;

    cur  = (uint8_t*)cur1  + w - 3;

    next = (uint8_t*)next1 + w - 3;

    prev2 = (uint8_t*)(parity ? prev : cur);

    next2 = (uint8_t*)(parity ? cur  : next);



    FILTER(w - 3, w, 0)

}
",1
Detect whether the following code contains vulnerabilities.,"static int xen_pt_bar_reg_init(XenPCIPassthroughState *s, XenPTRegInfo *reg,

                               uint32_t real_offset, uint32_t *data)

{

    uint32_t reg_field = 0;

    int index;



    index = xen_pt_bar_offset_to_index(reg->offset);

    if (index < 0 || index >= PCI_NUM_REGIONS) {

        XEN_PT_ERR(&s->dev, ""Internal error: Invalid BAR index [%d].\n"", index);

        return -1;

    }



    /* set BAR flag */

    s->bases[index].bar_flag = xen_pt_bar_reg_parse(s, reg);

    if (s->bases[index].bar_flag == XEN_PT_BAR_FLAG_UNUSED) {

        reg_field = XEN_PT_INVALID_REG;

    }



    *data = reg_field;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus,
			     struct sk_buff *skb, bool first)
{
	int size = lstatus & BD_LENGTH_MASK;
	struct page *page = rxb->page;

	if (likely(first)) {
		skb_put(skb, size);
	} else {
		/* the last fragments' length contains the full frame length */
		if (lstatus & BD_LFLAG(RXBD_LAST))
			size -= skb->len;

		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
				rxb->page_offset + RXBUF_ALIGNMENT,
				size, GFAR_RXB_TRUESIZE);
	}

	/* try reuse page */
	if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page)))
		return false;

	/* change offset to the other half */
	rxb->page_offset ^= GFAR_RXB_TRUESIZE;

	page_ref_inc(page);

	return true;
}",1
Detect whether the following code contains vulnerabilities.,"int ip_options_get(struct net *net, struct ip_options **optp,
		   unsigned char *data, int optlen)
{
	struct ip_options *opt = ip_options_get_alloc(optlen);

	if (!opt)
		return -ENOMEM;
	if (optlen)
		memcpy(opt->__data, data, optlen);
	return ip_options_get_finish(net, optp, opt, optlen);
}",1
Detect whether the following code contains vulnerabilities.,"static void gen_mtsr(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    TCGv t0;

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    t0 = tcg_const_tl(SR(ctx->opcode));

    gen_helper_store_sr(cpu_env, t0, cpu_gpr[rS(ctx->opcode)]);

    tcg_temp_free(t0);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int do_format(int drive, struct format_descr *tmp_format_req)
{
	int ret;

	if (lock_fdc(drive))
		return -EINTR;

	set_floppy(drive);
	if (!_floppy ||
	    _floppy->track > drive_params[current_drive].tracks ||
	    tmp_format_req->track >= _floppy->track ||
	    tmp_format_req->head >= _floppy->head ||
	    (_floppy->sect << 2) % (1 << FD_SIZECODE(_floppy)) ||
	    !_floppy->fmt_gap) {
		process_fd_request();
		return -EINVAL;
	}
	format_req = *tmp_format_req;
	format_errors = 0;
	cont = &format_cont;
	errors = &format_errors;
	ret = wait_til_done(redo_format, true);
	if (ret == -EINTR)
		return -EINTR;
	process_fd_request();
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static av_cold OMXContext *omx_init(void *logctx, const char *libname, const char *prefix)

{

    static const char * const libnames[] = {

        ""libOMX_Core.so"",

        ""libOmxCore.so"",

        NULL

    };

    const char* const* nameptr;

    int ret = AVERROR_ENCODER_NOT_FOUND;

    OMXContext *omx_context;



    omx_context = av_mallocz(sizeof(*omx_context));

    if (!omx_context)

        return NULL;

    if (libname) {

        ret = omx_try_load(omx_context, logctx, libname, prefix);

        if (ret < 0) {

            av_free(omx_context);

            return NULL;

        }

    } else {

        for (nameptr = libnames; *nameptr; nameptr++)

            if (!(ret = omx_try_load(omx_context, logctx, *nameptr, prefix)))

                break;

        if (!*nameptr) {

            av_free(omx_context);

            return NULL;

        }

    }



    omx_context->ptr_Init();

    return omx_context;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_wrpsr(CPUSPARCState *env, target_ulong new_psr)

{

    if ((new_psr & PSR_CWP) >= env->nwindows) {

        cpu_raise_exception_ra(env, TT_ILL_INSN, GETPC());

    } else {



        cpu_put_psr(env, new_psr);


    }

}",1
Detect whether the following code contains vulnerabilities.,"static int thread_execute(AVCodecContext *avctx, action_func* func, void *arg, int *ret, int job_count, int job_size)

{

    SliceThreadContext *c = avctx->internal->thread_ctx;



    if (!(avctx->active_thread_type&FF_THREAD_SLICE) || avctx->thread_count <= 1)

        return avcodec_default_execute(avctx, func, arg, ret, job_count, job_size);



    if (job_count <= 0)

        return 0;



    pthread_mutex_lock(&c->current_job_lock);



    c->current_job = avctx->thread_count;

    c->job_count = job_count;

    c->job_size = job_size;

    c->args = arg;

    c->func = func;

    c->rets = ret;

    c->current_execute++;

    pthread_cond_broadcast(&c->current_job_cond);



    thread_park_workers(c, avctx->thread_count);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
			  struct sk_buff_head *hitlist)
{
	struct sk_buff *skb;
	struct sk_buff *next;

	spin_lock(&x->sk_receive_queue.lock);
	receive_queue_for_each_skb(x, next, skb) {
		/*
		 *	Do we have file descriptors ?
		 */
		if (UNIXCB(skb).fp) {
			bool hit = false;
			/*
			 *	Process the descriptors of this socket
			 */
			int nfd = UNIXCB(skb).fp->count;
			struct file **fp = UNIXCB(skb).fp->fp;
			while (nfd--) {
				/*
				 *	Get the socket the fd matches
				 *	if it indeed does so
				 */
				struct sock *sk = unix_get_socket(*fp++);
				if (sk) {
					hit = true;
					func(unix_sk(sk));
				}
			}
			if (hit && hitlist != NULL) {
				__skb_unlink(skb, &x->sk_receive_queue);
				__skb_queue_tail(hitlist, skb);
			}
		}
	}
	spin_unlock(&x->sk_receive_queue.lock);
}",1
Detect whether the following code contains vulnerabilities.,"static int handle_update_file_cred(int dirfd, const char *name, FsCred *credp)

{

    int fd, ret;

    fd = openat(dirfd, name, O_NONBLOCK | O_NOFOLLOW);

    if (fd < 0) {

        return fd;

    }

    ret = fchmod(fd, credp->fc_mode & 07777);

    if (ret < 0) {

        goto err_out;

    }

    ret = fchownat(fd, """", credp->fc_uid, credp->fc_gid, AT_EMPTY_PATH);

err_out:

    close(fd);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pc_compat_0_13(MachineState *machine)

{

    pc_compat_1_2(machine);

    kvmclock_enabled = false;

}
",0
Detect whether the following code contains vulnerabilities.,"static CURLcode hsts_out(struct stsentry *sts, FILE *fp)
{
  struct tm stamp;
  if(sts->expires != TIME_T_MAX) {
    CURLcode result = Curl_gmtime((time_t)sts->expires, &stamp);
    if(result)
      return result;
    fprintf(fp, ""%s%s \""%d%02d%02d %02d:%02d:%02d\""\n"",
            sts->includeSubDomains ? ""."": """", sts->host,
            stamp.tm_year + 1900, stamp.tm_mon + 1, stamp.tm_mday,
            stamp.tm_hour, stamp.tm_min, stamp.tm_sec);
  }
  else
    fprintf(fp, ""%s%s \""%s\""\n"",
            sts->includeSubDomains ? ""."": """", sts->host, UNLIMITED);
  return CURLE_OK;
}",0
Detect whether the following code contains vulnerabilities.,"httpPrintf(http_t     *http,		/* I - HTTP connection */
           const char *format,		/* I - printf-style format string */
	   ...)				/* I - Additional args as needed */
{
  ssize_t	bytes;			/* Number of bytes to write */
  char		buf[16384];		/* Buffer for formatted string */
  va_list	ap;			/* Variable argument pointer */


  DEBUG_printf((""2httpPrintf(http=%p, format=\""%s\"", ...)"", (void *)http, format));

  va_start(ap, format);
  bytes = vsnprintf(buf, sizeof(buf), format, ap);
  va_end(ap);

  DEBUG_printf((""3httpPrintf: ("" CUPS_LLFMT "" bytes) %s"", CUPS_LLCAST bytes, buf));

  if (http->data_encoding == HTTP_ENCODING_FIELDS)
    return ((int)httpWrite2(http, buf, (size_t)bytes));
  else
  {
    if (http->wused)
    {
      DEBUG_puts(""4httpPrintf: flushing existing data..."");

      if (httpFlushWrite(http) < 0)
	return (-1);
    }

    return ((int)http_write(http, buf, (size_t)bytes));
  }
}",1
Detect whether the following code contains vulnerabilities.,"flatpak_run_apply_env_vars (FlatpakBwrap *bwrap, FlatpakContext *context)
{
  GHashTableIter iter;
  gpointer key, value;

  g_hash_table_iter_init (&iter, context->env_vars);
  while (g_hash_table_iter_next (&iter, &key, &value))
    {
      const char *var = key;
      const char *val = value;

      if (val && val[0] != 0)
        flatpak_bwrap_set_env (bwrap, var, val, TRUE);
      else
        flatpak_bwrap_unset_env (bwrap, var);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static inline uint32_t mipsdsp_sub32(int32_t a, int32_t b, CPUMIPSState *env)

{

    int32_t temp;



    temp = a - b;

    if (MIPSDSP_OVERFLOW(a, -b, temp, 0x80000000)) {

        set_DSPControl_overflow_flag(1, 20, env);

    }



    return temp;

}
",1
Detect whether the following code contains vulnerabilities.,"/* {{{ date_period_it_dtor */
static void date_period_it_dtor(zend_object_iterator *iter TSRMLS_DC)
{
	date_period_it *iterator = (date_period_it *)iter;

	date_period_it_invalidate_current(iter TSRMLS_CC);

	zval_ptr_dtor(&iterator->date_period_zval);

	efree(iterator);",0
Detect whether the following code contains vulnerabilities.,"  void _enqueue(PG *pg, uint64_t priority) {
    if (!agent_queue.empty() &&
	agent_queue.rbegin()->first < priority)
      agent_valid_iterator = false;  // inserting higher-priority queue
    set<PGRef>& nq = agent_queue[priority];
    if (nq.empty())
      agent_cond.Signal();
    nq.insert(pg);
  }",0
Detect whether the following code contains vulnerabilities.,"long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
    int64_t t64;
    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;
    if (rdbver >= 9) /* Check the top comment of this function. */
        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
    return (long long)t64;
}",0
Detect whether the following code contains vulnerabilities.,"static int raw_reopen_prepare(BDRVReopenState *reopen_state,

                              BlockReopenQueue *queue, Error **errp)

{

    assert(reopen_state != NULL);

    assert(reopen_state->bs != NULL);



    reopen_state->opaque = g_new0(BDRVRawState, 1);



    return raw_read_options(

        reopen_state->options,

        reopen_state->bs,

        reopen_state->opaque,

        errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_rng_device_exit(DeviceState *qdev)

{

    VirtIORNG *vrng = VIRTIO_RNG(qdev);

    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);



    timer_del(vrng->rate_limit_timer);

    timer_free(vrng->rate_limit_timer);

    unregister_savevm(qdev, ""virtio-rng"", vrng);

    virtio_cleanup(vdev);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ppce500_reset_device_tree(void *opaque)

{

    DeviceTreeParams *p = opaque;

    ppce500_load_device_tree(p->machine, &p->params, p->addr, p->initrd_base,

                             p->initrd_size, false);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void code_gen_alloc(size_t tb_size)

{

    tcg_ctx.code_gen_buffer_size = size_code_gen_buffer(tb_size);

    tcg_ctx.code_gen_buffer = alloc_code_gen_buffer();

    if (tcg_ctx.code_gen_buffer == NULL) {

        fprintf(stderr, ""Could not allocate dynamic translator buffer\n"");

        exit(1);

    }



    qemu_madvise(tcg_ctx.code_gen_buffer, tcg_ctx.code_gen_buffer_size,

                 QEMU_MADV_HUGEPAGE);



    /* Estimate a good size for the number of TBs we can support.  We

       still haven't deducted the prologue from the buffer size here,

       but that's minimal and won't affect the estimate much.  */

    tcg_ctx.code_gen_max_blocks

        = tcg_ctx.code_gen_buffer_size / CODE_GEN_AVG_BLOCK_SIZE;

    tcg_ctx.tb_ctx.tbs = g_new(TranslationBlock, tcg_ctx.code_gen_max_blocks);



    qemu_mutex_init(&tcg_ctx.tb_ctx.tb_lock);

}
",1
Detect whether the following code contains vulnerabilities.,"int av_get_channel_layout_nb_channels(int64_t channel_layout)

{

    int count;

    uint64_t x = channel_layout;

    for (count = 0; x; count++)

        x &= x-1; // unset lowest set bit

    return count;

}
",0
Detect whether the following code contains vulnerabilities.,"evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)
{
	size_t need = buf->misalign + buf->off + datlen;
	size_t oldoff = buf->off;

	if (buf->totallen < need) {
		if (evbuffer_expand(buf, datlen) == -1)
			return (-1);
	}

	memcpy(buf->buffer + buf->off, data, datlen);
	buf->off += datlen;

	if (datlen && buf->cb != NULL)
		(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);

	return (0);
}",1
Detect whether the following code contains vulnerabilities.,"int qemu_peek_byte(QEMUFile *f, int offset)

{

    int index = f->buf_index + offset;



    assert(!qemu_file_is_writable(f));

    assert(offset < IO_BUF_SIZE);



    if (index >= f->buf_size) {

        qemu_fill_buffer(f);

        index = f->buf_index + offset;

        if (index >= f->buf_size) {

            return 0;

        }

    }

    return f->buf[index];

}
",1
Detect whether the following code contains vulnerabilities.,"report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ""\n"");

  va_end (args);
  if (exit_immediately_on_error)
    exit_shell (1);
}",1
Detect whether the following code contains vulnerabilities.,"LEX::create_unit(SELECT_LEX *first_sel)
{
  SELECT_LEX_UNIT *unit;
  DBUG_ENTER(""LEX::create_unit"");

  unit = first_sel->master_unit();

  if (!unit && !(unit= alloc_unit()))
    DBUG_RETURN(NULL);

  unit->register_select_chain(first_sel);
  if (first_sel->next_select())
  {
    unit->reset_distinct();
    DBUG_ASSERT(!unit->fake_select_lex);
    if (unit->add_fake_select_lex(thd))
      DBUG_RETURN(NULL);
  }
  DBUG_RETURN(unit);
}",0
Detect whether the following code contains vulnerabilities.,"static void test_visitor_in_native_list_uint8(TestInputVisitorData *data,

                                             const void *unused)

{

    test_native_list_integer_helper(data, unused,

                                    USER_DEF_NATIVE_LIST_UNION_KIND_U8);

}
",0
Detect whether the following code contains vulnerabilities.,"set_add_response(const char *code, const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    size_t sz = sizeof(add_response)/sizeof(add_response[0]);
    int num = snprintf(add_response, sz, ""%s:"", code);
    vsnprintf(add_response + num, sz - num, fmt, args);
    va_end(args);
    has_add_respose = true;
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t select_lease_time(struct dhcp_packet *packet)
{
	uint32_t lease_time_sec = server_config.max_lease_sec;
	uint8_t *lease_time_opt = udhcp_get_option(packet, DHCP_LEASE_TIME);
	if (lease_time_opt) {
		move_from_unaligned32(lease_time_sec, lease_time_opt);
		lease_time_sec = ntohl(lease_time_sec);
		if (lease_time_sec > server_config.max_lease_sec)
			lease_time_sec = server_config.max_lease_sec;
		if (lease_time_sec < server_config.min_lease_sec)
			lease_time_sec = server_config.min_lease_sec;
	}
	return lease_time_sec;
}",1
Detect whether the following code contains vulnerabilities.,"void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)
{
	if (fields->Len > 0)
	{
		Stream_SetPosition(s, fields->BufferOffset);
		Stream_Write(s, fields->Buffer, fields->Len);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static av_cold int v4l2_encode_init(AVCodecContext *avctx)

{

    V4L2m2mContext *s = avctx->priv_data;

    V4L2Context *capture = &s->capture;

    V4L2Context *output = &s->output;

    int ret;



    /* common settings output/capture */

    output->height = capture->height = avctx->height;

    output->width = capture->width = avctx->width;



    /* output context */

    output->av_codec_id = AV_CODEC_ID_RAWVIDEO;

    output->av_pix_fmt = avctx->pix_fmt;



    /* capture context */

    capture->av_codec_id = avctx->codec_id;

    capture->av_pix_fmt = AV_PIX_FMT_NONE;



    ret = ff_v4l2_m2m_codec_init(avctx);

    if (ret) {

        av_log(avctx, AV_LOG_ERROR, ""can't configure encoder\n"");

        return ret;

    }



    return v4l2_prepare_encoder(s);

}
",1
Detect whether the following code contains vulnerabilities.,"static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)

{

    dma_addr_t iov_pa, iov_size;



    cmd->flags = le16_to_cpu(cmd->frame->header.flags);

    if (!cmd->frame->header.sge_count) {

        trace_megasas_dcmd_zero_sge(cmd->index);

        cmd->iov_size = 0;

        return 0;

    } else if (cmd->frame->header.sge_count > 1) {

        trace_megasas_dcmd_invalid_sge(cmd->index,

                                       cmd->frame->header.sge_count);

        cmd->iov_size = 0;

        return -1;

    }

    iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);

    iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);

    pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);

    qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);

    cmd->iov_size = iov_size;

    return cmd->iov_size;

}
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(pcntl_waitpid)
{
	long pid, options = 0;
	zval *z_status = NULL;
	int status;
	pid_t child_id;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""lz|l"", &pid, &z_status, &options) == FAILURE)
		return;
	
	convert_to_long_ex(&z_status);

	status = Z_LVAL_P(z_status);

	child_id = waitpid((pid_t) pid, &status, options);

	if (child_id < 0) {
		PCNTL_G(last_error) = errno;
	}

	Z_LVAL_P(z_status) = status;

	RETURN_LONG((long) child_id);
}",1
Detect whether the following code contains vulnerabilities.,"void hpet_init(qemu_irq *irq) {

    int i, iomemtype;

    HPETState *s;



    DPRINTF (""hpet_init\n"");



    s = qemu_mallocz(sizeof(HPETState));

    hpet_statep = s;

    s->irqs = irq;

    for (i=0; i<HPET_NUM_TIMERS; i++) {

        HPETTimer *timer = &s->timer[i];

        timer->qemu_timer = qemu_new_timer(vm_clock, hpet_timer, timer);

    }

    vmstate_register(-1, &vmstate_hpet, s);

    qemu_register_reset(hpet_reset, s);

    /* HPET Area */

    iomemtype = cpu_register_io_memory(hpet_ram_read,

                                       hpet_ram_write, s);

    cpu_register_physical_memory(HPET_BASE, 0x400, iomemtype);

}
",1
Detect whether the following code contains vulnerabilities.,"static int chown_terminal(int fd, uid_t uid) {
        struct stat st;

        assert(fd >= 0);

        /* This might fail. What matters are the results. */
        fchown(fd, uid, -1);
        fchmod(fd, TTY_MODE);

        if (fstat(fd, &st) < 0)
                return -errno;

        if (st.st_uid != uid ||
            st.st_mode != TTY_MODE)
                return -EPERM;

        return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void vmxnet3_ring_read_curr_cell(Vmxnet3Ring *ring, void *buff)

{

    vmw_shmem_read(vmxnet3_ring_curr_cell_pa(ring), buff, ring->cell_size);

}
",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, 0);

  switch (input->type) {
    case kTfLiteFloat32:
      return EvalImpl<kernel_type, kTfLiteFloat32>(context, node);
    case kTfLiteUInt8:
      return EvalImpl<kernel_type, kTfLiteUInt8>(context, node);
    case kTfLiteInt8:
      return EvalImpl<kernel_type, kTfLiteInt8>(context, node);
    case kTfLiteInt16:
      return EvalImpl<kernel_type, kTfLiteInt16>(context, node);
    default:
      TF_LITE_KERNEL_LOG(context, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }
}",1
Detect whether the following code contains vulnerabilities.,"XML_SetBillionLaughsAttackProtectionMaximumAmplification(
    XML_Parser parser, float maximumAmplificationFactor) {
  if ((parser == NULL) || (parser->m_parentParser != NULL)
      || isnan(maximumAmplificationFactor)
      || (maximumAmplificationFactor < 1.0f)) {
    return XML_FALSE;
  }
  parser->m_accounting.maximumAmplificationFactor = maximumAmplificationFactor;
  return XML_TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"set_rdt(E1000State *s, int index, uint32_t val)

{

    s->check_rxov = 0;

    s->mac_reg[index] = val & 0xffff;

    if (e1000_has_rxbufs(s, 1)) {

        qemu_flush_queued_packets(&s->nic->nc);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int hugetlb_get_quota(struct address_space *mapping, long delta)
{
	int ret = 0;
	struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);

	if (sbinfo->free_blocks > -1) {
		spin_lock(&sbinfo->stat_lock);
		if (sbinfo->free_blocks - delta >= 0)
			sbinfo->free_blocks -= delta;
		else
			ret = -ENOMEM;
		spin_unlock(&sbinfo->stat_lock);
	}

	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"void qdev_prop_set_defaults(DeviceState *dev, Property *props)

{

    if (!props)

        return;

    while (props->name) {

        if (props->defval) {

            qdev_prop_cpy(dev, props, props->defval);

        }

        props++;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int bdrv_rd_badreq_sectors(BlockDriverState *bs,

                                  int64_t sector_num, int nb_sectors)

{

    return

        nb_sectors < 0 ||

        sector_num < 0 ||

        nb_sectors > bs->total_sectors ||

        sector_num > bs->total_sectors - nb_sectors;

}
",1
Detect whether the following code contains vulnerabilities.,"ncp_reply_be16(struct ncp_server *server, int offset)
{
	return get_unaligned_be16(ncp_reply_data(server, offset));
}",0
Detect whether the following code contains vulnerabilities.,"static gint conv_jistoutf8(gchar *outbuf, gint outlen, const gchar *inbuf)
{
	gchar *eucstr;

	Xalloca(eucstr, outlen, return -1);

	if (conv_jistoeuc(eucstr, outlen, inbuf) <0)
		return -1;
	if (conv_euctoutf8(outbuf, outlen, eucstr) < 0)
		return -1;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}",1
Detect whether the following code contains vulnerabilities.,"static int add_ca_name(STACK_OF(X509_NAME) **sk, const X509 *x)
{
    X509_NAME *name;

    if (x == NULL)
        return 0;
    if (*sk == NULL && ((*sk = sk_X509_NAME_new_null()) == NULL))
        return 0;

    if ((name = X509_NAME_dup(X509_get_subject_name(x))) == NULL)
        return 0;

    if (!sk_X509_NAME_push(*sk, name)) {
        X509_NAME_free(name);
        return 0;
    }
    return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static void sdhci_sysbus_realize(DeviceState *dev, Error ** errp)

{

    SDHCIState *s = SYSBUS_SDHCI(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);



    sdhci_common_realize(s, errp);

    if (errp && *errp) {

        return;

    }



    if (s->dma_mr) {


        address_space_init(s->dma_as, s->dma_mr, ""sdhci-dma"");

    } else {

        /* use system_memory() if property ""dma"" not set */

        s->dma_as = &address_space_memory;

    }



    sysbus_init_irq(sbd, &s->irq);

    sysbus_init_mmio(sbd, &s->iomem);

}",1
Detect whether the following code contains vulnerabilities.,"static void __clear_nat_cache_dirty(struct f2fs_nm_info *nm_i,
		struct nat_entry_set *set, struct nat_entry *ne)
{
	list_move_tail(&ne->list, &nm_i->nat_entries);
	set_nat_flag(ne, IS_DIRTY, false);
	set->entry_cnt--;
	nm_i->dirty_nat_cnt--;
}",0
Detect whether the following code contains vulnerabilities.,"static int n_tty_ioctl(struct tty_struct *tty, struct file *file,
		       unsigned int cmd, unsigned long arg)
{
	struct n_tty_data *ldata = tty->disc_data;
	int retval;

	switch (cmd) {
	case TIOCOUTQ:
		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
	case TIOCINQ:
		down_write(&tty->termios_rwsem);
		if (L_ICANON(tty))
			retval = inq_canon(ldata);
		else
			retval = read_cnt(ldata);
		up_write(&tty->termios_rwsem);
		return put_user(retval, (unsigned int __user *) arg);
	default:
		return n_tty_ioctl_helper(tty, file, cmd, arg);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static inline uint64_t storage_size_max(void) {
        if (arg_storage == COREDUMP_STORAGE_EXTERNAL)
                return arg_external_size_max;
        if (arg_storage == COREDUMP_STORAGE_JOURNAL)
                return arg_journal_size_max;
        assert(arg_storage == COREDUMP_STORAGE_NONE);
        return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void opt_pad_color(const char *arg) {

    /* Input is expected to be six hex digits similar to

       how colors are expressed in html tags (but without the #) */

    int rgb = strtol(arg, NULL, 16);

    int r,g,b;



    r = (rgb >> 16);

    g = ((rgb >> 8) & 255);

    b = (rgb & 255);



    padcolor[0] = RGB_TO_Y(r,g,b);

    padcolor[1] = RGB_TO_U(r,g,b,0);

    padcolor[2] = RGB_TO_V(r,g,b,0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void l2cap_sock_close_cb(struct l2cap_chan *chan)
{
	struct sock *sk = chan->data;

	l2cap_sock_kill(sk);
}",1
Detect whether the following code contains vulnerabilities.,"TEST(Context, EmptyHeadersAttributes) {
  HeadersWrapper<Http::RequestHeaderMap> headers(nullptr);
  auto header = headers[CelValue::CreateStringView(Referer)];
  EXPECT_FALSE(header.has_value());
  EXPECT_EQ(0, headers.size());
  EXPECT_TRUE(headers.empty());
}",1
Detect whether the following code contains vulnerabilities.,"static void start_children(FFStream *feed)
{
    if (no_launch)
        return;
    for (; feed; feed = feed->next) {
        if (feed->child_argv && !feed->pid) {
            feed->pid_start = time(0);
            feed->pid = fork();
            if (feed->pid < 0) {
                fprintf(stderr, ""Unable to create children\n"");
                exit(1);
            }
            if (!feed->pid) {
                /* In child */
                char pathname[1024];
                char *slash;
                int i;
                for (i = 3; i < 256; i++) {
                    close(i);
                }
                if (!ffserver_debug) {
                    i = open(""/dev/null"", O_RDWR);
                    if (i)
                        dup2(i, 0);
                    dup2(i, 1);
                    dup2(i, 2);
                    if (i)
                        close(i);
                }
                pstrcpy(pathname, sizeof(pathname), my_program_name);
                slash = strrchr(pathname, '/');
                if (!slash) {
                    slash = pathname;
                } else {
                    slash++;
                }
                strcpy(slash, ""ffmpeg"");
                /* This is needed to make relative pathnames work */
                chdir(my_program_dir);
                execvp(pathname, feed->child_argv);
                _exit(1);
            }
        }
    }
}",1
Detect whether the following code contains vulnerabilities.,"void bdrv_close_all(void)

{

    BlockDriverState *bs;



    QTAILQ_FOREACH(bs, &bdrv_states, device_list) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);

        bdrv_close(bs);

        aio_context_release(aio_context);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
{
	switch (func) {
	case 0x8000000A:
		entry->eax = 1; /* SVM revision 1 */
		entry->ebx = 8; /* Lets support 8 ASIDs in case we add proper
				   ASID emulation to nested SVM */
		entry->ecx = 0; /* Reserved */
		entry->edx = 0; /* Do not support any additional features */

		break;
	}
}",0
Detect whether the following code contains vulnerabilities.,"char* dd_load_text_ext(const struct dump_dir *dd, const char *name, unsigned flags)
{
//    if (!dd->locked)
//        error_msg_and_die(""dump_dir is not opened""); /* bug */

    /* Compat with old abrt dumps. Remove in abrt-2.1 */
    if (strcmp(name, ""release"") == 0)
        name = FILENAME_OS_RELEASE;

    char *full_path = concat_path_file(dd->dd_dirname, name);
    char *ret = load_text_file(full_path, flags);
    free(full_path);

    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"void isa_bus_irqs(ISABus *bus, qemu_irq *irqs)

{

    if (!bus) {

        hw_error(""Can't set isa irqs with no isa bus present."");

    }

    bus->irqs = irqs;

}
",1
Detect whether the following code contains vulnerabilities.,"SerialState *serial_init(int base, qemu_irq irq, int baudbase,

                         CharDriverState *chr)

{

    SerialState *s;



    s = qemu_mallocz(sizeof(SerialState));

    if (!s)

        return NULL;

    s->irq = irq;

    s->baudbase = baudbase;



    s->tx_timer = qemu_new_timer(vm_clock, serial_tx_done, s);

    if (!s->tx_timer)

        return NULL;



    qemu_register_reset(serial_reset, s);

    serial_reset(s);



    register_savevm(""serial"", base, 2, serial_save, serial_load, s);



    register_ioport_write(base, 8, 1, serial_ioport_write, s);

    register_ioport_read(base, 8, 1, serial_ioport_read, s);

    s->chr = chr;

    qemu_chr_add_handlers(chr, serial_can_receive1, serial_receive1,

                          serial_event, s);

    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"rndr_quote(struct buf *ob, const struct buf *text, void *opaque)
{
	if (!text || !text->size)
		return 0;

	BUFPUTSL(ob, ""<q>"");
	bufput(ob, text->data, text->size);
	BUFPUTSL(ob, ""</q>"");

	return 1;
}",1
Detect whether the following code contains vulnerabilities.,"void * calloc(size_t n, size_t lb)
{
    if (lb && n > SIZE_MAX / lb)
      return NULL;
#   if defined(GC_LINUX_THREADS) /* && !defined(USE_PROC_FOR_LIBRARIES) */
        /* libpthread allocated some memory that is only pointed to by  */
        /* mmapped thread stacks.  Make sure it's not collectable.      */
        {
          static GC_bool lib_bounds_set = FALSE;
          ptr_t caller = (ptr_t)__builtin_return_address(0);
          /* This test does not need to ensure memory visibility, since */
          /* the bounds will be set when/if we create another thread.   */
          if (!EXPECT(lib_bounds_set, TRUE)) {
            GC_init_lib_bounds();
            lib_bounds_set = TRUE;
          }
          if (((word)caller >= (word)GC_libpthread_start
               && (word)caller < (word)GC_libpthread_end)
              || ((word)caller >= (word)GC_libld_start
                  && (word)caller < (word)GC_libld_end))
            return GC_malloc_uncollectable(n*lb);
          /* The two ranges are actually usually adjacent, so there may */
          /* be a way to speed this up.                                 */
        }
#   endif
    return((void *)REDIRECT_MALLOC(n*lb));
}",1
Detect whether the following code contains vulnerabilities.,"void skip_comments(FILE * file) {
	int ch;

	while (EOF != (ch = get_char(file))) {
		/* ch is now the first character of a line.
		 */
		while (ch == ' ' || ch == '\t')
			ch = get_char(file);

		if (ch == EOF)
			break;

		/* ch is now the first non-blank character of a line.
		 */

		if (ch != '\n' && ch != '#')
			break;

		/* ch must be a newline or comment as first non-blank
		 * character on a line.
		 */

		while (ch != '\n' && ch != EOF)
			ch = get_char(file);

		/* ch is now the newline of a line which we're going to
		 * ignore.
		 */
	}
	if (ch != EOF)
		unget_char(ch, file);
}",1
Detect whether the following code contains vulnerabilities.,"int pcnet_can_receive(NetClientState *nc)

{

    PCNetState *s = qemu_get_nic_opaque(nc);

    if (CSR_STOP(s) || CSR_SPND(s))

        return 0;



    return sizeof(s->buffer)-16;

}
",0
Detect whether the following code contains vulnerabilities.,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = last_oformat;



    format->next = NULL;

    while(*p || avpriv_atomic_ptr_cas((void * volatile *)p, NULL, format))

        p = &(*p)->next;

    last_oformat = &format->next;

}
",1
Detect whether the following code contains vulnerabilities.,"dump_create_nhwindow(dummy)
int dummy;
{
    return dummy;
}",0
Detect whether the following code contains vulnerabilities.,"static PixelChannels **AcquirePixelThreadSet(const Image *image)
{
  PixelChannels
    **pixels;

  register ssize_t
    i;

  size_t
    number_threads;

  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,
    sizeof(*pixels));
  if (pixels == (PixelChannels **) NULL)
    return((PixelChannels **) NULL);
  (void) memset(pixels,0,number_threads*sizeof(*pixels));
  for (i=0; i < (ssize_t) number_threads; i++)
  {
    register ssize_t
      j;

    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,
      sizeof(**pixels));
    if (pixels[i] == (PixelChannels *) NULL)
      return(DestroyPixelThreadSet(pixels));
    for (j=0; j < (ssize_t) image->columns; j++)
    {
      register ssize_t
        k;

      for (k=0; k < MaxPixelChannels; k++)
        pixels[i][j].channel[k]=0.0;
    }
  }
  return(pixels);
}",1
Detect whether the following code contains vulnerabilities.,"static bool arm_cpu_has_work(CPUState *cs)

{

    ARMCPU *cpu = ARM_CPU(cs);



    return !cpu->powered_off

        && cs->interrupt_request &

        (CPU_INTERRUPT_FIQ | CPU_INTERRUPT_HARD

         | CPU_INTERRUPT_VFIQ | CPU_INTERRUPT_VIRQ

         | CPU_INTERRUPT_EXITTB);

}
",1
Detect whether the following code contains vulnerabilities.,"  explicit DrawBoundingBoxesOp(OpKernelConstruction* context)
      : OpKernel(context) {}",0
Detect whether the following code contains vulnerabilities.,"static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos, int *current) {

    int num_pos_channels = 0;

    int first_cpe = 0;

    int sce_parity = 0;

    int i;

    for (i = *current; i < tags; i++) {

        if (layout_map[i][2] != pos)

            break;

        if (layout_map[i][0] == TYPE_CPE) {

            if (sce_parity) {

                if (pos == AAC_CHANNEL_FRONT || !first_cpe) {

                    sce_parity = 0;

                } else {

                    return -1;

                }

            }

            num_pos_channels += 2;

            first_cpe = 1;

        } else {

            num_pos_channels++;

            sce_parity ^= 1;

        }

    }

    if (sce_parity &&

        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))

            return -1;

    *current = i;

    return num_pos_channels;

}
",0
Detect whether the following code contains vulnerabilities.,"struct b43_dmadesc_generic *op64_idx2desc(struct b43_dmaring *ring,
					  int slot,
					  struct b43_dmadesc_meta **meta)
{
	struct b43_dmadesc64 *desc;

	*meta = &(ring->meta[slot]);
	desc = ring->descbase;
	desc = &(desc[slot]);

	return (struct b43_dmadesc_generic *)desc;
}",0
Detect whether the following code contains vulnerabilities.,"static int ntop_gettimemsec(lua_State* vm) {
  struct timeval tp;
  double ret;

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  gettimeofday(&tp, NULL);

  ret = (((double)tp.tv_usec) / (double)1000) + tp.tv_sec;

  lua_pushnumber(vm, ret);
  return(CONST_LUA_OK);
}",0
Detect whether the following code contains vulnerabilities.,"void CConfig::Write(CFile& File, unsigned int iIndentation) {
    CString sIndentation = CString(iIndentation, '\t');

    for (const auto& it : m_ConfigEntries) {
        for (const CString& sValue : it.second) {
            File.Write(sIndentation + it.first + "" = "" + sValue + ""\n"");
        }
    }

    for (const auto& it : m_SubConfigs) {
        for (const auto& it2 : it.second) {
            File.Write(""\n"");

            File.Write(sIndentation + ""<"" + it.first + "" "" + it2.first + "">\n"");
            it2.second.m_pSubConfig->Write(File, iIndentation + 1);
            File.Write(sIndentation + ""</"" + it.first + "">\n"");
        }
    }
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t show_crash_notes_size(struct device *dev,
				     struct device_attribute *attr,
				     char *buf)
{
	ssize_t rc;

	rc = sprintf(buf, ""%zu\n"", sizeof(note_buf_t));
	return rc;
}",1
Detect whether the following code contains vulnerabilities.,"void av_bitstream_filter_close(AVBitStreamFilterContext *bsfc){



    if(bsfc->filter->close)

        bsfc->filter->close(bsfc);

    av_freep(&bsfc->priv_data);

    av_parser_close(bsfc->parser);

    av_free(bsfc);

}",1
Detect whether the following code contains vulnerabilities.,"static uint64_t qdev_get_prop_mask64(Property *prop)

{

    assert(prop->info == &qdev_prop_bit);

    return 0x1 << prop->bitnr;

}
",1
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(Array, rewind)
{
	zval *object = getThis();
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_array_rewind(intern TSRMLS_CC);
}",1
Detect whether the following code contains vulnerabilities.,"static int drop_sync(QIOChannel *ioc, size_t size, Error **errp)

{

    ssize_t ret = 0;

    char small[1024];

    char *buffer;



    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));

    while (size > 0) {

        ssize_t count = MIN(65536, size);

        ret = read_sync(ioc, buffer, MIN(65536, size), errp);



        if (ret < 0) {

            goto cleanup;

        }

        size -= count;

    }



 cleanup:

    if (buffer != small) {

        g_free(buffer);

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool esp_mem_accepts(void *opaque, target_phys_addr_t addr,

                            unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 4);

}
",0
Detect whether the following code contains vulnerabilities.,"static void raw_close(BlockDriverState *bs)

{

    BDRVRawState *s = bs->opaque;

    if (s->fd >= 0) {

        close(s->fd);

        s->fd = -1;

        if (s->aligned_buf != NULL)

            qemu_free(s->aligned_buf);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"brcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)
{
	struct wiphy *wiphy = ifp->drvr->wiphy;
	s32 err;
	u8 key_idx;
	struct brcmf_wsec_key *key;
	s32 wsec;

	for (key_idx = 0; key_idx < BRCMF_MAX_DEFAULT_KEYS; key_idx++) {
		key = &ifp->vif->profile.key[key_idx];
		if ((key->algo == CRYPTO_ALGO_WEP1) ||
		    (key->algo == CRYPTO_ALGO_WEP128))
			break;
	}
	if (key_idx == BRCMF_MAX_DEFAULT_KEYS)
		return;

	err = send_key_to_dongle(ifp, key);
	if (err) {
		bphy_err(wiphy, ""Setting WEP key failed (%d)\n"", err);
		return;
	}
	err = brcmf_fil_bsscfg_int_get(ifp, ""wsec"", &wsec);
	if (err) {
		bphy_err(wiphy, ""get wsec error (%d)\n"", err);
		return;
	}
	wsec |= WEP_ENABLED;
	err = brcmf_fil_bsscfg_int_set(ifp, ""wsec"", wsec);
	if (err)
		bphy_err(wiphy, ""set wsec error (%d)\n"", err);
}",0
Detect whether the following code contains vulnerabilities.,"php_apache_sapi_register_variables(zval *track_vars_array TSRMLS_DC)
{
	php_struct *ctx = SG(server_context);
	const apr_array_header_t *arr = apr_table_elts(ctx->r->subprocess_env);
	char *key, *val;
	int new_val_len;

	APR_ARRAY_FOREACH_OPEN(arr, key, val)
		if (!val) {
			val = """";
		}
		if (sapi_module.input_filter(PARSE_SERVER, key, &val, strlen(val), &new_val_len TSRMLS_CC)) {
			php_register_variable_safe(key, val, new_val_len, track_vars_array TSRMLS_CC);
		}
	APR_ARRAY_FOREACH_CLOSE()

	if (sapi_module.input_filter(PARSE_SERVER, ""PHP_SELF"", &ctx->r->uri, strlen(ctx->r->uri), &new_val_len TSRMLS_CC)) {
		php_register_variable_safe(""PHP_SELF"", ctx->r->uri, new_val_len, track_vars_array TSRMLS_CC);
	}
}",0
Detect whether the following code contains vulnerabilities.,"Item* Item_func_or_sum::build_clone(THD *thd)
{
  Item *copy_tmp_args[2]= {0,0};
  Item **copy_args= copy_tmp_args;
  if (arg_count > 2)
  {
    copy_args= static_cast<Item**>
      (alloc_root(thd->mem_root, sizeof(Item*) * arg_count));
    if (unlikely(!copy_args))
      return 0;
  }
  for (uint i= 0; i < arg_count; i++)
  {
    Item *arg_clone= args[i]->build_clone(thd);
    if (unlikely(!arg_clone))
      return 0;
    copy_args[i]= arg_clone;
  }
  Item_func_or_sum *copy= static_cast<Item_func_or_sum *>(get_copy(thd));
  if (unlikely(!copy))
    return 0;
  if (arg_count > 2)
    copy->args= copy_args;
  else if (arg_count > 0)
  {
    copy->args= copy->tmp_arg;
    memcpy(copy->args, copy_args, sizeof(Item *) * arg_count);
  }
  return copy;
}",0
Detect whether the following code contains vulnerabilities.,"static long sysconf_exact(int name, const char *name_str, Error **errp)
{
    long ret;

    errno = 0;
    ret = sysconf(name);
    if (ret == -1) {
        if (errno == 0) {
            error_setg(errp, ""sysconf(%s): value indefinite"", name_str);
        } else {
            error_setg_errno(errp, errno, ""sysconf(%s)"", name_str);
        }
    }
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	free(name);

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"proto_reg_handoff_e100(void)
{
    /* Check all UDP traffic, as the specific UDP port is configurable */
    heur_dissector_add(""udp"", dissect_e100, ""E100 over UDP"", ""e100_udp"", proto_e100, HEURISTIC_ENABLE);
    /* e100 traffic encapsulates traffic from the ethernet frame on */
    eth_handle = find_dissector(""eth"");
}",0
Detect whether the following code contains vulnerabilities.,"int cil_gen_optional(struct cil_db *db, struct cil_tree_node *parse_current, struct cil_tree_node *ast_node)
{
	enum cil_syntax syntax[] = {
		CIL_SYN_STRING,
		CIL_SYN_STRING,
		CIL_SYN_N_LISTS | CIL_SYN_END,
		CIL_SYN_END
	};
	int syntax_len = sizeof(syntax)/sizeof(*syntax);
	char *key = NULL;
	struct cil_optional *optional = NULL;
	int rc = SEPOL_ERR;

	if (db == NULL || parse_current == NULL || ast_node == NULL) {
		goto exit;
	}

	rc = __cil_verify_syntax(parse_current, syntax, syntax_len);
	if (rc != SEPOL_OK) {
		goto exit;
	}

	cil_optional_init(&optional);

	key = parse_current->next->data;

	rc = cil_gen_node(db, ast_node, (struct cil_symtab_datum*)optional, (hashtab_key_t)key, CIL_SYM_BLOCKS, CIL_OPTIONAL);
	if (rc != SEPOL_OK)
		goto exit;

	return SEPOL_OK;

exit:
	cil_tree_log(parse_current, CIL_ERR, ""Bad optional"");
	cil_destroy_optional(optional);
	cil_clear_node(ast_node);
	return rc;
}",0
Detect whether the following code contains vulnerabilities.,"PHP_METHOD(Phar, isCompressed)
{
	PHAR_ARCHIVE_OBJECT();
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (phar_obj->arc.archive->flags & PHAR_FILE_COMPRESSED_GZ) {
		RETURN_LONG(PHAR_ENT_COMPRESSED_GZ);
	}

	if (phar_obj->arc.archive->flags & PHAR_FILE_COMPRESSED_BZ2) {
		RETURN_LONG(PHAR_ENT_COMPRESSED_BZ2);
	}

	RETURN_FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"static inline pgd_t *pgd_alloc(struct mm_struct *mm)
{
	spin_lock_init(&mm->context.list_lock);
	INIT_LIST_HEAD(&mm->context.pgtable_list);
	INIT_LIST_HEAD(&mm->context.gmap_list);
	return (pgd_t *) crst_table_alloc(mm);
}",1
Detect whether the following code contains vulnerabilities.,"proto_read_byte_buffer (p11_rpc_message *msg,
                        CK_BYTE_PTR *buffer,
                        CK_ULONG *n_buffer)
{
	uint32_t length;

	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);

	/* Check that we're supposed to be reading this at this point */
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fy""));

	/* The number of ulongs there's room for on the other end */
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;

	*n_buffer = length;
	*buffer = NULL;

	/* If set to zero, then they just want the length */
	if (length == 0)
		return CKR_OK;

	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_BYTE));
	if (*buffer == NULL)
		return CKR_DEVICE_MEMORY;

	return CKR_OK;
}",1
Detect whether the following code contains vulnerabilities.,"TEST_F(ExprMatchTest, GteWithRHSFieldPathMatchesCorrectly) {
    createMatcher(fromjson(""{$expr: {$gte: [3, '$x']}}""));

    ASSERT_TRUE(matches(BSON(""x"" << 3)));
    ASSERT_TRUE(matches(BSON(""x"" << 1)));

    ASSERT_FALSE(matches(BSON(""x"" << 10)));
}",0
Detect whether the following code contains vulnerabilities.,"compile_one_expr_in_str(char_u *p, cctx_T *cctx)
{
    char_u	*block_start;
    char_u	*block_end;

    // Skip the opening {.
    block_start = skipwhite(p + 1);
    block_end = block_start;
    if (*block_start != NUL && skip_expr(&block_end, NULL) == FAIL)
	return NULL;
    block_end = skipwhite(block_end);
    // The block must be closed by a }.
    if (*block_end != '}')
    {
	semsg(_(e_missing_close_curly_str), p);
	return NULL;
    }
    if (compile_expr0(&block_start, cctx) == FAIL)
	return NULL;
    may_generate_2STRING(-1, TRUE, cctx);

    return block_end + 1;
}",0
Detect whether the following code contains vulnerabilities.,"static int common_end(HYuvContext *s)

{

    int i;



    for(i = 0; i < 3; i++) {

        av_freep(&s->temp[i]);

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void inode_init_owner(struct inode *inode, const struct inode *dir,
			umode_t mode)
{
	inode->i_uid = current_fsuid();
	if (dir && dir->i_mode & S_ISGID) {
		inode->i_gid = dir->i_gid;
		if (S_ISDIR(mode))
			mode |= S_ISGID;
	} else
		inode->i_gid = current_fsgid();
	inode->i_mode = mode;
}",1
Detect whether the following code contains vulnerabilities.,"static void sdl_resize(DisplayState *ds)

{

    int flags;



    //    printf(""resizing to %d %d\n"", w, h);



    flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    if (gui_fullscreen)

        flags |= SDL_FULLSCREEN;

    if (gui_noframe)

        flags |= SDL_NOFRAME;



 again:

    real_screen = SDL_SetVideoMode(ds_get_width(ds), ds_get_height(ds), 0, flags);

    if (!real_screen) {

        fprintf(stderr, ""Could not open SDL display\n"");

        exit(1);

    }

    if (!real_screen->pixels && (flags & SDL_HWSURFACE) && (flags & SDL_FULLSCREEN)) {

        flags &= ~SDL_HWSURFACE;

        goto again;

    }



    if (!real_screen->pixels) {

        fprintf(stderr, ""Could not open SDL display\n"");

        exit(1);

    }



    sdl_setdata(ds);

}
",0
Detect whether the following code contains vulnerabilities.,"gboolean
mono_verifier_is_enabled_for_method (MonoMethod *method)
{
	/* The verifier was disabled at compile time */
	return FALSE;",0
Detect whether the following code contains vulnerabilities.,"static int __init fwnet_init(void)
{
	int err;

	err = fw_core_add_descriptor(&rfc2374_unit_directory);
	if (err)
		return err;

#if IS_ENABLED(CONFIG_IPV6)
	err = fw_core_add_descriptor(&rfc3146_unit_directory);
	if (err)
		goto out;
#endif

	fwnet_packet_task_cache = kmem_cache_create(""packet_task"",
			sizeof(struct fwnet_packet_task), 0, 0, NULL);
	if (!fwnet_packet_task_cache) {
		err = -ENOMEM;
		goto out2;
	}

	err = driver_register(&fwnet_driver.driver);
	if (!err)
		return 0;

	kmem_cache_destroy(fwnet_packet_task_cache);
out2:
#if IS_ENABLED(CONFIG_IPV6)
	fw_core_remove_descriptor(&rfc3146_unit_directory);
out:
#endif
	fw_core_remove_descriptor(&rfc2374_unit_directory);

	return err;
}",0
Detect whether the following code contains vulnerabilities.,"void qemu_cond_wait(QemuCond *cond, QemuMutex *mutex)

{

    /*

     * This access is protected under the mutex.

     */

    cond->waiters++;



    /*

     * Unlock external mutex and wait for signal.

     * NOTE: we've held mutex locked long enough to increment

     * waiters count above, so there's no problem with

     * leaving mutex unlocked before we wait on semaphore.

     */

    qemu_mutex_unlock(mutex);

    WaitForSingleObject(cond->sema, INFINITE);



    /* Now waiters must rendez-vous with the signaling thread and

     * let it continue.  For cond_broadcast this has heavy contention

     * and triggers thundering herd.  So goes life.

     *

     * Decrease waiters count.  The mutex is not taken, so we have

     * to do this atomically.

     *

     * All waiters contend for the mutex at the end of this function

     * until the signaling thread relinquishes it.  To ensure

     * each waiter consumes exactly one slice of the semaphore,

     * the signaling thread stops until it is told by the last

     * waiter that it can go on.

     */

    if (InterlockedDecrement(&cond->waiters) == cond->target) {

        SetEvent(cond->continue_event);

    }



    qemu_mutex_lock(mutex);

}
",1
Detect whether the following code contains vulnerabilities.,"void nft_data_hold(const struct nft_data *data, enum nft_data_types type)
{
	struct nft_chain *chain;
	struct nft_rule *rule;

	if (type == NFT_DATA_VERDICT) {
		switch (data->verdict.code) {
		case NFT_JUMP:
		case NFT_GOTO:
			chain = data->verdict.chain;
			chain->use++;

			if (!nft_chain_is_bound(chain))
				break;

			chain->table->use++;
			list_for_each_entry(rule, &chain->rules, list)
				chain->use++;

			nft_chain_add(chain->table, chain);
			break;
		}
	}
}",0
Detect whether the following code contains vulnerabilities.,"struct page *get_node_page_ra(struct page *parent, int start)
{
	struct f2fs_sb_info *sbi = F2FS_P_SB(parent);
	nid_t nid = get_nid(parent, start, false);

	return __get_node_page(sbi, nid, parent, start);
}",0
Detect whether the following code contains vulnerabilities.,"static bool hugetlbfs_pagecache_present(struct hstate *h,
			struct vm_area_struct *vma, unsigned long address)
{
	struct address_space *mapping;
	pgoff_t idx;
	struct page *page;

	mapping = vma->vm_file->f_mapping;
	idx = vma_hugecache_offset(h, vma, address);

	page = find_get_page(mapping, idx);
	if (page)
		put_page(page);
	return page != NULL;
}",0
Detect whether the following code contains vulnerabilities.,"latin_ptr2len(char_u *p)
{
 return MB_BYTE2LEN(*p);
}",1
Detect whether the following code contains vulnerabilities.,"videobuf_vm_close(struct vm_area_struct *vma)
{
	struct videobuf_mapping *map = vma->vm_private_data;
	struct videobuf_queue *q = map->q;
	int i;

	dprintk(2,""vm_close %p [count=%u,vma=%08lx-%08lx]\n"",map,
		map->count,vma->vm_start,vma->vm_end);

	map->count--;
	if (0 == map->count) {
		dprintk(1,""munmap %p q=%p\n"",map,q);
		mutex_lock(&q->lock);
		for (i = 0; i < VIDEO_MAX_FRAME; i++) {
			if (NULL == q->bufs[i])
				continue;

			if (q->bufs[i]->map != map)
				continue;

			q->ops->buf_release(q,q->bufs[i]);

			q->bufs[i]->map   = NULL;
			q->bufs[i]->baddr = 0;
		}
		mutex_unlock(&q->lock);
		kfree(map);
	}
	return;
}",0
Detect whether the following code contains vulnerabilities.,"static void add_COM(struct camera_data *cam)
{
	if(cam->COM_len > 0) {
		cam->workbuff->data[cam->workbuff->length++] = 0xFF;
		cam->workbuff->data[cam->workbuff->length++] = 0xFE;
		cam->workbuff->data[cam->workbuff->length++] = 0;
		cam->workbuff->data[cam->workbuff->length++] = cam->COM_len+2;
		memcpy(cam->workbuff->data+cam->workbuff->length,
		       cam->COM_data, cam->COM_len);
		cam->workbuff->length += cam->COM_len;
	}
}",0
Detect whether the following code contains vulnerabilities.,"void qemu_macaddr_default_if_unset(MACAddr *macaddr)

{

    static int index = 0;

    static const MACAddr zero = { .a = { 0,0,0,0,0,0 } };



    if (memcmp(macaddr, &zero, sizeof(zero)) != 0)

        return;

    macaddr->a[0] = 0x52;

    macaddr->a[1] = 0x54;

    macaddr->a[2] = 0x00;

    macaddr->a[3] = 0x12;

    macaddr->a[4] = 0x34;

    macaddr->a[5] = 0x56 + index++;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int64_t sub64(const int64_t a, const int64_t b)

{

	return a - b;

}
",1
Detect whether the following code contains vulnerabilities.,"void EvalAddN(TfLiteContext* context, TfLiteNode* node) {
  // TODO(haoliang): Initialize all_inputs only once during init.
  VectorOfTensors<T> all_inputs(*context, *node->inputs);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  int num_inputs = NumInputs(node);
  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);
  reference_ops::AddN<T>(GetTensorShape(input1), num_inputs, all_inputs.data(),
                         GetTensorData<T>(output));
}",1
Detect whether the following code contains vulnerabilities.,"static void migrate_fd_cancel(MigrationState *s)
{
    int old_state ;
    QEMUFile *f = migrate_get_current()->to_dst_file;
    trace_migrate_fd_cancel();
    if (s->rp_state.from_dst_file) {
        /* shutdown the rp socket, so causing the rp thread to shutdown */
        qemu_file_shutdown(s->rp_state.from_dst_file);
    do {
        old_state = s->state;
        if (!migration_is_setup_or_active(old_state)) {
            break;
        migrate_set_state(&s->state, old_state, MIGRATION_STATUS_CANCELLING);
    } while (s->state != MIGRATION_STATUS_CANCELLING);
    /*
     * If we're unlucky the migration code might be stuck somewhere in a
     * send/write while the network has failed and is waiting to timeout;
     * if we've got shutdown(2) available then we can force it to quit.
     * The outgoing qemu file gets closed in migrate_fd_cleanup that is
     * called in a bh, so there is no race against this cancel.
     */
    if (s->state == MIGRATION_STATUS_CANCELLING && f) {
        qemu_file_shutdown(f);",1
Detect whether the following code contains vulnerabilities.,"  bool ms_verify_authorizer(Connection *con, int peer_type,
				    int protocol, bufferlist& authorizer,
				    bufferlist& authorizer_reply,
				    bool& isvalid, CryptoKey& session_key) override {
    /* always succeed */
    isvalid = true;
    return true;
  };",1
Detect whether the following code contains vulnerabilities.,"static int t_show(struct seq_file *m, void *v)
{
	struct tracer *t = v;

	if (!t)
		return 0;

	seq_puts(m, t->name);
	if (t->next)
		seq_putc(m, ' ');
	else
		seq_putc(m, '\n');

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void MD5::encode(unsigned char *output, UINT4 *input, unsigned int len)
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) {
	output[j] = static_cast<unsigned char>(input[i] & 0xff);
	output[j+1] = static_cast<unsigned char>((input[i] >> 8) & 0xff);
	output[j+2] = static_cast<unsigned char>((input[i] >> 16) & 0xff);
	output[j+3] = static_cast<unsigned char>((input[i] >> 24) & 0xff);
    }
}",1
Detect whether the following code contains vulnerabilities.,"dns_local_removehost(const char *hostname, const ip_addr_t *addr)
{
  int removed = 0;
  struct local_hostlist_entry *entry = local_hostlist_dynamic;
  struct local_hostlist_entry *last_entry = NULL;
  while (entry != NULL) {
    if (((hostname == NULL) || !strcmp(entry->name, hostname)) &&
        ((addr == NULL) || ip_addr_cmp(&entry->addr, addr))) {
      struct local_hostlist_entry *free_entry;
      if (last_entry != NULL) {
        last_entry->next = entry->next;
      } else {
        local_hostlist_dynamic = entry->next;
      }
      free_entry = entry;
      entry = entry->next;
      memp_free(MEMP_LOCALHOSTLIST, free_entry);
      removed++;
    } else {
      last_entry = entry;
      entry = entry->next;
    }
  }
  return removed;
}",1
Detect whether the following code contains vulnerabilities.,"ip_cancel_eval_core(interp, msg, flag)
    Tcl_Interp *interp;
    VALUE msg;
    int flag;
{
#if TCL_MAJOR_VERSION < 8 || (TCL_MAJOR_VERSION == 8 && TCL_MINOR_VERSION < 6)
    rb_raise(rb_eNotImpError,
	     ""cancel_eval is supported Tcl/Tk8.6 or later."");

    UNREACHABLE;
#else
    Tcl_Obj *msg_obj;

    if (NIL_P(msg)) {
      msg_obj = NULL;
    } else {
      msg_obj = Tcl_NewStringObj(RSTRING_PTR(msg), RSTRING_LEN(msg));
      Tcl_IncrRefCount(msg_obj);
    }

    return Tcl_CancelEval(interp, msg_obj, 0, flag);
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static void ax25_kill_by_device(struct net_device *dev)
{
	ax25_dev *ax25_dev;
	ax25_cb *s;
	struct sock *sk;

	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
		return;

	spin_lock_bh(&ax25_list_lock);
again:
	ax25_for_each(s, &ax25_list) {
		if (s->ax25_dev == ax25_dev) {
			sk = s->sk;
			sock_hold(sk);
			spin_unlock_bh(&ax25_list_lock);
			lock_sock(sk);
			s->ax25_dev = NULL;
			ax25_dev_put(ax25_dev);
			ax25_disconnect(s, ENETUNREACH);
			release_sock(sk);
			spin_lock_bh(&ax25_list_lock);
			sock_put(sk);
			/* The entry could have been deleted from the
			 * list meanwhile and thus the next pointer is
			 * no longer valid.  Play it safe and restart
			 * the scan.  Forward progress is ensured
			 * because we set s->ax25_dev to NULL and we
			 * are never passed a NULL 'dev' argument.
			 */
			goto again;
		}
	}
	spin_unlock_bh(&ax25_list_lock);
}",1
Detect whether the following code contains vulnerabilities.,"static int query_format(struct vf_instance *vf, unsigned int fmt)

{

        /* FIXME - really any YUV 4:2:0 input format should work */

        switch (fmt) {

        case IMGFMT_YV12:

        case IMGFMT_IYUV:

        case IMGFMT_I420:

                return ff_vf_next_query_format(vf, IMGFMT_YV12);

        }

        return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static long kvm_vm_compat_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
{
	struct kvm *kvm = filp->private_data;
	int r;

	if (kvm->mm != current->mm)
		return -EIO;
	switch (ioctl) {
	case KVM_GET_DIRTY_LOG: {
		struct compat_kvm_dirty_log compat_log;
		struct kvm_dirty_log log;

		r = -EFAULT;
		if (copy_from_user(&compat_log, (void __user *)arg,
				   sizeof(compat_log)))
			goto out;
		log.slot	 = compat_log.slot;
		log.padding1	 = compat_log.padding1;
		log.padding2	 = compat_log.padding2;
		log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

		r = kvm_vm_ioctl_get_dirty_log(kvm, &log);
		break;
	}
	default:
		r = kvm_vm_ioctl(filp, ioctl, arg);
	}

out:
	return r;
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_tlbie(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr || !ctx->hv)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    if (NARROW_MODE(ctx)) {

        TCGv t0 = tcg_temp_new();

        tcg_gen_ext32u_tl(t0, cpu_gpr[rB(ctx->opcode)]);

        gen_helper_tlbie(cpu_env, t0);

        tcg_temp_free(t0);

    } else {

        gen_helper_tlbie(cpu_env, cpu_gpr[rB(ctx->opcode)]);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_bmdma_setup(void)

{

    ide_test_start(

        ""-vnc none ""

        ""-drive file=%s,if=ide,serial=%s,cache=writeback ""

        ""-global ide-hd.ver=%s"",

        tmp_path, ""testdisk"", ""version"");

}
",1
Detect whether the following code contains vulnerabilities.,"static void dump_aml_files(test_data *data)

{

    AcpiSdtTable *sdt;

    GError *error = NULL;

    gint fd;

    ssize_t ret;

    int i;



    for (i = 0; i < data->ssdt_tables->len; ++i) {

        sdt = &g_array_index(data->ssdt_tables, AcpiSdtTable, i);

        g_assert(sdt->aml);



        fd = g_file_open_tmp(""aml-XXXXXX"", &sdt->aml_file, &error);

        g_assert_no_error(error);



        ret = qemu_write_full(fd, sdt, sizeof(AcpiTableHeader));

        g_assert(ret == sizeof(AcpiTableHeader));

        ret = qemu_write_full(fd, sdt->aml, sdt->aml_len);

        g_assert(ret == sdt->aml_len);



        close(fd);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}",0
Detect whether the following code contains vulnerabilities.,"dvi_document_file_exporter_end (EvFileExporter *exporter)
{
	gchar *command_line;
	gint exit_stat;
	GError *err = NULL;
	gboolean success;
	
	DviDocument *dvi_document = DVI_DOCUMENT(exporter);
	
	command_line = g_strdup_printf (""dvipdfm %s -o %s \""%s\"""", /* dvipdfm -s 1,2,.., -o exporter_filename dvi_filename */
					dvi_document->exporter_opts->str,
					dvi_document->exporter_filename,
					dvi_document->context->filename);
	
	success = g_spawn_command_line_sync (command_line,
					     NULL,
					     NULL,
					     &exit_stat,
					     &err);

	g_free (command_line);

	if (success == FALSE) {
		g_warning (""Error: %s"", err->message);
	} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){
		g_warning (""Error: dvipdfm does not end normally or exit with a failure status."");
	}

	if (err)
		g_error_free (err);
}",1
Detect whether the following code contains vulnerabilities.,"static int nbd_negotiate_handle_export_name(NBDClient *client, uint32_t length)

{

    int rc = -EINVAL;

    char name[256];



    /* Client sends:

        [20 ..  xx]   export name (length bytes)

     */

    TRACE(""Checking length"");

    if (length > 255) {

        LOG(""Bad length received"");

        goto fail;

    }

    if (nbd_negotiate_read(client->ioc, name, length) != length) {

        LOG(""read failed"");

        goto fail;

    }

    name[length] = '\0';



    TRACE(""Client requested export '%s'"", name);



    client->exp = nbd_export_find(name);

    if (!client->exp) {

        LOG(""export not found"");

        goto fail;

    }



    QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);

    nbd_export_get(client->exp);

    rc = 0;

fail:

    return rc;

}
",0
Detect whether the following code contains vulnerabilities.,"transform_cipher_param(struct rte_crypto_sym_xform *xform,
		VhostUserCryptoSessionParam *param)
{
	int ret;

	ret = cipher_algo_transform(param->cipher_algo, &xform->cipher.algo);
	if (unlikely(ret < 0))
		return ret;

	xform->type = RTE_CRYPTO_SYM_XFORM_CIPHER;
	xform->cipher.key.length = param->cipher_key_len;
	if (xform->cipher.key.length > 0)
		xform->cipher.key.data = param->cipher_key_buf;
	if (param->dir == VIRTIO_CRYPTO_OP_ENCRYPT)
		xform->cipher.op = RTE_CRYPTO_CIPHER_OP_ENCRYPT;
	else if (param->dir == VIRTIO_CRYPTO_OP_DECRYPT)
		xform->cipher.op = RTE_CRYPTO_CIPHER_OP_DECRYPT;
	else {
		VC_LOG_DBG(""Bad operation type"");
		return -VIRTIO_CRYPTO_BADMSG;
	}

	ret = get_iv_len(xform->cipher.algo);
	if (unlikely(ret < 0))
		return ret;
	xform->cipher.iv.length = (uint16_t)ret;
	xform->cipher.iv.offset = IV_OFFSET;
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void copy_gigantic_page(struct page *dst, struct page *src)
{
	int i;
	struct hstate *h = page_hstate(src);
	struct page *dst_base = dst;
	struct page *src_base = src;

	for (i = 0; i < pages_per_huge_page(h); ) {
		cond_resched();
		copy_highpage(dst, src);

		i++;
		dst = mem_map_next(dst, dst_base, i);
		src = mem_map_next(src, src_base, i);
	}
}",0
Detect whether the following code contains vulnerabilities.,"BlockStatsList *qmp_query_blockstats(Error **errp)
{
    BlockStatsList *head = NULL, **p_next = &head;
    BlockDriverState *bs = NULL;
     while ((bs = bdrv_next(bs))) {
        BlockStatsList *info = g_malloc0(sizeof(*info));
        info->value = bdrv_query_stats(bs);
        *p_next = info;
        p_next = &info->next;
    }
    return head;
}",1
Detect whether the following code contains vulnerabilities.,"int PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin) {
	if (!bin || !bin->nt_headers) {
		return false;
	}
	return HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);
}",0
Detect whether the following code contains vulnerabilities.,"static struct binder_node *binder_get_node_from_ref(
		struct binder_proc *proc,
		u32 desc, bool need_strong_ref,
		struct binder_ref_data *rdata)
{
	struct binder_node *node;
	struct binder_ref *ref;

	binder_proc_lock(proc);
	ref = binder_get_ref_olocked(proc, desc, need_strong_ref);
	if (!ref)
		goto err_no_ref;
	node = ref->node;
	/*
	 * Take an implicit reference on the node to ensure
	 * it stays alive until the call to binder_put_node()
	 */
	binder_inc_node_tmpref(node);
	if (rdata)
		*rdata = ref->data;
	binder_proc_unlock(proc);

	return node;

err_no_ref:
	binder_proc_unlock(proc);
	return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void check_alignment(CPUS390XState *env, uint64_t v,

                                   int wordsize, uintptr_t ra)

{

    if (v % wordsize) {

        CPUState *cs = CPU(s390_env_get_cpu(env));

        cpu_restore_state(cs, ra);

        program_interrupt(env, PGM_SPECIFICATION, 6);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"gs_nulldevice(gs_gstate * pgs)
{
    int code = 0;

    if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {
        gx_device *ndev;
        code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,
                                 pgs->memory);

        if (code < 0)
            return code;
        /*
         * Internal devices have a reference count of 0, not 1,
         * aside from references from graphics states.
         */
        /* There is some strange use of the null device in the code.  I need
           to sort out how the icc profile is best handled with this device.
           It seems to inherit properties from the current device if there
           is one */
        rc_init(ndev, pgs->memory, 0);
        if (pgs->device != NULL) {
            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,
                                               &(ndev->icc_struct))) < 0)
                return code;
            rc_increment(ndev->icc_struct);
            set_dev_proc(ndev, get_profile, gx_default_get_profile);
        }

        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)
            gs_free_object(pgs->memory, ndev, ""gs_copydevice(device)"");
    }
    return code;
}",1
Detect whether the following code contains vulnerabilities.,"  explicit FakeServerHandshake(
      QuicServerConnectionState& conn,
      std::shared_ptr<FizzServerQuicHandshakeContext> fizzContext,
      bool chloSync = false,
      bool cfinSync = false,
      folly::Optional<uint64_t> clientActiveConnectionIdLimit = folly::none)
      : FizzServerHandshake(&conn, std::move(fizzContext)),
        conn_(conn),
        chloSync_(chloSync),
        cfinSync_(cfinSync),
        clientActiveConnectionIdLimit_(clientActiveConnectionIdLimit) {}",0
Detect whether the following code contains vulnerabilities.,"rfbSendBell(rfbScreenInfoPtr rfbScreen)
{
    rfbClientIteratorPtr i;
    rfbClientPtr cl;
    rfbBellMsg b;

    i = rfbGetClientIterator(rfbScreen);
    while((cl=rfbClientIteratorNext(i))) {
	b.type = rfbBell;
	if (rfbWriteExact(cl, (char *)&b, sz_rfbBellMsg) < 0) {
	    rfbLogPerror(""rfbSendBell: write"");
	    rfbCloseClient(cl);
	}
    }
    rfbStatRecordMessageSent(cl, rfbBell, sz_rfbBellMsg, sz_rfbBellMsg);
    rfbReleaseClientIterator(i);
}",1
Detect whether the following code contains vulnerabilities.,"long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,
		       unsigned long bitmap_size)
{
	unsigned long nr_compat_longs;

	/* align bitmap up to nearest compat_long_t boundary */
	bitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);
	nr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);

	if (!access_ok(umask, bitmap_size / 8))
		return -EFAULT;

	user_access_begin();
	while (nr_compat_longs > 1) {
		unsigned long m = *mask++;
		unsafe_put_user((compat_ulong_t)m, umask++, Efault);
		unsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);
		nr_compat_longs -= 2;
	}
	if (nr_compat_longs)
		unsafe_put_user((compat_ulong_t)*mask, umask++, Efault);
	user_access_end();
	return 0;
Efault:
	user_access_end();
	return -EFAULT;
}",1
Detect whether the following code contains vulnerabilities.,"Item* Item_singlerow_subselect::expr_cache_insert_transformer(THD *tmp_thd,
                                                              uchar *unused)
{
  DBUG_ENTER(""Item_singlerow_subselect::expr_cache_insert_transformer"");

  DBUG_ASSERT(thd == tmp_thd);

  if (expr_cache)
    DBUG_RETURN(expr_cache);

  if (expr_cache_is_needed(tmp_thd) &&
      (expr_cache= set_expr_cache(tmp_thd)))
  {
    init_expr_cache_tracker(tmp_thd);
    DBUG_RETURN(expr_cache);
  }
  DBUG_RETURN(this);
}",1
Detect whether the following code contains vulnerabilities.,"void *smalloc(size_t size)
{
        void *buf;

        buf = malloc(size);
        if (!buf)
                raise(SIGUSR1);
        return buf;
}",0
Detect whether the following code contains vulnerabilities.,"static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)
{
	ext3_fsblk_t	sb_block;
	char		*options = (char *) *data;

	if (!options || strncmp(options, ""sb="", 3) != 0)
		return 1;	/* Default location */
	options += 3;
	/*todo: use simple_strtoll with >32bit ext3 */
	sb_block = simple_strtoul(options, &options, 0);
	if (*options && *options != ',') {
		ext3_msg(sb, ""error: invalid sb specification: %s"",
		       (char *) *data);
		return 1;
	}
	if (*options == ',')
		options++;
	*data = (void *) options;
	return sb_block;
}",1
Detect whether the following code contains vulnerabilities.,"static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
{
	return dax_mkwrite(vma, vmf, ext4_get_block_dax,
				ext4_end_io_unwritten);
}",1
Detect whether the following code contains vulnerabilities.,"static int io_prep_fsync(struct io_kiocb *req, const struct io_uring_sqe *sqe)
{
	struct io_ring_ctx *ctx = req->ctx;

	if (!req->file)
		return -EBADF;

	if (unlikely(ctx->flags & IORING_SETUP_IOPOLL))
		return -EINVAL;
	if (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index))
		return -EINVAL;

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static bool e1000_has_rxbufs(E1000State *s, size_t total_size)

{

    int bufs;

    /* Fast-path short packets */

    if (total_size <= s->rxbuf_size) {

        return s->mac_reg[RDH] != s->mac_reg[RDT] || !s->check_rxov;

    }

    if (s->mac_reg[RDH] < s->mac_reg[RDT]) {

        bufs = s->mac_reg[RDT] - s->mac_reg[RDH];

    } else if (s->mac_reg[RDH] > s->mac_reg[RDT] || !s->check_rxov) {

        bufs = s->mac_reg[RDLEN] /  sizeof(struct e1000_rx_desc) +

            s->mac_reg[RDT] - s->mac_reg[RDH];

    } else {

        return false;

    }

    return total_size <= bufs * s->rxbuf_size;

}
",0
Detect whether the following code contains vulnerabilities.,"void abort_not_in_this_version()
{
  die(""Not available in this version of mysqltest"");
}",0
Detect whether the following code contains vulnerabilities.,"static struct omap_rtc_s *omap_rtc_init(MemoryRegion *system_memory,

                                        target_phys_addr_t base,

                                        qemu_irq timerirq, qemu_irq alarmirq,

                                        omap_clk clk)

{

    struct omap_rtc_s *s = (struct omap_rtc_s *)

            g_malloc0(sizeof(struct omap_rtc_s));



    s->irq = timerirq;

    s->alarm = alarmirq;

    s->clk = qemu_new_timer_ms(rtc_clock, omap_rtc_tick, s);



    omap_rtc_reset(s);



    memory_region_init_io(&s->iomem, &omap_rtc_ops, s,

                          ""omap-rtc"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static int config_props(AVFilterLink *link)

{

    UnsharpContext *unsharp = link->dst->priv;

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(link->format);



    unsharp->hsub = desc->log2_chroma_w;

    unsharp->vsub = desc->log2_chroma_h;



    init_filter_param(link->dst, &unsharp->luma,   ""luma"",   link->w);

    init_filter_param(link->dst, &unsharp->chroma, ""chroma"", SHIFTUP(link->w, unsharp->hsub));



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int RGWDeleteObj_ObjStore_SWIFT::get_params()
{
  const string& mm = s->info.args.get(""multipart-manifest"");
  multipart_delete = (mm.compare(""delete"") == 0);

  return RGWDeleteObj_ObjStore::get_params();
}",0
Detect whether the following code contains vulnerabilities.,"static void xen_blkbk_unmap_and_respond_callback(int result, struct gntab_unmap_queue_data *data)
{
	struct pending_req *pending_req = (struct pending_req *)(data->data);
	struct xen_blkif_ring *ring = pending_req->ring;
	struct xen_blkif *blkif = ring->blkif;

	/* BUG_ON used to reproduce existing behaviour,
	   but is this the best way to deal with this? */
	BUG_ON(result);

	put_free_pages(ring, data->pages, data->count);
	make_response(ring, pending_req->id,
		      pending_req->operation, pending_req->status);
	free_req(ring, pending_req);
	/*
	 * Make sure the request is freed before releasing blkif,
	 * or there could be a race between free_req and the
	 * cleanup done in xen_blkif_free during shutdown.
	 *
	 * NB: The fact that we might try to wake up pending_free_wq
	 * before drain_complete (in case there's a drain going on)
	 * it's not a problem with our current implementation
	 * because we can assure there's no thread waiting on
	 * pending_free_wq if there's a drain going on, but it has
	 * to be taken into account if the current model is changed.
	 */
	if (atomic_dec_and_test(&ring->inflight) && atomic_read(&blkif->drain)) {
		complete(&blkif->drain_complete);
	}
	xen_blkif_put(blkif);
}",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_sublv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 - op2);

    if (unlikely(((~tmp) ^ op1 ^ (-1UL)) & ((~tmp) ^ op2) & (1UL << 31))) {

        helper_excp(EXCP_ARITH, EXCP_ARITH_OVERFLOW);

    }

    return op1;

}
",1
Detect whether the following code contains vulnerabilities.,"__nlmsg_put(struct sk_buff *skb, u32 pid, u32 seq, int type, int len, int flags)
{
	struct nlmsghdr *nlh;
	int size = NLMSG_LENGTH(len);

	nlh = (struct nlmsghdr*)skb_put(skb, NLMSG_ALIGN(size));
	nlh->nlmsg_type = type;
	nlh->nlmsg_len = size;
	nlh->nlmsg_flags = flags;
	nlh->nlmsg_pid = pid;
	nlh->nlmsg_seq = seq;
	return nlh;
}",1
Detect whether the following code contains vulnerabilities.,"			  bool poll_only)
	__must_hold(&ctx->completion_lock)
{
	struct io_kiocb *req = io_poll_find(ctx, sqe_addr, poll_only);

	if (!req)
		return -ENOENT;
	io_poll_cancel_req(req);
	return 0;",1
Detect whether the following code contains vulnerabilities.,"e1000e_set_dbal(E1000ECore *core, int index, uint32_t val)
{
    core->mac[index] = val & E1000_XDBAL_MASK;
}",0
Detect whether the following code contains vulnerabilities.,"static void srpt_mad_send_handler(struct ib_mad_agent *mad_agent,
				  struct ib_mad_send_wc *mad_wc)
{
	ib_destroy_ah(mad_wc->send_buf->ah);
	ib_free_send_mad(mad_wc->send_buf);
}",0
Detect whether the following code contains vulnerabilities.,"int bdrv_write(BlockDriverState *bs, int64_t sector_num,
               const uint8_t *buf, int nb_sectors)
{
    BlockDriver *drv = bs->drv;
    if (!bs->drv)
        return -ENOMEDIUM;
    if (bs->read_only)
        return -EACCES;
    if (drv->bdrv_pwrite) {
        int ret, len, count = 0;
        len = nb_sectors * 512;
        do {
            ret = drv->bdrv_pwrite(bs, sector_num * 512, buf, len - count);
            if (ret < 0) {
                printf(""bdrv_write ret=%d\n"", ret);
                return ret;
            }
            count += ret;
            buf += ret;
        } while (count != len);
        bs->wr_bytes += (unsigned) len;
        bs->wr_ops ++;
        return 0;
    }
    return drv->bdrv_write(bs, sector_num, buf, nb_sectors);
}",1
Detect whether the following code contains vulnerabilities.,"add_unsupported_rotation_item (GsdXrandrManager *manager)
{
        struct GsdXrandrManagerPrivate *priv = manager->priv;
        GtkWidget *item;
        GtkWidget *label;

        item = gtk_menu_item_new ();

        label = gtk_label_new (NULL);
        gtk_label_set_markup (GTK_LABEL (label), _(""<i>Rotation not supported</i>""));
        gtk_container_add (GTK_CONTAINER (item), label);

        gtk_widget_show_all (item);
        gtk_menu_shell_append (GTK_MENU_SHELL (priv->popup_menu), item);
}",0
Detect whether the following code contains vulnerabilities.,"static void term_read(void *opaque, const uint8_t *buf, int size)

{

    int i;

    for(i = 0; i < size; i++)

        term_handle_byte(buf[i]);

}
",0
Detect whether the following code contains vulnerabilities.,"Field *Type_handler_blob_common::make_conversion_table_field(TABLE *table,
                                                            uint metadata,
                                                            const Field *target)
                                                            const
{
  uint pack_length= metadata & 0x00ff;
  if (pack_length < 1 || pack_length > 4)
    return NULL; // Broken binary log?
  return new(table->in_use->mem_root)
         Field_blob(NULL, (uchar *) """", 1, Field::NONE, TMPNAME,
                    table->s, pack_length, target->charset());
}",0
Detect whether the following code contains vulnerabilities.," */
bool skb_gso_validate_mtu(const struct sk_buff *skb, unsigned int mtu)
{
	const struct skb_shared_info *shinfo = skb_shinfo(skb);
	const struct sk_buff *iter;
	unsigned int hlen;

	hlen = skb_gso_network_seglen(skb);

	if (shinfo->gso_size != GSO_BY_FRAGS)
		return hlen <= mtu;

	/* Undo this so we can re-use header sizes */
	hlen -= GSO_BY_FRAGS;

	skb_walk_frags(skb, iter) {
		if (hlen + skb_headlen(iter) > mtu)
			return false;
	}

	return true;",1
Detect whether the following code contains vulnerabilities.,"static void json_print_chapter_header(WriterContext *wctx, const char *chapter)

{

    JSONContext *json = wctx->priv;

    char *chapter_esc;



    if (wctx->nb_chapter)

        printf("","");

    json->multiple_entries = !strcmp(chapter, ""packets"") || !strcmp(chapter, ""streams"");

    chapter_esc = json_escape_str(chapter);

    printf(""\n  \""%s\"":%s"", chapter_esc ? chapter_esc : """",

           json->multiple_entries ? "" ["" : "" "");

    av_free(chapter_esc);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
",0
Detect whether the following code contains vulnerabilities.,"static int latest_repeatable_unsubmitted_iter(void *data, void *val)
{
    stream_iter_ctx *ctx = data;
    h2_stream *stream = val;
    
    if (stream->task && !stream->task->worker_done 
        && h2_task_can_redo(stream->task) 
        && !h2_ihash_get(ctx->m->sredo, stream->id)) {
        if (!h2_stream_is_ready(stream)) {
            /* this task occupies a worker, the response has not been submitted 
             * yet, not been cancelled and it is a repeatable request
             * -> it can be re-scheduled later */
            if (!ctx->stream 
                || (ctx->stream->task->started_at < stream->task->started_at)) {
                /* we did not have one or this one was started later */
                ctx->stream = stream;
            }
        }
    }
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"MagickExport size_t GetQuantumExtent(const Image *image,
  const QuantumInfo *quantum_info,const QuantumType quantum_type)
{
  size_t
    packet_size;

  assert(quantum_info != (QuantumInfo *) NULL);
  assert(quantum_info->signature == MagickCoreSignature);
  packet_size=1;
  switch (quantum_type)
  {
    case GrayAlphaQuantum: packet_size=2; break;
    case IndexAlphaQuantum: packet_size=2; break;
    case RGBQuantum: packet_size=3; break;
    case BGRQuantum: packet_size=3; break;
    case RGBAQuantum: packet_size=4; break;
    case RGBOQuantum: packet_size=4; break;
    case BGRAQuantum: packet_size=4; break;
    case CMYKQuantum: packet_size=4; break;
    case CMYKAQuantum: packet_size=5; break;
    default: break;
  }
  if (quantum_info->pack == MagickFalse)
    return((size_t) (packet_size*image->columns*((quantum_info->depth+7)/8)));
  return((size_t) ((packet_size*image->columns*quantum_info->depth+7)/8));
}",1
Detect whether the following code contains vulnerabilities.,"void ax25_return_dm(struct net_device *dev, ax25_address *src, ax25_address *dest, ax25_digi *digi)
{
	struct sk_buff *skb;
	char *dptr;
	ax25_digi retdigi;

	if (dev == NULL)
		return;

	if ((skb = alloc_skb(dev->hard_header_len + 1, GFP_ATOMIC)) == NULL)
		return;	/* Next SABM will get DM'd */

	skb_reserve(skb, dev->hard_header_len);
	skb_reset_network_header(skb);

	ax25_digi_invert(digi, &retdigi);

	dptr = skb_put(skb, 1);

	*dptr = AX25_DM | AX25_PF;

	/*
	 *	Do the address ourselves
	 */
	dptr  = skb_push(skb, ax25_addr_size(digi));
	dptr += ax25_addr_build(dptr, dest, src, &retdigi, AX25_RESPONSE, AX25_MODULUS);

	ax25_queue_xmit(skb, dev);
}",0
Detect whether the following code contains vulnerabilities.,"int handle_request(struct ipa_extdom_ctx *ctx, struct extdom_req *req,
                   struct berval **berval)
{
    int ret;

    switch (req->input_type) {
    case INP_POSIX_UID:
        ret = handle_uid_request(req->request_type, req->data.posix_uid.uid,
                                 req->data.posix_uid.domain_name, berval);

        break;
    case INP_POSIX_GID:
        ret = handle_gid_request(req->request_type, req->data.posix_gid.gid,
                                 req->data.posix_uid.domain_name, berval);

        break;
    case INP_SID:
        ret = handle_sid_request(req->request_type, req->data.sid, berval);
        break;
    case INP_NAME:
        ret = handle_name_request(req->request_type, req->data.name.object_name,
                                  req->data.name.domain_name, berval);

        break;
    default:
        ret = LDAP_PROTOCOL_ERROR;
        goto done;
    }


done:

    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"int kvm_handle_invalid_op(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}",0
Detect whether the following code contains vulnerabilities.,"archive_read_support_format_lha(struct archive *_a)
{
	struct archive_read *a = (struct archive_read *)_a;
	struct lha *lha;
	int r;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_lha"");

	lha = (struct lha *)calloc(1, sizeof(*lha));
	if (lha == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate lha data"");
		return (ARCHIVE_FATAL);
	}
	archive_string_init(&lha->ws);

	r = __archive_read_register_format(a,
	    lha,
	    ""lha"",
	    archive_read_format_lha_bid,
	    archive_read_format_lha_options,
	    archive_read_format_lha_read_header,
	    archive_read_format_lha_read_data,
	    archive_read_format_lha_read_data_skip,
	    NULL,
	    archive_read_format_lha_cleanup,
	    NULL,
	    NULL);

	if (r != ARCHIVE_OK)
		free(lha);
	return (ARCHIVE_OK);
}",0
Detect whether the following code contains vulnerabilities.,"envlist_create(void)

{

	envlist_t *envlist;



	if ((envlist = malloc(sizeof (*envlist))) == NULL)

		return (NULL);



	LIST_INIT(&envlist->el_entries);

	envlist->el_count = 0;



	return (envlist);

}
",0
Detect whether the following code contains vulnerabilities.,"bool Skin::operator==(const Skin &other) const {
  return this->extensions == other.extensions && this->extras == other.extras &&
         this->inverseBindMatrices == other.inverseBindMatrices &&
         this->joints == other.joints && this->name == other.name &&
         this->skeleton == other.skeleton;
}",0
Detect whether the following code contains vulnerabilities.,"const char *gf_filter_get_id(GF_Filter *filter)
{
	if (filter) return filter->id;
	return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static void br_multicast_del_pg(struct net_bridge *br,
				struct net_bridge_port_group *pg)
{
	struct net_bridge_mdb_htable *mdb;
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;

	mdb = mlock_dereference(br->mdb, br);

	mp = br_mdb_ip_get(mdb, &pg->addr);
	if (WARN_ON(!mp))
		return;

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p != pg)
			continue;

		rcu_assign_pointer(*pp, p->next);
		hlist_del_init(&p->mglist);
		del_timer(&p->timer);
		del_timer(&p->query_timer);
		call_rcu_bh(&p->rcu, br_multicast_free_pg);

		if (!mp->ports && hlist_unhashed(&mp->mglist) &&
		    netif_running(br->dev))
			mod_timer(&mp->timer, jiffies);

		return;
	}

	WARN_ON(1);
}",0
Detect whether the following code contains vulnerabilities.,"void fw_cfg_add_callback(FWCfgState *s, uint16_t key, FWCfgCallback callback,

                         void *callback_opaque, uint8_t *data, size_t len)

{

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    assert(key & FW_CFG_WRITE_CHANNEL);



    key &= FW_CFG_ENTRY_MASK;



    assert(key < FW_CFG_MAX_ENTRY && len <= 65535);



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;

}
",1
Detect whether the following code contains vulnerabilities.,"static int htc_setup_complete(struct htc_target *target)
{
	struct sk_buff *skb;
	struct htc_comp_msg *comp_msg;
	int ret = 0;
	unsigned long time_left;

	skb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);
	if (!skb) {
		dev_err(target->dev, ""failed to allocate send buffer\n"");
		return -ENOMEM;
	}
	skb_reserve(skb, sizeof(struct htc_frame_hdr));

	comp_msg = skb_put(skb, sizeof(struct htc_comp_msg));
	comp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);

	target->htc_flags |= HTC_OP_START_WAIT;

	ret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);
	if (ret)
		goto err;

	time_left = wait_for_completion_timeout(&target->cmd_wait, HZ);
	if (!time_left) {
		dev_err(target->dev, ""HTC start timeout\n"");
		return -ETIMEDOUT;
	}

	return 0;

err:
	kfree_skb(skb);
	return -EINVAL;
}",1
Detect whether the following code contains vulnerabilities.,"void rdp_read_flow_control_pdu(wStream* s, UINT16* type)
{
	/*
	 * Read flow control PDU - documented in FlowPDU section in T.128
	 * http://www.itu.int/rec/T-REC-T.128-199802-S/en
	 * The specification for the PDU has pad8bits listed BEFORE pduTypeFlow.
	 * However, so far pad8bits has always been observed to arrive AFTER pduTypeFlow.
	 * Switched the order of these two fields to match this observation.
	 */
	UINT8 pduType;
	Stream_Read_UINT8(s, pduType); /* pduTypeFlow */
	*type = pduType;
	Stream_Seek_UINT8(s);  /* pad8bits */
	Stream_Seek_UINT8(s);  /* flowIdentifier */
	Stream_Seek_UINT8(s);  /* flowNumber */
	Stream_Seek_UINT16(s); /* pduSource */
}",1
Detect whether the following code contains vulnerabilities.,"static int try_rgrow_left(MAIN_WINDOW_REC *window, int count)
{
	MAIN_WINDOW_REC *grow_win;

	grow_win = mainwindows_find_left(window, FALSE);
	if (grow_win != NULL) {
		grow_win->last_column += count;
		window->first_column += count;
		mainwindows_rresize_two(grow_win, window, count);
		return TRUE;
	}

	return FALSE;
}",0
Detect whether the following code contains vulnerabilities.,"  Compound_Selector_Ptr Simple_Selector::unify_with(Compound_Selector_Ptr rhs)
  {
    for (size_t i = 0, L = rhs->length(); i < L; ++i)
    { if (to_string() == rhs->at(i)->to_string()) return rhs; }

    // check for pseudo elements because they are always last
    size_t i, L;
    bool found = false;
    if (typeid(*this) == typeid(Pseudo_Selector) || typeid(*this) == typeid(Wrapped_Selector))
    {
      for (i = 0, L = rhs->length(); i < L; ++i)
      {
        if ((Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i])) && (*rhs)[L-1]->is_pseudo_element())
        { found = true; break; }
      }
    }
    else
    {
      for (i = 0, L = rhs->length(); i < L; ++i)
      {
        if (Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i]))
        { found = true; break; }
      }
    }
    if (!found)
    {
      rhs->append(this);
      return rhs;
    }
    rhs->elements().insert(rhs->elements().begin() + i, this);
    return rhs;
  }",1
Detect whether the following code contains vulnerabilities.,"glue(glue(cirrus_bitblt_rop_fwd_transp_, ROP_NAME),_8)(CirrusVGAState *s,
						       uint8_t *dst,const uint8_t *src,
						       int dstpitch,int srcpitch,
						       int bltwidth,int bltheight)
{
    int x,y;
    uint8_t p;
    dstpitch -= bltwidth;
    srcpitch -= bltwidth;

    if (bltheight > 1 && (dstpitch < 0 || srcpitch < 0)) {
        return;
    }

    for (y = 0; y < bltheight; y++) {
        for (x = 0; x < bltwidth; x++) {
	    p = *dst;
            ROP_OP(&p, *src);
	    if (p != s->vga.gr[0x34]) *dst = p;
            dst++;
            src++;
        }
        dst += dstpitch;
        src += srcpitch;
    }
}",1
Detect whether the following code contains vulnerabilities.,"void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )
{
	cJSON_AddItemToArray( array, create_reference( item ) );
}",1
Detect whether the following code contains vulnerabilities.,"static int _hostsock_ioctl(oe_fd_t* sock_, unsigned long request, uint64_t arg)
{
    int ret = -1;
    sock_t* sock = _cast_sock(sock_);

    oe_errno = 0;

    if (!sock)
        OE_RAISE_ERRNO(OE_EINVAL);

    if (oe_syscall_ioctl_ocall(&ret, sock->host_fd, request, arg, 0, NULL) !=
        OE_OK)
        OE_RAISE_ERRNO(OE_EINVAL);

done:

    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"uint8_t *av_packet_new_side_data(AVPacket *pkt, enum AVPacketSideDataType type,

                                 int size)

{

    int elems = pkt->side_data_elems;



    if ((unsigned)elems + 1 > INT_MAX / sizeof(*pkt->side_data))

        return NULL;

    if ((unsigned)size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return NULL;



    pkt->side_data = av_realloc(pkt->side_data,

                                (elems + 1) * sizeof(*pkt->side_data));

    if (!pkt->side_data)

        return NULL;



    pkt->side_data[elems].data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!pkt->side_data[elems].data)

        return NULL;

    pkt->side_data[elems].size = size;

    pkt->side_data[elems].type = type;

    pkt->side_data_elems++;



    return pkt->side_data[elems].data;

}
",1
Detect whether the following code contains vulnerabilities.,"MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)
{
	static const GdkPixbufModulePattern signature[] = {
		{ ""\xff\xd8"", NULL, 100 },
		{ NULL, NULL, 0 }
	};
	static const gchar *mime_types[] = {
		""image/jpeg"",
		NULL
	};
	static const gchar *extensions[] = {
		""jpeg"",
		""jpe"",
		""jpg"",
		NULL
	};

	info->name = ""jpeg"";
	info->signature = (GdkPixbufModulePattern *) signature;
	info->description = NC_(""image format"", ""JPEG"");
	info->mime_types = (gchar **) mime_types;
	info->extensions = (gchar **) extensions;
	info->flags = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;
	info->license = ""LGPL"";
}",0
Detect whether the following code contains vulnerabilities.,"static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
                                      unsigned char **p,
                                      unsigned char *end )
{
    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
    size_t  len;
    ((void) ssl);

    /*
     * PSK parameters:
     *
     * opaque psk_identity_hint<0..2^16-1>;
     */
    len = (*p)[0] << 8 | (*p)[1];
    *p += 2;

    if( (*p) + len > end )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                    ""(psk_identity_hint length)"" ) );
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
    }

    /*
     * Note: we currently ignore the PKS identity hint, as we only allow one
     * PSK to be provisionned on the client. This could be changed later if
     * someone needs that feature.
     */
    *p += len;
    ret = 0;

    return( ret );
}",1
Detect whether the following code contains vulnerabilities.,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;



    if (watchdog) {

        fprintf(stderr,

                 ""qemu: only one watchdog option may be given\n"");

        return 1;

    }



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            watchdog = model;

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int set_qf_name(struct super_block *sb, int qtype, substring_t *args)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	char *qname;

	if (sb_any_quota_loaded(sb) &&
		!sbi->s_qf_names[qtype]) {
		ext4_msg(sb, KERN_ERR,
			""Cannot change journaled ""
			""quota options when quota turned on"");
		return 0;
	}
	qname = match_strdup(args);
	if (!qname) {
		ext4_msg(sb, KERN_ERR,
			""Not enough memory for storing quotafile name"");
		return 0;
	}
	if (sbi->s_qf_names[qtype] &&
		strcmp(sbi->s_qf_names[qtype], qname)) {
		ext4_msg(sb, KERN_ERR,
			""%s quota file already specified"", QTYPE2NAME(qtype));
		kfree(qname);
		return 0;
	}
	sbi->s_qf_names[qtype] = qname;
	if (strchr(sbi->s_qf_names[qtype], '/')) {
		ext4_msg(sb, KERN_ERR,
			""quotafile must be on filesystem root"");
		kfree(sbi->s_qf_names[qtype]);
		sbi->s_qf_names[qtype] = NULL;
		return 0;
	}
	set_opt(sb, QUOTA);
	return 1;
}",0
Detect whether the following code contains vulnerabilities.,"static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)
{
	if(!src.HasSampleData()) return;

	dest.FreeSample();
	dest = src;
	dest.nLength = len;
	dest.pSample = nullptr;

	if(!dest.AllocateSample())
	{
		return;
	}

	// only preserve cue points if the target sample length is the same
	if(len != src.nLength)
		MemsetZero(dest.cues);

	std::memcpy(dest.pSample8, src.pSample8 + start, len);
	dest.uFlags.set(CHN_LOOP, loop);
	if(loop)
	{
		dest.nLoopStart = 0;
		dest.nLoopEnd = len;
	} else
	{
		dest.nLoopStart = 0;
		dest.nLoopEnd = 0;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t drop_sync(QIOChannel *ioc, size_t size)

{

    ssize_t ret = 0;

    char small[1024];

    char *buffer;



    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));

    while (size > 0) {

        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));



        if (count <= 0) {

            goto cleanup;

        }

        assert(count <= size);

        size -= count;

        ret += count;

    }



 cleanup:

    if (buffer != small) {

        g_free(buffer);

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static sctp_disposition_t sctp_sf_violation_chunk(
				     struct net *net,
				     const struct sctp_endpoint *ep,
				     const struct sctp_association *asoc,
				     const sctp_subtype_t type,
				     void *arg,
				     sctp_cmd_seq_t *commands)
{
	static const char err_str[] = ""The following chunk violates protocol:"";

	if (!asoc)
		return sctp_sf_violation(net, ep, asoc, type, arg, commands);

	return sctp_sf_abort_violation(net, ep, asoc, arg, commands, err_str,
					sizeof(err_str));
}",0
Detect whether the following code contains vulnerabilities.,"   Does a self test of the module ""module"" */
PHP_FUNCTION(mcrypt_module_self_test)
{
	MCRYPT_GET_MODE_DIR_ARGS(algorithms_dir);
	
	if (mcrypt_module_self_test(module, dir) == 0) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",1
Detect whether the following code contains vulnerabilities.,"static void unassigned_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem write "" TARGET_FMT_plx "" = 0x%x\n"", addr, val);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 1, 0, 0, 4);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
				  void (*get)(struct x86_emulate_ctxt *ctxt,
					      struct desc_ptr *ptr))
{
	struct desc_ptr desc_ptr;

	if (ctxt->mode == X86EMUL_MODE_PROT64)
		ctxt->op_bytes = 8;
	get(ctxt, &desc_ptr);
	if (ctxt->op_bytes == 2) {
		ctxt->op_bytes = 4;
		desc_ptr.address &= 0x00ffffff;
	}
	/* Disable writeback. */
	ctxt->dst.type = OP_NONE;
	return segmented_write_std(ctxt, ctxt->dst.addr.mem,
				   &desc_ptr, 2 + ctxt->op_bytes);
}",0
Detect whether the following code contains vulnerabilities.,"class_dir_create_and_add(struct class *class, struct kobject *parent_kobj)
{
	struct class_dir *dir;
	int retval;

	dir = kzalloc(sizeof(*dir), GFP_KERNEL);
	if (!dir)
		return ERR_PTR(-ENOMEM);

	dir->class = class;
	kobject_init(&dir->kobj, &class_dir_ktype);

	dir->kobj.kset = &class->p->glue_dirs;

	retval = kobject_add(&dir->kobj, parent_kobj, ""%s"", class->name);
	if (retval < 0) {
		kobject_put(&dir->kobj);
		return ERR_PTR(retval);
	}
	return &dir->kobj;
}",0
Detect whether the following code contains vulnerabilities.,"void auth_request_success_continue(struct auth_policy_check_ctx *ctx)
{
	struct auth_request *request = ctx->request;
	i_assert(request->state == AUTH_REQUEST_STATE_MECH_CONTINUE);

	timeout_remove(&request->to_penalty);

	if (request->failed || !request->passdb_success) {
		/* password was valid, but some other check failed. */
		auth_request_fail(request);
		return;
	}
	auth_request_set_auth_successful(request);

	/* log before delay */
	auth_request_log_finished(request);

	if (request->delay_until > ioloop_time) {
		unsigned int delay_secs = request->delay_until - ioloop_time;
		request->to_penalty = timeout_add(delay_secs * 1000,
			auth_request_success_continue, ctx);
		return;
	}

	if (ctx->success_data->used > 0 && !request->fields.final_resp_ok) {
		/* we'll need one more SASL round, since client doesn't support
		   the final SASL response */
		auth_request_handler_reply_continue(request,
			ctx->success_data->data, ctx->success_data->used);
		return;
	}

	auth_request_set_state(request, AUTH_REQUEST_STATE_FINISHED);
	auth_request_refresh_last_access(request);
	auth_request_handler_reply(request, AUTH_CLIENT_RESULT_SUCCESS,
		ctx->success_data->data, ctx->success_data->used);
}",0
Detect whether the following code contains vulnerabilities.,"TPM2B_PUBLIC_KEY_RSA_Marshal(TPM2B_PUBLIC_KEY_RSA *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}",1
Detect whether the following code contains vulnerabilities.,"__xfrm4_selector_match(const struct xfrm_selector *sel, const struct flowi *fl)
{
	const struct flowi4 *fl4 = &fl->u.ip4;

	return  addr4_match(fl4->daddr, sel->daddr.a4, sel->prefixlen_d) &&
		addr4_match(fl4->saddr, sel->saddr.a4, sel->prefixlen_s) &&
		!((xfrm_flowi_dport(fl, &fl4->uli) ^ sel->dport) & sel->dport_mask) &&
		!((xfrm_flowi_sport(fl, &fl4->uli) ^ sel->sport) & sel->sport_mask) &&
		(fl4->flowi4_proto == sel->proto || !sel->proto) &&
		(fl4->flowi4_oif == sel->ifindex || !sel->ifindex);
}",0
Detect whether the following code contains vulnerabilities.,"static int crypto_rng_init_tfm(struct crypto_tfm *tfm)
{
	struct crypto_rng *rng = __crypto_rng_cast(tfm);
	struct rng_alg *alg = crypto_rng_alg(rng);
	struct old_rng_alg *oalg = crypto_old_rng_alg(rng);

	if (oalg->rng_make_random) {
		rng->generate = generate;
		rng->seed = rngapi_reset;
		rng->seedsize = oalg->seedsize;
		return 0;
	}

	rng->generate = alg->generate;
	rng->seed = alg->seed;
	rng->seedsize = alg->seedsize;

	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void cpu_physical_memory_unmap(void *buffer, target_phys_addr_t len,

                               int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                if (!cpu_physical_memory_is_dirty(addr1)) {

                    /* invalidate code */

                    tb_invalidate_phys_page_range(addr1, addr1 + l, 0);

                    /* set dirty bit */

                    phys_ram_dirty[addr1 >> TARGET_PAGE_BITS] |=

                        (0xff & ~CODE_DIRTY_FLAG);

                }

                addr1 += l;

                access_len -= l;

            }

        }

        return;

    }

    if (is_write) {

        cpu_physical_memory_write(bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
",0
Detect whether the following code contains vulnerabilities.,"spnego_gss_process_context_token(
				OM_uint32	*minor_status,
				const gss_ctx_id_t context_handle,
				const gss_buffer_t token_buffer)
{
	OM_uint32 ret;
	ret = gss_process_context_token(minor_status,
					context_handle,
					token_buffer);

	return (ret);
}",1
Detect whether the following code contains vulnerabilities.,"static int lance_init(SysBusDevice *dev)

{

    SysBusPCNetState *d = FROM_SYSBUS(SysBusPCNetState, dev);

    PCNetState *s = &d->state;



    memory_region_init_io(&s->mmio, &lance_mem_ops, s, ""lance-mmio"", 4);



    qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1);



    sysbus_init_mmio_region(dev, &s->mmio);



    sysbus_init_irq(dev, &s->irq);



    s->phys_mem_read = ledma_memory_read;

    s->phys_mem_write = ledma_memory_write;

    return pcnet_common_init(&dev->qdev, s, &net_lance_info);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void task_numa_free(struct task_struct *p)
{
}",1
Detect whether the following code contains vulnerabilities.,"static int local_mksock(FsContext *ctx2, const char *path)

{

    struct sockaddr_un addr;

    int s;



    addr.sun_family = AF_UNIX;

    snprintf(addr.sun_path, 108, ""%s"", rpath(ctx2, path));



    s = socket(PF_UNIX, SOCK_STREAM, 0);

    if (s == -1) {

        return -1;

    }



    if (bind(s, (struct sockaddr *)&addr, sizeof(addr))) {

        close(s);

        return -1;

    }



    close(s);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"dirvote_clear_votes(int all_votes)
{
  if (!previous_vote_list)
    previous_vote_list = smartlist_create();
  if (!pending_vote_list)
    pending_vote_list = smartlist_create();

  /* All ""previous"" votes are now junk. */
  SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, v, {
      cached_dir_decref(v->vote_body);
      v->vote_body = NULL;
      networkstatus_vote_free(v->vote);
      tor_free(v);
    });
  smartlist_clear(previous_vote_list);

  if (all_votes) {
    /* If we're dumping all the votes, we delete the pending ones. */
    SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, v, {
        cached_dir_decref(v->vote_body);
        v->vote_body = NULL;
        networkstatus_vote_free(v->vote);
        tor_free(v);
      });
  } else {
    /* Otherwise, we move them into ""previous"". */
    smartlist_add_all(previous_vote_list, pending_vote_list);
  }
  smartlist_clear(pending_vote_list);

  if (pending_consensus_signature_list) {
    SMARTLIST_FOREACH(pending_consensus_signature_list, char *, cp,
                      tor_free(cp));
    smartlist_clear(pending_consensus_signature_list);
  }
  tor_free(pending_consensus_signatures);
  dirvote_clear_pending_consensuses();
}",0
Detect whether the following code contains vulnerabilities.,"VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,

                            VirtIOHandleOutput handle_output)

{

    int i;



    for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {

        if (vdev->vq[i].vring.num == 0)

            break;

    }



    if (i == VIRTIO_QUEUE_MAX || queue_size > VIRTQUEUE_MAX_SIZE)

        abort();



    vdev->vq[i].vring.num = queue_size;

    vdev->vq[i].vring.num_default = queue_size;

    vdev->vq[i].vring.align = VIRTIO_PCI_VRING_ALIGN;

    vdev->vq[i].handle_output = handle_output;

    vdev->vq[i].handle_aio_output = NULL;



    return &vdev->vq[i];

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_nabs(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_GT, cpu_gpr[rA(ctx->opcode)], 0, l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_neg_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    gen_set_label(l2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rD(ctx->opcode)]);

}
",0
Detect whether the following code contains vulnerabilities.,"    static longT _distance_sep_mdt(const longT i, const longT u, const longT *const g) {
      return (u - i<=g[u] - g[i]?999999999:(g[u] - g[i] + u + i)/2);
    }",0
Detect whether the following code contains vulnerabilities.,"Status AuthorizationManager::_initializeUserFromPrivilegeDocument(User* user,
                                                                  const BSONObj& privDoc) {
    V2UserDocumentParser parser;
    std::string userName = parser.extractUserNameFromUserDocument(privDoc);
    if (userName != user->getName().getUser()) {
        return Status(ErrorCodes::BadValue,
                      mongoutils::str::stream() << ""User name from privilege document \""""
                                                << userName
                                                << ""\"" doesn't match name of provided User \""""
                                                << user->getName().getUser()
                                                << ""\"""");
    }

    Status status = parser.initializeUserCredentialsFromUserDocument(user, privDoc);
    if (!status.isOK()) {
        return status;
    }
    status = parser.initializeUserRolesFromUserDocument(privDoc, user);
    if (!status.isOK()) {
        return status;
    }
    status = parser.initializeUserIndirectRolesFromUserDocument(privDoc, user);
    if (!status.isOK()) {
        return status;
    }
    status = parser.initializeUserPrivilegesFromUserDocument(privDoc, user);
    if (!status.isOK()) {
        return status;
    }
    status = parser.initializeAuthenticationRestrictionsFromUserDocument(privDoc, user);
    if (!status.isOK()) {
        return status;
    }

    return Status::OK();
}",1
Detect whether the following code contains vulnerabilities.,"check_owner_password_V4(std::string& user_password,
                        std::string const& owner_password,
                        QPDF::EncryptionData const& data)
{
    // Algorithm 3.7 from the PDF 1.7 Reference Manual

    unsigned char key[OU_key_bytes_V4];
    compute_O_rc4_key(user_password, owner_password, data, key);
    unsigned char O_data[key_bytes];
    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);
    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);
    pad_short_parameter(k1, data.getLengthBytes());
    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),
                data.getLengthBytes(),
                (data.getR() >= 3) ? 20 : 1, true);
    std::string new_user_password =
        std::string(reinterpret_cast<char*>(O_data), key_bytes);
    bool result = false;
    if (check_user_password(new_user_password, data))
    {
        result = true;
        user_password = new_user_password;
    }
    return result;
}",1
Detect whether the following code contains vulnerabilities.,"static void gd_set_keycode_type(GtkDisplayState *s)
{
#ifdef GDK_WINDOWING_X11
    GdkDisplay *display = gtk_widget_get_display(s->window);
    if (GDK_IS_X11_DISPLAY(display)) {
        Display *x11_display = gdk_x11_display_get_xdisplay(display);
        XkbDescPtr desc = XkbGetKeyboard(x11_display, XkbGBN_AllComponentsMask,
                                         XkbUseCoreKbd);
        char *keycodes = NULL;
        if (desc && desc->names) {
            keycodes = XGetAtomName(x11_display, desc->names->keycodes);
        if (keycodes == NULL) {
            fprintf(stderr, ""could not lookup keycode name\n"");
        } else if (strstart(keycodes, ""evdev"", NULL)) {
            s->has_evdev = true;
        } else if (!strstart(keycodes, ""xfree86"", NULL)) {
            fprintf(stderr, ""unknown keycodes `%s', please report to ""
                    ""qemu-devel@nongnu.org\n"", keycodes);
#endif",1
Detect whether the following code contains vulnerabilities.,"static void stub_device_rebind(void)
{
#if IS_MODULE(CONFIG_USBIP_HOST)
	struct bus_id_priv *busid_priv;
	int i;

	/* update status to STUB_BUSID_OTHER so probe ignores the device */
	spin_lock(&busid_table_lock);
	for (i = 0; i < MAX_BUSID; i++) {
		if (busid_table[i].name[0] &&
		    busid_table[i].shutdown_busid) {
			busid_priv = &(busid_table[i]);
			busid_priv->status = STUB_BUSID_OTHER;
		}
	}
	spin_unlock(&busid_table_lock);

	/* now run rebind */
	for (i = 0; i < MAX_BUSID; i++) {
		if (busid_table[i].name[0] &&
		    busid_table[i].shutdown_busid) {
			busid_priv = &(busid_table[i]);
			do_rebind(busid_table[i].name, busid_priv);
		}
	}
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static void gen_conditional_jump(DisasContext * ctx,

				 target_ulong ift, target_ulong ifnott)

{

    int l1;

    TCGv sr;



    l1 = gen_new_label();

    sr = tcg_temp_new();

    tcg_gen_andi_i32(sr, cpu_sr, SR_T);

    tcg_gen_brcondi_i32(TCG_COND_NE, sr, 0, l1);

    gen_goto_tb(ctx, 0, ifnott);

    gen_set_label(l1);

    gen_goto_tb(ctx, 1, ift);

}
",0
Detect whether the following code contains vulnerabilities.,"static void adu_disconnect(struct usb_interface *interface)
{
	struct adu_device *dev;

	dev = usb_get_intfdata(interface);

	mutex_lock(&dev->mtx);	/* not interruptible */
	dev->udev = NULL;	/* poison */
	usb_deregister_dev(interface, &adu_class);
	mutex_unlock(&dev->mtx);

	mutex_lock(&adutux_mutex);
	usb_set_intfdata(interface, NULL);

	/* if the device is not opened, then we clean up right now */
	if (!dev->open_count)
		adu_delete(dev);

	mutex_unlock(&adutux_mutex);
}",1
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateFloatArray( double *numbers, int count )
{
	int i;
	cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
	for ( i = 0; a && i < count; ++i ) {
		n = cJSON_CreateFloat( numbers[i] );
		if ( ! i )
			a->child = n;
		else
			suffix_object( p, n );
		p = n;
	}
	return a;
}",1
Detect whether the following code contains vulnerabilities.,"e1000e_set_icr(E1000ECore *core, int index, uint32_t val)

{

    if ((core->mac[ICR] & E1000_ICR_ASSERTED) &&

        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_IAME)) {

        trace_e1000e_irq_icr_process_iame();

        e1000e_clear_ims_bits(core, core->mac[IAM]);

    }



    trace_e1000e_irq_icr_write(val, core->mac[ICR], core->mac[ICR] & ~val);

    core->mac[ICR] &= ~val;

    e1000e_update_interrupt_state(core);

}
",1
Detect whether the following code contains vulnerabilities.,"int qemu_eventfd(int *fds)

{

#if defined(SYS_eventfd)

    int ret;



    ret = syscall(SYS_eventfd, 0);

    if (ret >= 0) {

        fds[0] = fds[1] = ret;

        return 0;

    } else if (!(ret == -1 && errno == ENOSYS))

        return ret;

#endif



    return pipe(fds);

}
",1
Detect whether the following code contains vulnerabilities.,"void visit_start_struct(Visitor *v, const char *name, void **obj,

                        size_t size, Error **errp)

{

    Error *err = NULL;



    if (obj) {

        assert(size);

        assert(v->type != VISITOR_OUTPUT || *obj);

    }

    v->start_struct(v, name, obj, size, &err);

    if (obj && v->type == VISITOR_INPUT) {

        assert(!err != !*obj);

    }

    error_propagate(errp, err);

}
",1
Detect whether the following code contains vulnerabilities.,"void ConnectionHandlerImpl::ActiveTcpListener::onAccept(Network::ConnectionSocketPtr&& socket) {
  onAcceptWorker(std::move(socket), config_->handOffRestoredDestinationConnections(), false);
}",1
Detect whether the following code contains vulnerabilities.,"static void __kvm_ioapic_update_eoi(struct kvm_ioapic *ioapic, int vector,
				     int trigger_mode)
{
	int i;

	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];

		if (ent->fields.vector != vector)
			continue;

		/*
		 * We are dropping lock while calling ack notifiers because ack
		 * notifier callbacks for assigned devices call into IOAPIC
		 * recursively. Since remote_irr is cleared only after call
		 * to notifiers if the same vector will be delivered while lock
		 * is dropped it will be put into irr and will be delivered
		 * after ack notifier returns.
		 */
		spin_unlock(&ioapic->lock);
		kvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);
		spin_lock(&ioapic->lock);

		if (trigger_mode != IOAPIC_LEVEL_TRIG)
			continue;

		ASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);
		ent->fields.remote_irr = 0;
		if (!ent->fields.mask && (ioapic->irr & (1 << i)))
			ioapic_service(ioapic, i);
	}
}",0
Detect whether the following code contains vulnerabilities.,"	if(pThis->pInst != NULL) {
		pThis->pModule->mod.pm.freeParserInst(pThis->pInst);
	}",0
Detect whether the following code contains vulnerabilities.,"static void test_bmdma_long_prdt(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;

    uint8_t status;



    PrdtEntry prdt[] = {

        {

            .addr = 0,

            .size = cpu_to_le32(0x1000 | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* Normal request */

    status = send_dma_request(CMD_READ_DMA, 0, 1,

                              prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_ACTIVE | BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);



    /* Abort the request before it completes */

    status = send_dma_request(CMD_READ_DMA | CMDF_ABORT, 0, 1,

                              prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_bar, reg_status), DF | ERR);


}",1
Detect whether the following code contains vulnerabilities.,"rsRetVal rsCStrAppendStr(cstr_t *pThis, uchar* psz)
{
	return rsCStrAppendStrWithLen(pThis, psz, strlen((char*) psz));
}",0
Detect whether the following code contains vulnerabilities.,"void visit_type_uint16(Visitor *v, uint16_t *obj, const char *name, Error **errp)

{

    int64_t value;

    if (!error_is_set(errp)) {

        if (v->type_uint16) {

            v->type_uint16(v, obj, name, errp);

        } else {

            value = *obj;

            v->type_int(v, &value, name, errp);

            if (value < 0 || value > UINT16_MAX) {

                error_set(errp, QERR_INVALID_PARAMETER_VALUE, name ? name : ""null"",

                          ""uint16_t"");

                return;

            }

            *obj = value;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int bdrv_has_zero_init(BlockDriverState *bs)

{

    assert(bs->drv);



    if (bs->drv->no_zero_init) {

        return 0;

    } else if (bs->file) {

        return bdrv_has_zero_init(bs->file);

    }



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int fsmMkdir(const char *path, mode_t mode)
{
    int rc = mkdir(path, (mode & 07777));
    if (_fsm_debug)
	rpmlog(RPMLOG_DEBUG, "" %8s (%s, 0%04o) %s\n"", __func__,
	       path, (unsigned)(mode & 07777),
	       (rc < 0 ? strerror(errno) : """"));
    if (rc < 0)	rc = RPMERR_MKDIR_FAILED;
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"ga_append(garray_T *gap, int c)
{
    if (ga_grow(gap, 1) == OK)
    {
	*((char *)gap->ga_data + gap->ga_len) = c;
	++gap->ga_len;
    }
}",0
Detect whether the following code contains vulnerabilities.,"int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)

{

    int ret;

    AVStream *st;



    ff_read_frame_flush(s);



    if(flags & AVSEEK_FLAG_BYTE)

        return av_seek_frame_byte(s, stream_index, timestamp, flags);



    if(stream_index < 0){

        stream_index= av_find_default_stream_index(s);

        if(stream_index < 0)

            return -1;



        st= s->streams[stream_index];

       /* timestamp for default must be expressed in AV_TIME_BASE units */

        timestamp = av_rescale(timestamp, st->time_base.den, AV_TIME_BASE * (int64_t)st->time_base.num);

    }



    /* first, we try the format specific seek */

    if (s->iformat->read_seek)

        ret = s->iformat->read_seek(s, stream_index, timestamp, flags);

    else

        ret = -1;

    if (ret >= 0) {

        return 0;

    }



    if(s->iformat->read_timestamp)

        return av_seek_frame_binary(s, stream_index, timestamp, flags);

    else

        return av_seek_frame_generic(s, stream_index, timestamp, flags);

}
",1
Detect whether the following code contains vulnerabilities.,"static int virtio_blk_load_device(VirtIODevice *vdev, QEMUFile *f,

                                  int version_id)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);



    while (qemu_get_sbyte(f)) {

        VirtIOBlockReq *req = virtio_blk_alloc_request(s);

        qemu_get_buffer(f, (unsigned char *)req->elem,

                        sizeof(VirtQueueElement));

        req->next = s->rq;

        s->rq = req;



        virtqueue_map_sg(req->elem->in_sg, req->elem->in_addr,

            req->elem->in_num, 1);

        virtqueue_map_sg(req->elem->out_sg, req->elem->out_addr,

            req->elem->out_num, 0);

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"cmsBool CMSEXPORT cmsSaveProfileToMem(cmsHPROFILE hProfile, void *MemPtr, cmsUInt32Number* BytesNeeded)
{
    cmsBool rc;
    cmsIOHANDLER* io;
    cmsContext ContextID = cmsGetProfileContextID(hProfile);

    // Should we just calculate the needed space?
    if (MemPtr == NULL) {

           *BytesNeeded =  cmsSaveProfileToIOhandler(hProfile, NULL);
            return TRUE;
    }

    // That is a real write operation
    io =  cmsOpenIOhandlerFromMem(ContextID, MemPtr, *BytesNeeded, ""w"");
    if (io == NULL) return FALSE;

    rc = (cmsSaveProfileToIOhandler(hProfile, io) != 0);
    rc &= cmsCloseIOhandler(io);

    return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static int adb_kbd_poll(ADBDevice *d, uint8_t *obuf)

{

    KBDState *s = ADB_KEYBOARD(d);

    int keycode;

    int olen;



    olen = 0;

    if (s->count == 0) {

        return 0;

    }

    keycode = s->data[s->rptr];

    s->rptr++;

    if (s->rptr == sizeof(s->data)) {

        s->rptr = 0;

    }

    s->count--;

    /*

     * The power key is the only two byte value key, so it is a special case.

     * Since 0x7f is not a used keycode for ADB we overload it to indicate the

     * power button when we're storing keycodes in our internal buffer, and

     * expand it out to two bytes when we send to the guest.

     */

    if (keycode == 0x7f) {

        obuf[0] = 0x7f;

        obuf[1] = 0x7f;

        olen = 2;

    } else {

        obuf[0] = keycode;

        /* NOTE: the power key key-up is the two byte sequence 0xff 0xff;

         * otherwise we could in theory send a second keycode in the second

         * byte, but choose not to bother.

         */

        obuf[1] = 0xff;

        olen = 2;

    }



    return olen;

}
",1
Detect whether the following code contains vulnerabilities.,"static void intern_stack_overflow(void)
{
  caml_gc_message (0x04, ""Stack overflow in un-marshaling value\n"", 0);
  intern_free_stack();
  caml_raise_out_of_memory();
}",0
Detect whether the following code contains vulnerabilities.,"static int handler_a0(deark *c, lctx *d, i64 opcode, i64 data_pos, i64 *bytes_used)
{
	i64 kind;
	kind = de_getu16be(data_pos);
	de_dbg(c, ""comment kind: %d"", (int)kind);
	return 1;
}",0
Detect whether the following code contains vulnerabilities.,"int cpu_sparc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,

                              int mmu_idx, int is_softmmu)

{

    target_ulong virt_addr, vaddr;

    target_phys_addr_t paddr;

    int error_code = 0, prot, ret = 0, access_index;



    error_code = get_physical_address(env, &paddr, &prot, &access_index,

                                      address, rw, mmu_idx);

    if (error_code == 0) {

        virt_addr = address & TARGET_PAGE_MASK;

        vaddr = virt_addr + ((address & TARGET_PAGE_MASK) &

                             (TARGET_PAGE_SIZE - 1));

#ifdef DEBUG_MMU

        printf(""Translate at 0x%"" PRIx64 "" -> 0x%"" PRIx64 "", vaddr 0x%"" PRIx64

               ""\n"", address, paddr, vaddr);

#endif

        ret = tlb_set_page_exec(env, vaddr, paddr, prot, mmu_idx, is_softmmu);

        return ret;

    }

    // XXX

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"int mnt_context_finalize_umount(struct libmnt_context *cxt)
{
	int rc;

	assert(cxt);
	assert(cxt->fs);
	assert((cxt->flags & MNT_FL_PREPARED));
	assert((cxt->flags & MNT_FL_MOUNTFLAGS_MERGED));

	rc = mnt_context_prepare_update(cxt);
	if (!rc)
		rc = mnt_context_update_tabs(cxt);
	return rc;
}",0
Detect whether the following code contains vulnerabilities.,"int proxy_authentication(zval* this_ptr, smart_str* soap_headers TSRMLS_DC)
{
	zval **login, **password;

	if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_proxy_login"", sizeof(""_proxy_login""), (void **)&login) == SUCCESS) {
		unsigned char* buf;
		int len;
		smart_str auth = {0};

		smart_str_appendl(&auth, Z_STRVAL_PP(login), Z_STRLEN_PP(login));
		smart_str_appendc(&auth, ':');
		if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_proxy_password"", sizeof(""_proxy_password""), (void **)&password) == SUCCESS) {
			smart_str_appendl(&auth, Z_STRVAL_PP(password), Z_STRLEN_PP(password));
		}
		smart_str_0(&auth);
		buf = php_base64_encode((unsigned char*)auth.c, auth.len, &len);
		smart_str_append_const(soap_headers, ""Proxy-Authorization: Basic "");
		smart_str_appendl(soap_headers, (char*)buf, len);
		smart_str_append_const(soap_headers, ""\r\n"");
		efree(buf);
		smart_str_free(&auth);
		return 1;
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)
{
    // Update nExtraNonce
    static uint256 hashPrevBlock;
    if (hashPrevBlock != pblock->hashPrevBlock)
    {
        nExtraNonce = 0;
        hashPrevBlock = pblock->hashPrevBlock;
    }
    ++nExtraNonce;
    pblock->vtx[0].vin[0].scriptSig = (CScript() << pblock->nTime << CBigNum(nExtraNonce)) + COINBASE_FLAGS;
    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);

    pblock->hashMerkleRoot = pblock->BuildMerkleTree();
}",0
Detect whether the following code contains vulnerabilities.,"query_fs_type (GFile *file,
	       GCancellable *cancellable)
{
	GFileInfo *fsinfo;
	char *ret;

	ret = NULL;

	fsinfo = g_file_query_filesystem_info (file,
					       G_FILE_ATTRIBUTE_FILESYSTEM_TYPE,
					       cancellable,
					       NULL);
	if (fsinfo != NULL) {
		ret = g_strdup (g_file_info_get_attribute_string (fsinfo, G_FILE_ATTRIBUTE_FILESYSTEM_TYPE));
		g_object_unref (fsinfo);
	}

	if (ret == NULL) {
		/* ensure that we don't attempt to query
		 * the FS type for each file in a given
		 * directory, if it can't be queried. */
		ret = g_strdup ("""");
	}

	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"gs_grab_get_mouse (GSGrab    *grab,
                   GdkWindow *window,
                   GdkScreen *screen,
                   gboolean   hide_cursor)
{
        GdkGrabStatus status;
        GdkCursor    *cursor;

        g_return_val_if_fail (window != NULL, FALSE);
        g_return_val_if_fail (screen != NULL, FALSE);

        cursor = get_cursor ();

        gs_debug (""Grabbing mouse widget=%X"", (guint32) GDK_WINDOW_XID (window));
        status = gdk_pointer_grab (window, TRUE, 0, NULL,
                                   (hide_cursor ? cursor : NULL),
                                   GDK_CURRENT_TIME);

        if (status == GDK_GRAB_SUCCESS) {
                grab->priv->mouse_grab_window = window;
                grab->priv->mouse_grab_screen = screen;
                grab->priv->mouse_hide_cursor = hide_cursor;
        }

        gdk_cursor_unref (cursor);

        return status;
}",1
Detect whether the following code contains vulnerabilities.,"void addDbAdminAnyDbPrivileges(PrivilegeVector* privileges) {
    Privilege::addPrivilegeToPrivilegeVector(
        privileges, Privilege(ResourcePattern::forClusterResource(), ActionType::listDatabases));
    Privilege::addPrivilegeToPrivilegeVector(
        privileges, Privilege(ResourcePattern::forAnyNormalResource(), dbAdminRoleActions));
    ActionSet profileActions = readRoleActions;
    profileActions.addAction(ActionType::convertToCapped);
    profileActions.addAction(ActionType::createCollection);
    profileActions.addAction(ActionType::dropCollection);
    Privilege::addPrivilegeToPrivilegeVector(
        privileges,
        Privilege(ResourcePattern::forCollectionName(""system.profile""), profileActions));
}",1
Detect whether the following code contains vulnerabilities.,"    State()
        : remote_encode_complete_(false), remote_decode_complete_(false), local_complete_(false),
          has_1xx_headers_(false), created_filter_chain_(false), is_head_request_(false),
          is_grpc_request_(false), non_100_response_headers_encoded_(false),
          under_on_local_reply_(false), decoder_filter_chain_aborted_(false),
          encoder_filter_chain_aborted_(false), saw_downstream_reset_(false) {}",1
Detect whether the following code contains vulnerabilities.,"static void do_change_block(const char *device, const char *filename)

{

    BlockDriverState *bs;



    bs = bdrv_find(device);

    if (!bs) {

        term_printf(""device not found\n"");

        return;

    }

    if (eject_device(bs, 0) < 0)

        return;

    bdrv_open(bs, filename, 0);

    qemu_key_check(bs, filename);

}
",1
Detect whether the following code contains vulnerabilities.,"static PyObject *Log_writelines(LogObject *self, PyObject *args)
{
    PyObject *sequence = NULL;
    PyObject *iterator = NULL;
    PyObject *item = NULL;
    const char *msg = NULL;

    if (self->expired) {
        PyErr_SetString(PyExc_RuntimeError, ""log object has expired"");
        return NULL;
    }

    if (!PyArg_ParseTuple(args, ""O:writelines"", &sequence))
        return NULL;

    iterator = PyObject_GetIter(sequence);

    if (iterator == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        ""argument must be sequence of strings"");

        return NULL;
    }

    while ((item = PyIter_Next(iterator))) {
        PyObject *result = NULL;
        PyObject *args = NULL;

        args = PyTuple_Pack(1, item);

        result = Log_write(self, args);

        Py_DECREF(args);
        Py_DECREF(item);

        if (!result) {
            Py_DECREF(iterator);

            PyErr_SetString(PyExc_TypeError,
                            ""argument must be sequence of strings"");

            return NULL;
        }
    }

    Py_DECREF(iterator);

    Py_INCREF(Py_None);
    return Py_None;
}",0
Detect whether the following code contains vulnerabilities.,"static inline void iommu_prepare_isa(void)
{
	return;
}",0
Detect whether the following code contains vulnerabilities.,"acl_insert_proxy_user(ACL_PROXY_USER *new_value)
{
  DBUG_ENTER(""acl_insert_proxy_user"");
  mysql_mutex_assert_owner(&acl_cache->lock);
  (void) push_dynamic(&acl_proxy_users, (uchar *) new_value);
  my_qsort((uchar*) dynamic_element(&acl_proxy_users, 0, ACL_PROXY_USER *),
           acl_proxy_users.elements,
           sizeof(ACL_PROXY_USER), (qsort_cmp) acl_compare);
  DBUG_VOID_RETURN;
}",0
Detect whether the following code contains vulnerabilities.,"DEFUN (clear_ip_bgp_all_soft_in,
       clear_ip_bgp_all_soft_in_cmd,
       ""clear ip bgp * soft in"",
       CLEAR_STR
       IP_STR
       BGP_STR
       ""Clear all peers\n""
       ""Soft reconfig\n""
       ""Soft reconfig inbound update\n"")
{
  if (argc == 1)
    return bgp_clear_vty (vty, argv[0], AFI_IP, SAFI_UNICAST, clear_all,
                          BGP_CLEAR_SOFT_IN, NULL);

  return bgp_clear_vty (vty, NULL, AFI_IP, SAFI_UNICAST, clear_all,
			BGP_CLEAR_SOFT_IN, NULL);
}",0
Detect whether the following code contains vulnerabilities.,"static void spapr_drc_release(sPAPRDRConnector *drc)

{

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    drck->release(drc->dev);



    drc->awaiting_release = false;

    g_free(drc->fdt);

    drc->fdt = NULL;

    drc->fdt_start_offset = 0;

    object_property_del(OBJECT(drc), ""device"", &error_abort);

    drc->dev = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"long keyctl_update_key(key_serial_t id,
		       const void __user *_payload,
		       size_t plen)
{
	key_ref_t key_ref;
	void *payload;
	long ret;

	ret = -EINVAL;
	if (plen > PAGE_SIZE)
		goto error;

	/* pull the payload in if one was supplied */
	payload = NULL;
	if (_payload) {
		ret = -ENOMEM;
		payload = kmalloc(plen, GFP_KERNEL);
		if (!payload)
			goto error;

		ret = -EFAULT;
		if (copy_from_user(payload, _payload, plen) != 0)
			goto error2;
	}

	/* find the target key (which must be writable) */
	key_ref = lookup_user_key(id, 0, KEY_WRITE);
	if (IS_ERR(key_ref)) {
		ret = PTR_ERR(key_ref);
		goto error2;
	}

	/* update the key */
	ret = key_update(key_ref, payload, plen);

	key_ref_put(key_ref);
 error2:
	kfree(payload);
 error:
	return ret;

} /* end keyctl_update_key() */",0
Detect whether the following code contains vulnerabilities.,"int ffurl_register_protocol(URLProtocol *protocol)

{

    URLProtocol **p;

    p = &first_protocol;

    while (*p != NULL)

        p = &(*p)->next;

    *p             = protocol;

    protocol->next = NULL;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"ImageProvider::provideStreamData(int objid, int generation,
                                 Pipeline* pipeline)
{
    std::vector<PointerHolder<Pipeline> > to_delete;
    Pipeline* p = pipeline;

    if (filter == ""/DCTDecode"")
    {
        p = new Pl_DCT(
            ""image encoder"", pipeline,
            width, getHeight(), stripes[0].length(), j_color_space);
        to_delete.push_back(p);
    }
    else if (filter == ""/RunLengthDecode"")
    {
        p = new Pl_RunLength(
            ""image encoder"", pipeline, Pl_RunLength::a_encode);
        to_delete.push_back(p);
    }

    for (int i = 0; i < n_stripes; ++i)
    {
        for (int j = 0; j < width * stripe_height; ++j)
        {
            p->write(
                QUtil::unsigned_char_pointer(stripes[i].c_str()),
                stripes[i].length());
        }
    }
    p->finish();
}",1
Detect whether the following code contains vulnerabilities.,"static int wake_idle(int cpu, struct task_struct *p)
{
	cpumask_t tmp;
	struct sched_domain *sd;
	int i;

	/*
	 * If it is idle, then it is the best cpu to run this task.
	 *
	 * This cpu is also the best, if it has more than one task already.
	 * Siblings must be also busy(in most cases) as they didn't already
	 * pickup the extra load from this cpu and hence we need not check
	 * sibling runqueue info. This will avoid the checks and cache miss
	 * penalities associated with that.
	 */
	if (idle_cpu(cpu) || cpu_rq(cpu)->nr_running > 1)
		return cpu;

	for_each_domain(cpu, sd) {
		if ((sd->flags & SD_WAKE_IDLE)
		    || ((sd->flags & SD_WAKE_IDLE_FAR)
			&& !task_hot(p, task_rq(p)->clock, sd))) {
			cpus_and(tmp, sd->span, p->cpus_allowed);
			for_each_cpu_mask(i, tmp) {
				if (idle_cpu(i)) {
					if (i != task_cpu(p)) {
						schedstat_inc(p,
						       se.nr_wakeups_idle);
					}
					return i;
				}
			}
		} else {
			break;
		}
	}
	return cpu;
}",0
Detect whether the following code contains vulnerabilities.,"static ssize_t f2fs_sbi_show(struct f2fs_attr *a,
			struct f2fs_sb_info *sbi, char *buf)
{
	unsigned char *ptr = NULL;
	unsigned int *ui;

	ptr = __struct_ptr(sbi, a->struct_type);
	if (!ptr)
		return -EINVAL;

	ui = (unsigned int *)(ptr + a->offset);

	return snprintf(buf, PAGE_SIZE, ""%u\n"", *ui);
}",0
Detect whether the following code contains vulnerabilities.,"lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)
{
    const struct lys_node *snode = NULL, *siblings;

    if ((!parent && !module) || !name) {
        LOGARG;
        return NULL;
    }

    siblings = lyd_new_find_schema(parent, module, 1);
    if (!siblings) {
        LOGARG;
        return NULL;
    }

    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {
        LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."",
               name, lys_node_module(siblings)->name, siblings->name);
        return NULL;
    }

    return _lyd_new_leaf(parent, snode, val_str, 0, 0);
}",1
Detect whether the following code contains vulnerabilities.,"static inline int signed_shift(int i, int shift) {

    if (shift > 0)

        return i << shift;

    return i >> -shift;

}
",1
Detect whether the following code contains vulnerabilities.,"static void xendev_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->props = xendev_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);






}",1
Detect whether the following code contains vulnerabilities.,"bool cma_release(struct cma *cma, const struct page *pages, unsigned int count)
{
	unsigned long pfn;

	if (!cma || !pages)
		return false;

	pr_debug(""%s(page %p)\n"", __func__, (void *)pages);

	pfn = page_to_pfn(pages);

	if (pfn < cma->base_pfn || pfn >= cma->base_pfn + cma->count)
		return false;

	VM_BUG_ON(pfn + count > cma->base_pfn + cma->count);

	free_contig_range(pfn, count);
	cma_clear_bitmap(cma, pfn, count);
	trace_cma_release(pfn, pages, count);

	return true;
}",0
Detect whether the following code contains vulnerabilities.,"static void clear_sdr_rep(IPMIBmcSim *ibs,

                          uint8_t *cmd, unsigned int cmd_len,

                          uint8_t *rsp, unsigned int *rsp_len,

                          unsigned int max_rsp_len)

{

    IPMI_CHECK_CMD_LEN(8);

    IPMI_CHECK_RESERVATION(2, ibs->sdr.reservation);

    if (cmd[4] != 'C' || cmd[5] != 'L' || cmd[6] != 'R') {

        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;

        return;

    }

    if (cmd[7] == 0xaa) {

        ibs->sdr.next_free = 0;

        ibs->sdr.overflow = 0;

        set_timestamp(ibs, ibs->sdr.last_clear);

        IPMI_ADD_RSP_DATA(1); /* Erasure complete */

        sdr_inc_reservation(&ibs->sdr);

    } else if (cmd[7] == 0) {

        IPMI_ADD_RSP_DATA(1); /* Erasure complete */

    } else {

        rsp[2] = IPMI_CC_INVALID_DATA_FIELD;

        return;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void parse_version(std::string const& full_version_string,
                          std::string& version, int& extension_level)
{
    PointerHolder<char> vp(true, QUtil::copy_string(full_version_string));
    char* v = vp.getPointer();
    char* p1 = strchr(v, '.');
    char* p2 = (p1 ? strchr(1 + p1, '.') : 0);
    if (p2 && *(p2 + 1))
    {
        *p2++ = '\0';
        extension_level = atoi(p2);
    }
    version = v;
}",1
Detect whether the following code contains vulnerabilities.,"Pl_PNGFilter::encodeRow()
{
    // For now, hard-code to using UP filter.
    unsigned char ch = 2;
    getNext()->write(&ch, 1);
    if (this->prev_row)
    {
	for (unsigned int i = 0; i < this->bytes_per_row; ++i)
	{
	    ch = this->cur_row[i] - this->prev_row[i];
	    getNext()->write(&ch, 1);
	}
    }
    else
    {
	getNext()->write(this->cur_row, this->bytes_per_row);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void DMA_run (void)

{

    struct dma_cont *d;

    int icont, ichan;

    int rearm = 0;

    static int running = 0;



    if (running) {

        rearm = 1;

        goto out;

    } else {

        running = 1;

    }



    d = dma_controllers;



    for (icont = 0; icont < 2; icont++, d++) {

        for (ichan = 0; ichan < 4; ichan++) {

            int mask;



            mask = 1 << ichan;



            if ((0 == (d->mask & mask)) && (0 != (d->status & (mask << 4)))) {

                channel_run (icont, ichan);

                rearm = 1;

            }

        }

    }



    running = 0;

out:

    if (rearm)

        qemu_bh_schedule_idle(dma_bh);

}
",0
Detect whether the following code contains vulnerabilities.,"int avio_open2(AVIOContext **s, const char *filename, int flags,

               const AVIOInterruptCB *int_cb, AVDictionary **options)

{

    AVIOInternal *internal;

    const URLProtocol **protocols;

    URLContext *h;

    int err;



    protocols = ffurl_get_protocols(NULL, NULL);

    if (!protocols)

        return AVERROR(ENOMEM);



    err = ffurl_open(&h, filename, flags, int_cb, options, protocols);

    if (err < 0) {

        av_freep(&protocols);

        return err;

    }



    err = ffio_fdopen(s, h);

    if (err < 0) {

        ffurl_close(h);

        av_freep(&protocols);

        return err;

    }



    internal = (*s)->opaque;

    internal->protocols = protocols;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"ArgParser::argPreserveUnreferencedResources()
{
    o.preserve_unreferenced_page_resources = true;
}",0
Detect whether the following code contains vulnerabilities.,"static void iothread_instance_finalize(Object *obj)

{

    IOThread *iothread = IOTHREAD(obj);



    iothread_stop(obj, NULL);

    qemu_cond_destroy(&iothread->init_done_cond);

    qemu_mutex_destroy(&iothread->init_done_lock);




    aio_context_unref(iothread->ctx);
",1
Detect whether the following code contains vulnerabilities.,"ConnectionImpl::StreamImpl::StreamImpl(ConnectionImpl& parent, uint32_t buffer_limit)
    : parent_(parent), local_end_stream_sent_(false), remote_end_stream_(false),
      data_deferred_(false), waiting_for_non_informational_headers_(false),
      pending_receive_buffer_high_watermark_called_(false),
      pending_send_buffer_high_watermark_called_(false), reset_due_to_messaging_error_(false) {
  if (buffer_limit > 0) {
    setWriteBufferWatermarks(buffer_limit / 2, buffer_limit);
  }
}",1
Detect whether the following code contains vulnerabilities.,"static uint8_t ide_wait_clear(uint8_t flag)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;

    uint8_t data;

    time_t st;



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* Wait with a 5 second timeout */

    time(&st);

    while (true) {

        data = qpci_io_readb(dev, ide_bar, reg_status);

        if (!(data & flag)) {


            return data;

        }

        if (difftime(time(NULL), st) > 5.0) {

            break;

        }

        nsleep(400);

    }

    g_assert_not_reached();

}",1
Detect whether the following code contains vulnerabilities.,"static int proxy_fstat(FsContext *fs_ctx, int fid_type,

                       V9fsFidOpenState *fs, struct stat *stbuf)

{

    int fd;



    if (fid_type == P9_FID_DIR) {

        fd = dirfd(fs->dir);

    } else {

        fd = fs->fd;

    }

    return fstat(fd, stbuf);

}
",0
Detect whether the following code contains vulnerabilities.,"gdk_pixbuf__gif_image_load (FILE *file, GError **error)
{
	GifContext *context;
	GdkPixbuf *pixbuf;

	g_return_val_if_fail (file != NULL, NULL);

	context = new_context ();
	context->file = file;
        context->error = error;
        
	if (gif_main_loop (context) == -1 || context->animation->frames == NULL) {
                if (context->error && *(context->error) == NULL)
                        g_set_error (context->error,
                                     GDK_PIXBUF_ERROR,
                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
                                     _(""GIF file was missing some data (perhaps it was truncated somehow?)""));
        }
        
        pixbuf = gdk_pixbuf_animation_get_static_image (GDK_PIXBUF_ANIMATION (context->animation));

        if (pixbuf)
                g_object_ref (G_OBJECT (pixbuf));

        g_object_unref (G_OBJECT (context->animation));
        
        g_free (context->buf);
	g_free (context);
 
	return pixbuf;
}",1
Detect whether the following code contains vulnerabilities.,"static int ssl_rsa_decrypt( void *ctx, int mode, size_t *olen,
                        const unsigned char *input, unsigned char *output,
                        size_t output_max_len )
{
    return rsa_pkcs1_decrypt( (rsa_context *) ctx, mode, olen, input, output,
                              output_max_len );
}",1
Detect whether the following code contains vulnerabilities.,"void ip_mc_destroy_dev(struct in_device *in_dev)
{
	struct ip_mc_list *i;

	ASSERT_RTNL();

	/* Deactivate timers */
	ip_mc_down(in_dev);
#ifdef CONFIG_IP_MULTICAST
	igmpv3_clear_delrec(in_dev);
#endif

	while ((i = rtnl_dereference(in_dev->mc_list)) != NULL) {
		in_dev->mc_list = i->next_rcu;
		in_dev->mc_count--;
		ip_mc_clear_src(i);
		ip_ma_put(i);
	}
}",0
Detect whether the following code contains vulnerabilities.,"int monitor_set_cpu(int cpu_index)

{

    CPUState *cpu;



    cpu = qemu_get_cpu(cpu_index);

    if (cpu == NULL) {

        return -1;

    }

    cur_mon->mon_cpu = cpu;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"ipv6_sanity_check(const struct ovs_16aligned_ip6_hdr *nh, size_t size)
{
    uint16_t plen;

    if (OVS_UNLIKELY(size < sizeof *nh)) {
        return false;
    }

    plen = ntohs(nh->ip6_plen);
    if (OVS_UNLIKELY(plen + IPV6_HEADER_LEN > size)) {
        return false;
    }
    /* Jumbo Payload option not supported yet. */
    if (OVS_UNLIKELY(size - (plen + IPV6_HEADER_LEN) > UINT8_MAX)) {
        return false;
    }

    return true;
}",1
Detect whether the following code contains vulnerabilities.,"static int pix_norm1_altivec(uint8_t *pix, int line_size)

{

    int i, s = 0;

    const vector unsigned int zero =

        (const vector unsigned int) vec_splat_u32(0);

    vector unsigned int sv = (vector unsigned int) vec_splat_u32(0);

    vector signed int sum;



    for (i = 0; i < 16; i++) {

        /* Read the potentially unaligned pixels. */

        //vector unsigned char pixl = vec_ld(0,  pix);

        //vector unsigned char pixr = vec_ld(15, pix);

        //vector unsigned char pixv = vec_perm(pixl, pixr, perm);

        vector unsigned char pixv = vec_vsx_ld(0,  pix);



        /* Square the values, and add them to our sum. */

        sv = vec_msum(pixv, pixv, sv);



        pix += line_size;

    }

    /* Sum up the four partial sums, and put the result into s. */

    sum = vec_sums((vector signed int) sv, (vector signed int) zero);

    sum = vec_splat(sum, 3);

    vec_vsx_st(sum, 0, &s);

    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"  int save_in_field(Field *field, bool no_conversions)
  {
    return ref->save_in_field(field, no_conversions);
  }",0
Detect whether the following code contains vulnerabilities.,"static void evaluate_utility_inc(elbg_data *elbg)

{

    int i, inc=0;



    for (i=0; i < elbg->numCB; i++) {

        if (elbg->numCB*elbg->utility[i] > elbg->error)

            inc += elbg->utility[i];

        elbg->utility_inc[i] = inc;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"perf_event_groups_delete(struct perf_event_groups *groups,
			 struct perf_event *event)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&event->group_node) ||
		     RB_EMPTY_ROOT(&groups->tree));

	rb_erase(&event->group_node, &groups->tree);
	init_event_group(event);
}",0
Detect whether the following code contains vulnerabilities.,"const char* ExpressionRange::getOpName() const {
    return ""$range"";
}",0
Detect whether the following code contains vulnerabilities.,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->dinfo->bdrv;

    s->conf = conf;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    register_savevm(""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);



    return &s->vdev;

}
",0
Detect whether the following code contains vulnerabilities.,"zzip_mem_disk_open(char* filename)
{
    ZZIP_DISK* disk = zzip_disk_open(filename);
    if (! disk) { perror(error[_zzip_mem_disk_open_fail]); return 0; }
    ___ ZZIP_MEM_DISK* dir = calloc(1, sizeof(*dir)); 
    zzip_mem_disk_load(dir, disk);
    return dir; ____;
}",1
Detect whether the following code contains vulnerabilities.,"inline void Http2Stream::EmitStatistics() {
  if (!HasHttp2Observer(env()))
    return;
  Http2StreamPerformanceEntry* entry =
    new Http2StreamPerformanceEntry(env(), statistics_);
  env()->SetImmediate([](Environment* env, void* data) {
    Local<Context> context = env->context();
    Http2StreamPerformanceEntry* entry =
      static_cast<Http2StreamPerformanceEntry*>(data);
    if (HasHttp2Observer(env)) {
      Local<Object> obj = entry->ToObject();
      v8::PropertyAttribute attr =
          static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);
      obj->DefineOwnProperty(
          context,
          FIXED_ONE_BYTE_STRING(env->isolate(), ""timeToFirstByte""),
          Number::New(env->isolate(),
                      (entry->first_byte() - entry->startTimeNano()) / 1e6),
          attr);
      obj->DefineOwnProperty(
          context,
          FIXED_ONE_BYTE_STRING(env->isolate(), ""timeToFirstHeader""),
          Number::New(env->isolate(),
                      (entry->first_header() - entry->startTimeNano()) / 1e6),
          attr);
      entry->Notify(obj);
    }
    delete entry;
  }, static_cast<void*>(entry));
}",0
Detect whether the following code contains vulnerabilities.,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h, int intra ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 || !intra ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int socket_get_fd(void *opaque)

{

    QEMUFileSocket *s = opaque;



    return s->fd;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pnv_chip_power9_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PnvChipClass *k = PNV_CHIP_CLASS(klass);



    k->cpu_model = ""POWER9"";

    k->chip_type = PNV_CHIP_POWER9;

    k->chip_cfam_id = 0x100d104980000000ull; /* P9 Nimbus DD1.0 */

    k->cores_mask = POWER9_CORE_MASK;

    k->core_pir = pnv_chip_core_pir_p9;


    dc->desc = ""PowerNV Chip POWER9"";

}",1
Detect whether the following code contains vulnerabilities.,"static void prb_close_block(struct tpacket_kbdq_core *pkc1,
		struct tpacket_block_desc *pbd1,
		struct packet_sock *po, unsigned int stat)
{
	__u32 status = TP_STATUS_USER | stat;

	struct tpacket3_hdr *last_pkt;
	struct tpacket_hdr_v1 *h1 = &pbd1->hdr.bh1;

	if (po->stats.stats3.tp_drops)
		status |= TP_STATUS_LOSING;

	last_pkt = (struct tpacket3_hdr *)pkc1->prev;
	last_pkt->tp_next_offset = 0;

	/* Get the ts of the last pkt */
	if (BLOCK_NUM_PKTS(pbd1)) {
		h1->ts_last_pkt.ts_sec = last_pkt->tp_sec;
		h1->ts_last_pkt.ts_nsec	= last_pkt->tp_nsec;
	} else {
		/* Ok, we tmo'd - so get the current time */
		struct timespec ts;
		getnstimeofday(&ts);
		h1->ts_last_pkt.ts_sec = ts.tv_sec;
		h1->ts_last_pkt.ts_nsec	= ts.tv_nsec;
	}

	smp_wmb();

	/* Flush the block */
	prb_flush_block(pkc1, pbd1, status);

	pkc1->kactive_blk_num = GET_NEXT_PRB_BLK_NUM(pkc1);
}",0
Detect whether the following code contains vulnerabilities.,"fill_threshhold_buffer(byte *dest_strip, byte *src_strip, int src_width,
                       int left_offset, int left_width, int num_tiles,
                       int right_width)
{
    byte *ptr_out_temp = dest_strip;
    int ii;

    /* Left part */
    memcpy(dest_strip, src_strip + left_offset, left_width);
    ptr_out_temp += left_width;
    /* Now the full parts */
    for (ii = 0; ii < num_tiles; ii++){
        memcpy(ptr_out_temp, src_strip, src_width);
        ptr_out_temp += src_width;
    }
    /* Now the remainder */
    memcpy(ptr_out_temp, src_strip, right_width);
#ifdef PACIFY_VALGRIND
    ptr_out_temp += right_width;
    ii = (dest_strip-ptr_out_temp) % (LAND_BITS-1);
    if (ii > 0)
        memset(ptr_out_temp, 0, ii);
#endif
}",1
Detect whether the following code contains vulnerabilities.,"struct key *key_get_instantiation_authkey(key_serial_t target_id)
{
	char description[16];
	struct keyring_search_context ctx = {
		.index_key.type		= &key_type_request_key_auth,
		.index_key.description	= description,
		.cred			= current_cred(),
		.match_data.cmp		= user_match,
		.match_data.raw_data	= description,
		.match_data.lookup_type	= KEYRING_SEARCH_LOOKUP_DIRECT,
	};
	struct key *authkey;
	key_ref_t authkey_ref;

	sprintf(description, ""%x"", target_id);

	authkey_ref = search_process_keyrings(&ctx);

	if (IS_ERR(authkey_ref)) {
		authkey = ERR_CAST(authkey_ref);
		if (authkey == ERR_PTR(-EAGAIN))
			authkey = ERR_PTR(-ENOKEY);
		goto error;
	}

	authkey = key_ref_to_ptr(authkey_ref);
	if (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {
		key_put(authkey);
		authkey = ERR_PTR(-EKEYREVOKED);
	}

error:
	return authkey;
}",1
Detect whether the following code contains vulnerabilities.,"static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,
		struct page *page)
{
}",0
Detect whether the following code contains vulnerabilities.,"static int gif_read_header(AVFormatContext * s1,

                           AVFormatParameters * ap)

{

    GifState *s = s1->priv_data;

    ByteIOContext *f = s1->pb;

    AVStream *st;



    s->f = f;

    if (gif_read_header1(s) < 0)

        return -1;



    /* allocate image buffer */

    s->image_linesize = s->screen_width * 3;

    s->image_buf = av_malloc(s->screen_height * s->image_linesize);

    if (!s->image_buf)

        return AVERROR(ENOMEM);

    s->pix_fmt = PIX_FMT_RGB24;

    /* now we are ready: build format streams */

    st = av_new_stream(s1, 0);

    if (!st)

        return -1;



    st->codec->codec_type = CODEC_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_RAWVIDEO;

    st->codec->time_base.den = 5;

    st->codec->time_base.num = 1;

    /* XXX: check if screen size is always valid */

    st->codec->width = s->screen_width;

    st->codec->height = s->screen_height;

    st->codec->pix_fmt = PIX_FMT_RGB24;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"PPC_OP(addme)

{

    T1 = T0;

    T0 += xer_ca + (-1);

    if (T1 != 0)

        xer_ca = 1;

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"int get_physical_address(CPUState * env, target_ulong * physical,

			 int *prot, target_ulong address,

			 int rw, int access_type)

{

    /* P1, P2 and P4 areas do not use translation */

    if ((address >= 0x80000000 && address < 0xc0000000) ||

	address >= 0xe0000000) {

	if (!(env->sr & SR_MD)

	    && (address < 0xe0000000 || address > 0xe4000000)) {

	    /* Unauthorized access in user mode (only store queues are available) */

	    fprintf(stderr, ""Unauthorized access\n"");

	    return (rw & PAGE_WRITE) ? MMU_DTLB_MISS_WRITE :

		MMU_DTLB_MISS_READ;

	}

	/* Mask upper 3 bits */

	*physical = address & 0x1FFFFFFF;

	*prot = PAGE_READ | PAGE_WRITE;

	return MMU_OK;

    }



    /* If MMU is disabled, return the corresponding physical page */

    if (!env->mmucr & MMUCR_AT) {

	*physical = address & 0x1FFFFFFF;

	*prot = PAGE_READ | PAGE_WRITE;

	return MMU_OK;

    }



    /* We need to resort to the MMU */

    return get_mmu_address(env, physical, prot, address, rw, access_type);

}
",0
Detect whether the following code contains vulnerabilities.,"horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)
{
	tmsize_t stride = PredictorState(tif)->stride;
	uint32* wp = (uint32*) cp0;
	tmsize_t wc = cc / 4;

	assert((cc%(4*stride))==0);

	if (wc > stride) {
		wc -= stride;
		do {
			REPEAT4(stride, wp[stride] += wp[0]; wp++)
			wc -= stride;
		} while (wc > 0);
	}
}",1
Detect whether the following code contains vulnerabilities.,"int qemu_file_get_error(QEMUFile *f)

{

    return f->last_error;

}
",1
Detect whether the following code contains vulnerabilities.,"static void check_exception(sPAPREnvironment *spapr,

                            uint32_t token, uint32_t nargs,

                            target_ulong args,

                            uint32_t nret, target_ulong rets)

{

    uint32_t mask, buf, len;

    uint64_t xinfo;



    if ((nargs < 6) || (nargs > 7) || nret != 1) {

        rtas_st(rets, 0, -3);

        return;

    }



    xinfo = rtas_ld(args, 1);

    mask = rtas_ld(args, 2);

    buf = rtas_ld(args, 4);

    len = rtas_ld(args, 5);

    if (nargs == 7) {

        xinfo |= (uint64_t)rtas_ld(args, 6) << 32;

    }



    if ((mask & EVENT_MASK_EPOW) && pending_epow) {

        if (sizeof(*pending_epow) < len) {

            len = sizeof(*pending_epow);

        }



        cpu_physical_memory_write(buf, pending_epow, len);

        g_free(pending_epow);

        pending_epow = NULL;

        rtas_st(rets, 0, 0);

    } else {

        rtas_st(rets, 0, 1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void parse_rtcp_bye(pjmedia_rtcp_session *sess,
			   const void *pkt,
			   pj_size_t size)
{
    pj_str_t reason = {""-"", 1};

    /* Check and get BYE reason */
    if (size > 8) {
	reason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),
                             *((pj_uint8_t*)pkt+8));
	pj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),
		  reason.slen);
	reason.ptr = sess->stat.peer_sdes_buf_;
    }

    /* Just print RTCP BYE log */
    PJ_LOG(5, (sess->name, ""Received RTCP BYE, reason: %.*s"",
	       reason.slen, reason.ptr));
}",1
Detect whether the following code contains vulnerabilities.,"static void t1_check_unusual_charstring(void)
{
    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);
    int i;
    /* if no number follows ""/CharStrings"", let's read the next line */
    if (sscanf(p, ""%i"", &i) != 1) {
        /* pdftex_warn(""no number found after `%s', I assume it's on the next line"",
                    charstringname); */
        strcpy(t1_buf_array, t1_line_array);

        /* t1_getline always appends EOL to t1_line_array; let's change it to
         * space before appending the next line
         */
        *(strend(t1_buf_array) - 1) = ' ';

        t1_getline();
        strcat(t1_buf_array, t1_line_array);
        strcpy(t1_line_array, t1_buf_array);
        t1_line_ptr = eol(t1_line_array);
    }
}",1
Detect whether the following code contains vulnerabilities.,"void ide_dma_cancel(BMDMAState *bm)

{

    if (bm->status & BM_STATUS_DMAING) {

        bm->status &= ~BM_STATUS_DMAING;

        /* cancel DMA request */

        bm->unit = -1;

        bm->dma_cb = NULL;

        if (bm->aiocb) {

#ifdef DEBUG_AIO

            printf(""aio_cancel\n"");

#endif

            bdrv_aio_cancel(bm->aiocb);

            bm->aiocb = NULL;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static struct wildmat *split_wildmats(char *str)
{
    const char *prefix;
    char pattern[MAX_MAILBOX_BUFFER] = """", *p, *c;
    struct wildmat *wild = NULL;
    int n = 0;

    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))
	snprintf(pattern, sizeof(pattern), ""%s."", prefix);
    p = pattern + strlen(pattern);

    /*
     * split the list of wildmats
     *
     * we split them right to left because this is the order in which
     * we want to test them (per RFC3977 section 4.2)
     */
    do {
	if ((c = strrchr(str, ',')))
	    *c++ = '\0';
	else
	    c = str;

	if (!(n % 10)) /* alloc some more */
	    wild = xrealloc(wild, (n + 11) * sizeof(struct wildmat));

	if (*c == '!') wild[n].not = 1;		/* not */
	else if (*c == '@') wild[n].not = -1;	/* absolute not (feeding) */
	else wild[n].not = 0;

	strcpy(p, wild[n].not ? c + 1 : c);
	wild[n++].pat = xstrdup(pattern);
    } while (c != str);
    wild[n].pat = NULL;

    return wild;
}",1
Detect whether the following code contains vulnerabilities.,"static void kvmclock_reset(struct kvm_vcpu *vcpu)
{
	if (vcpu->arch.time_page) {
		kvm_release_page_dirty(vcpu->arch.time_page);
		vcpu->arch.time_page = NULL;
	}
}",1
Detect whether the following code contains vulnerabilities.,"struct GuestAgentInfo *qmp_guest_info(Error **errp)

{

    GuestAgentInfo *info = g_malloc0(sizeof(GuestAgentInfo));



    info->version = g_strdup(QEMU_VERSION);

    qmp_for_each_command(qmp_command_info, info);

    return info;

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_mul(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_ov = tcg_temp_new();

    TCGv t0 = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_ov, srca, srcb);

    tcg_gen_sari_tl(t0, dest, TARGET_LONG_BITS - 1);

    tcg_gen_setcond_tl(TCG_COND_NE, sr_ov, sr_ov, t0);

    tcg_temp_free(t0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_ov, ctz32(SR_OV), 1);



    gen_ove_ov(dc, sr_ov);

    tcg_temp_free(sr_ov);

}
",1
Detect whether the following code contains vulnerabilities.,"void acpi_pm1_cnt_init(ACPIREGS *ar, qemu_irq cmos_s3)

{

    ar->pm1.cnt.cmos_s3 = cmos_s3;

}
",0
Detect whether the following code contains vulnerabilities.,"eap_state_name(esc)
enum eap_state_code esc;
{
	static const char *state_names[] = { EAP_STATES };

	return (state_names[(int)esc]);
}",0
Detect whether the following code contains vulnerabilities.,"static void seg_free_context(SegmentContext *seg)

{

    avio_closep(&seg->pb);

    avformat_free_context(seg->avf);

    seg->avf = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static void usb_msd_send_status(MSDState *s, USBPacket *p)

{

    struct usb_msd_csw csw;

    int len;



    csw.sig = cpu_to_le32(0x53425355);

    csw.tag = cpu_to_le32(s->tag);

    csw.residue = s->residue;

    csw.status = s->result;



    len = MIN(sizeof(csw), p->len);

    memcpy(p->data, &csw, len);

}
",1
Detect whether the following code contains vulnerabilities.,"void cgroup_file_notify(struct cgroup_file *cfile)
{
	unsigned long flags;

	spin_lock_irqsave(&cgroup_file_kn_lock, flags);
	if (cfile->kn) {
		unsigned long last = cfile->notified_at;
		unsigned long next = last + CGROUP_FILE_NOTIFY_MIN_INTV;

		if (time_in_range(jiffies, last, next)) {
			timer_reduce(&cfile->notify_timer, next);
		} else {
			kernfs_notify(cfile->kn);
			cfile->notified_at = jiffies;
		}
	}
	spin_unlock_irqrestore(&cgroup_file_kn_lock, flags);
}",0
Detect whether the following code contains vulnerabilities.,"static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,
				    const struct bpf_insn *insn)
{
	return env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;
}",0
Detect whether the following code contains vulnerabilities.,"dnExtractRdn( 
	struct berval	*dn, 
	struct berval 	*rdn,
	void *ctx )
{
	LDAPRDN		tmpRDN;
	const char	*p;
	int		rc;

	assert( dn != NULL );
	assert( rdn != NULL );

	if( dn->bv_len == 0 ) {
		return LDAP_OTHER;
	}

	rc = ldap_bv2rdn_x( dn, &tmpRDN, (char **)&p, LDAP_DN_FORMAT_LDAP, ctx );
	if ( rc != LDAP_SUCCESS ) {
		return rc;
	}

	rc = ldap_rdn2bv_x( tmpRDN, rdn, LDAP_DN_FORMAT_LDAPV3 | LDAP_DN_PRETTY,
		ctx );

	ldap_rdnfree_x( tmpRDN, ctx );
	return rc;
}",0
Detect whether the following code contains vulnerabilities.,"static void flac_lpc_16_c(int32_t *decoded, const int coeffs[32],

                          int pred_order, int qlevel, int len)

{

    int i, j;



    for (i = pred_order; i < len - 1; i += 2, decoded += 2) {

        int c = coeffs[0];

        int d = decoded[0];

        int s0 = 0, s1 = 0;

        for (j = 1; j < pred_order; j++) {

            s0 += c*d;

            d = decoded[j];

            s1 += c*d;

            c = coeffs[j];

        }

        s0 += c*d;

        d = decoded[j] += s0 >> qlevel;

        s1 += c*d;

        decoded[j + 1] += s1 >> qlevel;

    }

    if (i < len) {

        int sum = 0;

        for (j = 0; j < pred_order; j++)

            sum += coeffs[j] * decoded[j];

        decoded[j] += sum >> qlevel;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void HELPER(wsr_lend)(uint32_t v)

{

    if (env->sregs[LEND] != v) {

        tb_invalidate_phys_page_range(

                env->sregs[LEND] - 1, env->sregs[LEND], 0);

        env->sregs[LEND] = v;

        tb_invalidate_phys_page_range(

                env->sregs[LEND] - 1, env->sregs[LEND], 0);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_fcmps(int fccno, TCGv r_rs1, TCGv r_rs2)

{

    gen_helper_fcmps(cpu_env, r_rs1, r_rs2);

}
",0
Detect whether the following code contains vulnerabilities.,"sf_open	(const char *path, int mode, SF_INFO *sfinfo)
{	SF_PRIVATE 	*psf ;

	/* Ultimate sanity check. */
	assert (sizeof (sf_count_t) == 8) ;

	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;

	psf_init_files (psf) ;

	psf_log_printf (psf, ""File : %s\n"", path) ;

	if (copy_filename (psf, path) != 0)
	{	sf_errno = psf->error ;
		return	NULL ;
		} ;

	psf->file.mode = mode ;
	if (strcmp (path, ""-"") == 0)
		psf->error = psf_set_stdio (psf) ;
	else
		psf->error = psf_fopen (psf) ;

	return psf_open_file (psf, sfinfo) ;
} /* sf_open */",1
Detect whether the following code contains vulnerabilities.,"static int xv_write_trailer(AVFormatContext *s)

{

    XVContext *xv = s->priv_data;



    XShmDetach(xv->display, &xv->yuv_shminfo);

    shmdt(xv->yuv_image->data);

    XFree(xv->yuv_image);


    XCloseDisplay(xv->display);

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode error;

  error = Curl_base64_encode(conn->data,
                             (const char*)neg_ctx->output_token,
                             neg_ctx->output_token_length,
                             &encoded, &len);
  if(error)
    return error;

  if(len == 0)
    return CURLE_REMOTE_ACCESS_DENIED;

  userp = aprintf(""%sAuthorization: %s %s\r\n"", proxy ? ""Proxy-"" : """",
                  neg_ctx->protocol, encoded);

  if(proxy)
    conn->allocptr.proxyuserpwd = userp;
  else
    conn->allocptr.userpwd = userp;
  free(encoded);
  Curl_cleanup_negotiate (conn->data);
  return (userp == NULL) ? CURLE_OUT_OF_MEMORY : CURLE_OK;
}",1
Detect whether the following code contains vulnerabilities.,"wchar_t* gf_utf8_to_wcs(const char* str)
{
	size_t source_len;
	wchar_t* result;
	if (str == 0) return 0;
	source_len = strlen(str);
	result = gf_calloc(source_len + 1, sizeof(wchar_t));
	if (!result)
		return 0;
	if (gf_utf8_mbstowcs(result, source_len, &str) == GF_UTF8_FAIL) {
		gf_free(result);
		return 0;
	}
	return result;
}",0
Detect whether the following code contains vulnerabilities.,"encode_METER(const struct ofpact_meter *meter,
             enum ofp_version ofp_version, struct ofpbuf *out)
{
    if (ofp_version == OFP13_VERSION || ofp_version == OFP14_VERSION) {
        instruction_put_OFPIT13_METER(out)->meter_id = htonl(meter->meter_id);
    } else if (ofp_version >= OFP15_VERSION) {
        put_OFPAT15_METER(out, meter->meter_id);
    }
}",0
Detect whether the following code contains vulnerabilities.,"bool migrate_zero_blocks(void)

{

    MigrationState *s;



    s = migrate_get_current();



    return s->enabled_capabilities[MIGRATION_CAPABILITY_ZERO_BLOCKS];

}
",1
Detect whether the following code contains vulnerabilities.,"static int vp8dx_decode_bool(BOOL_DECODER *br, int probability) {
  unsigned int bit = 0;
  VP8_BD_VALUE value;
  unsigned int split;
  VP8_BD_VALUE bigsplit;
  int count;
  unsigned int range;

  split = 1 + (((br->range - 1) * probability) >> 8);

  if (br->count < 0) vp8dx_bool_decoder_fill(br);

  value = br->value;
  count = br->count;

  bigsplit = (VP8_BD_VALUE)split << (VP8_BD_VALUE_SIZE - 8);

  range = split;

  if (value >= bigsplit) {
    range = br->range - split;
    value = value - bigsplit;
    bit = 1;
  }

  {
    const int shift = vp8_norm[range];
    range <<= shift;
    value <<= shift;
    count -= shift;
  }
  br->value = value;
  br->count = count;
  br->range = range;

  return bit;
}",1
Detect whether the following code contains vulnerabilities.,"void Field_timef::store_TIME(const MYSQL_TIME *ltime)
{
  longlong tmp= TIME_to_longlong_time_packed(ltime);
  my_time_packed_to_binary(tmp, ptr, dec);
}",0
Detect whether the following code contains vulnerabilities.,"static void handle_ti(ESPState *s)
{
    uint32_t dmalen, minlen;

    if (s->dma && !s->dma_enabled) {
        s->dma_cb = handle_ti;
        return;
    }

    dmalen = s->rregs[ESP_TCLO];
    dmalen |= s->rregs[ESP_TCMID] << 8;
    dmalen |= s->rregs[ESP_TCHI] << 16;
    if (dmalen==0) {
      dmalen=0x10000;
    }
    s->dma_counter = dmalen;

    if (s->do_cmd)
        minlen = (dmalen < 32) ? dmalen : 32;
    else if (s->ti_size < 0)
        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;
    else
        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;
    trace_esp_handle_ti(minlen);
    if (s->dma) {
        s->dma_left = minlen;
        s->rregs[ESP_RSTAT] &= ~STAT_TC;
        esp_do_dma(s);
    }
    if (s->do_cmd) {
        trace_esp_handle_ti_cmd(s->cmdlen);
        s->ti_size = 0;
        s->cmdlen = 0;
        s->do_cmd = 0;
        do_cmd(s, s->cmdbuf);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static gsize calc_float_string_storage(double value)

{

    int whole_value = value;

    gsize i = 0;

    do {

        i++;

    } while (whole_value /= 10);

    return i + 2 + FLOAT_STRING_PRECISION;

}
",1
Detect whether the following code contains vulnerabilities.,"HeaderMapImpl::HeaderEntryImpl& HeaderMapImpl::maybeCreateInline(HeaderEntryImpl** entry,
                                                                 const LowerCaseString& key,
                                                                 HeaderString&& value) {
  if (*entry) {
    value.clear();
    return **entry;
  }

  std::list<HeaderEntryImpl>::iterator i = headers_.insert(key, std::move(value));
  i->entry_ = i;
  *entry = &(*i);
  return **entry;
}",1
Detect whether the following code contains vulnerabilities.,"bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *blk,
                                  VirtIOBlockDataPlane **dataplane)
{
    VirtIOBlockDataPlane *s;
    int fd;
    *dataplane = NULL;
    if (!blk->data_plane) {
        return true;
    if (blk->scsi) {
        error_report(""device is incompatible with x-data-plane, use scsi=off"");
    if (blk->config_wce) {
        error_report(""device is incompatible with x-data-plane, ""
                     ""use config-wce=off"");
    fd = raw_get_aio_fd(blk->conf.bs);
    if (fd < 0) {
        error_report(""drive is incompatible with x-data-plane, ""
                     ""use format=raw,cache=none,aio=native"");
    s = g_new0(VirtIOBlockDataPlane, 1);
    s->vdev = vdev;
    s->fd = fd;
    s->blk = blk;
    /* Prevent block operations that conflict with data plane thread */
    bdrv_set_in_use(blk->conf.bs, 1);
    *dataplane = s;
    return true;",1
Detect whether the following code contains vulnerabilities.,"static void mkv_free(MatroskaMuxContext *mkv) {


















    if (mkv->main_seekhead) {

        av_freep(&mkv->main_seekhead->entries);

        av_freep(&mkv->main_seekhead);


    if (mkv->cues) {

        av_freep(&mkv->cues->entries);

        av_freep(&mkv->cues);


    if (mkv->attachments) {

        av_freep(&mkv->attachments->entries);

        av_freep(&mkv->attachments);


    av_freep(&mkv->tracks);

    av_freep(&mkv->stream_durations);

    av_freep(&mkv->stream_duration_offsets);
",1
Detect whether the following code contains vulnerabilities.,"  virtual Type type() const
  {
    return TABLE_ARENA;
  }",1
Detect whether the following code contains vulnerabilities.,"void CLASS unpacked_load_raw()
{
  int row, col, bits = 0;
  while (1 << ++bits < maximum)
    ;
  read_shorts(raw_image, raw_width * raw_height);
  if (maximum < 0xffff)
    for (row = 0; row < raw_height; row++)
    {
#ifdef LIBRAW_LIBRARY_BUILD
      checkCancel();
#endif
      for (col = 0; col < raw_width; col++)
        if ((RAW(row, col) >>= load_flags) >> bits && (unsigned)(row - top_margin) < height &&
            (unsigned)(col - left_margin) < width)
          derror();
    }
}",0
Detect whether the following code contains vulnerabilities.,"static zval *com_read_dimension(zval *object, zval *offset, int type, zval *rv)
{
	php_com_dotnet_object *obj;
	VARIANT v;

	ZVAL_NULL(rv);

	obj = CDNO_FETCH(object);

	if (V_VT(&obj->v) == VT_DISPATCH) {
		VariantInit(&v);

		if (SUCCESS == php_com_do_invoke_by_id(obj, DISPID_VALUE,
				DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, 1, offset, 0, 0)) {
			php_com_zval_from_variant(rv, &v, obj->code_page);
			VariantClear(&v);
		}
	} else if (V_ISARRAY(&obj->v)) {
		convert_to_long(offset);

		if (SafeArrayGetDim(V_ARRAY(&obj->v)) == 1) {
			if (php_com_safearray_get_elem(&obj->v, &v, (LONG)Z_LVAL_P(offset))) {
				php_com_wrap_variant(rv, &v, obj->code_page);
				VariantClear(&v);
			}
		} else {
			php_com_saproxy_create(object, rv, offset);
		}

	} else {
		php_com_throw_exception(E_INVALIDARG, ""this variant is not an array type"");
	}

	return rv;
}",0
Detect whether the following code contains vulnerabilities.,"inline uint8_t* WireFormatLite::WriteInt32NoTagToArray(
    const RepeatedField<int32_t>& value, uint8_t* target) {
  return WritePrimitiveNoTagToArray(value, WriteInt32NoTagToArray, target);
}",0
Detect whether the following code contains vulnerabilities.,"xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {
    xmlIDTablePtr table;
    xmlIDPtr id;
    xmlChar *ID;

    if (doc == NULL) return(-1);
    if (attr == NULL) return(-1);

    table = (xmlIDTablePtr) doc->ids;
    if (table == NULL)
        return(-1);

    ID = xmlNodeListGetString(doc, attr->children, 1);
    if (ID == NULL)
        return(-1);

    id = xmlHashLookup(table, ID);
    if (id == NULL || id->attr != attr) {
        xmlFree(ID);
        return(-1);
    }

    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);
    xmlFree(ID);
    attr->atype = 0;
    return(0);
}",1
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoul_underflow(void)

{

    const char *str = ""-99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err  = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, -1ul);

    g_assert(endptr == str + strlen(str));

}
",0
Detect whether the following code contains vulnerabilities.,"static void kqemu_reset_modified_ram_pages(void)

{

    int i;

    unsigned long page_index;



    for(i = 0; i < nb_modified_ram_pages; i++) {

        page_index = modified_ram_pages[i] >> TARGET_PAGE_BITS;

        modified_ram_pages_table[page_index] = 0;

    }

    nb_modified_ram_pages = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static loff_t find_tree_dqentry(struct qtree_mem_dqinfo *info,
				struct dquot *dquot, uint blk, int depth)
{
	char *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS);
	loff_t ret = 0;
	__le32 *ref = (__le32 *)buf;

	if (!buf)
		return -ENOMEM;
	ret = read_blk(info, blk, buf);
	if (ret < 0) {
		quota_error(dquot->dq_sb, ""Can't read quota tree block %u"",
			    blk);
		goto out_buf;
	}
	ret = 0;
	blk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]);
	if (!blk)	/* No reference? */
		goto out_buf;
	if (depth < info->dqi_qtree_depth - 1)
		ret = find_tree_dqentry(info, dquot, blk, depth+1);
	else
		ret = find_block_dqentry(info, dquot, blk);
out_buf:
	kfree(buf);
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void clear_commits(BDRVVVFATState* s)

{

    int i;

DLOG(fprintf(stderr, ""clear_commits (%d commits)\n"", s->commits.next));

    for (i = 0; i < s->commits.next; i++) {

	commit_t* commit = array_get(&(s->commits), i);

	assert(commit->path || commit->action == ACTION_WRITEOUT);

	if (commit->action != ACTION_WRITEOUT) {

	    assert(commit->path);

	    free(commit->path);

	} else

	    assert(commit->path == NULL);

    }

    s->commits.next = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"TEST_F(Http1ClientConnectionImplTest, 100Response) {
  initialize();

  NiceMock<MockResponseDecoder> response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);

  EXPECT_CALL(response_decoder, decode100ContinueHeaders_(_));
  EXPECT_CALL(response_decoder, decodeData(_, _)).Times(0);
  Buffer::OwnedImpl initial_response(""HTTP/1.1 100 Continue\r\n\r\n"");
  auto status = codec_->dispatch(initial_response);

  EXPECT_CALL(response_decoder, decodeHeaders_(_, false));
  EXPECT_CALL(response_decoder, decodeData(_, _)).Times(0);
  Buffer::OwnedImpl response(""HTTP/1.1 200 OK\r\n\r\n"");
  status = codec_->dispatch(response);
  EXPECT_TRUE(status.ok());
}",0
Detect whether the following code contains vulnerabilities.,"static void h2_shutw(struct conn_stream *cs, enum cs_shw_mode mode)
{
	struct h2s *h2s = cs->ctx;

	h2_do_shutw(h2s);
}",0
Detect whether the following code contains vulnerabilities.,"void mk_request_free(struct session_request *sr)
{
    if (sr->fd_file > 0) {
        mk_vhost_close(sr);
    }

    if (sr->headers.location) {
        mk_mem_free(sr->headers.location);
    }

    if (sr->uri_processed.data != sr->uri.data) {
        mk_ptr_free(&sr->uri_processed);
    }

    if (sr->real_path.data != sr->real_path_static) {
        mk_ptr_free(&sr->real_path);
    }
}",1
Detect whether the following code contains vulnerabilities.,"	switch (yych) {
		case 'a': goto yy44;
		default: goto yy41;
	}",1
Detect whether the following code contains vulnerabilities.,  virtual void updateFlatness(GfxState * /*state*/) {},0
Detect whether the following code contains vulnerabilities.,"calc_delta_fair(unsigned long delta_exec, struct load_weight *lw)
{
	return calc_delta_mine(delta_exec, NICE_0_LOAD, lw);
}",1
Detect whether the following code contains vulnerabilities.,"cssp_gss_report_error(OM_uint32 code, char *str, OM_uint32 major_status, OM_uint32 minor_status)
{
	OM_uint32 msgctx = 0, ms;
	gss_buffer_desc status_string;

	logger(Core, Debug, ""GSS error [%d:%d:%d]: %s"", (major_status & 0xff000000) >> 24,	// Calling error
	       (major_status & 0xff0000) >> 16,	// Routine error
	       major_status & 0xffff,	// Supplementary info bits
	       str);

	do
	{
		ms = gss_display_status(&minor_status, major_status,
					code, GSS_C_NULL_OID, &msgctx, &status_string);
		if (ms != GSS_S_COMPLETE)
			continue;

		logger(Core, Debug, "" - %s"", status_string.value);

	}
	while (ms == GSS_S_COMPLETE && msgctx);

}",0
Detect whether the following code contains vulnerabilities.,"int nfs_access_get_cached(struct inode *inode, struct rpc_cred *cred, struct nfs_access_entry *res)
{
	struct nfs_inode *nfsi = NFS_I(inode);
	struct nfs_access_entry *cache;
	int err = -ENOENT;

	spin_lock(&inode->i_lock);
	if (nfsi->cache_validity & NFS_INO_INVALID_ACCESS)
		goto out_zap;
	cache = nfs_access_search_rbtree(inode, cred);
	if (cache == NULL)
		goto out;
	if (time_after(jiffies, cache->jiffies + NFS_ATTRTIMEO(inode)))
		goto out_stale;
	res->jiffies = cache->jiffies;
	res->cred = cache->cred;
	res->mask = cache->mask;
	list_move_tail(&cache->lru, &nfsi->access_cache_entry_lru);
	err = 0;
out:
	spin_unlock(&inode->i_lock);
	return err;
out_stale:
	rb_erase(&cache->rb_node, &nfsi->access_cache);
	list_del(&cache->lru);
	spin_unlock(&inode->i_lock);
	nfs_access_free_entry(cache);
	return -ENOENT;
out_zap:
	/* This will release the spinlock */
	__nfs_access_zap_cache(inode);
	return -ENOENT;
}",0
Detect whether the following code contains vulnerabilities.,"static inline int handle_dots(struct nameidata *nd, int type)
{
	if (type == LAST_DOTDOT) {
		if (nd->flags & LOOKUP_RCU) {
			return follow_dotdot_rcu(nd);
		} else
			follow_dotdot(nd);
	}
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void mono_gc_init (void)
{
	InitializeCriticalSection (&handle_section);
}",1
Detect whether the following code contains vulnerabilities.,"int bdrv_child_check_perm(BdrvChild *c, uint64_t perm, uint64_t shared,

                          Error **errp)

{

    return bdrv_check_update_perm(c->bs, perm, shared, c, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)
{
	i64 selector;
	i64 data_len;

	if(len<4) return;
	selector = de_getu32be(pos);
	data_len = len-4;
	de_dbg(c, ""ICC profile segment, selector=%d, data len=%d"", (int)selector,
		(int)data_len);

	if(selector!=1) {
		// If this is not a Continuation segment, close any current file.
		dbuf_close(d->iccprofile_file);
		d->iccprofile_file = NULL;
	}

	if(selector==0) { // Beginning segment
		d->iccprofile_file = dbuf_create_output_file(c, ""icc"", NULL, DE_CREATEFLAG_IS_AUX);
	}

	if(selector==0 || selector==1) {
		// Beginning and Continuation segments normally have profile data.
		// End segments (selector==2) are not allowed to include data.
		dbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);
	}
}",1
Detect whether the following code contains vulnerabilities.,"int apply_event_filter(struct trace_event_file *file, char *filter_string)
{
	struct trace_event_call *call = file->event_call;
	struct event_filter *filter = NULL;
	int err;

	if (!strcmp(strstrip(filter_string), ""0"")) {
		filter_disable(file);
		filter = event_filter(file);

		if (!filter)
			return 0;

		event_clear_filter(file);

		/* Make sure the filter is not being used */
		tracepoint_synchronize_unregister();
		__free_filter(filter);

		return 0;
	}

	err = create_filter(file->tr, call, filter_string, true, &filter);

	/*
	 * Always swap the call filter with the new filter
	 * even if there was an error. If there was an error
	 * in the filter, we disable the filter and show the error
	 * string
	 */
	if (filter) {
		struct event_filter *tmp;

		tmp = event_filter(file);
		if (!err)
			event_set_filtered_flag(file);
		else
			filter_disable(file);

		event_set_filter(file, filter);

		if (tmp) {
			/* Make sure the call is done with the filter */
			tracepoint_synchronize_unregister();
			__free_filter(tmp);
		}
	}

	return err;
}",0
Detect whether the following code contains vulnerabilities.,"int show_filters(void *optctx, const char *opt, const char *arg)

{

    AVFilter av_unused(**filter) = NULL;



    printf(""Filters:\n"");

#if CONFIG_AVFILTER

    while ((filter = av_filter_next(filter)) && *filter)

        printf(""%-16s %s\n"", (*filter)->name, (*filter)->description);

#endif

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t vmsvga_bios_read(void *opaque, uint32_t address)

{

    printf(""%s: what are we supposed to return?\n"", __FUNCTION__);

    return 0xcafe;

}
",0
Detect whether the following code contains vulnerabilities.,"FontData::FontData(FontData* data, int32_t offset) {
  Init(data->array_);
  Bound(data->bound_offset_ + offset,
        (data->bound_length_ == GROWABLE_SIZE)
            ? GROWABLE_SIZE : data->bound_length_ - offset);
}",1
Detect whether the following code contains vulnerabilities.,"read_hwclock_file(const char *hwclock_file)
{
  FILE *in;
  char line[256];
  int i;

  if (!hwclock_file || !hwclock_file[0])
    return;

  in = fopen(hwclock_file, ""r"");
  if (!in) {
    LOG(LOGS_WARN, ""Could not open %s : %s"",
        hwclock_file, strerror(errno));
    return;
  }

  /* Read third line from the file. */
  for (i = 0; i < 3; i++) {
    if (!fgets(line, sizeof(line), in))
      break;
  }

  fclose(in);

  if (i == 3 && !strncmp(line, ""LOCAL"", 5)) {
    rtc_on_utc = 0;
  } else if (i == 3 && !strncmp(line, ""UTC"", 3)) {
    rtc_on_utc = 1;
  } else {
    LOG(LOGS_WARN, ""Could not read RTC LOCAL/UTC setting from %s"", hwclock_file);
  }
}",1
Detect whether the following code contains vulnerabilities.,"bool virtio_scsi_handle_ctrl_vq(VirtIOSCSI *s, VirtQueue *vq)

{

    VirtIOSCSIReq *req;

    bool progress = false;



    virtio_scsi_acquire(s);

    while ((req = virtio_scsi_pop_req(s, vq))) {

        progress = true;

        virtio_scsi_handle_ctrl_req(s, req);

    }

    virtio_scsi_release(s);

    return progress;

}
",1
Detect whether the following code contains vulnerabilities.,"xmlXPtrNewRangeNodePoint(xmlNodePtr start, xmlXPathObjectPtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    if (start->type != XPATH_POINT)
	return(NULL);
    if (end->type != XPATH_POINT)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end->user;
    ret->index2 = end->index;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",1
Detect whether the following code contains vulnerabilities.,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static uint32_t eepro100_read4(EEPRO100State * s, uint32_t addr)

{

    uint32_t val;

    if (addr <= sizeof(s->mem) - sizeof(val)) {

        memcpy(&val, &s->mem[addr], sizeof(val));

    }



    switch (addr) {

    case SCBStatus:

        TRACE(OTHER, logout(""addr=%s val=0x%08x\n"", regname(addr), val));

        break;

    case SCBPointer:

#if 0

        val = eepro100_read_pointer(s);

#endif

        TRACE(OTHER, logout(""addr=%s val=0x%08x\n"", regname(addr), val));

        break;

    case SCBPort:

        val = eepro100_read_port(s);

        TRACE(OTHER, logout(""addr=%s val=0x%08x\n"", regname(addr), val));

        break;

    case SCBCtrlMDI:

        val = eepro100_read_mdi(s);

        break;

    default:

        logout(""addr=%s val=0x%08x\n"", regname(addr), val);

        missing(""unknown longword read"");

    }

    return val;

}
",1
Detect whether the following code contains vulnerabilities.,"rb_str_dup_frozen(str)
    VALUE str;
{
    if (FL_TEST(str, ELTS_SHARED) && RSTRING(str)->aux.shared) {
	VALUE shared = RSTRING(str)->aux.shared;
	if (RSTRING(shared)->len == RSTRING(str)->len) {
	    OBJ_FREEZE(shared);
	    return shared;
	}
    }
    if (OBJ_FROZEN(str)) return str;
    str = rb_str_dup(str);
    OBJ_FREEZE(str);
    return str;
}",0
Detect whether the following code contains vulnerabilities.,"BlockDriverAIOCB *bdrv_aio_write(BlockDriverState *bs, int64_t sector_num,

                                 const uint8_t *buf, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {

        memcpy(bs->boot_sector_data, buf, 512);

    }



    ret = drv->bdrv_aio_write(bs, sector_num, buf, nb_sectors, cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"nfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,
					struct nfsd3_createargs *args)
{
	if (!(p = decode_fh(p, &args->fh))
	 || !(p = decode_filename(p, &args->name, &args->len)))
		return 0;

	switch (args->createmode = ntohl(*p++)) {
	case NFS3_CREATE_UNCHECKED:
	case NFS3_CREATE_GUARDED:
		p = decode_sattr3(p, &args->attrs);
		break;
	case NFS3_CREATE_EXCLUSIVE:
		args->verf = p;
		p += 2;
		break;
	default:
		return 0;
	}

	return xdr_argsize_check(rqstp, p);
}",0
Detect whether the following code contains vulnerabilities.,"int css_create_css_image(uint8_t cssid, bool default_image)

{

    trace_css_new_image(cssid, default_image ? ""(default)"" : """");

    if (cssid > MAX_CSSID) {

        return -EINVAL;

    }

    if (channel_subsys.css[cssid]) {

        return -EBUSY;

    }

    channel_subsys.css[cssid] = g_malloc0(sizeof(CssImage));

    if (default_image) {

        channel_subsys.default_cssid = cssid;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t platform_mmio_read(ReadWriteHandler *handler, pcibus_t addr, int len)

{

    DPRINTF(""Warning: attempted read from physical address ""

            ""0x"" TARGET_FMT_plx "" in xen platform mmio space\n"", addr);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"  const string name() override { return ""put_bucket_metadata""; }",0
Detect whether the following code contains vulnerabilities.,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    return truncate(rpath(ctx, path, buffer), size);

}
",0
Detect whether the following code contains vulnerabilities.,"void perf_sched_cb_dec(struct pmu *pmu)
{
	struct perf_cpu_context *cpuctx = this_cpu_ptr(pmu->pmu_cpu_context);

	--cpuctx->sched_cb_usage;
}",0
Detect whether the following code contains vulnerabilities.,"MagickPrivate void ConvertRGBToLCHuv(const double red,const double green,
  const double blue,double *luma,double *chroma,double *hue)
{
  double
    X,
    Y,
    Z;

  /*
    Convert RGB to LCHuv colorspace.
  */
  assert(luma != (double *) NULL);
  assert(chroma != (double *) NULL);
  assert(hue != (double *) NULL);
  ConvertRGBToXYZ(red,green,blue,&X,&Y,&Z);
  ConvertXYZToLCHuv(X,Y,Z,luma,chroma,hue);
}",0
Detect whether the following code contains vulnerabilities.,"void ff_set_fixed_vector(float *out, const AMRFixed *in, float scale, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x   = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);

        float y = in->y[i] * scale;




        do {

            out[x] += y;

            y *= in->pitch_fac;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",1
Detect whether the following code contains vulnerabilities.,"rsCStrExtendBuf(cstr_t *pThis, size_t iMinNeeded)
{
	uchar *pNewBuf;
	unsigned short iNewSize;
	DEFiRet;

	/* first compute the new size needed */
	if(iMinNeeded > RS_STRINGBUF_ALLOC_INCREMENT) {
		/* we allocate ""n"" ALLOC_INCREMENTs. Usually, that should
		 * leave some room after the absolutely needed one. It also
		 * reduces memory fragmentation. Note that all of this are
		 * integer operations (very important to understand what is
		 * going on)! Parenthesis are for better readibility.
		 */
		iNewSize = (iMinNeeded / RS_STRINGBUF_ALLOC_INCREMENT + 1) * RS_STRINGBUF_ALLOC_INCREMENT;
	} else {
		iNewSize = pThis->iBufSize + RS_STRINGBUF_ALLOC_INCREMENT;
	}
	iNewSize += pThis->iBufSize; /* add current size */

	/* DEV debugging only: dbgprintf(""extending string buffer, old %d, new %d\n"", pThis->iBufSize, iNewSize); */
	CHKmalloc(pNewBuf = (uchar*) realloc(pThis->pBuf, iNewSize * sizeof(uchar)));
	pThis->iBufSize = iNewSize;
	pThis->pBuf = pNewBuf;

finalize_it:
	RETiRet;
}",1
Detect whether the following code contains vulnerabilities.,"flatpak_proxy_client_finalize (GObject *object)
{
  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);

  client->proxy->clients = g_list_remove (client->proxy->clients, client);
  g_clear_object (&client->proxy);

  g_hash_table_destroy (client->rewrite_reply);
  g_hash_table_destroy (client->get_owner_reply);
  g_hash_table_destroy (client->unique_id_policy);

  free_side (&client->client_side);
  free_side (&client->bus_side);

  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);
}",1
Detect whether the following code contains vulnerabilities.,"swap_pointers(char **a, char **b)
{
  char *t = *a;
  *a = *b;
  *b = t;
}",0
Detect whether the following code contains vulnerabilities.,"void bdrv_io_limits_disable(BlockDriverState *bs)

{

    bs->io_limits_enabled = false;



    bdrv_start_throttled_reqs(bs);



    throttle_destroy(&bs->throttle_state);

}
",0
Detect whether the following code contains vulnerabilities.,"static av_always_inline void iadst4_1d(const dctcoef *in, ptrdiff_t stride,

                                       dctcoef *out, int pass)

{

    int t0, t1, t2, t3;



    t0 =  5283 * IN(0) + 15212 * IN(2) +  9929 * IN(3);

    t1 =  9929 * IN(0) -  5283 * IN(2) - 15212 * IN(3);

    t2 = 13377 * (IN(0) - IN(2) + IN(3));

    t3 = 13377 * IN(1);



    out[0] = (t0 + t3      + (1 << 13)) >> 14;

    out[1] = (t1 + t3      + (1 << 13)) >> 14;

    out[2] = (t2           + (1 << 13)) >> 14;

    out[3] = (t0 + t1 - t3 + (1 << 13)) >> 14;

}
",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);

  const TfLiteTensor* dims = GetInput(context, node, kDimsTensor);
  const TfLiteTensor* value = GetInput(context, node, kValueTensor);

  // Make sure the 1st input tensor is 1-D.
  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);

  // Make sure the 1st input tensor is int32 or int64.
  const auto dtype = dims->type;
  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);

  // Make sure the 2nd input tensor is a scalar.
  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);

  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  output->type = value->type;

  if (IsConstantTensor(dims)) {
    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));
  } else {
    SetTensorToDynamic(output);
  }
  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"static int sol_probe(AVProbeData *p)

{

    /* check file header */

    uint16_t magic;

    if (p->buf_size <= 14)

        return 0;

    magic=le2me_16(*((uint16_t*)p->buf));

    if ((magic == 0x0B8D || magic == 0x0C0D || magic == 0x0C8D) &&

        p->buf[2] == 'S' && p->buf[3] == 'O' &&

        p->buf[4] == 'L' && p->buf[5] == 0)

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void generate_offset_lut(DiracGolombLUT *lut, int off)

{

    int idx;

    for (idx = 0; idx < LUT_SIZE; idx++) {

        DiracGolombLUT *l = &lut[idx];



        INIT_RESIDUE(res);

        SET_RESIDUE(res, idx, LUT_BITS);



        l->preamble      = CONVERT_TO_RESIDUE(res >> (RSIZE_BITS - off), off);

        l->preamble_bits = off;

        l->sign = ((l->preamble >> (RSIZE_BITS - l->preamble_bits)) & 1) ? -1 : +1;



        search_for_golomb(l, res << off, LUT_BITS - off);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, DriveInfo *dinfo, int unit)

{

    const char *driver;

    DeviceState *dev;



    driver = bdrv_is_sg(dinfo->bdrv) ? ""scsi-generic"" : ""scsi-disk"";

    dev = qdev_create(&bus->qbus, driver);

    qdev_prop_set_uint32(dev, ""scsi-id"", unit);

    qdev_prop_set_drive(dev, ""drive"", dinfo);

    if (qdev_init(dev) < 0)

        return NULL;

    return DO_UPCAST(SCSIDevice, qdev, dev);

}
",0
Detect whether the following code contains vulnerabilities.,"slhc_remember(struct slcompress *comp, unsigned char *icp, int isize)
{
  printk(KERN_DEBUG ""Called IP function on non IP-system: slhc_remember"");
  return -EINVAL;
}",0
Detect whether the following code contains vulnerabilities.,"int bdrv_snapshot_goto(BlockDriverState *bs,

                       const char *snapshot_id)

{

    BlockDriver *drv = bs->drv;

    int ret, open_ret;



    if (!drv)

        return -ENOMEDIUM;

    if (drv->bdrv_snapshot_goto)

        return drv->bdrv_snapshot_goto(bs, snapshot_id);



    if (bs->file) {

        drv->bdrv_close(bs);

        ret = bdrv_snapshot_goto(bs->file, snapshot_id);

        open_ret = drv->bdrv_open(bs, NULL, bs->open_flags);

        if (open_ret < 0) {

            bdrv_delete(bs->file);

            bs->drv = NULL;

            return open_ret;

        }

        return ret;

    }



    return -ENOTSUP;

}
",0
Detect whether the following code contains vulnerabilities.,"rsvg_new_filter_primitive_offset (void)
{
    RsvgFilterPrimitiveOffset *filter;
    filter = g_new (RsvgFilterPrimitiveOffset, 1);
    _rsvg_node_init (&filter->super.super);
    filter->super.in = g_string_new (""none"");
    filter->super.result = g_string_new (""none"");
    filter->super.x.factor = filter->super.y.factor = filter->super.width.factor =
        filter->super.height.factor = 'n';
    filter->dy = _rsvg_css_parse_length (""0"");
    filter->dx = _rsvg_css_parse_length (""0"");
    filter->super.render = &rsvg_filter_primitive_offset_render;
    filter->super.super.free = &rsvg_filter_primitive_offset_free;
    filter->super.super.set_atts = rsvg_filter_primitive_offset_set_atts;
    return (RsvgNode *) filter;
}",1
Detect whether the following code contains vulnerabilities.,"static inline bool FNAME(is_last_gpte)(struct kvm_mmu *mmu,
				       unsigned int level, unsigned int gpte)
{
	/*
	 * For EPT and PAE paging (both variants), bit 7 is either reserved at
	 * all level or indicates a huge page (ignoring CR3/EPTP).  In either
	 * case, bit 7 being set terminates the walk.
	 */
#if PTTYPE == 32
	/*
	 * 32-bit paging requires special handling because bit 7 is ignored if
	 * CR4.PSE=0, not reserved.  Clear bit 7 in the gpte if the level is
	 * greater than the last level for which bit 7 is the PAGE_SIZE bit.
	 *
	 * The RHS has bit 7 set iff level < (2 + PSE).  If it is clear, bit 7
	 * is not reserved and does not indicate a large page at this level,
	 * so clear PT_PAGE_SIZE_MASK in gpte if that is the case.
	 */
	gpte &= level - (PT32_ROOT_LEVEL + mmu->mmu_role.ext.cr4_pse);
#endif
	/*
	 * PG_LEVEL_4K always terminates.  The RHS has bit 7 set
	 * iff level <= PG_LEVEL_4K, which for our purpose means
	 * level == PG_LEVEL_4K; set PT_PAGE_SIZE_MASK in gpte then.
	 */
	gpte |= level - PG_LEVEL_4K - 1;

	return gpte & PT_PAGE_SIZE_MASK;
}",0
Detect whether the following code contains vulnerabilities.,"static void RENAME(lumRangeFromJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++)

        dst[i] = (dst[i]*14071 + 33561947)>>14;

}
",0
Detect whether the following code contains vulnerabilities.,"TPM2B_SENSITIVE_DATA_Marshal(TPM2B_SENSITIVE_DATA *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}",1
Detect whether the following code contains vulnerabilities.,"FILE *fdopen_tempfile(struct tempfile *tempfile, const char *mode)
{
	if (!tempfile->active)
		die(""BUG: fdopen_tempfile() called for inactive object"");
	if (tempfile->fp)
		die(""BUG: fdopen_tempfile() called for open object"");

	tempfile->fp = fdopen(tempfile->fd, mode);
	return tempfile->fp;
}",0
Detect whether the following code contains vulnerabilities.,"static int tmp105_tx(I2CSlave *i2c, uint8_t data)

{

    TMP105State *s = (TMP105State *) i2c;



    if (!s->len ++)

        s->pointer = data;

    else {

        if (s->len <= 2)

            s->buf[s->len - 1] = data;

        tmp105_write(s);

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int read_channels(AVFilterContext *ctx, int channels, uint8_t *item_str, int *nb, double **c, double **cache)

{

    char *p, *arg, *old_str, *prev_arg = NULL, *saveptr = NULL;

    int i, ret;



    p = old_str = av_strdup(item_str);

    if (!p)

        return AVERROR(ENOMEM);

    for (i = 0; i < channels; i++) {

        if (!(arg = av_strtok(p, ""|"", &saveptr)))

            arg = prev_arg;



        p = NULL;

        count_coefficients(arg, &nb[i]);

        cache[i] = av_calloc(nb[i], sizeof(cache[i]));

        c[i] = av_calloc(nb[i], sizeof(c[i]));

        if (!c[i] || !cache[i])

            return AVERROR(ENOMEM);



        ret = read_coefficients(ctx, arg, nb[i], c[i]);

        if (ret < 0)

            return ret;

        prev_arg = arg;

    }



    av_freep(&old_str);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"GF_Box *encs_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);
	gf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);
	tmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;
	return (GF_Box *)tmp;
}",1
Detect whether the following code contains vulnerabilities.,"void hmp_pci_del(Monitor *mon, const QDict *qdict)

{

    pci_device_hot_remove(mon, qdict_get_str(qdict, ""pci_addr""));

}
",1
Detect whether the following code contains vulnerabilities.,"static int ovs_flow_cmd_dump(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct ovs_header *ovs_header = genlmsg_data(nlmsg_data(cb->nlh));
	struct table_instance *ti;
	struct datapath *dp;

	rcu_read_lock();
	dp = get_dp(sock_net(skb->sk), ovs_header->dp_ifindex);
	if (!dp) {
		rcu_read_unlock();
		return -ENODEV;
	}

	ti = rcu_dereference(dp->table.ti);
	for (;;) {
		struct sw_flow *flow;
		u32 bucket, obj;

		bucket = cb->args[0];
		obj = cb->args[1];
		flow = ovs_flow_tbl_dump_next(ti, &bucket, &obj);
		if (!flow)
			break;

		if (ovs_flow_cmd_fill_info(flow, dp, skb,
					   NETLINK_CB(cb->skb).portid,
					   cb->nlh->nlmsg_seq, NLM_F_MULTI,
					   OVS_FLOW_CMD_NEW) < 0)
			break;

		cb->args[0] = bucket;
		cb->args[1] = obj;
	}
	rcu_read_unlock();
	return skb->len;
}",0
Detect whether the following code contains vulnerabilities.,"void smb_vfs_call_disconnect(struct vfs_handle_struct *handle)
{
	VFS_FIND(disconnect);
	handle->fns->disconnect(handle);
}",0
Detect whether the following code contains vulnerabilities.,"cib_timeout_handler(gpointer data)
{
    struct timer_rec_s *timer = data;

    timer_expired = TRUE;
    crm_err(""Call %d timed out after %ds"", timer->call_id, timer->timeout);

    /* Always return TRUE, never remove the handler
     * We do that after the while-loop in cib_native_perform_op()
     */
    return TRUE;
}",1
Detect whether the following code contains vulnerabilities.,"static int hci_uart_tty_open(struct tty_struct *tty)
{
	struct hci_uart *hu;

	BT_DBG(""tty %p"", tty);

	/* Error if the tty has no write op instead of leaving an exploitable
	 * hole
	 */
	if (tty->ops->write == NULL)
		return -EOPNOTSUPP;

	hu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);
	if (!hu) {
		BT_ERR(""Can't allocate control structure"");
		return -ENFILE;
	}

	tty->disc_data = hu;
	hu->tty = tty;
	tty->receive_room = 65536;

	/* disable alignment support by default */
	hu->alignment = 1;
	hu->padding = 0;

	INIT_WORK(&hu->init_ready, hci_uart_init_work);
	INIT_WORK(&hu->write_work, hci_uart_write_work);

	percpu_init_rwsem(&hu->proto_lock);

	/* Flush any pending characters in the driver */
	tty_driver_flush_buffer(tty);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
	else if (len < ds)
		msg->msg_flags |= MSG_TRUNC;

	lock_sock(sk);
	if (ctx->more) {
		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}",1
Detect whether the following code contains vulnerabilities.,"void *bson_realloc( void *ptr, int size ) {
    void *p;
    p = bson_realloc_func( ptr, size );
    bson_fatal_msg( !!p, ""realloc() failed"" );
    return p;
}",1
Detect whether the following code contains vulnerabilities.,"sraSpanRemove(sraSpan *span) {
  span->_prev->_next = span->_next;
  span->_next->_prev = span->_prev;
}",1
Detect whether the following code contains vulnerabilities.,"static void sigill_handler (int sig)

{

    if (!canjump) {

        signal (sig, SIG_DFL);

        raise (sig);

    }



    canjump = 0;

    siglongjmp (jmpbuf, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int send_data_callback(nghttp2_session *session, nghttp2_frame *frame,
                              const uint8_t *framehd, size_t length,
                              nghttp2_data_source *source, void *user_data) {
  accumulator *acc = ((my_user_data *)user_data)->acc;
  (void)session;
  (void)source;

  memcpy(acc->buf + acc->length, framehd, NGHTTP2_FRAME_HDLEN);
  acc->length += NGHTTP2_FRAME_HDLEN;

  if (frame->data.padlen) {
    *(acc->buf + acc->length++) = (uint8_t)(frame->data.padlen - 1);
  }

  acc->length += length;

  if (frame->data.padlen) {
    acc->length += frame->data.padlen - 1;
  }

  return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void ieee80211_destroy_assoc_data(struct ieee80211_sub_if_data *sdata,
					 bool assoc, bool abandon)
{
	struct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;

	sdata_assert_lock(sdata);

	if (!assoc) {
		/*
		 * we are not associated yet, the only timer that could be
		 * running is the timeout for the association response which
		 * which is not relevant anymore.
		 */
		del_timer_sync(&sdata->u.mgd.timer);
		sta_info_destroy_addr(sdata, assoc_data->bss->bssid);

		eth_zero_addr(sdata->u.mgd.bssid);
		ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BSSID);
		sdata->u.mgd.flags = 0;
		sdata->vif.mu_mimo_owner = false;

		mutex_lock(&sdata->local->mtx);
		ieee80211_vif_release_channel(sdata);
		mutex_unlock(&sdata->local->mtx);

		if (abandon)
			cfg80211_abandon_assoc(sdata->dev, assoc_data->bss);
	}

	kfree(assoc_data);
	sdata->u.mgd.assoc_data = NULL;
}",0
Detect whether the following code contains vulnerabilities.,"static int cirrus_bitblt_common_patterncopy(CirrusVGAState * s,

					    const uint8_t * src)

{

    uint8_t *dst;



    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);



    if (BLTUNSAFE(s))

        return 0;



    (*s->cirrus_rop) (s, dst, src,

                      s->cirrus_blt_dstpitch, 0,

                      s->cirrus_blt_width, s->cirrus_blt_height);

    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,

                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,

                             s->cirrus_blt_height);

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"zfs_ace_v0_set_flags(void *acep, uint16_t flags)
{
	((zfs_oldace_t *)acep)->z_flags = flags;
}",0
Detect whether the following code contains vulnerabilities.,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
	ret = php_stream_seek(ts->innerstream, offset, whence);
	*newoffs = php_stream_tell(ts->innerstream);
	stream->eof = ts->innerstream->eof;
	
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"    int BSONTool::run() {
        _objcheck = hasParam( ""objcheck"" );

        if ( hasParam( ""filter"" ) )
            _matcher.reset( new Matcher( fromjson( getParam( ""filter"" ) ) ) );

        return doRun();
    }",1
Detect whether the following code contains vulnerabilities.,"void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source)
{
	void *old_p, *retval;

	if ((old_p = zend_hash_index_find_ptr(&xlat_table, (zend_ulong)source)) != NULL) {
		/* we already duplicated this pointer */
		return old_p;
	}
	retval = ZCG(mem);
	ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));
	memcpy(retval, source, size);
	if (free_source) {
		efree(source);
	}
	zend_shared_alloc_register_xlat_entry(source, retval);
	return retval;
}",1
Detect whether the following code contains vulnerabilities.,"gss_complete_auth_token (OM_uint32 *minor_status,
	                 const gss_ctx_id_t context_handle,
	                 gss_buffer_t input_message_buffer)
{
    OM_uint32		status;
    gss_union_ctx_id_t	ctx;
    gss_mechanism	mech;

    if (context_handle == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;

    /*
     * select the approprate underlying mechanism routine and
     * call it.
     */

    ctx = (gss_union_ctx_id_t) context_handle;
    mech = gssint_get_mechanism (ctx->mech_type);

    if (mech != NULL) {
	if (mech->gss_complete_auth_token != NULL) {
	    status = mech->gss_complete_auth_token(minor_status,
						   ctx->internal_ctx_id,
						   input_message_buffer);
	    if (status != GSS_S_COMPLETE)
		map_error(minor_status, mech);
	} else
	    status = GSS_S_COMPLETE;
    } else
	status = GSS_S_BAD_MECH;

    return status;
}",1
Detect whether the following code contains vulnerabilities.,"static void chap_binaryhex_to_asciihex(char *dst, char *src, int src_len)
{
	int i;

	for (i = 0; i < src_len; i++) {
		sprintf(&dst[i*2], ""%02x"", (int) src[i] & 0xff);
	}
}",1
Detect whether the following code contains vulnerabilities.,"TPM_GENERATED_Unmarshal(TPM_GENERATED *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target != TPM_GENERATED_VALUE) {
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_movcf_d (DisasContext *ctx, int fs, int fd, int cc, int tf)

{

    int cond;

    TCGv_i32 t0 = tcg_temp_new_i32();

    TCGv_i64 fp0;

    int l1 = gen_new_label();



    if (tf)

        cond = TCG_COND_EQ;

    else

        cond = TCG_COND_NE;



    tcg_gen_andi_i32(t0, fpu_fcr31, 1 << get_fp_bit(cc));

    tcg_gen_brcondi_i32(cond, t0, 0, l1);

    tcg_temp_free_i32(t0);

    fp0 = tcg_temp_new_i64();

    gen_load_fpr64(ctx, fp0, fs);

    gen_store_fpr64(ctx, fp0, fd);

    tcg_temp_free_i64(fp0);

    gen_set_label(l1);

}
",0
Detect whether the following code contains vulnerabilities.,"nfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)
{
	struct xdr_stream *xdr = &resp->xdr;
	struct svc_fh *fhp = *fhpp;
	unsigned int len;
	__be32 *p;

	if (!nfserr) {
		len = fhp->fh_handle.fh_size;
		p = xdr_reserve_space(xdr, len + 4);
		if (!p)
			return nfserr_resource;
		p = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);
	}
	return nfserr;
}",0
Detect whether the following code contains vulnerabilities.,"static void perf_event_for_each(struct perf_event *event,
				  void (*func)(struct perf_event *))
{
	struct perf_event_context *ctx = event->ctx;
	struct perf_event *sibling;

	WARN_ON_ONCE(ctx->parent_ctx);
	mutex_lock(&ctx->mutex);
	event = event->group_leader;

	perf_event_for_each_child(event, func);
	list_for_each_entry(sibling, &event->sibling_list, group_entry)
		perf_event_for_each_child(sibling, func);
	mutex_unlock(&ctx->mutex);
}",1
Detect whether the following code contains vulnerabilities.,"bool Cipher::neededFeaturesAvailable()
{
    QCA::Initializer init;

    if (QCA::isSupported(""blowfish-ecb"") && QCA::isSupported(""blowfish-cbc"") && QCA::isSupported(""dh""))
        return true;

    return false;
}",0
Detect whether the following code contains vulnerabilities.,"static void start_frame_overlay(AVFilterLink *inlink, AVFilterBufferRef *inpicref)

{

    AVFilterContext *ctx = inlink->dst;

    OverlayContext *over = ctx->priv;



    inpicref->pts = av_rescale_q(inpicref->pts, ctx->inputs[OVERLAY]->time_base,

                                 ctx->outputs[0]->time_base);



    if (!over->overpicref) over->overpicref      = inpicref;

    else                   over->overpicref_next = inpicref;

}
",1
Detect whether the following code contains vulnerabilities.,"int bdrv_read_unthrottled(BlockDriverState *bs, int64_t sector_num,
                          uint8_t *buf, int nb_sectors)
{
    bool enabled;
    int ret;

    enabled = bs->io_limits_enabled;
    bs->io_limits_enabled = false;
    ret = bdrv_read(bs, sector_num, buf, nb_sectors);
    bs->io_limits_enabled = enabled;
    return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static uint32_t pci_unin_main_config_readl (void *opaque,

                                            target_phys_addr_t addr)

{

    UNINState *s = opaque;

    uint32_t val;



    val = s->config_reg;

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    UNIN_DPRINTF(""config_readl addr "" TARGET_FMT_plx "" val %x\n"", addr, val);



    return val;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool object_is_type(Object *obj, const char *typename)

{

    TypeImpl *target_type = type_get_by_name(typename);

    TypeImpl *type = obj->class->type;

    GSList *i;



    /* Check if typename is a direct ancestor of type */

    while (type) {

        if (type == target_type) {

            return true;

        }



        type = type_get_parent(type);

    }



    /* Check if obj has an interface of typename */

    for (i = obj->interfaces; i; i = i->next) {

        Interface *iface = i->data;



        if (object_is_type(OBJECT(iface), typename)) {

            return true;

        }

    }



    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* indices = GetInput(context, node, kIndicesTensor);
  const TfLiteTensor* values = GetInput(context, node, kValueInputTensor);

  switch (values->type) {
    case kTfLiteFloat32:
      return EvalForIndexType<float>(context, node, indices);
    case kTfLiteInt32:
      return EvalForIndexType<int32_t>(context, node, indices);
    case kTfLiteInt64:
      return EvalForIndexType<int64_t>(context, node, indices);
    case kTfLiteInt8:
      return EvalForIndexType<int8_t>(context, node, indices);
    case kTfLiteUInt8:
      return EvalForIndexType<uint8_t>(context, node, indices);
    default:
      TF_LITE_KERNEL_LOG(
          context,
          ""Value type %s is currently not supported by sparse to dense."",
          TfLiteTypeGetName(values->type));
      return kTfLiteError;
  }
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_mutex_unlock_iothread(void) {}
",1
Detect whether the following code contains vulnerabilities.,"horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)
{
	TIFFPredictorState* sp = PredictorState(tif);
	tmsize_t stride = sp->stride;
	uint16 *wp = (uint16*) cp0;
	tmsize_t wc = cc/2;

	assert((cc%(2*stride))==0);

	if (wc > stride) {
		wc -= stride;
		wp += wc - 1;
		do {
			REPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)
			wc -= stride;
		} while (wc > 0);
	}
}",1
Detect whether the following code contains vulnerabilities.,"static void qmp_input_stack_object_free(StackObject *tos)

{

    if (tos->h) {

        g_hash_table_unref(tos->h);

    }



    g_free(tos);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtol_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",1
Detect whether the following code contains vulnerabilities.,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

	*addr_len = sizeof(*haddr);
	haddr->hci_family = AF_BLUETOOTH;
	haddr->hci_dev    = hdev->id;

	release_sock(sk);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"int unit_reload(Unit *u) {
        UnitActiveState state;
        Unit *following;

        assert(u);

        if (u->load_state != UNIT_LOADED)
                return -EINVAL;

        if (!unit_can_reload(u))
                return -EBADR;

        state = unit_active_state(u);
        if (state == UNIT_RELOADING)
                return -EALREADY;

        if (state != UNIT_ACTIVE) {
                log_warning_unit(u->id, ""Unit %s cannot be reloaded because it is inactive."",
                                 u->id);
                return -ENOEXEC;
        }

        following = unit_following(u);
        if (following) {
                log_debug_unit(u->id, ""Redirecting reload request from %s to %s."",
                               u->id, following->id);
                return unit_reload(following);
        }

        unit_status_log_starting_stopping_reloading(u, JOB_RELOAD);

        unit_add_to_dbus_queue(u);
        return UNIT_VTABLE(u)->reload(u);
}",0
Detect whether the following code contains vulnerabilities.,"static int local_statfs(FsContext *s, V9fsPath *fs_path, struct statfs *stbuf)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    return statfs(rpath(s, path, buffer), stbuf);

}
",0
Detect whether the following code contains vulnerabilities.,"int fbytes(unsigned char *buf, int num)
{
    int ret;
    BIGNUM *tmp = NULL;

    if (fbytes_counter >= 8)
        return 0;
    tmp = BN_new();
    if (!tmp)
        return 0;
    if (!BN_dec2bn(&tmp, numbers[fbytes_counter])) {
        BN_free(tmp);
        return 0;
    }
    fbytes_counter++;
    if (num != BN_num_bytes(tmp) || !BN_bn2bin(tmp, buf))
        ret = 0;
    else
        ret = 1;
    if (tmp)
        BN_free(tmp);
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static void FUNCC(pred16x16_vertical)(uint8_t *_src, int _stride){

    int i;

    pixel *src = (pixel*)_src;

    int stride = _stride/sizeof(pixel);

    const pixel4 a = ((pixel4*)(src-stride))[0];

    const pixel4 b = ((pixel4*)(src-stride))[1];

    const pixel4 c = ((pixel4*)(src-stride))[2];

    const pixel4 d = ((pixel4*)(src-stride))[3];



    for(i=0; i<16; i++){

        ((pixel4*)(src+i*stride))[0] = a;

        ((pixel4*)(src+i*stride))[1] = b;

        ((pixel4*)(src+i*stride))[2] = c;

        ((pixel4*)(src+i*stride))[3] = d;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"floatx80 floatx80_scalbn( floatx80 a, int n STATUS_PARAM )

{

    flag aSign;

    int16 aExp;

    uint64_t aSig;



    aSig = extractFloatx80Frac( a );

    aExp = extractFloatx80Exp( a );

    aSign = extractFloatx80Sign( a );



    if ( aExp == 0x7FF ) {

        return a;

    }

    if (aExp == 0 && aSig == 0)

        return a;



    aExp += n;

    return normalizeRoundAndPackFloatx80( STATUS(floatx80_rounding_precision),

                                          aSign, aExp, aSig, 0 STATUS_VAR );

}
",1
Detect whether the following code contains vulnerabilities.,"static int mpeg_mux_end(AVFormatContext *ctx)

{

    StreamInfo *stream;

    int i;



    /* flush each packet */

    for(i=0;i<ctx->nb_streams;i++) {

        stream = ctx->streams[i]->priv_data;

        if (stream->buffer_ptr > 0) {

            if (i == (ctx->nb_streams - 1)) 

                flush_packet(ctx, i, 1);

            else

                flush_packet(ctx, i, 0);

        }

    }



    /* write the end header */

    //put_be32(&ctx->pb, ISO_11172_END_CODE);

    //put_flush_packet(&ctx->pb);



    for(i=0;i<ctx->nb_streams;i++)

        av_freep(&ctx->streams[i]->priv_data);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static struct omap_tipb_bridge_s *omap_tipb_bridge_init(

    MemoryRegion *memory, target_phys_addr_t base,

    qemu_irq abort_irq, omap_clk clk)

{

    struct omap_tipb_bridge_s *s = (struct omap_tipb_bridge_s *)

            g_malloc0(sizeof(struct omap_tipb_bridge_s));



    s->abort = abort_irq;

    omap_tipb_bridge_reset(s);



    memory_region_init_io(&s->iomem, &omap_tipb_bridge_ops, s,

                          ""omap-tipb-bridge"", 0x100);

    memory_region_add_subregion(memory, base, &s->iomem);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static int do_recv_NPStream(rpc_message_t *message, void *p_value)
{
  int error;
  uint32_t stream_id;

  if ((error = rpc_message_recv_uint32(message, &stream_id)) < 0)
	return error;

  NPW_StreamInstance *stream = id_lookup(stream_id);
  *((NPStream **)p_value) = stream ? stream->stream : NULL;
  return RPC_ERROR_NO_ERROR;
}",0
Detect whether the following code contains vulnerabilities.,"static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,
		     rpmpsm psm, int nodigest, int *setmeta,
		     int * firsthardlink)
{
    int rc = 0;
    int numHardlinks = rpmfiFNlink(fi);

    if (numHardlinks > 1) {
	/* Create first hardlinked file empty */
	if (*firsthardlink < 0) {
	    *firsthardlink = rpmfiFX(fi);
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);
	} else {
	    /* Create hard links for others */
	    char *fn = rpmfilesFN(files, *firsthardlink);
	    rc = link(fn, dest);
	    if (rc < 0) {
		rc = RPMERR_LINK_FAILED;
	    }
	    free(fn);
	}
    }
    /* Write normal files or fill the last hardlinked (already
       existing) file with content */
    if (numHardlinks<=1) {
	if (!rc)
	    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);
    } else if (rpmfiArchiveHasContent(fi)) {
	if (!rc)
	    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);
	*firsthardlink = -1;
    } else {
	*setmeta = 0;
    }

    return rc;
}",0
Detect whether the following code contains vulnerabilities.,TfLiteRegistration* Register_QUANTIZE() { return Register_QUANTIZE_OPT(); },0
Detect whether the following code contains vulnerabilities.,"format_rfc1123_time(char *buf, time_t t)
{
  struct tm tm;

  tor_gmtime_r(&t, &tm);

  strftime(buf, RFC1123_TIME_LEN+1, ""___, %d ___ %Y %H:%M:%S GMT"", &tm);
  tor_assert(tm.tm_wday >= 0);
  tor_assert(tm.tm_wday <= 6);
  memcpy(buf, WEEKDAY_NAMES[tm.tm_wday], 3);
  tor_assert(tm.tm_mon >= 0);
  tor_assert(tm.tm_mon <= 11);
  memcpy(buf+8, MONTH_NAMES[tm.tm_mon], 3);
}",0
Detect whether the following code contains vulnerabilities.,"    difference_type operator-(const const_iterator &rhs) const {
      if (charPtr_) {
        return charPtr_ - rhs.charPtr_;
      }
      return char16Ptr_ - rhs.char16Ptr_;
    }",0
Detect whether the following code contains vulnerabilities.,"void ppc_hash64_set_external_hpt(PowerPCCPU *cpu, void *hpt, int shift,

                                 Error **errp)

{

    CPUPPCState *env = &cpu->env;

    Error *local_err = NULL;



    cpu_synchronize_state(CPU(cpu));



    env->external_htab = hpt;

    ppc_hash64_set_sdr1(cpu, (target_ulong)(uintptr_t)hpt | (shift - 18),

                        &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    /* Not strictly necessary, but makes it clearer that an external

     * htab is in use when debugging */

    env->htab_base = -1;



    if (kvm_enabled()) {

        if (kvmppc_put_books_sregs(cpu) < 0) {

            error_setg(errp, ""Unable to update SDR1 in KVM"");

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void Curl_cookie_freelist(struct Cookie *co, bool cookiestoo)
{
  struct Cookie *next;
  while(co) {
    next = co->next;
    if(cookiestoo)
      freecookie(co);
    else
      free(co); /* we only free the struct since the ""members"" are all just
                   pointed out in the main cookie list! */
    co = next;
  }
}",0
Detect whether the following code contains vulnerabilities.,"static bool ccc_match_service(const void *data, const void *match_data)
{
	const struct ccc_state *ccc = data;
	const struct gatt_db_attribute *attrib = match_data;
	uint16_t start, end;

	if (!gatt_db_attribute_get_service_handles(attrib, &start, &end))
		return false;

	return ccc->handle >= start && ccc->handle <= end;
}",0
Detect whether the following code contains vulnerabilities.,"date_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__iso8601(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void vvfat_close(BlockDriverState *bs)

{

    BDRVVVFATState *s = bs->opaque;



    vvfat_close_current_file(s);

    array_free(&(s->fat));

    array_free(&(s->directory));

    array_free(&(s->mapping));

    if(s->cluster_buffer)

        free(s->cluster_buffer);

}
",1
Detect whether the following code contains vulnerabilities.,"static RTSPTransportField *find_transport(RTSPMessageHeader *h, enum RTSPLowerTransport lower_transport)
{
    RTSPTransportField *th;
    int i;

    for(i=0;i<h->nb_transports;i++) {
        th = &h->transports[i];
        if (th->lower_transport == lower_transport)
            return th;
    }
    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"GF_Box *void_New()
{
	ISOM_DECL_BOX_ALLOC(GF_Box, GF_ISOM_BOX_TYPE_VOID);
	return tmp;
}",0
Detect whether the following code contains vulnerabilities.,"void f2fs_replace_block(struct f2fs_sb_info *sbi, struct dnode_of_data *dn,
				block_t old_addr, block_t new_addr,
				unsigned char version, bool recover_curseg,
				bool recover_newaddr)
{
	struct f2fs_summary sum;

	set_summary(&sum, dn->nid, dn->ofs_in_node, version);

	__f2fs_replace_block(sbi, &sum, old_addr, new_addr,
					recover_curseg, recover_newaddr);

	f2fs_update_data_blkaddr(dn, new_addr);
}",0
Detect whether the following code contains vulnerabilities.,"AVRational av_guess_frame_rate(AVFormatContext *format, AVStream *st, AVFrame *frame)

{

    AVRational fr = st->r_frame_rate;

    AVRational codec_fr = st->codec->framerate;

    AVRational   avg_fr = st->avg_frame_rate;



    if (avg_fr.num > 0 && avg_fr.den > 0 && fr.num > 0 && fr.den > 0 &&

        av_q2d(avg_fr) < 70 && av_q2d(fr) > 210) {

        fr = avg_fr;

    }





    if (st->codec->ticks_per_frame > 1) {

        if (   codec_fr.num > 0 && codec_fr.den > 0 && av_q2d(codec_fr) < av_q2d(fr)*0.7

            && fabs(1.0 - av_q2d(av_div_q(avg_fr, fr))) > 0.1)

            fr = codec_fr;

    }



    return fr;

}
",1
Detect whether the following code contains vulnerabilities.,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (!mp)
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		umount_tree(mnt, 0);
	}
	unlock_mount_hash();
	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}",1
Detect whether the following code contains vulnerabilities.,"static uint32_t virtio_net_bad_features(VirtIODevice *vdev)
{
    uint32_t features = 0;

    /* Linux kernel 2.6.25.  It understood MAC (as everyone must),
     * but also these: */
    features |= (1 << VIRTIO_NET_F_MAC);
    features |= (1 << VIRTIO_NET_F_GUEST_CSUM);
    features |= (1 << VIRTIO_NET_F_GUEST_TSO4);
    features |= (1 << VIRTIO_NET_F_GUEST_TSO6);
    features |= (1 << VIRTIO_NET_F_GUEST_ECN);

    return features & virtio_net_get_features(vdev);
}",1
Detect whether the following code contains vulnerabilities.,"gst_asf_demux_get_uint32 (guint8 ** p_data, guint64 * p_size)
{
  guint32 ret;

  g_assert (*p_size >= 4);
  ret = GST_READ_UINT32_LE (*p_data);
  *p_data += sizeof (guint32);
  *p_size -= sizeof (guint32);
  return ret;
}",0
Detect whether the following code contains vulnerabilities.,"term_is_gui(char_u *name)
{
    return (STRCMP(name, ""builtin_gui"") == 0 || STRCMP(name, ""gui"") == 0);
}",0
Detect whether the following code contains vulnerabilities.,"fixup_vorbis_headers(AVFormatContext * as, struct oggvorbis_private *priv,

                     uint8_t **buf)

{

    int i,offset, len, buf_len;

    unsigned char *ptr;



    len = priv->len[0] + priv->len[1] + priv->len[2];

    buf_len = len + len/255 + 64;

    ptr = *buf = av_realloc(NULL, buf_len);



    memset(*buf, '\0', buf_len);



    ptr[0] = 2;

    offset = 1;

    offset += av_xiphlacing(&ptr[offset], priv->len[0]);

    offset += av_xiphlacing(&ptr[offset], priv->len[1]);

    for (i = 0; i < 3; i++) {

        memcpy(&ptr[offset], priv->packet[i], priv->len[i]);

        offset += priv->len[i];

        av_freep(&priv->packet[i]);

    }

    *buf = av_realloc(*buf, offset + FF_INPUT_BUFFER_PADDING_SIZE);

    return offset;

}",1
Detect whether the following code contains vulnerabilities.,"static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);


	mod_function(&EX_T(opline->result.u.var).tmp_var,
		_get_zval_ptr_cv(&opline->op1, EX(Ts), BP_VAR_R TSRMLS_CC),
		_get_zval_ptr_cv(&opline->op2, EX(Ts), BP_VAR_R TSRMLS_CC) TSRMLS_CC);


	ZEND_VM_NEXT_OPCODE();
}",0
Detect whether the following code contains vulnerabilities.,"findmatch(oparg_T *oap, int initc)
{
    return findmatchlimit(oap, initc, 0, 0);
}",0
Detect whether the following code contains vulnerabilities.,"static void t_gen_lsl(TCGv d, TCGv a, TCGv b)

{

	TCGv t0, t_31;



	t0 = tcg_temp_new(TCG_TYPE_TL);

	t_31 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(d, a, b);



	tcg_gen_movi_tl(t_31, 31);

	tcg_gen_sub_tl(t0, t_31, b);

	tcg_gen_sar_tl(t0, t0, t_31);

	tcg_gen_and_tl(t0, t0, d);

	tcg_gen_xor_tl(d, d, t0);

	tcg_temp_free(t0);

	tcg_temp_free(t_31);

}
",1
Detect whether the following code contains vulnerabilities.,"void btrt_box_del(GF_Box *s)
{
	GF_BitRateBox *ptr = (GF_BitRateBox *)s;
	if (ptr) gf_free(ptr);
}",0
Detect whether the following code contains vulnerabilities.,"PHP_METHOD(Phar, createDefaultStub)
{
	char *index = NULL, *webindex = NULL, *stub, *error;
	int index_len = 0, webindex_len = 0;
	size_t stub_len;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|pp"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
		return;
	}

	stub = phar_create_default_stub(index, webindex, &stub_len, &error TSRMLS_CC);

	if (error) {
		zend_throw_exception_ex(phar_ce_PharException, 0 TSRMLS_CC, ""%s"", error);
		efree(error);
		return;
	}
	RETURN_STRINGL(stub, stub_len, 0);
}",0
Detect whether the following code contains vulnerabilities.,"MemoryRegionSection memory_region_find(MemoryRegion *address_space,

                                       target_phys_addr_t addr, uint64_t size)

{

    AddressSpace *as = memory_region_to_address_space(address_space);

    AddrRange range = addrrange_make(int128_make64(addr),

                                     int128_make64(size));

    FlatRange *fr = address_space_lookup(as, range);

    MemoryRegionSection ret = { .mr = NULL, .size = 0 };



    if (!fr) {

        return ret;

    }



    while (fr > as->current_map.ranges

           && addrrange_intersects(fr[-1].addr, range)) {

        --fr;

    }



    ret.mr = fr->mr;

    range = addrrange_intersection(range, fr->addr);

    ret.offset_within_region = fr->offset_in_region;

    ret.offset_within_region += int128_get64(int128_sub(range.start,

                                                        fr->addr.start));

    ret.size = int128_get64(range.size);

    ret.offset_within_address_space = int128_get64(range.start);

    ret.readonly = fr->readonly;

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_parse_offset_hole_payload(NBDStructuredReplyChunk *chunk,

                                         uint8_t *payload, uint64_t orig_offset,

                                         QEMUIOVector *qiov, Error **errp)

{

    uint64_t offset;

    uint32_t hole_size;



    if (chunk->length != sizeof(offset) + sizeof(hole_size)) {

        error_setg(errp, ""Protocol error: invalid payload for ""

                         ""NBD_REPLY_TYPE_OFFSET_HOLE"");

        return -EINVAL;

    }



    offset = payload_advance64(&payload);

    hole_size = payload_advance32(&payload);



    if (offset < orig_offset || hole_size > qiov->size ||

        offset > orig_offset + qiov->size - hole_size) {

        error_setg(errp, ""Protocol error: server sent chunk exceeding requested""

                         "" region"");

        return -EINVAL;

    }



    qemu_iovec_memset(qiov, offset - orig_offset, 0, hole_size);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void test_tls_write_cert_chain(const char *filename,

                               gnutls_x509_crt_t *certs,

                               size_t ncerts)

{

    size_t i;

    size_t capacity = 1024, offset = 0;

    char *buffer = g_new0(char, capacity);

    int err;



    for (i = 0; i < ncerts; i++) {

        size_t len = capacity - offset;

    retry:

        err = gnutls_x509_crt_export(certs[i], GNUTLS_X509_FMT_PEM,

                                     buffer + offset, &len);

        if (err < 0) {

            if (err == GNUTLS_E_SHORT_MEMORY_BUFFER) {

                buffer = g_renew(char, buffer, offset + len);

                capacity = offset + len;

                goto retry;

            }

            g_critical(""Failed to export certificate chain %s: %d"",

                       gnutls_strerror(err), err);

            abort();

        }

        offset += len;

    }



    if (!g_file_set_contents(filename, buffer, offset, NULL)) {

        abort();

    }


}",1
Detect whether the following code contains vulnerabilities.,"static void FUNCC(pred8x8_horizontal)(uint8_t *_src, int stride){

    int i;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    for(i=0; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= PIXEL_SPLAT_X4(src[-1+i*stride]);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void cmd_oper_got_pass(const char *password, OPER_PASS_REC *rec)
{
        if (*password != '\0')
		irc_send_cmdv(rec->server, ""OPER %s %s"", rec->nick, password);
	g_free(rec->nick);
        g_free(rec);
}",1
Detect whether the following code contains vulnerabilities.,"void cpu_write_xer(CPUPPCState *env, target_ulong xer)

{

    env->so = (xer >> XER_SO) & 1;

    env->ov = (xer >> XER_OV) & 1;

    env->ca = (xer >> XER_CA) & 1;

    env->xer = xer & ~((1u << XER_SO) | (1u << XER_OV) | (1u << XER_CA));

}
",1
Detect whether the following code contains vulnerabilities.,"void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic){

    int i;

    InternalBuffer *buf, *last;

    AVCodecInternal *avci = s->internal;



    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);



    assert(pic->type==FF_BUFFER_TYPE_INTERNAL);

    assert(avci->buffer_count);



    if (avci->buffer) {

        buf = NULL; /* avoids warning */

        for (i = 0; i < avci->buffer_count; i++) { //just 3-5 checks so is not worth to optimize

            buf = &avci->buffer[i];

            if (buf->data[0] == pic->data[0])

                break;

        }

        assert(i < avci->buffer_count);

        avci->buffer_count--;

        last = &avci->buffer[avci->buffer_count];



        FFSWAP(InternalBuffer, *buf, *last);

    }



    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {

        pic->data[i]=NULL;

//        pic->base[i]=NULL;

    }

//printf(""R%X\n"", pic->opaque);



    if(s->debug&FF_DEBUG_BUFFERS)

        av_log(s, AV_LOG_DEBUG, ""default_release_buffer called on pic %p, %d ""

               ""buffers used\n"", pic, avci->buffer_count);

}
",0
Detect whether the following code contains vulnerabilities.,"int snd_ctl_enum_info(struct snd_ctl_elem_info *info, unsigned int channels,
		      unsigned int items, const char *const names[])
{
	info->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
	info->count = channels;
	info->value.enumerated.items = items;
	if (!items)
		return 0;
	if (info->value.enumerated.item >= items)
		info->value.enumerated.item = items - 1;
	WARN(strlen(names[info->value.enumerated.item]) >= sizeof(info->value.enumerated.name),
	     ""ALSA: too long item name '%s'\n"",
	     names[info->value.enumerated.item]);
	strscpy(info->value.enumerated.name,
		names[info->value.enumerated.item],
		sizeof(info->value.enumerated.name));
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void t1_puts(const char *s)
{
    if (s != t1_line_array)
        strcpy(t1_line_array, s);
    t1_line_ptr = strend(t1_line_array);
    t1_putline();
}",0
Detect whether the following code contains vulnerabilities.,"static int get_importer(struct transport *transport, struct child_process *fastimport)
{
	struct child_process *helper = get_helper(transport);
	struct helper_data *data = transport->data;
	int cat_blob_fd, code;
	child_process_init(fastimport);
	fastimport->in = helper->out;
	argv_array_push(&fastimport->args, ""fast-import"");
	argv_array_push(&fastimport->args, debug ? ""--stats"" : ""--quiet"");

	if (data->bidi_import) {
		cat_blob_fd = xdup(helper->in);
		argv_array_pushf(&fastimport->args, ""--cat-blob-fd=%d"", cat_blob_fd);
	}
	fastimport->git_cmd = 1;

	code = start_command(fastimport);
	return code;
}",1
Detect whether the following code contains vulnerabilities.,"static int check_for_evdev(void)

{

    SDL_SysWMinfo info;

    XkbDescPtr desc;

    int has_evdev = 0;

    const char *keycodes;



    SDL_VERSION(&info.version);

    if (!SDL_GetWMInfo(&info))

        return 0;



    desc = XkbGetKeyboard(info.info.x11.display,

                          XkbGBN_AllComponentsMask,

                          XkbUseCoreKbd);

    if (desc == NULL || desc->names == NULL)

        return 0;



    keycodes = XGetAtomName(info.info.x11.display, desc->names->keycodes);

    if (keycodes == NULL)

        fprintf(stderr, ""could not lookup keycode name\n"");

    else if (strstart(keycodes, ""evdev"", NULL))

        has_evdev = 1;

    else if (!strstart(keycodes, ""xfree86"", NULL))

        fprintf(stderr,

                ""unknown keycodes `%s', please report to qemu-devel@nongnu.org\n"",

                keycodes);



    XkbFreeClientMap(desc, XkbGBN_AllComponentsMask, True);



    return has_evdev;

}
",1
Detect whether the following code contains vulnerabilities.,"static int sweep(void)
{
	int modified = 0;
	struct ifsock *ifs, *tmp;

	LIST_FOREACH_SAFE(ifs, &il, link, tmp) {
		if (!ifs->stale)
			continue;

		modified++;
		logit(LOG_DEBUG, ""Removing stale ifs %s"", inet_ntoa(ifs->addr.sin_addr));

		LIST_REMOVE(ifs, link);
		close(ifs->out);
		free(ifs);
	}

	return modified;
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold int vaapi_encode_h264_init_fixed_qp(AVCodecContext *avctx)

{

    VAAPIEncodeContext      *ctx = avctx->priv_data;

    VAAPIEncodeH264Context *priv = ctx->priv_data;

    VAAPIEncodeH264Options  *opt = ctx->codec_options;



    priv->fixed_qp_p = opt->qp;

    if (avctx->i_quant_factor > 0.0)

        priv->fixed_qp_idr = (int)((priv->fixed_qp_p * avctx->i_quant_factor +

                                    avctx->i_quant_offset) + 0.5);

    else

        priv->fixed_qp_idr = priv->fixed_qp_p;

    if (avctx->b_quant_factor > 0.0)

        priv->fixed_qp_b = (int)((priv->fixed_qp_p * avctx->b_quant_factor +

                                  avctx->b_quant_offset) + 0.5);

    else

        priv->fixed_qp_b = priv->fixed_qp_p;



    av_log(avctx, AV_LOG_DEBUG, ""Using fixed QP = ""

           ""%d / %d / %d for IDR- / P- / B-frames.\n"",

           priv->fixed_qp_idr, priv->fixed_qp_p, priv->fixed_qp_b);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static struct Curl_easy* gethandleathead(struct curl_llist *pipeline)
{
  struct curl_llist_element *curr = pipeline->head;
#ifdef DEBUGBUILD
  {
    struct curl_llist_element *p = pipeline->head;
    while(p) {
      struct Curl_easy *e = p->ptr;
      DEBUGASSERT(GOOD_EASY_HANDLE(e));
      p = p->next;
    }
  }
#endif
  if(curr) {
    return (struct Curl_easy *) curr->ptr;
  }

  return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"void replay_configure(QemuOpts *opts)

{

    const char *fname;

    const char *rr;

    ReplayMode mode = REPLAY_MODE_NONE;

    Location loc;



    if (!opts) {

        return;

    }



    loc_push_none(&loc);

    qemu_opts_loc_restore(opts);



    rr = qemu_opt_get(opts, ""rr"");

    if (!rr) {

        /* Just enabling icount */

        return;

    } else if (!strcmp(rr, ""record"")) {

        mode = REPLAY_MODE_RECORD;

    } else if (!strcmp(rr, ""replay"")) {

        mode = REPLAY_MODE_PLAY;

    } else {

        error_report(""Invalid icount rr option: %s"", rr);

        exit(1);

    }



    fname = qemu_opt_get(opts, ""rrfile"");

    if (!fname) {

        error_report(""File name not specified for replay"");

        exit(1);

    }



    replay_enable(fname, mode);



    loc_pop(&loc);

}
",1
Detect whether the following code contains vulnerabilities.,  bool remoteDecodeComplete() const { return state_.remote_decode_complete_; },1
Detect whether the following code contains vulnerabilities.,"int av_reallocp_array(void *ptr, size_t nmemb, size_t size)

{

    void **ptrptr = ptr;

    void *ret;

    if (size <= 0 || nmemb >= INT_MAX / size)

        return AVERROR(ENOMEM);

    if (nmemb <= 0) {

        av_freep(ptr);

        return 0;

    }

    ret = av_realloc(*ptrptr, nmemb * size);

    if (!ret) {

        av_freep(ptr);

        return AVERROR(ENOMEM);

    }

    *ptrptr = ret;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int omap_validate_emiff_addr(struct omap_mpu_state_s *s,

                target_phys_addr_t addr)

{

    return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s->sdram_size;

}
",0
Detect whether the following code contains vulnerabilities.,"void *jas_malloc(size_t size)
{
	void *result;
	jas_mb_t *mb;
	size_t ext_size;
	size_t mem;

	JAS_DBGLOG(100, (""jas_malloc(%zu)\n"", size));
#if defined(JAS_MALLOC_RETURN_NULL_PTR_FOR_ZERO_SIZE)
	if (!size) {
		return 0;
	}
#endif
	if (!jas_safe_size_add(size, JAS_MB_SIZE, &ext_size)) {
		jas_eprintf(""requested memory size is too large\n"");
		result = 0;
		mb = 0;
	} else if (!jas_safe_size_add(jas_mem, size, &mem) || mem > jas_max_mem) {
		jas_eprintf(""maximum memory limit would be exceeded\n"");
		result = 0;
		mb = 0;
	} else {
		JAS_DBGLOG(100, (""jas_malloc: ext_size=%zu\n"", ext_size));
		if ((mb = malloc(ext_size))) {
			result = jas_mb_get_data(mb);
			mb->size = size;
			jas_mem = mem;
		} else {
			result = 0;
		}
	}
	JAS_DBGLOG(99, (""jas_malloc(%zu) -> %p (mb=%p)\n"", size, result, mb));
	JAS_DBGLOG(102, (""max_mem=%zu; mem=%zu\n"", jas_max_mem, jas_mem));
	return result;
}",1
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xC(IpvideoContext *s)

{

    int x, y;



    /* 16-color block encoding: each 2x2 block is a different color */

    CHECK_STREAM_PTR(16);



    for (y = 0; y < 8; y += 2) {

        for (x = 0; x < 8; x += 2) {

            s->pixel_ptr[x                ] =

            s->pixel_ptr[x + 1            ] =

            s->pixel_ptr[x +     s->stride] =

            s->pixel_ptr[x + 1 + s->stride] = *s->stream_ptr++;

        }

        s->pixel_ptr += s->stride * 2;

    }



    /* report success */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output)

{

    AVSubtitle subtitle;

    int i, ret = avcodec_decode_subtitle2(ist->dec_ctx,

                                          &subtitle, got_output, pkt);

    if (ret < 0)

        return ret;

    if (!*got_output)

        return ret;



    ist->frames_decoded++;



    for (i = 0; i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || !ost->encoding_needed)

            continue;



        do_subtitle_out(output_files[ost->file_index]->ctx, ost, ist, &subtitle, pkt->pts);

    }



    avsubtitle_free(&subtitle);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void RateTransposer::setChannels(int nChannels)
{
    assert(nChannels > 0);

    if (pTransposer->numChannels == nChannels) return;
    pTransposer->setChannels(nChannels);

    inputBuffer.setChannels(nChannels);
    midBuffer.setChannels(nChannels);
    outputBuffer.setChannels(nChannels);
}",1
Detect whether the following code contains vulnerabilities.,"void X509Certificate::InfoAccess(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  Local<Value> ret;
  if (GetInfoString<NID_info_access>(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1
Detect whether the following code contains vulnerabilities.,"void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status,
	const u8 *desc, int length, int offset, int total_size);",1
Detect whether the following code contains vulnerabilities.,"void jspeiLoadScopesFromVar(JsVar *arr) {
  execInfo.scopeCount = 0;

  if (jsvIsArray(arr)) {
    JsvObjectIterator it;
    jsvObjectIteratorNew(&it, arr);
    while (jsvObjectIteratorHasValue(&it)) {
      execInfo.scopes[execInfo.scopeCount++] = jsvObjectIteratorGetValue(&it);
      jsvObjectIteratorNext(&it);
    }
    jsvObjectIteratorFree(&it);
  } else
    execInfo.scopes[execInfo.scopeCount++] = jsvLockAgain(arr);
}",0
Detect whether the following code contains vulnerabilities.,"BOOL nego_read_request(rdpNego* nego, wStream* s)
{
	BYTE li;
	BYTE type;
	UINT16 length;

	if (!tpkt_read_header(s, &length))
		return FALSE;

	if (!tpdu_read_connection_request(s, &li, length))
		return FALSE;

	if (li != Stream_GetRemainingLength(s) + 6)
	{
		WLog_ERR(TAG, ""Incorrect TPDU length indicator."");
		return FALSE;
	}

	if (!nego_read_request_token_or_cookie(nego, s))
	{
		WLog_ERR(TAG, ""Failed to parse routing token or cookie."");
		return FALSE;
	}

	if (Stream_GetRemainingLength(s) >= 8)
	{
		/* rdpNegData (optional) */
		Stream_Read_UINT8(s, type); /* Type */

		if (type != TYPE_RDP_NEG_REQ)
		{
			WLog_ERR(TAG, ""Incorrect negotiation request type %"" PRIu8 """", type);
			return FALSE;
		}

		nego_process_negotiation_request(nego, s);
	}

	return tpkt_ensure_stream_consumed(s, length);
}",1
Detect whether the following code contains vulnerabilities.,"new_msg_sync_lsdb (u_int32_t seqnum, struct lsa_filter_type *filter)
{
  u_char buf[OSPF_API_MAX_MSG_SIZE];
  struct msg_sync_lsdb *smsg;
  int len;

  smsg = (struct msg_sync_lsdb *) buf;
  len = sizeof (struct msg_sync_lsdb) +
    filter->num_areas * sizeof (struct in_addr);
  smsg->filter.typemask = htons (filter->typemask);
  smsg->filter.origin = filter->origin;
  smsg->filter.num_areas = filter->num_areas;
  return msg_new (MSG_SYNC_LSDB, smsg, seqnum, len);
}",1
Detect whether the following code contains vulnerabilities.,"check_cleanup_prefix_route(struct inet6_ifaddr *ifp, unsigned long *expires)
{
	struct inet6_ifaddr *ifa;
	struct inet6_dev *idev = ifp->idev;
	unsigned long lifetime;
	enum cleanup_prefix_rt_t action = CLEANUP_PREFIX_RT_DEL;

	*expires = jiffies;

	list_for_each_entry(ifa, &idev->addr_list, if_list) {
		if (ifa == ifp)
			continue;
		if (!ipv6_prefix_equal(&ifa->addr, &ifp->addr,
				       ifp->prefix_len))
			continue;
		if (ifa->flags & (IFA_F_PERMANENT | IFA_F_NOPREFIXROUTE))
			return CLEANUP_PREFIX_RT_NOP;

		action = CLEANUP_PREFIX_RT_EXPIRE;

		spin_lock(&ifa->lock);

		lifetime = addrconf_timeout_fixup(ifa->valid_lft, HZ);
		/*
		 * Note: Because this address is
		 * not permanent, lifetime <
		 * LONG_MAX / HZ here.
		 */
		if (time_before(*expires, ifa->tstamp + lifetime * HZ))
			*expires = ifa->tstamp + lifetime * HZ;
		spin_unlock(&ifa->lock);
	}

	return action;
}",0
Detect whether the following code contains vulnerabilities.,"iscsi_aio_write16_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    trace_iscsi_aio_write16_cb(iscsi, status, acb, acb->canceled);



    g_free(acb->buf);



    if (acb->canceled != 0) {

        qemu_aio_release(acb);

        scsi_free_scsi_task(acb->task);

        acb->task = NULL;

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to write16 data to iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

    scsi_free_scsi_task(acb->task);

    acb->task = NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"status WAVEFile::parseList(const Tag &id, uint32_t size)
{
	Tag typeID;
	readTag(&typeID);
	size-=4;

	if (typeID == ""adtl"")
	{
		/* Handle adtl sub-chunks. */
		return parseADTLSubChunk(typeID, size);
	}
	else if (typeID == ""INFO"")
	{
		/* Handle INFO sub-chunks. */
		return parseINFOSubChunk(typeID, size);
	}
	else
	{
		/* Skip unhandled sub-chunks. */
		m_fh->seek(size, File::SeekFromCurrent);
		return AF_SUCCEED;
	}
	return AF_SUCCEED;
}",0
Detect whether the following code contains vulnerabilities.,"float64 helper_fsmuld(CPUSPARCState *env, float32 src1, float32 src2)

{

    float64 ret;

    clear_float_exceptions(env);

    ret = float64_mul(float32_to_float64(src1, &env->fp_status),

                      float32_to_float64(src2, &env->fp_status),

                      &env->fp_status);

    check_ieee_exceptions(env);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int SafeMulDims(const matvar_t *matvar, size_t* nelems)
{
    int i;

    for ( i = 0; i < matvar->rank; i++ ) {
        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {
            *nelems = 0;
            return 1;
        }
    }

    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)
{
    Uint8 *map;
    int i;

    if (identical) {
        if (src->ncolors <= dst->ncolors) {
            /* If an identical palette, no need to map */
            if (src == dst
                ||
                (SDL_memcmp
                 (src->colors, dst->colors,
                  src->ncolors * sizeof(SDL_Color)) == 0)) {
                *identical = 1;
                return (NULL);
            }
        }
        *identical = 0;
    }
    map = (Uint8 *) SDL_malloc(src->ncolors);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < src->ncolors; ++i) {
        map[i] = SDL_FindColor(dst,
                               src->colors[i].r, src->colors[i].g,
                               src->colors[i].b, src->colors[i].a);
    }
    return (map);
}",1
Detect whether the following code contains vulnerabilities.,"stream_buffer_dispose (GObject *object)
{
	CamelStreamBufferPrivate *priv;

	priv = CAMEL_STREAM_BUFFER (object)->priv;

	if (priv->stream != NULL) {
		g_object_unref (priv->stream);
		priv->stream = NULL;
	}

	/* Chain up to parent's dispose() method. */
	G_OBJECT_CLASS (camel_stream_buffer_parent_class)->dispose (object);
}",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,

                           uint64_t off, uint32_t max_count)

{

    ssize_t err;

    size_t offset = 7;

    int read_count;

    int64_t xattr_len;

    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);

    VirtQueueElement *elem = &v->elems[pdu->idx];



    xattr_len = fidp->fs.xattr.len;

    read_count = xattr_len - off;

    if (read_count > max_count) {

        read_count = max_count;

    } else if (read_count < 0) {

        /*

         * read beyond XATTR value

         */

        read_count = 0;

    }

    err = pdu_marshal(pdu, offset, ""d"", read_count);

    if (err < 0) {

        return err;

    }

    offset += err;



    err = v9fs_pack(elem->in_sg, elem->in_num, offset,

                    ((char *)fidp->fs.xattr.value) + off,

                    read_count);

    if (err < 0) {

        return err;

    }

    offset += err;

    return offset;

}
",0
Detect whether the following code contains vulnerabilities.,"ebb_ews_convert_contact_to_xml_cb (ESoapMessage *msg,
				   gpointer user_data,
				   GError **error)
{
	EContact *contact = user_data;
	gint i, element_type;

	/* Prepare Contact node in the SOAP message */
	e_soap_message_start_element (msg, ""Contact"", NULL, NULL);

	for (i = 0; i < G_N_ELEMENTS (mappings); i++) {
		element_type = mappings[i].element_type;

		if (element_type == ELEMENT_TYPE_SIMPLE) {
			gchar *val;

			/* skip uid while creating contacts */
			if (mappings[i].field_id == E_CONTACT_UID)
				continue;

			val = e_contact_get (contact, mappings[i].field_id);
			if (val && *val)
				e_ews_message_write_string_parameter (msg, mappings[i].element_name, NULL, val);
			g_free (val);
		} else
			mappings[i].set_value_in_soap_message (msg, contact);
	}

	/* end of ""Contact"" */
	e_soap_message_end_element (msg);

	return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"void replace_all(std::string & subject, const std::string & search, const std::string & replace) {
	size_t pos = 0;
	while ((pos = subject.find(search, pos)) != std::string::npos) {
		subject.replace(pos, search.length(), replace);
		pos += replace.length();
	}
}",1
Detect whether the following code contains vulnerabilities.,"static int ntop_get_ndpi_protocol_category(lua_State* vm) {
  NetworkInterface *ntop_interface = getCurrentInterface(vm);
  u_int proto;

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TNUMBER)) return(CONST_LUA_ERROR);
  proto = (u_int)lua_tonumber(vm, 1);

  if(ntop_interface) {
    ndpi_protocol_category_t category = ntop_interface->get_ndpi_proto_category(proto);
    
    lua_newtable(vm);
    lua_push_int32_table_entry(vm, ""id"", category);
    lua_push_str_table_entry(vm, ""name"", (char*)ndpi_category_str(category));
  } else
    lua_pushnil(vm);

  return(CONST_LUA_OK);
}",0
Detect whether the following code contains vulnerabilities.,"static int ath6kl_wmi_rx_probe_req_event_rx(struct wmi *wmi, u8 *datap, int len,
					    struct ath6kl_vif *vif)
{
	struct wmi_p2p_rx_probe_req_event *ev;
	u32 freq;
	u16 dlen;

	if (len < sizeof(*ev))
		return -EINVAL;

	ev = (struct wmi_p2p_rx_probe_req_event *) datap;
	freq = le32_to_cpu(ev->freq);
	dlen = le16_to_cpu(ev->len);
	if (datap + len < ev->data + dlen) {
		ath6kl_err(""invalid wmi_p2p_rx_probe_req_event: len=%d dlen=%u\n"",
			   len, dlen);
		return -EINVAL;
	}
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""rx_probe_req: len=%u freq=%u probe_req_report=%d\n"",
		   dlen, freq, vif->probe_req_report);

	if (vif->probe_req_report || vif->nw_type == AP_NETWORK)
		cfg80211_rx_mgmt(&vif->wdev, freq, 0, ev->data, dlen, 0);

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static void trigger_prot_fault(CPUS390XState *env, target_ulong vaddr,

                               uint64_t mode)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int ilen = ILEN_LATER_INC;

    int bits = trans_bits(env, mode) | 4;



    DPRINTF(""%s: vaddr=%016"" PRIx64 "" bits=%d\n"", __func__, vaddr, bits);



    stq_phys(cs->as,

             env->psa + offsetof(LowCore, trans_exc_code), vaddr | bits);

    trigger_pgm_exception(env, PGM_PROTECTION, ilen);

}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err gf_isom_text_add_karaoke(GF_TextSample *samp, u32 start_time)
{
	if (!samp) return GF_BAD_PARAM;
	samp->cur_karaoke = (GF_TextKaraokeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_KROK);
	if (!samp->cur_karaoke) return GF_OUT_OF_MEM;
	samp->cur_karaoke->highlight_starttime = start_time;
	return gf_list_add(samp->others, samp->cur_karaoke);
}",0
Detect whether the following code contains vulnerabilities.,"void qxl_render_resize(PCIQXLDevice *qxl)

{

    QXLSurfaceCreate *sc = &qxl->guest_primary.surface;



    qxl->guest_primary.stride = sc->stride;

    qxl->guest_primary.resized++;

    switch (sc->format) {

    case SPICE_SURFACE_FMT_16_555:

        qxl->guest_primary.bytes_pp = 2;

        qxl->guest_primary.bits_pp = 15;

        break;

    case SPICE_SURFACE_FMT_16_565:

        qxl->guest_primary.bytes_pp = 2;

        qxl->guest_primary.bits_pp = 16;

        break;

    case SPICE_SURFACE_FMT_32_xRGB:

    case SPICE_SURFACE_FMT_32_ARGB:

        qxl->guest_primary.bytes_pp = 4;

        qxl->guest_primary.bits_pp = 32;

        break;

    default:

        fprintf(stderr, ""%s: unhandled format: %x\n"", __FUNCTION__,

                qxl->guest_primary.surface.format);

        qxl->guest_primary.bytes_pp = 4;

        qxl->guest_primary.bits_pp = 32;

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void BrotliContext::resetOut() {
  avail_out_ = chunk_size_;
  next_out_ = chunk_ptr_.get();
}",0
Detect whether the following code contains vulnerabilities.,"static void load_tco(const TestData *d)

{

    qpci_io_writew(d->dev, d->tco_io_base + TCO_RLD, 4);

}
",1
Detect whether the following code contains vulnerabilities.,"Status GetInputList(OpKernelContext* c, int index, const TensorList** list) {
  if (!TensorShapeUtils::IsScalar(c->input(index).shape())) {
    return errors::InvalidArgument(""Input list must be a scalar saw: "",
                                   c->input(index).shape().DebugString());
  }
  const TensorList* l = c->input(index).scalar<Variant>()().get<TensorList>();
  if (l == nullptr) {
    return errors::InvalidArgument(
        ""Input handle is not a list. Saw: '"",
        c->input(index).scalar<Variant>()().DebugString(), ""'"");
  }
  *list = l;
  return Status::OK();
}",0
Detect whether the following code contains vulnerabilities.,"static MemTxResult memory_region_oldmmio_read_accessor(MemoryRegion *mr,

                                                       hwaddr addr,

                                                       uint64_t *value,

                                                       unsigned size,

                                                       unsigned shift,

                                                       uint64_t mask,

                                                       MemTxAttrs attrs)

{

    uint64_t tmp;



    tmp = mr->ops->old_mmio.read[ctz32(size)](mr->opaque, addr);

    if (mr->subpage) {

        trace_memory_region_subpage_read(get_cpu_index(), mr, addr, tmp, size);






    } else if (TRACE_MEMORY_REGION_OPS_READ_ENABLED) {

        hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);

        trace_memory_region_ops_read(get_cpu_index(), mr, abs_addr, tmp, size);

    }

    *value |= (tmp & mask) << shift;

    return MEMTX_OK;

}",1
Detect whether the following code contains vulnerabilities.,"Assign(asdl_seq * targets, expr_ty value, int lineno, int col_offset, int
       end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!value) {
        PyErr_SetString(PyExc_ValueError,
                        ""field value is required for Assign"");
        return NULL;
    }
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = Assign_kind;
    p->v.Assign.targets = targets;
    p->v.Assign.value = value;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}",1
Detect whether the following code contains vulnerabilities.,"tty_open(struct tty *tty, char **cause)
{
	tty->term = tty_term_find(tty->term_name, tty->fd, cause);
	if (tty->term == NULL) {
		tty_close(tty);
		return (-1);
	}
	tty->flags |= TTY_OPENED;

	tty->flags &= ~(TTY_NOCURSOR|TTY_FREEZE|TTY_BLOCK|TTY_TIMER);

	event_set(&tty->event_in, tty->fd, EV_PERSIST|EV_READ,
	    tty_read_callback, tty);
	tty->in = evbuffer_new();

	event_set(&tty->event_out, tty->fd, EV_WRITE, tty_write_callback, tty);
	tty->out = evbuffer_new();

	evtimer_set(&tty->timer, tty_timer_callback, tty);

	tty_start_tty(tty);

	tty_keys_build(tty);

	return (0);
}",1
Detect whether the following code contains vulnerabilities.,"static void vp8_decode_flush(AVCodecContext *avctx)

{

    vp8_decode_flush_impl(avctx, 0, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"static void fifo_deinit(AVFormatContext *avf)

{

    FifoContext *fifo = avf->priv_data;



    av_dict_free(&fifo->format_options);

    avformat_free_context(fifo->avf);

    av_thread_message_queue_free(&fifo->queue);

    pthread_mutex_destroy(&fifo->overflow_flag_lock);

}
",1
Detect whether the following code contains vulnerabilities.,"ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,

                                              const char *typename,

                                              const char *file, int line,

                                              const char *func)

{

    ObjectClass *ret = object_class_dynamic_cast(class, typename);



    if (!ret && class) {

        fprintf(stderr, ""%s:%d:%s: Object %p is not an instance of type %s\n"",

                file, line, func, class, typename);

        abort();

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"QUtil::setRandomDataProvider(RandomDataProvider* p)
{
    random_data_provider = p;
}",0
Detect whether the following code contains vulnerabilities.,"void qga_vss_fsfreeze(int *nr_volume, Error **errp, bool freeze)

{

    const char *func_name = freeze ? ""requester_freeze"" : ""requester_thaw"";

    QGAVSSRequesterFunc func;

    ErrorSet errset = {

        .error_setg_win32 = error_setg_win32,

        .errp = errp,

    };



    g_assert(errp);             /* requester.cpp requires it */

    func = (QGAVSSRequesterFunc)GetProcAddress(provider_lib, func_name);

    if (!func) {

        error_setg_win32(errp, GetLastError(), ""failed to load %s from %s"",

                         func_name, QGA_VSS_DLL);

        return;

    }



    func(nr_volume, &errset);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_eval_bgu(TCGv dst, TCGv_i32 src)

{

    gen_mov_reg_Z(cpu_tmp0, src);

    gen_mov_reg_C(dst, src);

    tcg_gen_or_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_op_mull_T0_T1(void)

{

    TCGv tmp1 = tcg_temp_new(TCG_TYPE_I64);

    TCGv tmp2 = tcg_temp_new(TCG_TYPE_I64);



    tcg_gen_extu_i32_i64(tmp1, cpu_T[0]);

    tcg_gen_extu_i32_i64(tmp2, cpu_T[1]);

    tcg_gen_mul_i64(tmp1, tmp1, tmp2);

    tcg_gen_trunc_i64_i32(cpu_T[0], tmp1);

    tcg_gen_shri_i64(tmp1, tmp1, 32);

    tcg_gen_trunc_i64_i32(cpu_T[1], tmp1);

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t error_mem_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    abort();

}
",1
Detect whether the following code contains vulnerabilities.,"static void cpu_sh4_reset(CPUSH4State * env)
{
#if defined(CONFIG_USER_ONLY)
    env->sr = 0;
#else
    env->sr = SR_MD | SR_RB | SR_BL | SR_I3 | SR_I2 | SR_I1 | SR_I0;
#endif
    env->vbr = 0;
    env->pc = 0xA0000000;
#if defined(CONFIG_USER_ONLY)
    env->fpscr = FPSCR_PR; /* value for userspace according to the kernel */
    set_float_rounding_mode(float_round_nearest_even, &env->fp_status); /* ?! */
#else
    env->fpscr = 0x00040001; /* CPU reset value according to SH4 manual */
    set_float_rounding_mode(float_round_to_zero, &env->fp_status);
#endif
    env->mmucr = 0;",1
Detect whether the following code contains vulnerabilities.,"TPM2B_NAME_Marshal(TPM2B_NAME *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}",1
Detect whether the following code contains vulnerabilities.,"static void rtas_display_character(sPAPREnvironment *spapr,

                                   uint32_t token, uint32_t nargs,

                                   target_ulong args,

                                   uint32_t nret, target_ulong rets)

{

    uint8_t c = rtas_ld(args, 0);

    VIOsPAPRDevice *sdev = vty_lookup(spapr, 0);



    if (!sdev) {

        rtas_st(rets, 0, -1);

    } else {

        vty_putchars(sdev, &c, sizeof(c));

        rtas_st(rets, 0, 0);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static NetSocketState *net_socket_fd_init(VLANState *vlan,

                                          const char *model, const char *name,

                                          int fd, int is_connected)

{

    int so_type=-1, optlen=sizeof(so_type);



    if(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&so_type,

        (socklen_t *)&optlen)< 0) {

	fprintf(stderr, ""qemu: error: getsockopt(SO_TYPE) for fd=%d failed\n"", fd);

	return NULL;

    }

    switch(so_type) {

    case SOCK_DGRAM:

        return net_socket_fd_init_dgram(vlan, model, name, fd, is_connected);

    case SOCK_STREAM:

        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);

    default:

        /* who knows ... this could be a eg. a pty, do warn and continue as stream */

        fprintf(stderr, ""qemu: warning: socket type=%d for fd=%d is not SOCK_DGRAM or SOCK_STREAM\n"", so_type, fd);

        return net_socket_fd_init_stream(vlan, model, name, fd, is_connected);

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static VncJobQueue *vnc_queue_init(void)

{

    VncJobQueue *queue = g_malloc0(sizeof(VncJobQueue));



    qemu_cond_init(&queue->cond);

    qemu_mutex_init(&queue->mutex);

    QTAILQ_INIT(&queue->jobs);

    return queue;

}
",1
Detect whether the following code contains vulnerabilities.,"static void expire_timers(struct timer_base *base, struct hlist_head *head)
{
	while (!hlist_empty(head)) {
		struct timer_list *timer;
		void (*fn)(unsigned long);
		unsigned long data;

		timer = hlist_entry(head->first, struct timer_list, entry);
		timer_stats_account_timer(timer);

		base->running_timer = timer;
		detach_timer(timer, true);

		fn = timer->function;
		data = timer->data;

		if (timer->flags & TIMER_IRQSAFE) {
			spin_unlock(&base->lock);
			call_timer_fn(timer, fn, data);
			spin_lock(&base->lock);
		} else {
			spin_unlock_irq(&base->lock);
			call_timer_fn(timer, fn, data);
			spin_lock_irq(&base->lock);
		}
	}
}",1
Detect whether the following code contains vulnerabilities.,"int vmci_transport_send_read(struct sock *sk)
{
	return vmci_transport_send_control_pkt(
					sk, VMCI_TRANSPORT_PACKET_TYPE_READ, 0,
					0, NULL, VSOCK_PROTO_INVALID,
					VMCI_INVALID_HANDLE);
}",0
Detect whether the following code contains vulnerabilities.,"TfLiteRegistration* Register_TRANSPOSECONV_REF() {
  static TfLiteRegistration r = {
      transpose_conv::Init, transpose_conv::Free,
      transpose_conv::Prepare<transpose_conv::kReference>,
      transpose_conv::Eval<transpose_conv::kReference>};
  return &r;
}",0
Detect whether the following code contains vulnerabilities.,"static int fd_close(MigrationState *s)

{

    DPRINTF(""fd_close\n"");

    if (s->fd != -1) {

        close(s->fd);

        s->fd = -1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_mux(CharDriverState *drv)

{

    CharDriverState *chr;

    MuxDriver *d;



    chr = qemu_chr_alloc();

    d = g_malloc0(sizeof(MuxDriver));



    chr->opaque = d;

    d->drv = drv;

    d->focus = -1;

    chr->chr_write = mux_chr_write;

    chr->chr_update_read_handler = mux_chr_update_read_handler;

    chr->chr_accept_input = mux_chr_accept_input;

    /* Frontend guest-open / -close notification is not support with muxes */

    chr->chr_set_fe_open = NULL;

    if (drv->chr_add_watch) {

        chr->chr_add_watch = mux_chr_add_watch;

    }

    /* only default to opened state if we've realized the initial

     * set of muxes

     */

    chr->explicit_be_open = muxes_realized ? 0 : 1;

    chr->is_mux = 1;



    return chr;

}
",1
Detect whether the following code contains vulnerabilities.,"MagickExport ChannelType SetImageChannelMask(Image *image,
  const ChannelType channel_mask)
{
  return(SetPixelChannelMask(image,channel_mask));
}",0
Detect whether the following code contains vulnerabilities.,"static void *vmstate_base_addr(void *opaque, VMStateField *field, bool alloc)

{

    void *base_addr = opaque + field->offset;



    if (field->flags & VMS_POINTER) {

        if (alloc && (field->flags & VMS_ALLOC)) {

            gsize size = 0;

            if (field->flags & VMS_VBUFFER) {

                size = vmstate_size(opaque, field);

            } else {

                int n_elems = vmstate_n_elems(opaque, field);

                if (n_elems) {

                    size = n_elems * field->size;

                }

            }

            if (size) {

                *((void **)base_addr + field->start) = g_malloc(size);

            }

        }

        base_addr = *(void **)base_addr + field->start;

    }



    return base_addr;

}
",1
Detect whether the following code contains vulnerabilities.,"RZ_API const char *rz_bin_dwarf_get_lang_name(ut64 lang) {
	if (lang >= RZ_ARRAY_SIZE(dwarf_langs)) {
		return NULL;
	}
	return dwarf_langs[lang];
}",0
Detect whether the following code contains vulnerabilities.,"static inline void free_chunk(struct audit_chunk *chunk)
{
	call_rcu(&chunk->head, __free_chunk);
}",1
Detect whether the following code contains vulnerabilities.,"int longLatFromMember(robj *zobj, robj *member, double *xy) {
    double score = 0;

    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
    if (!decodeGeohash(score, xy)) return C_ERR;
    return C_OK;
}",0
Detect whether the following code contains vulnerabilities.,"static int decode_end(AVCodecContext * avctx)

{

    KmvcContext *const c = (KmvcContext *) avctx->priv_data;



    if (c->frm0)

        av_free(c->frm0);

    if (c->frm1)

        av_free(c->frm1);

    if (c->pic.data[0])

        avctx->release_buffer(avctx, &c->pic);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pcrypt_free(struct crypto_instance *inst)
{
	struct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);

	crypto_drop_aead(&ctx->spawn);
	kfree(inst);
}",1
Detect whether the following code contains vulnerabilities.,"static inline int range_get_symbol(APEContext * ctx,

                                   const uint32_t counts[],

                                   const uint16_t counts_diff[])

{

    int symbol, cf;



    cf = range_decode_culshift(ctx, 16);










    /* figure out the symbol inefficiently; a binary search would be much better */

    for (symbol = 0; counts[symbol + 1] <= cf; symbol++);



    range_decode_update(ctx, counts_diff[symbol], counts[symbol]);



",1
Detect whether the following code contains vulnerabilities.,"int Init_v9(void) {
int i;

	output_templates = NULL;

	cache.lookup_info	    = (struct element_param_s *)calloc(65536, sizeof(struct element_param_s));
	cache.common_extensions = (uint32_t *)malloc((Max_num_extensions+1)*sizeof(uint32_t));
	if ( !cache.common_extensions || !cache.lookup_info ) {
		syslog(LOG_ERR, ""Process_v9: Panic! malloc(): %s line %d: %s"", __FILE__, __LINE__, strerror (errno));
		return 0;
	}

	// init the helper element table
	for (i=1; v9_element_map[i].id != 0; i++ ) {
		uint32_t Type = v9_element_map[i].id;
		// multiple same type - save first index only
		// iterate through same Types afterwards
		if ( cache.lookup_info[Type].index == 0 ) 
			cache.lookup_info[Type].index  = i;
	}
	cache.max_v9_elements = i;

	syslog(LOG_DEBUG,""Init v9: Max number of v9 tags: %u"", cache.max_v9_elements);


	return 1;
	
} // End of Init_v9",1
Detect whether the following code contains vulnerabilities.,"static coroutine_fn int quorum_co_flush(BlockDriverState *bs)

{

    BDRVQuorumState *s = bs->opaque;

    QuorumVoteVersion *winner = NULL;

    QuorumVotes error_votes;

    QuorumVoteValue result_value;

    int i;

    int result = 0;



    QLIST_INIT(&error_votes.vote_list);

    error_votes.compare = quorum_64bits_compare;



    for (i = 0; i < s->num_children; i++) {

        result = bdrv_co_flush(s->children[i]->bs);

        result_value.l = result;

        quorum_count_vote(&error_votes, &result_value, i);

    }



    winner = quorum_get_vote_winner(&error_votes);

    result = winner->value.l;



    quorum_free_vote_list(&error_votes);



    return result;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_disconnect_finish(VncState *vs)

{

    if (vs->input.buffer) qemu_free(vs->input.buffer);

    if (vs->output.buffer) qemu_free(vs->output.buffer);

#ifdef CONFIG_VNC_TLS

    vnc_tls_client_cleanup(vs);

#endif /* CONFIG_VNC_TLS */

#ifdef CONFIG_VNC_SASL

    vnc_sasl_client_cleanup(vs);

#endif /* CONFIG_VNC_SASL */

    audio_del(vs);



    VncState *p, *parent = NULL;

    for (p = vs->vd->clients; p != NULL; p = p->next) {

        if (p == vs) {

            if (parent)

                parent->next = p->next;

            else

                vs->vd->clients = p->next;

            break;

        }

        parent = p;

    }

    if (!vs->vd->clients)

        dcl->idle = 1;



    vnc_remove_timer(vs->vd);

    qemu_free(vs);

}
",0
Detect whether the following code contains vulnerabilities.,"bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,
                              const CString& sModPath, CString& sRetMsg) {
    ModInfo.SetName(sModule);
    ModInfo.SetPath(sModPath);

    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);
    if (!p) return false;

    dlclose(p);

    return true;
}",1
Detect whether the following code contains vulnerabilities.,"TPMI_ALG_MAC_SCHEME_Unmarshal(TPMI_ALG_MAC_SCHEME *target, BYTE **buffer, INT32 *size, BOOL allowNull)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_ALG_ID_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
#if ALG_SHA1
	  case TPM_ALG_SHA1:
#endif
#if ALG_SHA256	
	  case TPM_ALG_SHA256:
#endif
#if ALG_SHA384
	  case 	TPM_ALG_SHA384:
#endif
#if ALG_SHA512
	  case 	TPM_ALG_SHA512:
#endif
#if ALG_SM3_256
	  case TPM_ALG_SM3_256:
#endif
#if ALG_CMAC
	  case TPM_ALG_CMAC:
#endif
	    break;
	  case TPM_ALG_NULL:
	    if (allowNull) {
		break;
	    }
	  default:
	    rc = TPM_RC_SYMMETRIC;
	}
    }
    return rc;
}",1
Detect whether the following code contains vulnerabilities.,"static int send_full_color_rect(VncState *vs, int x, int y, int w, int h)
{
    int stream = 0;
    ssize_t bytes;

#ifdef CONFIG_VNC_PNG
    if (tight_can_send_png_rect(vs, w, h)) {
        return send_png_rect(vs, x, y, w, h, NULL);
    }
#endif

    vnc_write_u8(vs, stream << 4); /* no flushing, no filter */

    if (vs->tight.pixel24) {
        tight_pack24(vs, vs->tight.tight.buffer, w * h, &vs->tight.tight.offset);
        bytes = 3;
    } else {
        bytes = vs->client_pf.bytes_per_pixel;
    }

    bytes = tight_compress_data(vs, stream, w * h * bytes,
                                tight_conf[vs->tight.compression].raw_zlib_level,
                                Z_DEFAULT_STRATEGY);

    return (bytes >= 0);
}",1
Detect whether the following code contains vulnerabilities.,"ZEND_VM_HELPER(zend_bw_and_helper, ANY, ANY, zval *op_1, zval *op_2)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (UNEXPECTED(Z_TYPE_INFO_P(op_1) == IS_UNDEF)) {
		op_1 = ZVAL_UNDEFINED_OP1();
	}
	if (UNEXPECTED(Z_TYPE_INFO_P(op_2) == IS_UNDEF)) {
		op_2 = ZVAL_UNDEFINED_OP2();
	}
	bitwise_and_function(EX_VAR(opline->result.var), op_1, op_2);
	if (OP1_TYPE & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_1);
	}
	if (OP2_TYPE & (IS_TMP_VAR|IS_VAR)) {
		zval_ptr_dtor_nogc(op_2);
	}
	ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}",0
Detect whether the following code contains vulnerabilities.,"zzip_mem_entry_fopen(ZZIP_MEM_DISK * dir, ZZIP_MEM_ENTRY * entry)
{
    /* keep this in sync with zzip_disk_entry_fopen */
    ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_MEM_DISK_FILE));
    if (! file)
        return file;
    file->buffer = dir->disk->buffer;
    file->endbuf = dir->disk->endbuf;
    file->avail = zzip_mem_entry_usize(entry);

    if (! file->avail || zzip_mem_entry_data_stored(entry))
        { file->stored = zzip_mem_entry_to_data (entry); return file; }

    file->stored = 0;
    file->zlib.opaque = 0;
    file->zlib.zalloc = Z_NULL;
    file->zlib.zfree = Z_NULL;
    file->zlib.avail_in = zzip_mem_entry_csize(entry);
    file->zlib.next_in = zzip_mem_entry_to_data(entry);

    if (! zzip_mem_entry_data_deflated(entry) ||
        inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK)
        { free (file); return 0; }

    return file;
}",1
Detect whether the following code contains vulnerabilities.,"static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,

                             ram_addr_t memory, ram_addr_t region_offset)

{

    int idx, eidx;



    if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)

        return -1;

    idx = SUBPAGE_IDX(start);

    eidx = SUBPAGE_IDX(end);

#if defined(DEBUG_SUBPAGE)

    printf(""%s: %p start %08x end %08x idx %08x eidx %08x mem %ld\n"", __func__,

           mmio, start, end, idx, eidx, memory);

#endif



    memory = (memory >> IO_MEM_SHIFT) & (IO_MEM_NB_ENTRIES - 1);

    for (; idx <= eidx; idx++) {

        mmio->sub_io_index[idx] = memory;

        mmio->region_offset[idx] = region_offset;

    }



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void finish_object(struct object *obj,
			  struct strbuf *path, const char *name,
			  void *cb_data)
{
	struct rev_list_info *info = cb_data;
	if (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))
		die(""missing blob object '%s'"", oid_to_hex(&obj->oid));
	if (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)
		parse_object(obj->oid.hash);
}",1
Detect whether the following code contains vulnerabilities.,"int xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta)
{
	struct xt_af *xp = &xt[af];

	WARN_ON(!mutex_is_locked(&xt[af].compat_mutex));

	if (WARN_ON(!xp->compat_tab))
		return -ENOMEM;

	if (xp->cur >= xp->number)
		return -EINVAL;

	if (xp->cur)
		delta += xp->compat_tab[xp->cur - 1].delta;
	xp->compat_tab[xp->cur].offset = offset;
	xp->compat_tab[xp->cur].delta = delta;
	xp->cur++;
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static int blk_get_request(struct XenBlkDev *blkdev, struct ioreq *ioreq, RING_IDX rc)

{

    switch (blkdev->protocol) {

    case BLKIF_PROTOCOL_NATIVE:

        memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),

               sizeof(ioreq->req));

        break;

    case BLKIF_PROTOCOL_X86_32:

        blkif_get_x86_32_req(&ioreq->req,

                             RING_GET_REQUEST(&blkdev->rings.x86_32_part, rc));

        break;

    case BLKIF_PROTOCOL_X86_64:

        blkif_get_x86_64_req(&ioreq->req,

                             RING_GET_REQUEST(&blkdev->rings.x86_64_part, rc));

        break;

    }



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static int sctp_getsockopt_maxburst(struct sock *sk, int len,
				    char __user *optval,
				    int __user *optlen)
{
	struct sctp_assoc_value params;
	struct sctp_sock *sp;
	struct sctp_association *asoc;

	if (len == sizeof(int)) {
		pr_warn(""Use of int in max_burst socket option deprecated\n"");
		pr_warn(""Use struct sctp_assoc_value instead\n"");
		params.assoc_id = 0;
	} else if (len >= sizeof(struct sctp_assoc_value)) {
		len = sizeof(struct sctp_assoc_value);
		if (copy_from_user(&params, optval, len))
			return -EFAULT;
	} else
		return -EINVAL;

	sp = sctp_sk(sk);

	if (params.assoc_id != 0) {
		asoc = sctp_id2assoc(sk, params.assoc_id);
		if (!asoc)
			return -EINVAL;
		params.assoc_value = asoc->max_burst;
	} else
		params.assoc_value = sp->max_burst;

	if (len == sizeof(int)) {
		if (copy_to_user(optval, &params.assoc_value, len))
			return -EFAULT;
	} else {
		if (copy_to_user(optval, &params, len))
			return -EFAULT;
	}

	return 0;

}",0
Detect whether the following code contains vulnerabilities.,"find_with_resource_array(WinLibrary *fi, WinResource *wr, const char *id)
{
    int c, rescnt;
    WinResource *return_wr;

    wr = list_resources(fi, wr, &rescnt);
    if (wr == NULL)
        return NULL;

    for (c = 0 ; c < rescnt ; c++) {
        if (compare_resource_id (&wr[c], id)) {
            /* duplicate WinResource and return it */
            return_wr = xmalloc(sizeof(WinResource));
            memcpy(return_wr, &wr[c], sizeof(WinResource));

            /* free old WinResource */
            free(wr);
            return return_wr;
        }
    }

    return NULL;
}",0
Detect whether the following code contains vulnerabilities.,"#endif

    // [internal] Sorting function, used by cimg::files().
    inline int _sort_files(const void* a, const void* b) {",0
Detect whether the following code contains vulnerabilities.,"xmlXPathNsLookup(xmlXPathContextPtr ctxt, const xmlChar *prefix) {
    if (ctxt == NULL)
	return(NULL);
    if (prefix == NULL)
	return(NULL);

#ifdef XML_XML_NAMESPACE
    if (xmlStrEqual(prefix, (const xmlChar *) ""xml""))
	return(XML_XML_NAMESPACE);
#endif

    if (ctxt->namespaces != NULL) {
	int i;

	for (i = 0;i < ctxt->nsNr;i++) {
	    if ((ctxt->namespaces[i] != NULL) &&
		(xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))
		return(ctxt->namespaces[i]->href);
	}
    }

    return((const xmlChar *) xmlHashLookup(ctxt->nsHash, prefix));
}",0
Detect whether the following code contains vulnerabilities.,"static void opt_frame_pix_fmt(const char *arg)

{

    if (strcmp(arg, ""list""))

        frame_pix_fmt = avcodec_get_pix_fmt(arg);

    else {

        list_fmts(avcodec_pix_fmt_string, PIX_FMT_NB);

        av_exit(0);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"std::string color_profile_nclx::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << indent << ""colour_primaries: "" << m_colour_primaries << ""\n""
       << indent << ""transfer_characteristics: "" << m_transfer_characteristics << ""\n""
       << indent << ""matrix_coefficients: "" << m_matrix_coefficients << ""\n""
       << indent << ""full_range_flag: "" << m_full_range_flag << ""\n"";
  return sstr.str();
}",0
Detect whether the following code contains vulnerabilities.,"int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,
                     const bool bypass) {
  /* This will be reset when sync callback is called.
   * Should we set wsrep_ready to false here too? */
  local_status.set(wsrep::server_state::s_donor);

  const char *method = msg.data();
  size_t method_len = strlen(method);
  const char *data = method + method_len + 1;

  wsp::env env(NULL);
  if (env.error()) {
    WSREP_ERROR(""wsrep_sst_donate_cb(): env var ctor failed: %d"", -env.error());
    return WSREP_CB_FAILURE;
  }

#if 0
  /* Wait for wsrep-SE to initialize that also signals
  completion of init_server_component which is important before we initiate
  any meangiful action especially DONOR action from this node. */
  while (!wsrep_is_SE_initialized()) {
    sleep(1);
    THD *applier_thd = static_cast<THD *>(recv_ctx);
    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;
  }
#endif

  int ret;
  ret = sst_donate_other(method, data, current_gtid, bypass, env());

  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);
}",1
Detect whether the following code contains vulnerabilities.,"static int aio_epoll(AioContext *ctx, GPollFD *pfds,

                     unsigned npfd, int64_t timeout)

{

    assert(false);

}
",0
Detect whether the following code contains vulnerabilities.,"  AcceptedSocketImpl(IoHandlePtr&& io_handle, const Address::InstanceConstSharedPtr& local_address,
                     const Address::InstanceConstSharedPtr& remote_address)
      : ConnectionSocketImpl(std::move(io_handle), local_address, remote_address) {}",1
Detect whether the following code contains vulnerabilities.,"static void udp_chr_close(CharDriverState *chr)

{

    NetCharDriver *s = chr->opaque;

    if (s->tag) {

        g_source_remove(s->tag);

        s->tag = 0;

    }

    if (s->chan) {

        g_io_channel_unref(s->chan);

        closesocket(s->fd);

    }

    g_free(s);

    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);

}
",1
Detect whether the following code contains vulnerabilities.,"static int io_open_default(AVFormatContext *s, AVIOContext **pb,
                           const char *url, int flags, AVDictionary **options)
{
#if FF_API_OLD_OPEN_CALLBACKS
FF_DISABLE_DEPRECATION_WARNINGS
    if (s->open_cb)
        return s->open_cb(s, pb, url, flags, &s->interrupt_callback, options);
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    return ffio_open_whitelist(pb, url, flags, &s->interrupt_callback, options, s->protocol_whitelist, s->protocol_blacklist);
}",1
Detect whether the following code contains vulnerabilities.,"static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)
{
	/* The address will be sent first */
	u8 addr = i2c_8bit_addr_from_msg(msg);
	pec = i2c_smbus_pec(pec, &addr, 1);

	/* The data buffer follows */
	return i2c_smbus_pec(pec, msg->buf, msg->len);
}",0
Detect whether the following code contains vulnerabilities.,"static void input_dev_toggle(struct input_dev *dev, bool activate)
{
	if (!dev->event)
		return;

	INPUT_DO_TOGGLE(dev, LED, led, activate);
	INPUT_DO_TOGGLE(dev, SND, snd, activate);

	if (activate && test_bit(EV_REP, dev->evbit)) {
		dev->event(dev, EV_REP, REP_PERIOD, dev->rep[REP_PERIOD]);
		dev->event(dev, EV_REP, REP_DELAY, dev->rep[REP_DELAY]);
	}
}",0
Detect whether the following code contains vulnerabilities.,"static void qmp_input_end_list(Visitor *v)

{

    QmpInputVisitor *qiv = to_qiv(v);



    qmp_input_pop(qiv, &error_abort);

}
",1
Detect whether the following code contains vulnerabilities.,"oal_download_response_cb (SoupSession *soup_session,
                          SoupMessage *soup_message,
                          gpointer user_data)
{
	GSimpleAsyncResult *simple;
	struct _oal_req_data *data;

	simple = G_SIMPLE_ASYNC_RESULT (user_data);
	data = g_simple_async_result_get_op_res_gpointer (simple);

	if (ews_connection_credentials_failed (data->cnc, soup_message, simple)) {
		g_unlink (data->cache_filename);
	} else if (soup_message->status_code != 200) {
		g_simple_async_result_set_error (
			simple, SOUP_HTTP_ERROR,
			soup_message->status_code,
			""%d %s"",
			soup_message->status_code,
			soup_message->reason_phrase);
		g_unlink (data->cache_filename);

	} else if (data->error != NULL) {
		g_simple_async_result_take_error (simple, data->error);
		data->error = NULL;
		g_unlink (data->cache_filename);
	}

	e_ews_debug_dump_raw_soup_response (soup_message);

	g_simple_async_result_complete_in_idle (simple);
	e_ews_connection_utils_unref_in_thread (simple);
}",1
Detect whether the following code contains vulnerabilities.,"uint64_t ssh_scp_request_get_size64(ssh_scp scp){
  if(scp==NULL)
      return 0;
  return scp->filelen;
}",1
Detect whether the following code contains vulnerabilities.,"  void timeoutExpired() noexcept override {
    FAIL() << ""test timed out"";
    eventBase_->terminateLoopSoon();
  }",0
Detect whether the following code contains vulnerabilities.,"static inline void timer_stats_hrtimer_set_start_info(struct hrtimer *timer)
{
#ifdef CONFIG_TIMER_STATS
	if (timer->start_site)
		return;
	timer->start_site = __builtin_return_address(0);
	memcpy(timer->start_comm, current->comm, TASK_COMM_LEN);
	timer->start_pid = current->pid;
#endif
}",1
Detect whether the following code contains vulnerabilities.,"static inline int load_segment(uint32_t *e1_ptr, uint32_t *e2_ptr,

                               int selector)

{

    SegmentCache *dt;

    int index;

    uint8_t *ptr;



    if (selector & 0x4)

        dt = &env->ldt;

    else

        dt = &env->gdt;

    index = selector & ~7;

    if ((index + 7) > dt->limit)

        return -1;

    ptr = dt->base + index;

    *e1_ptr = ldl_kernel(ptr);

    *e2_ptr = ldl_kernel(ptr + 4);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static bool aio_dispatch(AioContext *ctx)

{

    AioHandler *node;

    bool progress = false;



    /*

     * We have to walk very carefully in case qemu_aio_set_fd_handler is

     * called while we're walking.

     */

    node = QLIST_FIRST(&ctx->aio_handlers);

    while (node) {

        AioHandler *tmp;

        int revents;



        ctx->walking_handlers++;



        revents = node->pfd.revents & node->pfd.events;

        node->pfd.revents = 0;



        if (!node->deleted &&

            (revents & (G_IO_IN | G_IO_HUP | G_IO_ERR)) &&

            node->io_read) {

            node->io_read(node->opaque);

            progress = true;

        }

        if (!node->deleted &&

            (revents & (G_IO_OUT | G_IO_ERR)) &&

            node->io_write) {

            node->io_write(node->opaque);

            progress = true;

        }



        tmp = node;

        node = QLIST_NEXT(node, node);



        ctx->walking_handlers--;



        if (!ctx->walking_handlers && tmp->deleted) {

            QLIST_REMOVE(tmp, node);

            g_free(tmp);

        }

    }

    return progress;

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR_INVALIDDATA;



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline bool media_is_cd(SCSIDiskState *s)

{

    uint64_t nb_sectors;

    if (s->qdev.type != TYPE_ROM) {

        return false;

    }

    if (!bdrv_is_inserted(s->qdev.conf.bs)) {

        return false;

    }

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    return nb_sectors <= CD_MAX_SECTORS;

}
",0
Detect whether the following code contains vulnerabilities.,"static VALUE from_document(VALUE klass, VALUE document)
{
  xmlDocPtr doc;
  xmlRelaxNGParserCtxtPtr ctx;
  xmlRelaxNGPtr schema;
  VALUE errors;
  VALUE rb_schema;

  Data_Get_Struct(document, xmlDoc, doc);

  /* In case someone passes us a node. ugh. */
  doc = doc->doc;

  ctx = xmlRelaxNGNewDocParserCtxt(doc);

  errors = rb_ary_new();
  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);

#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS
  xmlRelaxNGSetParserStructuredErrors(
    ctx,
    Nokogiri_error_array_pusher,
    (void *)errors
  );
#endif

  schema = xmlRelaxNGParse(ctx);

  xmlSetStructuredErrorFunc(NULL, NULL);
  xmlRelaxNGFreeParserCtxt(ctx);

  if(NULL == schema) {
    xmlErrorPtr error = xmlGetLastError();
    if(error)
      Nokogiri_error_raise(NULL, error);
    else
      rb_raise(rb_eRuntimeError, ""Could not parse document"");

    return Qnil;
  }

  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);
  rb_iv_set(rb_schema, ""@errors"", errors);

  return rb_schema;
}",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);
  OpData* data = reinterpret_cast<OpData*>(node->user_data);

  TfLiteTensor* output;
  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));
  const TfLiteTensor* input;
  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));
  switch (input->type) {  // Already know in/out types are same.
    case kTfLiteFloat32:
      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);
      break;
    case kTfLiteUInt8:
      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    case kTfLiteInt8:
      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,
                                            output);
      break;
    case kTfLiteInt16:
      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,
                                             output);
      break;
    default:
      TF_LITE_KERNEL_LOG(context, ""Type %s not currently supported."",
                         TfLiteTypeGetName(input->type));
      return kTfLiteError;
  }
  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"static void virtio_net_add_queue(VirtIONet *n, int index)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    n->vqs[index].rx_vq = virtio_add_queue(vdev, 256, virtio_net_handle_rx);

    if (n->net_conf.tx && !strcmp(n->net_conf.tx, ""timer"")) {

        n->vqs[index].tx_vq =

            virtio_add_queue(vdev, 256, virtio_net_handle_tx_timer);

        n->vqs[index].tx_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                                              virtio_net_tx_timer,

                                              &n->vqs[index]);

    } else {

        n->vqs[index].tx_vq =

            virtio_add_queue(vdev, 256, virtio_net_handle_tx_bh);

        n->vqs[index].tx_bh = qemu_bh_new(virtio_net_tx_bh, &n->vqs[index]);

    }



    n->vqs[index].tx_waiting = 0;

    n->vqs[index].n = n;

}
",1
Detect whether the following code contains vulnerabilities.,"
static JSValue js_fileio_destroy(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	JSFileIOCtx *ioctx = JS_GetOpaque(this_val, fileio_class_id);
	if (!ioctx) return JS_UNDEFINED;
	if (!ioctx->factory->lock) return JS_UNDEFINED;

	ioctx->factory->lock = GF_FALSE;
	ioctx->factory->all_refs--;
	if (!ioctx->factory->all_refs) {
		js_fileio_factory_delete(ctx, ioctx->factory, NULL);
	}
	return JS_UNDEFINED;",0
Detect whether the following code contains vulnerabilities.,"static inline void render_line_unrolled(intptr_t x, intptr_t y, int x1,

                                        intptr_t sy, int ady, int adx,

                                        float *buf)

{

    int err = -adx;

    x -= x1 - 1;

    buf += x1 - 1;

    while (++x < 0) {

        err += ady;

        if (err >= 0) {

            err += ady - adx;

            y   += sy;

            buf[x++] = ff_vorbis_floor1_inverse_db_table[y];

        }

        buf[x] = ff_vorbis_floor1_inverse_db_table[y];

    }

    if (x <= 0) {

        if (err + ady >= 0)

            y += sy;

        buf[x] = ff_vorbis_floor1_inverse_db_table[y];

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_aio_init(void)

{

    struct sigaction act;



    aio_initialized = 1;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0; /* do not restart syscalls to interrupt select() */

    act.sa_handler = aio_signal_handler;

    sigaction(aio_sig_num, &act, NULL);



#if defined(__GLIBC__) && defined(__linux__)

    {

        /* XXX: aio thread exit seems to hang on RedHat 9 and this init

           seems to fix the problem. */

        struct aioinit ai;

        memset(&ai, 0, sizeof(ai));

        ai.aio_threads = 1;

        ai.aio_num = 1;

        ai.aio_idle_time = 365 * 100000;

        aio_init(&ai);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"httpSpecialClientSideHandler(int status,
                             FdEventHandlerPtr event,
                             StreamRequestPtr srequest)
{
    HTTPConnectionPtr connection = srequest->data;
    HTTPRequestPtr request = connection->request;
    int push;

    if((request->object->flags & OBJECT_ABORTED) || 
       !(request->object->flags & OBJECT_INPROGRESS)) {
        httpClientDiscardBody(connection);
        httpClientError(request, 503, internAtom(""Post aborted""));
        return 1;
    }
        
    if(status < 0) {
        do_log_error(L_ERROR, -status, ""Reading from client"");
        if(status == -EDOGRACEFUL)
            httpClientFinish(connection, 1);
        else
            httpClientFinish(connection, 2);
        return 1;
    }

    push = MIN(srequest->offset - connection->reqlen,
               connection->bodylen - connection->reqoffset);
    if(push > 0) {
        connection->reqlen += push;
        httpSpecialDoSide(request);
    }

    do_log(L_ERROR, ""Incomplete client request.\n"");
    connection->flags &= ~CONN_READER;
    httpClientRawError(connection, 502,
                       internAtom(""Incomplete client request""), 1);
    return 1;
}",1
Detect whether the following code contains vulnerabilities.,"xfs_iflush_abort(
	xfs_inode_t		*ip,
	bool			stale)
{
	xfs_inode_log_item_t	*iip = ip->i_itemp;

	if (iip) {
		if (iip->ili_item.li_flags & XFS_LI_IN_AIL) {
			xfs_trans_ail_remove(&iip->ili_item,
					     stale ? SHUTDOWN_LOG_IO_ERROR :
						     SHUTDOWN_CORRUPT_INCORE);
		}
		iip->ili_logged = 0;
		/*
		 * Clear the ili_last_fields bits now that we know that the
		 * data corresponding to them is safely on disk.
		 */
		iip->ili_last_fields = 0;
		/*
		 * Clear the inode logging fields so no more flushes are
		 * attempted.
		 */
		iip->ili_fields = 0;
	}
	/*
	 * Release the inode's flush lock since we're done with it.
	 */
	xfs_ifunlock(ip);
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_chr_be_event(CharDriverState *s, int event)
{
    /* Keep track if the char device is open */
    switch (event) {
        case CHR_EVENT_OPENED:
            s->be_open = 1;
            break;
        case CHR_EVENT_CLOSED:
            s->be_open = 0;
            break;
    }

    if (!s->chr_event)
        return;
    s->chr_event(s->handler_opaque, event);
}",1
Detect whether the following code contains vulnerabilities.,"uint32_t git_pool__system_page_size(void)
{
	static uint32_t size = 0;

	if (!size) {
		size_t page_size;
		if (git__page_size(&page_size) < 0)
			page_size = 4096;
		size = page_size - 2 * sizeof(void *); /* allow space for malloc overhead */
	}

	return size;
}",0
Detect whether the following code contains vulnerabilities.,"rsvg_paint_server_parse (gboolean * inherit, const RsvgDefs * defs, const char *str,
                         guint32 current_color)
{
    char *name;
    guint32 rgb;
    if (inherit != NULL)
        *inherit = 1;
    if (!strcmp (str, ""none""))
        return NULL;

    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);

        if (val == NULL)
            return NULL;
        if (!strcmp (val->type->str, ""linearGradient""))
            return rsvg_paint_server_lin_grad ((RsvgLinearGradient *) val);
        else if (!strcmp (val->type->str, ""radialGradient""))
            return rsvg_paint_server_rad_grad ((RsvgRadialGradient *) val);
        else if (!strcmp (val->type->str, ""pattern""))
            return rsvg_paint_server_pattern ((RsvgPattern *) val);
        else
            return NULL;
    } else if (!strcmp (str, ""inherit"")) {
        if (inherit != NULL)
            *inherit = 0;
        return rsvg_paint_server_solid (0);
    } else if (!strcmp (str, ""currentColor"")) {
        RsvgPaintServer *ps;
        ps = rsvg_paint_server_solid_current_colour ();
        return ps;
    } else {
        rgb = rsvg_css_parse_color (str, inherit);
        return rsvg_paint_server_solid (rgb);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static ExitStatus trans_fop_dew_0e(DisasContext *ctx, uint32_t insn,

                                   const DisasInsn *di)

{

    unsigned rt = extract32(insn, 0, 5);

    unsigned ra = assemble_ra64(insn);

    return do_fop_dew(ctx, rt, ra, di->f_dew);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline Quantum ClampPixel(const MagickRealType value)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((Quantum) value);
#else
  if (value < 0.0f)
    return(0.0);
  if (value >= (MagickRealType) QuantumRange)
    return((Quantum) QuantumRange);
  return(value);
#endif
}",1
Detect whether the following code contains vulnerabilities.,"pci_emul_deinit(struct vmctx *ctx, struct pci_vdev_ops *ops, int bus, int slot,
		int func, struct funcinfo *fi)
{
	if (ops->vdev_deinit && fi->fi_devi)
		(*ops->vdev_deinit)(ctx, fi->fi_devi, fi->fi_param);
	if (fi->fi_param)
		free(fi->fi_param);

	if (fi->fi_devi) {
		pci_lintr_release(fi->fi_devi);
		pci_emul_free_bars(fi->fi_devi);
		pci_emul_free_msixcap(fi->fi_devi);
		free(fi->fi_devi);
	}
}",0
Detect whether the following code contains vulnerabilities.,"perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
	struct perf_event *event = file->private_data;

	return perf_read_hw(event, buf, count);
}",1
Detect whether the following code contains vulnerabilities.,"int EncryptionUtil::encrypt(EncryptionMode mode, const unsigned char* source,
                            uint32_t source_length, const unsigned char* key, uint32_t key_length,
                            const unsigned char* iv, bool padding, unsigned char* encrypt) {
    const EVP_CIPHER* cipher = get_evp_type(mode);
    /* The encrypt key to be used for encryption */
    unsigned char encrypt_key[ENCRYPTION_MAX_KEY_LENGTH / 8];
    create_key(key, key_length, encrypt_key, mode);

    if (cipher == nullptr || (EVP_CIPHER_iv_length(cipher) > 0 && !iv)) {
        return AES_BAD_DATA;
    }
    EVP_CIPHER_CTX* cipher_ctx = EVP_CIPHER_CTX_new();
    EVP_CIPHER_CTX_reset(cipher_ctx);
    int length = 0;
    int ret = do_encrypt(cipher_ctx, cipher, source, source_length, encrypt_key, iv, padding,
                         encrypt, &length);
    EVP_CIPHER_CTX_free(cipher_ctx);
    if (ret == 0) {
        ERR_clear_error();
        return AES_BAD_DATA;
    } else {
        return length;
    }
}",1
Detect whether the following code contains vulnerabilities.,"int tap_open(char *ifname, int ifname_size, int *vnet_hdr,

             int vnet_hdr_required, int mq_required, Error **errp)

{

    /* FIXME error_setg(errp, ...) on failure */

    char  dev[10]="""";

    int fd;

    if( (fd = tap_alloc(dev, sizeof(dev))) < 0 ){

       fprintf(stderr, ""Cannot allocate TAP device\n"");

       return -1;

    }

    pstrcpy(ifname, ifname_size, dev);

    if (*vnet_hdr) {

        /* Solaris doesn't have IFF_VNET_HDR */

        *vnet_hdr = 0;



        if (vnet_hdr_required && !*vnet_hdr) {

            error_report(""vnet_hdr=1 requested, but no kernel ""

                         ""support for IFF_VNET_HDR available"");

            close(fd);

            return -1;

        }

    }

    fcntl(fd, F_SETFL, O_NONBLOCK);

    return fd;

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);



    qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);

    if (s->dataplane_started && !s->dataplane_fenced) {

        virtio_scsi_dataplane_notify(vdev, req);

    } else {

        virtio_notify(vdev, vq);

    }



    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

}
",1
Detect whether the following code contains vulnerabilities.,"void validate_bootdevices(const char *devices)

{

    /* We just do some generic consistency checks */

    const char *p;

    int bitmap = 0;



    for (p = devices; *p != '\0'; p++) {

        /* Allowed boot devices are:

         * a-b: floppy disk drives

         * c-f: IDE disk drives

         * g-m: machine implementation dependent drives

         * n-p: network devices

         * It's up to each machine implementation to check if the given boot

         * devices match the actual hardware implementation and firmware

         * features.

         */

        if (*p < 'a' || *p > 'p') {

            fprintf(stderr, ""Invalid boot device '%c'\n"", *p);

            exit(1);

        }

        if (bitmap & (1 << (*p - 'a'))) {

            fprintf(stderr, ""Boot device '%c' was given twice\n"", *p);

            exit(1);

        }

        bitmap |= 1 << (*p - 'a');

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void start_filelist_progress(char *kind)
{
	rprintf(FCLIENT, ""%s ... "", kind);
	output_needs_newline = 1;
	rflush(FINFO);
}",0
Detect whether the following code contains vulnerabilities.,"static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)
{
	int i, fail = 0;

	for (i = 0; i < 4; i++)
		if (addr[i] != (input[i] & mask[i])) {
			fail = 1;
			break;
		}

	return !fail;
}",0
Detect whether the following code contains vulnerabilities.,"point_filter_func(const ImageRef *ref, Image *img, const void *data, CellPixelSize cell) {
    return x_filter_func(ref, img, data, cell) && y_filter_func(ref, img, data, cell);
}",0
Detect whether the following code contains vulnerabilities.,"_PUBLIC_ enum ndr_err_code ndr_push_dns_string(struct ndr_push *ndr,
					       int ndr_flags,
					       const char *s)
{
	return ndr_push_dns_string_list(ndr,
					&ndr->dns_string_list,
					ndr_flags,
					s);
}",1
Detect whether the following code contains vulnerabilities.,"static inline uint64_t do_fri(CPUPPCState *env, uint64_t arg,

                              int rounding_mode)

{

    CPU_DoubleU farg;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN round */

        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN |

                                        POWERPC_EXCP_FP_VXCVI);

    } else if (unlikely(float64_is_quiet_nan(farg.d) ||

                        float64_is_infinity(farg.d))) {

        /* qNan / infinity round */

        farg.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXCVI);

    } else {

        set_float_rounding_mode(rounding_mode, &env->fp_status);

        farg.ll = float64_round_to_int(farg.d, &env->fp_status);

        /* Restore rounding mode from FPSCR */

        fpscr_set_rounding_mode(env);

    }

    return farg.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"compute_binder_key(const mac_entry_st *prf,
		   const uint8_t *key, size_t keylen,
		   bool resuming,
		   void *out)
{
	int ret;
	const char ext_label[] = EXT_BINDER_LABEL;
	const size_t ext_label_len = sizeof(ext_label) - 1;
	const char res_label[] = RES_BINDER_LABEL;
	const size_t res_label_len = sizeof(res_label) - 1;
	const char *label = resuming ? res_label : ext_label;
	size_t label_len = resuming ? res_label_len : ext_label_len;
	uint8_t tmp_key[MAX_HASH_SIZE];

	/* Compute HKDF-Extract(0, psk) */
	ret = _tls13_init_secret2(prf, key, keylen, tmp_key);
	if (ret < 0)
		return ret;

	/* Compute Derive-Secret(secret, label, transcript_hash) */
	ret = _tls13_derive_secret2(prf, label, label_len,
				    NULL, 0, tmp_key, out);
	if (ret < 0)
		return ret;

	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_mpeg_flush(AVCodecContext *avctx){

    int i;

    MpegEncContext *s = avctx->priv_data;



    if(s==NULL || s->picture==NULL)

        return;



    for (i = 0; i < MAX_PICTURE_COUNT; i++)

        ff_mpeg_unref_picture(s, &s->picture[i]);

    s->current_picture_ptr = s->last_picture_ptr = s->next_picture_ptr = NULL;



    ff_mpeg_unref_picture(s, &s->current_picture);

    ff_mpeg_unref_picture(s, &s->last_picture);

    ff_mpeg_unref_picture(s, &s->next_picture);



    s->mb_x= s->mb_y= 0;



    s->parse_context.state= -1;

    s->parse_context.frame_start_found= 0;

    s->parse_context.overread= 0;

    s->parse_context.overread_index= 0;

    s->parse_context.index= 0;

    s->parse_context.last_index= 0;

    s->bitstream_buffer_size=0;

    s->pp_time=0;

}
",0
Detect whether the following code contains vulnerabilities.,"void rose_start_t3timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t3;

	add_timer(&rose->timer);
}",1
Detect whether the following code contains vulnerabilities.,"static int cdrom_probe_device(const char *filename)

{

    if (strstart(filename, ""/dev/cd"", NULL))

        return 100;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"
static SDL_INLINE FT_UInt get_char_index(TTF_Font *font, Uint32 ch)
{
    Uint32 cache_index_size = sizeof (font->cache_index) / sizeof (font->cache_index[0]);

    if (ch < cache_index_size) {
        FT_UInt idx = font->cache_index[ch];
        if (idx) {
            return idx;
        }
        idx = FT_Get_Char_Index(font->face, ch);
        font->cache_index[ch] = idx;
        return idx;
    }

    return FT_Get_Char_Index(font->face, ch);",0
Detect whether the following code contains vulnerabilities.,"static int ldb_lock_backend_callback(struct ldb_request *req,
				     struct ldb_reply *ares)
{
	struct ldb_db_lock_context *lock_context;
	int ret;

	lock_context = talloc_get_type(req->context,
				       struct ldb_db_lock_context);

	if (!ares) {
		return ldb_module_done(lock_context->req, NULL, NULL,
					LDB_ERR_OPERATIONS_ERROR);
	}
	if (ares->error != LDB_SUCCESS || ares->type == LDB_REPLY_DONE) {
		ret = ldb_module_done(lock_context->req, ares->controls,
				      ares->response, ares->error);
		/*
		 * If this is a LDB_REPLY_DONE or an error, unlock the
		 * DB by calling the destructor on this context
		 */
		talloc_free(lock_context);
		return ret;
	}

	/* Otherwise pass on the callback */
	switch (ares->type) {
	case LDB_REPLY_ENTRY:
		return ldb_module_send_entry(lock_context->req, ares->message,
					     ares->controls);

	case LDB_REPLY_REFERRAL:
		return ldb_module_send_referral(lock_context->req,
						ares->referral);
	default:
		/* Can't happen */
		return LDB_ERR_OPERATIONS_ERROR;
	}
}",1
Detect whether the following code contains vulnerabilities.,"static inline bool extended_addresses_enabled(CPUARMState *env)

{

    return arm_feature(env, ARM_FEATURE_LPAE)

        && (env->cp15.c2_control & (1 << 31));

}
",1
Detect whether the following code contains vulnerabilities.,"void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {
  if (static_cast<int32_t>(in_.length()) < size) {
    str.reserve(size); // only reserve for multi iter case below
  }
  str.clear();
  size_t size_left = size;
  while (size_left > 0) {
    auto data = in_.peekBytes();
    auto data_avail = std::min(data.size(), size_left);
    if (data.empty()) {
      TProtocolException::throwExceededSizeLimit();
    }

    str.append((const char*)data.data(), data_avail);
    size_left -= data_avail;
    in_.skipNoAdvance(data_avail);
  }
}",1
Detect whether the following code contains vulnerabilities.,"nv_select(cmdarg_T *cap)
{
    if (VIsual_active)
	VIsual_select = TRUE;
    else if (VIsual_reselect)
    {
	cap->nchar = 'v';	    // fake ""gv"" command
	cap->arg = TRUE;
	nv_g_cmd(cap);
    }
}",0
Detect whether the following code contains vulnerabilities.,"void spapr_dt_events(void *fdt, uint32_t check_exception_irq)

{

    int event_sources, epow_events;

    uint32_t irq_ranges[] = {cpu_to_be32(check_exception_irq), cpu_to_be32(1)};

    uint32_t interrupts[] = {cpu_to_be32(check_exception_irq), 0};



    _FDT(event_sources = fdt_add_subnode(fdt, 0, ""event-sources""));



    _FDT(fdt_setprop(fdt, event_sources, ""interrupt-controller"", NULL, 0));

    _FDT(fdt_setprop_cell(fdt, event_sources, ""#interrupt-cells"", 2));

    _FDT(fdt_setprop(fdt, event_sources, ""interrupt-ranges"",

                     irq_ranges, sizeof(irq_ranges)));



    _FDT(epow_events = fdt_add_subnode(fdt, event_sources, ""epow-events""));

    _FDT(fdt_setprop(fdt, epow_events, ""interrupts"",

                     interrupts, sizeof(interrupts)));

}
",0
Detect whether the following code contains vulnerabilities.,"_TIFFmalloc(tmsize_t s)
{
	return (malloc((size_t) s));
}",1
Detect whether the following code contains vulnerabilities.,"static void omap_i2c_set_slave_addr(OMAPI2C *s, uint8_t addr)

{

    uint16_t data = addr;



    memwrite(s->addr + OMAP_I2C_SA, &data, 2);

    memread(s->addr + OMAP_I2C_SA, &data, 2);

    g_assert_cmphex(data, ==, addr);

}
",1
Detect whether the following code contains vulnerabilities.,"void exit_thread(void)
{
	thread_notify(THREAD_NOTIFY_EXIT, current_thread_info());
}",0
Detect whether the following code contains vulnerabilities.,"static void vtd_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    X86IOMMUClass *x86_class = X86_IOMMU_CLASS(klass);



    dc->reset = vtd_reset;

    dc->vmsd = &vtd_vmstate;

    dc->props = vtd_properties;

    dc->hotpluggable = false;

    x86_class->realize = vtd_realize;

    x86_class->int_remap = vtd_int_remap;






}",1
Detect whether the following code contains vulnerabilities.,"static int do_io_accounting(struct task_struct *task, char *buffer, int whole)
{
	struct task_io_accounting acct = task->ioac;
	unsigned long flags;

	if (whole && lock_task_sighand(task, &flags)) {
		struct task_struct *t = task;

		task_io_accounting_add(&acct, &task->signal->ioac);
		while_each_thread(task, t)
			task_io_accounting_add(&acct, &t->ioac);

		unlock_task_sighand(task, &flags);
	}
	return sprintf(buffer,
			""rchar: %llu\n""
			""wchar: %llu\n""
			""syscr: %llu\n""
			""syscw: %llu\n""
			""read_bytes: %llu\n""
			""write_bytes: %llu\n""
			""cancelled_write_bytes: %llu\n"",
			(unsigned long long)acct.rchar,
			(unsigned long long)acct.wchar,
			(unsigned long long)acct.syscr,
			(unsigned long long)acct.syscw,
			(unsigned long long)acct.read_bytes,
			(unsigned long long)acct.write_bytes,
			(unsigned long long)acct.cancelled_write_bytes);
}",1
Detect whether the following code contains vulnerabilities.,"static void SetLexerLocus( TidyDocImpl* doc, Lexer *lexer )
{
    lexer->lines = doc->docIn->curline;
    lexer->columns = doc->docIn->curcol;
}",0
Detect whether the following code contains vulnerabilities.,"bool qdict_get_try_bool(const QDict *qdict, const char *key, bool def_value)

{

    QObject *obj;



    obj = qdict_get(qdict, key);

    if (!obj || qobject_type(obj) != QTYPE_QBOOL)

        return def_value;



    return qbool_get_bool(qobject_to_qbool(obj));

}
",1
Detect whether the following code contains vulnerabilities.,"void* Init(TfLiteContext* context, const char* buffer, size_t length) {
  auto* data = new OpData;
  return data;
}",0
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateBool( int b )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = b ? cJSON_True : cJSON_False;
	return item;
}",1
Detect whether the following code contains vulnerabilities.,"TEST_F(ZNCTest, StatusEchoMessage) {
    auto znc = Run();
    auto ircd = ConnectIRCd();
    auto client = LoginClient();
    client.Write(""CAP REQ :echo-message"");
    client.Write(""PRIVMSG *status :blah"");
    client.ReadUntil("":nick!user@irc.znc.in PRIVMSG *status :blah"");
    client.ReadUntil("":*status!znc@znc.in PRIVMSG nick :Unknown command"");
}",1
Detect whether the following code contains vulnerabilities.,"static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,
				   struct rm_data_op *op,
				   int wc_status)
{
	if (op->op_nents)
		ib_dma_unmap_sg(ic->i_cm_id->device,
				op->op_sg, op->op_nents,
				DMA_TO_DEVICE);
}",0
Detect whether the following code contains vulnerabilities.,"static gboolean qio_channel_websock_handshake_send(QIOChannel *ioc,

                                                   GIOCondition condition,

                                                   gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelWebsock *wioc = QIO_CHANNEL_WEBSOCK(

        qio_task_get_source(task));

    Error *err = NULL;

    ssize_t ret;



    ret = qio_channel_write(wioc->master,

                            (char *)wioc->encoutput.buffer,

                            wioc->encoutput.offset,

                            &err);



    if (ret < 0) {

        trace_qio_channel_websock_handshake_fail(ioc);

        qio_task_set_error(task, err);

        qio_task_complete(task);

        return FALSE;

    }



    buffer_advance(&wioc->encoutput, ret);

    if (wioc->encoutput.offset == 0) {

        trace_qio_channel_websock_handshake_complete(ioc);

        qio_task_complete(task);

        return FALSE;

    }

    trace_qio_channel_websock_handshake_pending(ioc, G_IO_OUT);

    return TRUE;

}
",1
Detect whether the following code contains vulnerabilities.,"void mbedtls_strerror( int ret, char *buf, size_t buflen )
{
    ((void) ret);

    if( buflen > 0 )
        buf[0] = '\0';
}",1
Detect whether the following code contains vulnerabilities.,"struct mm_struct *mm_for_maps(struct task_struct *task)
{
	struct mm_struct *mm = get_task_mm(task);
	if (!mm)
		return NULL;
	if (mm != current->mm) {
		/*
		 * task->mm can be changed before security check,
		 * in that case we must notice the change after.
		 */
		if (!ptrace_may_access(task, PTRACE_MODE_READ) ||
		    mm != task->mm) {
			mmput(mm);
			return NULL;
		}
	}
	down_read(&mm->mmap_sem);
	return mm;
}",1
Detect whether the following code contains vulnerabilities.,"static inline int get_file_caps(struct linux_binprm *bprm)
{
	bprm_clear_caps(bprm);
	return 0;
}",1
Detect whether the following code contains vulnerabilities.,"bool inode_owner_or_capable(const struct inode *inode)
{
	if (uid_eq(current_fsuid(), inode->i_uid))
		return true;
	if (inode_capable(inode, CAP_FOWNER))
		return true;
	return false;
}",1
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_pic_save(QEMUFile *f, void *opaque)

{

    PXA2xxPICState *s = (PXA2xxPICState *) opaque;

    int i;



    for (i = 0; i < 2; i ++)

        qemu_put_be32s(f, &s->int_enabled[i]);

    for (i = 0; i < 2; i ++)

        qemu_put_be32s(f, &s->int_pending[i]);

    for (i = 0; i < 2; i ++)

        qemu_put_be32s(f, &s->is_fiq[i]);

    qemu_put_be32s(f, &s->int_idle);

    for (i = 0; i < PXA2XX_PIC_SRCS; i ++)

        qemu_put_be32s(f, &s->priority[i]);

}
",0
Detect whether the following code contains vulnerabilities.,"stop_postmaster(void)
{
	if (postmaster_running)
	{
		/* We use pg_ctl to issue the kill and wait for stop */
		char		buf[MAXPGPATH * 2];
		int			r;

		/* On Windows, system() seems not to force fflush, so... */
		fflush(stdout);
		fflush(stderr);

		snprintf(buf, sizeof(buf),
				 SYSTEMQUOTE ""\""%s/pg_ctl\"" stop -D \""%s/data\"" -s -m fast"" SYSTEMQUOTE,
				 bindir, temp_install);
		r = system(buf);
		if (r != 0)
		{
			fprintf(stderr, _(""\n%s: could not stop postmaster: exit code was %d\n""),
					progname, r);
			_exit(2);			/* not exit(), that could be recursive */
		}

		postmaster_running = false;
	}
}",0
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateFloat( double num )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_Number;
		item->valuefloat = num;
		item->valueint = num;
	}
	return item;
}",1
Detect whether the following code contains vulnerabilities.,"closure (void)
{
  int tindex, ntokens, i;

  atom();
  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
    if (tok == REPMN && (minrep || maxrep))
      {
        ntokens = nsubtoks(dfa->tindex);
        tindex = dfa->tindex - ntokens;
        if (maxrep < 0)
          addtok(PLUS);
        if (minrep == 0)
          addtok(QMARK);
        for (i = 1; i < minrep; ++i)
          {
            copytoks(tindex, ntokens);
            addtok(CAT);
          }
        for (; i < maxrep; ++i)
          {
            copytoks(tindex, ntokens);
            addtok(QMARK);
            addtok(CAT);
          }
        tok = lex();
      }
    else if (tok == REPMN)
      {
        dfa->tindex -= nsubtoks(dfa->tindex);
        tok = lex();
        closure();
      }
    else
      {
        addtok(tok);
        tok = lex();
      }
}",1
Detect whether the following code contains vulnerabilities.,"int ff_h264_get_profile(SPS *sps)

{

    int profile = sps->profile_idc;



    switch (sps->profile_idc) {

    case FF_PROFILE_H264_BASELINE:

        // constraint_set1_flag set to 1

        profile |= (sps->constraint_set_flags & 1 << 1) ? FF_PROFILE_H264_CONSTRAINED : 0;

        break;

    case FF_PROFILE_H264_HIGH_10:

    case FF_PROFILE_H264_HIGH_422:

    case FF_PROFILE_H264_HIGH_444_PREDICTIVE:

        // constraint_set3_flag set to 1

        profile |= (sps->constraint_set_flags & 1 << 3) ? FF_PROFILE_H264_INTRA : 0;

        break;

    }



    return profile;

}
",0
Detect whether the following code contains vulnerabilities.,"static void _note_batch_job_finished(uint32_t job_id)
{
	slurm_mutex_lock(&fini_mutex);
	fini_job_id[next_fini_job_inx] = job_id;
	if (++next_fini_job_inx >= FINI_JOB_CNT)
		next_fini_job_inx = 0;
	slurm_mutex_unlock(&fini_mutex);
}",0
Detect whether the following code contains vulnerabilities.,"static void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)
{
	struct vcpu_svm *svm = to_svm(vcpu);

	svm->vmcb->save.idtr.limit = dt->size;
	svm->vmcb->save.idtr.base = dt->address ;
	mark_dirty(svm->vmcb, VMCB_DT);
}",0
Detect whether the following code contains vulnerabilities.,"void MsgSetHOSTNAME(msg_t *pThis, uchar* pszHOSTNAME, int lenHOSTNAME)
{
	assert(pThis != NULL);

	freeHOSTNAME(pThis);

	pThis->iLenHOSTNAME = lenHOSTNAME;
	if(pThis->iLenHOSTNAME < CONF_HOSTNAME_BUFSIZE) {
		/* small enough: use fixed buffer (faster!) */
		pThis->pszHOSTNAME = pThis->szHOSTNAME;
	} else if((pThis->pszHOSTNAME = (uchar*) MALLOC(pThis->iLenHOSTNAME + 1)) == NULL) {
		/* truncate message, better than completely loosing it... */
		pThis->pszHOSTNAME = pThis->szHOSTNAME;
		pThis->iLenHOSTNAME = CONF_HOSTNAME_BUFSIZE - 1;
	}

	memcpy(pThis->pszHOSTNAME, pszHOSTNAME, pThis->iLenHOSTNAME);
	pThis->pszHOSTNAME[pThis->iLenHOSTNAME] = '\0'; /* this also works with truncation! */
}",0
Detect whether the following code contains vulnerabilities.,"ContentLine_Analyzer::ContentLine_Analyzer(Connection* conn, bool orig)
: TCP_SupportAnalyzer(""CONTENTLINE"", conn, orig)
	{
	InitState();
	}",0
Detect whether the following code contains vulnerabilities.,"static int ftp_write(URLContext *h, const unsigned char *buf, int size)

{

    int err;

    FTPContext *s = h->priv_data;

    int written;



    av_dlog(h, ""ftp protocol write %d bytes\n"", size);



    if (s->state == DISCONNECTED) {

        if ((err = ftp_connect_data_connection(h)) < 0)

            return err;

    }

    if (s->state == READY) {

        if ((err = ftp_store(s)) < 0)

            return err;

    }

    if (s->conn_data && s->state == UPLOADING) {

        written = ffurl_write(s->conn_data, buf, size);

        if (written > 0) {

            s->position += written;

            s->filesize = FFMAX(s->filesize, s->position);

        }

        return written;

    }



    av_log(h, AV_LOG_ERROR, ""FTP write failed\n"");

    return AVERROR(EIO);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ahci_dma_rw_buf(IDEDMA *dma, int is_write)

{

    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);

    IDEState *s = &ad->port.ifs[0];

    uint8_t *p = s->io_buffer + s->io_buffer_index;

    int l = s->io_buffer_size - s->io_buffer_index;



    if (ahci_populate_sglist(ad, &s->sg)) {

        return 0;

    }



    if (is_write) {

        dma_buf_read(p, l, &s->sg);

    } else {

        dma_buf_write(p, l, &s->sg);

    }



    /* update number of transferred bytes */

    ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + l);

    s->io_buffer_index += l;



    DPRINTF(ad->port_no, ""len=%#x\n"", l);



    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void page_flush_tb(void)

{

    int i;



    for (i = 0; i < V_L1_SIZE; i++) {

        page_flush_tb_1(V_L1_SHIFT / L2_BITS - 1, l1_map + i);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"target_ulong helper_load_slb_esid(CPUPPCState *env, target_ulong rb)

{

    target_ulong rt;



    if (ppc_load_slb_esid(env, rb, &rt) < 0) {

        helper_raise_exception_err(env, POWERPC_EXCP_PROGRAM,

                                   POWERPC_EXCP_INVAL);

    }

    return rt;

}
",1
Detect whether the following code contains vulnerabilities.,"allow_mech_by_default(gss_OID mech)
{
    OM_uint32 status, minor;
    gss_OID_set attrs;
    int reject = 0, p;

    /* Whether we accept an interposer mech depends on whether we accept the
     * mech it interposes. */
    mech = gssint_get_public_oid(mech);
    if (mech == GSS_C_NO_OID)
	return 0;

    status = gss_inquire_attrs_for_mech(&minor, mech, &attrs, NULL);
    if (status)
	return 0;

    /* Check for each attribute which would cause us to exclude this mech from
     * the default credential. */
    if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_DEPRECATED,
					attrs, &p) != GSS_S_COMPLETE || p)
	reject = 1;
    else if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_NOT_DFLT_MECH,
					     attrs, &p) != GSS_S_COMPLETE || p)
	reject = 1;

    (void) gss_release_oid_set(&minor, &attrs);
    return !reject;
}",0
Detect whether the following code contains vulnerabilities.,"double Field_short::val_real(void)
{
  ASSERT_COLUMN_MARKED_FOR_READ;
  short j;
  j=sint2korr(ptr);
  return unsigned_flag ? (double) (unsigned short) j : (double) j;
}",0
Detect whether the following code contains vulnerabilities.,"static int net_host_check_device(const char *device)

{

    int i;

    const char *valid_param_list[] = { ""tap"", ""socket"", ""dump""

#ifdef CONFIG_NET_BRIDGE

                                       , ""bridge""

#endif

#ifdef CONFIG_SLIRP

                                       ,""user""

#endif

#ifdef CONFIG_VDE

                                       ,""vde""

#endif

    };

    for (i = 0; i < ARRAY_SIZE(valid_param_list); i++) {

        if (!strncmp(valid_param_list[i], device,

                     strlen(valid_param_list[i])))

            return 1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int decode_residual_inter(AVSContext *h) {

    int block;



    /* get coded block pattern */

    int cbp= get_ue_golomb(&h->s.gb);

    if(cbp > 63){

        av_log(h->s.avctx, AV_LOG_ERROR, ""illegal inter cbp\n"");

        return -1;

    }

    h->cbp = cbp_tab[cbp][1];



    /* get quantizer */

    if(h->cbp && !h->qp_fixed)

        h->qp = (h->qp + get_se_golomb(&h->s.gb)) & 63;

    for(block=0;block<4;block++)

        if(h->cbp & (1<<block))

            decode_residual_block(h,&h->s.gb,ff_cavs_inter_dec,0,h->qp,

                                  h->cy + h->luma_scan[block], h->l_stride);

    decode_residual_chroma(h);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"  UnknownRecordContent(const string& zone) : DNSRecordContent(0)
  {
    d_record.insert(d_record.end(), zone.begin(), zone.end());
  }",0
Detect whether the following code contains vulnerabilities.,"void regexp_release(struct regexp *regexp) {
    if (regexp->re != NULL) {
        regfree(regexp->re);
        FREE(regexp->re);
    }
}",0
Detect whether the following code contains vulnerabilities.,"uint32_t PacketReader::get32BitInt()
{
  uint32_t ret=0;
  ret+=d_content.at(d_pos++);
  ret<<=8;
  ret+=d_content.at(d_pos++);
  ret<<=8;
  ret+=d_content.at(d_pos++);
  ret<<=8;
  ret+=d_content.at(d_pos++);
  
  return ret;
}",0
Detect whether the following code contains vulnerabilities.,"long do_rt_sigreturn(CPUAlphaState *env)

{

    abi_ulong frame_addr = env->ir[IR_A0];

    struct target_rt_sigframe *frame;

    sigset_t set;



    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1)) {

        goto badframe;

    }

    target_to_host_sigset(&set, &frame->uc.tuc_sigmask);

    do_sigprocmask(SIG_SETMASK, &set, NULL);



    if (restore_sigcontext(env, &frame->uc.tuc_mcontext)) {

        goto badframe;

    }

    if (do_sigaltstack(frame_addr + offsetof(struct target_rt_sigframe,

                                             uc.tuc_stack),

                       0, env->ir[IR_SP]) == -EFAULT) {

        goto badframe;

    }



    unlock_user_struct(frame, frame_addr, 0);

    return env->ir[IR_V0];





 badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t ucma_bind_ip(struct ucma_file *file, const char __user *inbuf,
			      int in_len, int out_len)
{
	struct rdma_ucm_bind_ip cmd;
	struct ucma_context *ctx;
	int ret;

	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
		return -EFAULT;

	if (!rdma_addr_size_in6(&cmd.addr))
		return -EINVAL;

	ctx = ucma_get_ctx(file, cmd.id);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	mutex_lock(&ctx->mutex);
	ret = rdma_bind_addr(ctx->cm_id, (struct sockaddr *) &cmd.addr);
	mutex_unlock(&ctx->mutex);

	ucma_put_ctx(ctx);
	return ret;
}",0
Detect whether the following code contains vulnerabilities.,"static int intf_find_seq(struct ipmi_smi      *intf,
			 unsigned char        seq,
			 short                channel,
			 unsigned char        cmd,
			 unsigned char        netfn,
			 struct ipmi_addr     *addr,
			 struct ipmi_recv_msg **recv_msg)
{
	int           rv = -ENODEV;
	unsigned long flags;

	if (seq >= IPMI_IPMB_NUM_SEQ)
		return -EINVAL;

	spin_lock_irqsave(&intf->seq_lock, flags);
	if (intf->seq_table[seq].inuse) {
		struct ipmi_recv_msg *msg = intf->seq_table[seq].recv_msg;

		if ((msg->addr.channel == channel) && (msg->msg.cmd == cmd)
				&& (msg->msg.netfn == netfn)
				&& (ipmi_addr_equal(addr, &msg->addr))) {
			*recv_msg = msg;
			intf->seq_table[seq].inuse = 0;
			rv = 0;
		}
	}
	spin_unlock_irqrestore(&intf->seq_lock, flags);

	return rv;
}",0
Detect whether the following code contains vulnerabilities.,"window_select_shape_events (GSWindow *window)
{
#ifdef HAVE_SHAPE_EXT
        unsigned long events;
        int           shape_error_base;

        gdk_error_trap_push ();

        if (XShapeQueryExtension (GDK_DISPLAY (), &window->priv->shape_event_base, &shape_error_base)) {
                events = ShapeNotifyMask;
                XShapeSelectInput (GDK_DISPLAY (), GDK_WINDOW_XID (GTK_WIDGET (window)->window), events);
        }

        gdk_display_sync (gdk_display_get_default ());
        gdk_error_trap_pop ();
#endif
}",0
Detect whether the following code contains vulnerabilities.,"static inline struct shmid_kernel *shm_obtain_object(struct ipc_namespace *ns, int id)
{
	struct kern_ipc_perm *ipcp = ipc_obtain_object(&shm_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct shmid_kernel, shm_perm);
}",0
Detect whether the following code contains vulnerabilities.,"PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)
{
    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;
    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);
    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);
    upx_uint64_t align = get_te64(&phdr->p_align);
    if (s < t || (upx_uint64_t)file_size < s
    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)
    ||  (-1+ align) & (t ^ vaddr)
    ||  (unsigned long)file_size <= memsz
    ||  filesz < sizeof(Elf64_Dyn)
    ||  memsz  < sizeof(Elf64_Dyn)
    ||  filesz < memsz) {
        char msg[50]; snprintf(msg, sizeof(msg), ""bad PT_DYNAMIC phdr[%u]"",
            (unsigned)(phdr - phdri));
        throwCantPack(msg);
    }
    sz_dynseg = memsz;
    return t;
}",1
Detect whether the following code contains vulnerabilities.,"static int __btrfs_submit_bio_start(struct inode *inode, int rw,
				    struct bio *bio, int mirror_num,
				    unsigned long bio_flags,
				    u64 bio_offset)
{
	struct btrfs_root *root = BTRFS_I(inode)->root;
	int ret = 0;

	ret = btrfs_csum_one_bio(root, inode, bio, 0, 0);
	BUG_ON(ret); /* -ENOMEM */
	return 0;
}",0
Detect whether the following code contains vulnerabilities.,"static bool aio_epoll_try_enable(AioContext *ctx)

{

    AioHandler *node;

    struct epoll_event event;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        int r;

        if (node->deleted || !node->pfd.events) {

            continue;

        }

        event.events = epoll_events_from_pfd(node->pfd.events);

        event.data.ptr = node;

        r = epoll_ctl(ctx->epollfd, EPOLL_CTL_ADD, node->pfd.fd, &event);

        if (r) {

            return false;

        }

    }

    ctx->epoll_enabled = true;

    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"rightTrim(char *s)
{
	char	   *sEnd;

	sEnd = s + strlen(s) - 1;
	while (sEnd >= s && isspace(*sEnd))
		sEnd--;
	if (sEnd < s)
		s[0] = '\0';
	else
		s[sEnd - s + 1] = '\0';
	return s;
}",0
Detect whether the following code contains vulnerabilities.,"tcp_sequence_number_analysis_print_zero_window(packet_info * pinfo,
                          proto_item * flags_item,
                          struct tcp_acked *ta
                        )
{
    /* TCP Zero Window Probe */
    if (ta->flags & TCP_A_ZERO_WINDOW_PROBE) {
        expert_add_info(pinfo, flags_item, &ei_tcp_analysis_zero_window_probe);
        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, ""[TCP ZeroWindowProbe] "");
    }
    /* TCP Zero Window */
    if (ta->flags&TCP_A_ZERO_WINDOW) {
        expert_add_info(pinfo, flags_item, &ei_tcp_analysis_zero_window);
        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO, ""[TCP ZeroWindow] "");
    }
    /* TCP Zero Window Probe Ack */
    if (ta->flags & TCP_A_ZERO_WINDOW_PROBE_ACK) {
        expert_add_info(pinfo, flags_item, &ei_tcp_analysis_zero_window_probe_ack);
        col_prepend_fence_fstr(pinfo->cinfo, COL_INFO,
                               ""[TCP ZeroWindowProbeAck] "");
    }
}",0
Detect whether the following code contains vulnerabilities.,"size_t qsb_get_length(const QEMUSizedBuffer *qsb)

{

    return qsb->used;

}
",1
Detect whether the following code contains vulnerabilities.,"hstrerror(int herr)
{
  if (0 <= herr && herr < h_nerr)
    return h_errlist[herr];
  else
    return ""Error number out of range (hstrerror)"";
}",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(bcsqrt)
{
	char *left;
	int left_len;
	long scale_param = 0;
	bc_num result;
	int scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc TSRMLS_CC, ""s|l"", &left, &left_len, &scale_param) == FAILURE) {
		return;
	}
	
	if (argc == 2) {
		scale = (int) ((int)scale_param < 0) ? 0 : scale_param;
	}

	bc_init_num(&result TSRMLS_CC);
	php_str2num(&result, left TSRMLS_CC);
	
	if (bc_sqrt (&result, scale TSRMLS_CC) != 0) {
		if (result->n_scale > scale) {
			result->n_scale = scale;
		}
		Z_STRVAL_P(return_value) = bc_num2str(result);
		Z_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));
		Z_TYPE_P(return_value) = IS_STRING;
	} else {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Square root of negative number"");
	}

	bc_free_num(&result);
	return;
}",1
Detect whether the following code contains vulnerabilities.,"str_matches_option(const char *s1, const char *optionname)
{
        /* Option names are given as ""option:"" We accept either 'option' in
	 * s1, or 'option:randomjunk'.  The latter form is to implement the
	 * resolv.conf parser. */
	size_t optlen = strlen(optionname);
	if (strlen(s1) == optlen)
		return !strncmp(s1, optionname, optlen-1);
	else
		return !strncmp(s1, optionname, optlen);
}",0
Detect whether the following code contains vulnerabilities.,"static void unref_buffer(InputStream *ist, FrameBuffer *buf)

{

    av_assert0(buf->refcount);

    buf->refcount--;

    if (!buf->refcount) {

        buf->next = ist->buffer_pool;

        ist->buffer_pool = buf;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"
void skb_complete_tx_timestamp(struct sk_buff *skb,
			       struct skb_shared_hwtstamps *hwtstamps)
{
	struct sock *sk = skb->sk;

	if (!skb_may_tx_timestamp(sk, false))
		return;

	/* Take a reference to prevent skb_orphan() from freeing the socket,
	 * but only if the socket refcount is not zero.
	 */
	if (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {
		*skb_hwtstamps(skb) = *hwtstamps;
		__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);
		sock_put(sk);
	}",1
Detect whether the following code contains vulnerabilities.,"static int proc_cwd_link(struct dentry *dentry, struct path *path)
{
	struct task_struct *task = get_proc_task(d_inode(dentry));
	int result = -ENOENT;

	if (task) {
		task_lock(task);
		if (task->fs) {
			get_fs_pwd(task->fs, path);
			result = 0;
		}
		task_unlock(task);
		put_task_struct(task);
	}
	return result;
}",0
Detect whether the following code contains vulnerabilities.,"static void do_gdbserver(int argc, const char **argv)

{

    int port;



    port = DEFAULT_GDBSTUB_PORT;

    if (argc >= 2)

        port = atoi(argv[1]);

    if (gdbserver_start(port) < 0) {

        qemu_printf(""Could not open gdbserver socket on port %d\n"", port);

    } else {

        qemu_printf(""Waiting gdb connection on port %d\n"", port);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void vmx_flush_tlb(struct kvm_vcpu *vcpu, bool invalidate_gpa)
{
	__vmx_flush_tlb(vcpu, to_vmx(vcpu)->vpid, invalidate_gpa);
}",0
Detect whether the following code contains vulnerabilities.,"LogLuvFixupTags(TIFF* tif)
{
	(void) tif;
	return (1);
}",0
Detect whether the following code contains vulnerabilities.,"static av_cold int asink_init(AVFilterContext *ctx, void *opaque)

{

    BufferSinkContext *buf = ctx->priv;

    AVABufferSinkParams *params = opaque;



    if (params && params->sample_fmts) {

        buf->sample_fmts = ff_copy_int_list(params->sample_fmts);

        if (!buf->sample_fmts)

            return AVERROR(ENOMEM);

    }

    if (params && params->sample_rates) {

        buf->sample_rates = ff_copy_int_list(params->sample_rates);

        if (!buf->sample_rates)

            return AVERROR(ENOMEM);

    }

    if (params && (params->channel_layouts || params->channel_counts)) {

        if (params->all_channel_counts) {

            av_log(ctx, AV_LOG_ERROR,

                   ""Conflicting all_channel_counts and list in parameters\n"");

            return AVERROR(EINVAL);

        }

        buf->channel_layouts = concat_channels_lists(params->channel_layouts,

                                                     params->channel_counts);

        if (!buf->channel_layouts)

            return AVERROR(ENOMEM);

    }

    if (params)

        buf->all_channel_counts = params->all_channel_counts;

    return common_init(ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_qmp_capabilities(Error **errp)

{

    cur_mon->qmp.in_command_mode = true;

}
",1
Detect whether the following code contains vulnerabilities.,"static void raven_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->realize = raven_pcihost_realizefn;

    dc->fw_name = ""pci"";

    dc->no_user = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  switch (input->type) {
    case kTfLiteInt64:
      reference_ops::Negate(
          GetTensorShape(input), GetTensorData<int64_t>(input),
          GetTensorShape(output), GetTensorData<int64_t>(output));
      break;
    case kTfLiteInt32:
      reference_ops::Negate(
          GetTensorShape(input), GetTensorData<int32_t>(input),
          GetTensorShape(output), GetTensorData<int32_t>(output));
      break;
    case kTfLiteFloat32:
      reference_ops::Negate(GetTensorShape(input), GetTensorData<float>(input),
                            GetTensorShape(output),
                            GetTensorData<float>(output));
      break;
    default:
      context->ReportError(
          context,
          ""Neg only currently supports int64, int32, and float32, got %d."",
          input->type);
      return kTfLiteError;
  }
  return kTfLiteOk;
}",1
Detect whether the following code contains vulnerabilities.,"mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)
{
  struct RClass *ins_pos;

  ins_pos = c;
  while (m) {
    struct RClass *p = c, *ic;
    int superclass_seen = 0;

    if (c->mt == m->mt) {
      mrb_raise(mrb, E_ARGUMENT_ERROR, ""cyclic include detected"");
    }
    while (p) {
      if (c != p && p->tt == MRB_TT_CLASS) {
        superclass_seen = 1;
      }
      else if (p->mt == m->mt) {
        if (p->tt == MRB_TT_ICLASS && !superclass_seen) {
          ins_pos = p;
        }
        goto skip;
      }
      p = p->super;
    }
    ic = (struct RClass*)mrb_obj_alloc(mrb, MRB_TT_ICLASS, mrb->class_class);
    if (m->tt == MRB_TT_ICLASS) {
      ic->c = m->c;
    }
    else {
      ic->c = m;
    }
    ic->mt = m->mt;
    ic->iv = m->iv;
    ic->super = ins_pos->super;
    ins_pos->super = ic;
    mrb_field_write_barrier(mrb, (struct RBasic*)ins_pos, (struct RBasic*)ic);
    ins_pos = ic;
  skip:
    m = m->super;
  }
}",0
Detect whether the following code contains vulnerabilities.,"	switch (yych) {
		case 'a': goto yy8;
		default: goto yy5;
	}",1
Detect whether the following code contains vulnerabilities.,"u64 snmp_get_cpu_field64(void __percpu *mib, int cpu, int offt,
			 size_t syncp_offset)
{
	void *bhptr;
	struct u64_stats_sync *syncp;
	u64 v;
	unsigned int start;

	bhptr = per_cpu_ptr(mib, cpu);
	syncp = (struct u64_stats_sync *)(bhptr + syncp_offset);
	do {
		start = u64_stats_fetch_begin_irq(syncp);
		v = *(((u64 *)bhptr) + offt);
	} while (u64_stats_fetch_retry_irq(syncp, start));

	return v;
}",0
Detect whether the following code contains vulnerabilities.,"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint8_t val = data;

    if (addr > (vdev->config_len - sizeof(val)))
        return;

    stb_p(vdev->config + addr, val);

    if (k->set_config) {
        k->set_config(vdev, vdev->config);
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void t_gen_cc_jmp(TCGv pc_true, TCGv pc_false)

{

	TCGv btaken;

	int l1;



	l1 = gen_new_label();

	btaken = tcg_temp_new(TCG_TYPE_TL);



	/* Conditional jmp.  */

	tcg_gen_mov_tl(btaken, env_btaken);

	tcg_gen_mov_tl(env_pc, pc_false);

	tcg_gen_brcondi_tl(TCG_COND_EQ, btaken, 0, l1);

	tcg_gen_mov_tl(env_pc, pc_true);

	gen_set_label(l1);



	tcg_temp_free(btaken);

}
",0
Detect whether the following code contains vulnerabilities.,"commercial_to_jd(VALUE y, int w, int d, double sg,
		 VALUE *nth, int *ry,
		 int *rjd,
		 int *ns)
{
    double style = guess_style(y, sg);

    if (style == 0) {
	int jd;

	c_commercial_to_jd(FIX2INT(y), w, d, sg, &jd, ns);
	decode_jd(INT2FIX(jd), nth, rjd);
	if (f_zero_p(*nth))
	    *ry = FIX2INT(y);
	else {
	    VALUE nth2;
	    decode_year(y, *ns ? -1 : +1, &nth2, ry);
	}
    }
    else {
	decode_year(y, style, nth, ry);
	c_commercial_to_jd(*ry, w, d, style, rjd, ns);
    }
}",0
Detect whether the following code contains vulnerabilities.,"inline void Tanh(const float* input_data, const Dims<4>& input_dims,
                 float* output_data, const Dims<4>& output_dims) {
  Tanh(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}",0
Detect whether the following code contains vulnerabilities.,"static void gen_dcread(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    TCGv EA, val;

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_set_access_type(ctx, ACCESS_CACHE);

    EA = tcg_temp_new();

    gen_addr_reg_index(ctx, EA);

    val = tcg_temp_new();

    gen_qemu_ld32u(ctx, val, EA);

    tcg_temp_free(val);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], EA);

    tcg_temp_free(EA);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static inline unsigned long zap_pud_range(struct mmu_gather *tlb,
				struct vm_area_struct *vma, pgd_t *pgd,
				unsigned long addr, unsigned long end,
				struct zap_details *details)
{
	pud_t *pud;
	unsigned long next;

	pud = pud_offset(pgd, addr);
	do {
		next = pud_addr_end(addr, end);
		if (pud_none_or_clear_bad(pud))
			continue;
		next = zap_pmd_range(tlb, vma, pud, addr, next, details);
	} while (pud++, addr = next, addr != end);

	return addr;
}",0
Detect whether the following code contains vulnerabilities.,"static void compactxref(fz_context *ctx, pdf_document *doc, pdf_write_state *opts)
{
	int num, newnum;
	int xref_len = pdf_xref_len(ctx, doc);

	/*
	 * Update renumber_map in-place, clustering all used
	 * objects together at low object ids. Objects that
	 * already should be renumbered will have their new
	 * object ids be updated to reflect the compaction.
	 */

	newnum = 1;
	for (num = 1; num < xref_len; num++)
	{
		/* If it's not used, map it to zero */
		if (!opts->use_list[opts->renumber_map[num]])
		{
			opts->renumber_map[num] = 0;
		}
		/* If it's not moved, compact it. */
		else if (opts->renumber_map[num] == num)
		{
			opts->rev_renumber_map[newnum] = opts->rev_renumber_map[num];
			opts->renumber_map[num] = newnum++;
		}
		/* Otherwise it's used, and moved. We know that it must have
		 * moved down, so the place it's moved to will be in the right
		 * place already. */
		else
		{
			opts->renumber_map[num] = opts->renumber_map[opts->renumber_map[num]];
		}
	}
}",1
Detect whether the following code contains vulnerabilities.,"int spapr_rtas_register(const char *name, spapr_rtas_fn fn)

{

    int i;



    for (i = 0; i < (rtas_next - rtas_table); i++) {

        if (strcmp(name, rtas_table[i].name) == 0) {

            fprintf(stderr, ""RTAS call \""%s\"" registered twice\n"", name);

            exit(1);

        }

    }



    assert(rtas_next < (rtas_table + TOKEN_MAX));



    rtas_next->name = name;

    rtas_next->fn = fn;



    return (rtas_next++ - rtas_table) + TOKEN_BASE;

}
",1
Detect whether the following code contains vulnerabilities.,"static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,
			    struct msghdr *msg, size_t len,
			    int flags)
{
	int err;
	struct sk_buff *skb;
	struct sock *sk = sock->sk;

	err = -EIO;
	if (sk->sk_state & PPPOX_BOUND)
		goto end;

	msg->msg_namelen = 0;

	err = 0;
	skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
				flags & MSG_DONTWAIT, &err);
	if (skb) {
		err = memcpy_toiovec(msg->msg_iov, (unsigned char *) skb->data,
				     skb->len);
		if (err < 0)
			goto do_skb_free;
		err = skb->len;
	}
do_skb_free:
	kfree_skb(skb);
end:
	return err;
}",1
Detect whether the following code contains vulnerabilities.,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,
                                  QEMUIOVector *iov, int nb_sectors,
                                  BlockDriverCompletionFunc *cb, void *opaque)
{
    return bdrv_aio_rw_vector(bs, sector_num, iov, nb_sectors,
                              cb, opaque, 1);
}",1
Detect whether the following code contains vulnerabilities.,"For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int
    lineno, int col_offset, int end_lineno, int end_col_offset, PyArena *arena)
{
    stmt_ty p;
    if (!target) {
        PyErr_SetString(PyExc_ValueError,
                        ""field target is required for For"");
        return NULL;
    }
    if (!iter) {
        PyErr_SetString(PyExc_ValueError,
                        ""field iter is required for For"");
        return NULL;
    }
    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p)
        return NULL;
    p->kind = For_kind;
    p->v.For.target = target;
    p->v.For.iter = iter;
    p->v.For.body = body;
    p->v.For.orelse = orelse;
    p->lineno = lineno;
    p->col_offset = col_offset;
    p->end_lineno = end_lineno;
    p->end_col_offset = end_col_offset;
    return p;
}",1
Detect whether the following code contains vulnerabilities.,"set_num_723(unsigned char *p, uint16_t value)
{
	archive_le16enc(p, value);
	archive_be16enc(p+2, value);
}",0
Detect whether the following code contains vulnerabilities.,"static void vnc_desktop_resize(VncState *vs)

{

    DisplaySurface *ds = vs->vd->ds;



    if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {

        return;

    }

    if (vs->client_width == surface_width(ds) &&

        vs->client_height == surface_height(ds)) {

        return;

    }

    vs->client_width = surface_width(ds);

    vs->client_height = surface_height(ds);

    vnc_lock_output(vs);

    vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);

    vnc_write_u8(vs, 0);

    vnc_write_u16(vs, 1); /* number of rects */

    vnc_framebuffer_update(vs, 0, 0, vs->client_width, vs->client_height,

                           VNC_ENCODING_DESKTOPRESIZE);

    vnc_unlock_output(vs);

    vnc_flush(vs);

}
",1
Detect whether the following code contains vulnerabilities.,"static int filter_frame(AVFilterLink *link, AVFrame *frame)

{

    AVFilterContext *ctx = link->dst;

    AudioFIRContext *s = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    int ret = 0;



    av_audio_fifo_write(s->fifo[0], (void **)frame->extended_data,

                        frame->nb_samples);

    if (s->pts == AV_NOPTS_VALUE)

        s->pts = frame->pts;



    av_frame_free(&frame);



    if (!s->have_coeffs && s->eof_coeffs) {

        ret = convert_coeffs(ctx);

        if (ret < 0)

            return ret;

    }



    if (s->have_coeffs) {

        while (av_audio_fifo_size(s->fifo[0]) >= s->part_size) {

            ret = fir_frame(s, outlink);

            if (ret < 0)

                break;

        }

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline FILE *xfmkstemp(char **tmpname, char *dir)
{
	int fd;
	FILE *ret;

	fd = xmkstemp(tmpname, dir);
	if (fd == -1)
		return NULL;

	if (!(ret = fdopen(fd, ""w+"" UL_CLOEXECSTR))) {
		close(fd);
		return NULL;
	}
	return ret;
}",1
Detect whether the following code contains vulnerabilities.,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
{
	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
	    (EXTRACT_16BITS(dat) & 0xff)));
}",1
Detect whether the following code contains vulnerabilities.,"check_user_copy_file (const char *srcfile,
                      const char *destfile,
                      uid_t       user,
                      gssize      max_file_size)
{
        struct stat srcfileinfo;
        struct stat destfileinfo;

        if (max_file_size < 0) {
                max_file_size = G_MAXSIZE;
        }

        /* Exists/Readable? */
        if (g_stat (srcfile, &srcfileinfo) < 0) {
                g_debug (""File does not exist"");
                return FALSE;
        }

        /* Is newer than the file already in the cache? */
        if (destfile != NULL && g_stat (destfile, &destfileinfo) == 0) {
                if (srcfileinfo.st_mtime <= destfileinfo.st_mtime) {
                        g_debug (""Destination file is newer"");
                        return FALSE;
                }
        }

        /* Is a regular file */
        if (G_UNLIKELY (!S_ISREG (srcfileinfo.st_mode))) {
                g_debug (""File is not a regular file"");
                return FALSE;
        }

        /* Owned by user? */
        if (G_UNLIKELY (srcfileinfo.st_uid != user)) {
                g_debug (""File is not owned by user"");
                return FALSE;
        }

        /* Size is kosher? */
        if (G_UNLIKELY (srcfileinfo.st_size > max_file_size)) {
                g_debug (""File is too large"");
                return FALSE;
        }

        return TRUE;
}",0
Detect whether the following code contains vulnerabilities.,"void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)
{
    int reslevelno, bandno, precno;
    for (reslevelno = 0;
         comp->reslevel && reslevelno < codsty->nreslevels;
         reslevelno++) {
        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;

        for (bandno = 0; bandno < reslevel->nbands; bandno++) {
            Jpeg2000Band *band = reslevel->band + bandno;
            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {
                Jpeg2000Prec *prec = band->prec + precno;
                av_freep(&prec->zerobits);
                av_freep(&prec->cblkincl);
                av_freep(&prec->cblk);
            }

            av_freep(&band->prec);
        }
        av_freep(&reslevel->band);
    }

    ff_dwt_destroy(&comp->dwt);
    av_freep(&comp->reslevel);
    av_freep(&comp->i_data);
    av_freep(&comp->f_data);
}",1
Detect whether the following code contains vulnerabilities.,"static av_always_inline void thread_park_workers(SliceThreadContext *c, int thread_count)

{

    while (c->current_job != thread_count + c->job_count)

        pthread_cond_wait(&c->last_job_cond, &c->current_job_lock);

    pthread_mutex_unlock(&c->current_job_lock);

}
",1
Detect whether the following code contains vulnerabilities.,"void virtio_9p_push_and_notify(V9fsPDU *pdu)

{

    V9fsState *s = pdu->s;

    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);

    VirtQueueElement *elem = &v->elems[pdu->idx];



    /* push onto queue and notify */

    virtqueue_push(v->vq, elem, pdu->size);



    /* FIXME: we should batch these completions */

    virtio_notify(VIRTIO_DEVICE(v), v->vq);

}
",0
Detect whether the following code contains vulnerabilities.,"static GArray *nvdimm_build_device_structure(void)

{

    GSList *device_list = nvdimm_get_plugged_device_list();

    GArray *structures = g_array_new(false, true /* clear */, 1);



    for (; device_list; device_list = device_list->next) {

        DeviceState *dev = device_list->data;



        /* build System Physical Address Range Structure. */

        nvdimm_build_structure_spa(structures, dev);



        /*

         * build Memory Device to System Physical Address Range Mapping

         * Structure.

         */

        nvdimm_build_structure_memdev(structures, dev);



        /* build NVDIMM Control Region Structure. */

        nvdimm_build_structure_dcr(structures, dev);

    }

    g_slist_free(device_list);



    return structures;

}
",0
Detect whether the following code contains vulnerabilities.,"void qpci_msix_disable(QPCIDevice *dev)

{

    uint8_t addr;

    uint16_t val;



    g_assert(dev->msix_enabled);

    addr = qpci_find_capability(dev, PCI_CAP_ID_MSIX);

    g_assert_cmphex(addr, !=, 0);

    val = qpci_config_readw(dev, addr + PCI_MSIX_FLAGS);

    qpci_config_writew(dev, addr + PCI_MSIX_FLAGS,

                                                val & ~PCI_MSIX_FLAGS_ENABLE);



    qpci_iounmap(dev, dev->msix_table);

    qpci_iounmap(dev, dev->msix_pba);

    dev->msix_enabled = 0;

    dev->msix_table = NULL;

    dev->msix_pba = NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static int skip_data_stream_element(AACContext *ac, GetBitContext *gb)

{

    int byte_align = get_bits1(gb);

    int count = get_bits(gb, 8);

    if (count == 255)

        count += get_bits(gb, 8);

    if (byte_align)

        align_get_bits(gb);



    if (get_bits_left(gb) < 8 * count) {

        av_log(ac->avctx, AV_LOG_ERROR, overread_err);

        return -1;

    }

    skip_bits_long(gb, 8 * count);

    return 0;

}
",1
