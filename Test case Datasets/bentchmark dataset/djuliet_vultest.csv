instruction,input,output
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_01()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_relativePath_65aSink;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_42()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_09()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_53c_CWE114_Process_Control__w32_char_file_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_file_53d_CWE114_Process_Control__w32_char_file_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_17()
{
    int h;
    wchar_t * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_18()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    goto source;
source:
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    goto sink;
sink:
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_31()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strcat(dest, data);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_67bSink(structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22bSource(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22bGlobal)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_07()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_18()
{
    void * data;
    data = NULL;
    goto source;
source:
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    goto sink;
sink:
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_17()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54cSink_c(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int * buffer = new int[10];
        /* initialize buffer */
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        delete[] buffer;
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_17()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44Sink;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_03()
{
    int data;
    /* Initialize data */
    data = -1;
    if(5==5)
    {
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
    }
    if(5==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_18()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_07()
{
    int64_t * data;
    data = NULL;
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54dSink_d(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_16()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_43Source(int &data)
{
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)
{
    wchar_t * data = dataVector[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73bSink(list<int64_t *> dataList)
{
    /* copy data out of dataList */
    int64_t * data = dataList.back();
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73a()
{
    int * data;
    list<int *> dataList;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74a()
{
    char * data;
    map<int, char *> dataMap;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink()
{
    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_11()
{
    if(globalReturnsTrue())
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    {
        wchar_t * data = dataRef;
        {
            wchar_t source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = wcslen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_61bSource(wchar_t * data)
{
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_34()
{
    int data;
    unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_74bSink(map<int, void *> dataMap)
{
    void * data = dataMap[2];
    {
        /* FIX: treating pointer like a wchar_t*  */
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);
        printWLine((wchar_t *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(char * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_17()
{
    int h;
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65bSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67_structType myStruct;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_12()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_06()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_11()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(globalReturnsFalse())
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int * * dataPtr = (int * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int * data = (*dataPtr);
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_01()
{
    wchar_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_16()
{
    int * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Source(TwoIntsClass * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Static)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new TwoIntsClass[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = wcslen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_wchar_t_file_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()
{
    void * data;
    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65b_CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_32()
{
    void * data;
    void * *dataPtr1 = &data;
    void * *dataPtr2 = &data;
    data = NULL;
    {
        void * data = *dataPtr1;
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
        *dataPtr1 = data;
    }
    {
        void * data = *dataPtr2;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_12()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_16()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_34()
{
    int * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72bSink(vector<int64_t *> dataVector)
{
    /* copy data out of dataVector */
    int64_t * data = dataVector[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_22bSource(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_22bGlobal)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()
{
    void * data;
    void * dataArray[5];
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22aGlobal = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int64_t * data = (*dataPtr);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_42()
{
    int * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_42Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_34()
{
    void * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_12()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_44()
{
    int * data;
    /* define a function pointer */
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_44Sink;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54eSink(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_12()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_54d_CWE114_Process_Control__w32_wchar_t_console_54dSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_console_54e_CWE114_Process_Control__w32_wchar_t_console_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_67a()
{
    wchar_t * data;
    CWE114_Process_Control__w32_wchar_t_console_67_structType myStruct;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = wcslen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgetws() */
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                data[dataLen] = L'\0';
            }
        }
    }
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_wchar_t_console_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_12()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73a()
{
    int * data;
    list<int *> dataList;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_17()
{
    int h;
    char * data;
    data = new char[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74a()
{
    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_15()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strcat(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_72a()
{
    twoIntsStruct * data;
    vector<twoIntsStruct *> dataVector;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_18()
{
    goto sink;
sink:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printLine((char *)structCharVoid.voidSecond);
        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid.charFirst);
        printLine((char *)structCharVoid.voidSecond);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_21()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])
{
    /* copy data out of dataArray */
    void * data = dataArray[2];
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_15()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53dSink(char * data)
{
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_44()
{
    int * data;
    /* define a function pointer */
    void (*funcPtr) (int *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_44Sink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_12()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_04()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_08()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(staticReturnsFalse())
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_18()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_64a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_17()
{
    int i;
    wchar_t * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_12()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_41Sink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_08()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    if(staticReturnsTrue())
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(staticReturnsTrue())
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bSource(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bGlobal)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34()
{
    wchar_t * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_52bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_18()
{
    int data;
    /* Initialize data */
    data = -1;
    goto source;
source:
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    goto sink;
sink:
    {
        int i;
        int * buffer = new int[10];
        /* initialize buffer */
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        delete[] buffer;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_16()
{
    int * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        break;
    }
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_01()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42()
{
    char * data;
    data = new char[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_44()
{
    void * data;
    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_44Sink;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_74a()
{
    int * data;
    map<int, int *> dataMap;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_17()
{
    int h;
    int64_t * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strcat(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_53c_CWE114_Process_Control__w32_wchar_t_environment_53cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_environment_53d_CWE114_Process_Control__w32_wchar_t_environment_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int64_t * data = (*dataPtr);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_65aSink;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_15()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_32()
{
    TwoIntsClass * data;
    TwoIntsClass * *dataPtr1 = &data;
    TwoIntsClass * *dataPtr2 = &data;
    data = NULL;
    {
        TwoIntsClass * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
        *dataPtr1 = data;
    }
    {
        TwoIntsClass * data = *dataPtr2;
        {
            TwoIntsClass source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(TwoIntsClass));
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_54d_CWE114_Process_Control__w32_char_file_54dSink(char * data)
{
    CWE114_Process_Control__w32_char_file_54e_CWE114_Process_Control__w32_char_file_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54a()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_17()
{
    int i;
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_63bSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_15()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73bSink(list<int> dataList)
{
    /* copy data out of dataList */
    int data = dataList.back();
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_17()
{
    int h,j;
    int data;
    /* Initialize data */
    data = -1;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
         * access an index of the array in the sink that is out-of-bounds */
        data = 7;
    }
    for(j = 0; j < 1; j++)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22a()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22aSource(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcscat(data, source);
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51bSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_12()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_32()
{
    void * data;
    void * *dataPtr1 = &data;
    void * *dataPtr2 = &data;
    data = NULL;
    {
        void * data = *dataPtr1;
        /* FIX: Set data to point to a char string */
        data = (void *)CHAR_STRING;
        *dataPtr1 = data;
    }
    {
        void * data = *dataPtr2;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34_unionType myUnion;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_10()
{
    char * data;
    data = NULL;
    if(globalTrue)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_listen_socket_52b_CWE114_Process_Control__w32_char_listen_socket_52bSink(char * data)
{
    CWE114_Process_Control__w32_char_listen_socket_52c_CWE114_Process_Control__w32_char_listen_socket_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_52bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_18()
{
    wchar_t * data;
    data = NULL;
    goto source;
source:
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_44Sink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_66a()
{
    int * data;
    int * dataArray[5];
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_53c_CWE114_Process_Control__w32_char_connect_socket_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_53d_CWE114_Process_Control__w32_char_connect_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_03()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_32()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    /* Initialize data */
    data = -1;
    {
        int data = *dataPtr1;
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            /* POTENTIAL FLAW: Read data from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to int */
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int * * dataPtr = (int * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int * data = (*dataPtr);
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_54a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54b_CWE121_Stack_Based_Buffer_Overflow__CWE135_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66bSink(int * dataArray[])
{
    int * data = dataArray[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_62bSource(wchar_t * &data)
{
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE114_Process_Control__w32_char_environment_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72a()
{
    int64_t * data;
    vector<int64_t *> dataVector;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_06()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_16()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_34_unionType myUnion;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strncpy(data, source, strlen(source) + 1);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_03()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(5==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_04()
{
    TwoIntsClass * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new TwoIntsClass[100];
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(int * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_17()
{
    int i;
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_15()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_12()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)
{
    wchar_t * data = dataList.back();
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_listen_socket_53c_CWE114_Process_Control__w32_char_listen_socket_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_listen_socket_53d_CWE114_Process_Control__w32_char_listen_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_21()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE114_Process_Control__w32_char_connect_socket_21Static = 0; /* false */
    data = CWE114_Process_Control__w32_char_connect_socket_21Source(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_12()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10()
{
    int * data;
    data = NULL;
    if(globalTrue)
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_54b_CWE114_Process_Control__w32_char_relativePath_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_relativePath_54c_CWE114_Process_Control__w32_char_relativePath_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_01()
{
    char * data;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a()
{
    twoIntsStruct * data;
    /* define a function pointer */
    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65aSink;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73a()
{
    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_01()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61a()
{
    int * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61aSource(data);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34_unionType myUnion;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_54c_CWE114_Process_Control__w32_wchar_t_file_54cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_file_54d_CWE114_Process_Control__w32_wchar_t_file_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t * data = dataRef;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67_structType myStruct;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_03()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_44()
{
    void * data;
    /* define a function pointer */
    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_44Sink;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_08()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(staticReturnsTrue())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE114_Process_Control__w32_wchar_t_environment_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54dSink_d(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_16()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_44Sink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_43Source(int &data)
{
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34_unionType myUnion;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            for (i = 0; i < 10; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67_structType myStruct;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    {
        char * data = *dataPtr1;
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_17()
{
    int i;
    int64_t * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_15()
{
    int64_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44Sink(int data)
{
    {
        int i;
        int buffer[10] = { 0 };
        /* FIX: Properly validate the array index and prevent a buffer overflow */
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_06()
{
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_33()
{
    char * data;
    char * &dataRef = data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_52bSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_52bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_52bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_74a()
{
    void * data;
    map<int, void *> dataMap;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_34()
{
    wchar_t * data;
    unionType myUnion;
    data = new wchar_t[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_73a()
{
    int * data;
    list<int *> dataList;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_01()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = strlen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_43Source(wchar_t * &data)
{
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_03()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(5==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_18()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_33()
{
    char * data;
    char * &dataRef = data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    {
        char * data = dataRef;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_12()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_14()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(globalFive==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            memcpy(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE114_Process_Control__w32_wchar_t_relativePath_44Sink;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void * CWE121_Stack_Based_Buffer_Overflow__CWE135_42Source(void * data)
{
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_31()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_12()
{
    int64_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_02()
{
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_41()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE114_Process_Control__w32_char_environment_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            size_t i;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_02()
{
    wchar_t * data;
    data = NULL;
    if(1)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_34_unionType myUnion;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t * data = dataRef;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_06()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    if(STATIC_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34_unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41Sink(int * data)
{
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_17()
{
    int i;
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_34()
{
    int64_t * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Static = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41Sink(int data)
{
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_12()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72a()
{
    char * data;
    vector<char *> dataVector;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22a()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22aGlobal = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22aSource(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22a()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22aSource(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_wchar_t_relativePath_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Sink()
{
    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Data;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_01()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63bSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_17()
{
    int i;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_41Sink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_15()
{
    TwoIntsClass * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_62a()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_62aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_72bSink(vector<int *> dataVector)
{
    int * data = dataVector[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72a()
{
    int * data;
    vector<int *> dataVector;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_14()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalFive==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_41()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    CWE114_Process_Control__w32_wchar_t_connect_socket_41_CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryW(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34_unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_16()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"int CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61bSource(int data)
{
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_03()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(5==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_62bSource(TwoIntsClass * &data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_43Source(int &data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_63a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_62bSource(TwoIntsClass * &data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_02()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(1)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_16()
{
    wchar_t * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_22a()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    CWE114_Process_Control__w32_wchar_t_console_22aGlobal = 1; /* true */
    data = CWE114_Process_Control__w32_wchar_t_console_22aSource(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_21Sink(int data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_21Static)
    {
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_73a()
{
    int * data;
    list<int *> dataList;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_16()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    while(1)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_41()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    CWE114_Process_Control__w32_wchar_t_environment_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            memcpy(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_03()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    if(5==5)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(5==5)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74a()
{
    int * data;
    map<int, int *> dataMap;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_11()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(globalReturnsTrue())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74bSink(map<int, int64_t *> dataMap)
{
    /* copy data out of dataMap */
    int64_t * data = dataMap[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_01()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_18()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66a()
{
    int * data;
    int * dataArray[5];
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54eSink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67_structType myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_01()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_34()
{
    char * data;
    unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_03()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(5==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_06()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_31()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    {
        TwoIntsClass * dataCopy = data;
        TwoIntsClass * data = dataCopy;
        {
            TwoIntsClass source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0].intOne);
                delete [] data;
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_03()
{
    char * data;
    data = NULL;
    if(5==5)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22a()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22aSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17()
{
    int k;
    for(k = 0; k < 1; k++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_06()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21Static = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_44Sink;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Static = 0; /* false */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_02()
{
    wchar_t * data;
    data = NULL;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_62bSource(char * &data)
{
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73bSink(list<int *> dataList)
{
    /* copy data out of dataList */
    int * data = dataList.back();
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_66a()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_34_unionType myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            strncpy(dest, data, strlen(data));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_06()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_41Sink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_07()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67_structType myStruct;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53a()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_16()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    while(1)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
        break;
    }
    while(1)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t dest[50] = L"""";
            size_t i, dataLen;
            dataLen = wcslen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_listen_socket_54c_CWE114_Process_Control__w32_wchar_t_listen_socket_54cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_listen_socket_54d_CWE114_Process_Control__w32_wchar_t_listen_socket_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_15()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_17()
{
    int h;
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44()
{
    int64_t * data;
    /* define a function pointer */
    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44Sink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72bSink(vector<int64_t *> dataVector)
{
    int64_t * data = dataVector[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_31()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    {
        int * dataCopy = data;
        int * data = dataCopy;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t * data = dataRef;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_15()
{
    char * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41Sink(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_13()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_54d_CWE114_Process_Control__w32_char_console_54dSink(char * data)
{
    CWE114_Process_Control__w32_char_console_54e_CWE114_Process_Control__w32_char_console_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_18()
{
    int data;
    /* Initialize data */
    data = -1;
    goto source;
source:
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    goto sink;
sink:
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_14()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67_structType myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_22bSink(void * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE135_22bGlobal)
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a()
{
    int * data;
    int * dataArray[5];
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_65aSink;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73bSink(list<int> dataList)
{
    int data = dataList.back();
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)
{
    wchar_t * data = dataVector[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_42()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_42Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_44()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_44Sink;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17()
{
    int i;
    int * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_13()
{
    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_54b_CWE114_Process_Control__w32_wchar_t_file_54bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_file_54c_CWE114_Process_Control__w32_wchar_t_file_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45Data;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_07()
{
    int data;
    /* Initialize data */
    data = -1;
    if(staticFive==5)
    {
        /* POTENTIAL FLAW: Use an invalid index */
        data = 10;
    }
    if(staticFive==5)
    {
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52cSink(int * data)
{
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_12()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_01()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65aSink;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_45Sink()
{
    void * data = CWE121_Stack_Based_Buffer_Overflow__CWE135_45_CWE121_Stack_Based_Buffer_Overflow__CWE135_45Data;
    {
        /* FIX: treating pointer like a wchar_t*  */
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_03()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(5==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_54c_CWE114_Process_Control__w32_char_file_54cSink(char * data)
{
    CWE114_Process_Control__w32_char_file_54d_CWE114_Process_Control__w32_char_file_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_31()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    {
        int dataCopy = data;
        int data = dataCopy;
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17()
{
    int i;
    char * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54dSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_41_CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(wchar_t * data)
{
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = new wchar_t[100];
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_67a()
{
    char * data;
    CWE114_Process_Control__w32_char_console_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_char_console_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44Sink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_relativePath_43Source(char * &data)
{
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_unionType myUnion;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printLongLongLine(data[0]);
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Source(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int64_t * data = (*dataPtr);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67a()
{
    int * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_31()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strcat(dest, data);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_53c_CWE114_Process_Control__w32_char_environment_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_environment_53d_CWE114_Process_Control__w32_char_environment_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_04()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_63a()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65a()
{
    int data;
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65aSink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_67a()
{
    char * data;
    CWE114_Process_Control__w32_char_relativePath_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_char_relativePath_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53a()
{
    char * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_33()
{
    char * data;
    char * &dataRef = data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strncat(dest, data, strlen(data));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54dSink_d(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_01()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34_unionType myUnion;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72bSink(vector<int *> dataVector)
{
    /* copy data out of dataVector */
    int * data = dataVector[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_62a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_62aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
            wcsncat(data, source, 100);
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15()
{
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printLine((char *)structCharVoid.voidSecond);
        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid.charFirst);
        printLine((char *)structCharVoid.voidSecond);
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_34_unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22a()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22aSource(data);
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41Sink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_66a()
{
    TwoIntsClass * data;
    TwoIntsClass * dataArray[5];
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_16()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_54b_CWE114_Process_Control__w32_char_environment_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_environment_54c_CWE114_Process_Control__w32_char_environment_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_45Data;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73a()
{
    int * data;
    list<int *> dataList;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22a()
{
    TwoIntsClass * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22aGlobal = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22aSource(data);
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_04()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_62bSource(char * &data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_04()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_connect_socket_21Static)
    {
        /* FIX: Specify the full pathname for the library */
        wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_51a()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;
    /* dereference dataPtr into data */
    TwoIntsClass * data = (*dataPtr);
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_42()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    data = CWE114_Process_Control__w32_char_connect_socket_42Source(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_45Data;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bSource(char * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bGlobal)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_15()
{
    char * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_54c_CWE114_Process_Control__w32_wchar_t_console_54cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_console_54d_CWE114_Process_Control__w32_wchar_t_console_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_43Source(wchar_t * &data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_41Sink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_02()
{
    char * data;
    data = NULL;
    if(1)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_72a()
{
    int * data;
    vector<int *> dataVector;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_listen_socket_54c_CWE114_Process_Control__w32_char_listen_socket_54cSink(char * data)
{
    CWE114_Process_Control__w32_char_listen_socket_54d_CWE114_Process_Control__w32_char_listen_socket_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_42Source(char * data)
{
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_12()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_12()
{
    char * data;
    data = new char[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_41Sink(int64_t * data)
{
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_04()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73bSink(list<int64_t *> dataList)
{
    /* copy data out of dataList */
    int64_t * data = dataList.back();
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61a()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_06()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54dSink_d(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67_structType myStruct;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_34()
{
    TwoIntsClass * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        {
            TwoIntsClass source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(TwoIntsClass));
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strncat(data, source, 100);
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a()
{
    int * data;
    /* define a function pointer */
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65aSink;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_02()
{
    char * data;
    data = NULL;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61bSource(int * data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_66a()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = strlen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_char_file_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_01()
{
    wchar_t * data;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_17()
{
    int h;
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_43Source(void * &data)
{
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67_structType myStruct;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_64a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67a()
{
    wchar_t * data;
    structType myStruct;
    data = new wchar_t[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_06()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66bSink(wchar_t * dataArray[])
{
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34_unionType myUnion;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67_structType myStruct;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_18()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    goto source;
source:
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67_structType myStruct;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_43Source(char * &data)
{
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])
{
    void * data = dataArray[2];
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()
{
    int data;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink()
{
    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_15()
{
    char * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_54c_CWE114_Process_Control__w32_wchar_t_relativePath_54cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_54d_CWE114_Process_Control__w32_wchar_t_relativePath_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_44()
{
    int * data;
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_44Sink;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_17()
{
    int h;
    char * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44()
{
    int data;
    /* define a function pointer */
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44Sink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_01()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_15()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17()
{
    int k;
    for(k = 0; k < 1; k++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72a()
{
    int64_t * data;
    vector<int64_t *> dataVector;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67bSink(structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strncat(data, source, 100);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_16()
{
    char * data;
    data = new char[100];
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_01()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_31()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
            wcscat(dest, data);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_34()
{
    int64_t * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printLongLongLine(data[0]);
                delete [] data;
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_15()
{
    wchar_t * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67_structType myStruct;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67_structType myStruct;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_31()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int * dataCopy = data;
        int * data = dataCopy;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68a()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34_unionType myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = wcslen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[10] = {0};
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            memcpy(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_15()
{
    char * data;
    data = new char[100];
    switch(6)
    {
    case 6:
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_72bSink(vector<void *> dataVector)
{
    /* copy data out of dataVector */
    void * data = dataVector[2];
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44Sink;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_32()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54dSink_d(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_12()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_41Sink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54dSink_d(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_53b_CWE114_Process_Control__w32_wchar_t_file_53bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_file_53c_CWE114_Process_Control__w32_wchar_t_file_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_03()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    if(5==5)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(5==5)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_65bSink(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_42()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_12()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_04()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_33()
{
    char * data;
    char * &dataRef = data;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strcat(dest, data);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72bSink(vector<int64_t *> dataVector)
{
    /* copy data out of dataVector */
    int64_t * data = dataVector[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65a()
{
    TwoIntsClass * data;
    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65aSink;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74a()
{
    char * data;
    map<int, char *> dataMap;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_67a()
{
    wchar_t * data;
    CWE114_Process_Control__w32_wchar_t_connect_socket_67_structType myStruct;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_wchar_t_connect_socket_67b_CWE114_Process_Control__w32_wchar_t_connect_socket_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_33()
{
    int * data;
    int * &dataRef = data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    {
        int * data = dataRef;
        {
            int source[10] = {0};
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            for (i = 0; i < 10; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_42Source(wchar_t * data)
{
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_15()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_52b_CWE114_Process_Control__w32_wchar_t_file_52bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_file_52c_CWE114_Process_Control__w32_wchar_t_file_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_14()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_17()
{
    int i,k;
    int data;
    /* Initialize data */
    data = -1;
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
    }
    for(k = 0; k < 1; k++)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_18()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67a()
{
    char * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            wcscpy(data, source);
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_03()
{
    wchar_t * data;
    data = NULL;
    if(5==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_10()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalTrue)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_67a()
{
    TwoIntsClass * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_10()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(globalTrue)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52cSink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_53c_CWE114_Process_Control__w32_wchar_t_relativePath_53cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_53d_CWE114_Process_Control__w32_wchar_t_relativePath_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_42()
{
    wchar_t * data;
    data = new wchar_t[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_42Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72a()
{
    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_01()
{
    char * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_15()
{
    int * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_17()
{
    int h;
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_62bSource(char * &data)
{
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_44()
{
    int64_t * data;
    /* define a function pointer */
    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_44Sink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_18()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_04()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        {
            /* Read input from a file */
            size_t dataLen = wcslen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        /* Restore NUL terminator if fgetws fails */
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45Data;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"char * CWE114_Process_Control__w32_char_relativePath_22bSource(char * data)
{
    if(CWE114_Process_Control__w32_char_relativePath_22bGlobal)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        strcpy(data, ""winsrv.dll"");
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53a()
{
    wchar_t * data;
    data = new wchar_t[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_relativePath_21Source(char * data)
{
    if(CWE114_Process_Control__w32_char_relativePath_21Static)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        strcpy(data, ""winsrv.dll"");
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_16()
{
    int * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
        break;
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcscat(data, source);
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_04()
{
    char * data;
    data = new char[100];
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_01()
{
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printWLine((wchar_t *)structCharVoid.voidSecond);
        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE114_Process_Control__w32_char_relativePath_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_unionType myUnion;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printLongLongLine(data[0]);
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_14()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_31()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54a()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44Sink;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_67bSink(structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_17()
{
    int h;
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45Sink()
{
    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45Data;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67_structType myStruct;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_15()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_01()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Source(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22a()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22aGlobal = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_34()
{
    wchar_t * data;
    CWE114_Process_Control__w32_wchar_t_relativePath_34_unionType myUnion;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryW(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_16()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72bSink(vector<int64_t *> dataVector)
{
    int64_t * data = dataVector[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_74bSink(map<int, int *> dataMap)
{
    /* copy data out of dataMap */
    int * data = dataMap[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_16()
{
    int * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_32()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    {
        int64_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printLongLongLine(data[0]);
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_67a()
{
    char * data;
    CWE114_Process_Control__w32_char_environment_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_char_environment_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_01()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_52bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_67a()
{
    wchar_t * data;
    CWE114_Process_Control__w32_wchar_t_relativePath_67_structType myStruct;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_wchar_t_relativePath_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = strlen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_char_file_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_74bSink(map<int, twoIntsStruct *> dataMap)
{
    /* copy data out of dataMap */
    twoIntsStruct * data = dataMap[2];
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_16()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    while(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34_unionType myUnion;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aGlobal = 0; /* false */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67_structType myStruct;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_06()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_67bSink(structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_54d_CWE114_Process_Control__w32_wchar_t_relativePath_54dSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_54e_CWE114_Process_Control__w32_wchar_t_relativePath_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_06()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_15()
{
    switch(6)
    {
    case 6:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printLine((char *)structCharVoid.voidSecond);
        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid.charFirst);
        printLine((char *)structCharVoid.voidSecond);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_41()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    CWE114_Process_Control__w32_char_relativePath_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41Sink(char * data)
{
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_15()
{
    char * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_32()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    /* Initialize data */
    data = -1;
    {
        int data = *dataPtr1;
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_51a()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_51b_CWE121_Stack_Based_Buffer_Overflow__CWE135_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54dSink_d(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_14()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67a()
{
    char * data;
    structType myStruct;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Source(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_54a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_53b_CWE114_Process_Control__w32_wchar_t_environment_53bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_environment_53c_CWE114_Process_Control__w32_wchar_t_environment_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_41()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int i;
        int buffer[10] = { 0 };
        /* FIX: Properly validate the array index and prevent a buffer overflow */
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67_structType myStruct;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_01()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_22bSource(char * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_22bGlobal)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_34_unionType myUnion;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            size_t i, dataLen;
            dataLen = wcslen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_41Sink(char * data)
{
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54a()
{
    wchar_t * data;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_52bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_67a()
{
    void * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72bSink(vector<int> dataVector)
{
    /* copy data out of dataVector */
    int data = dataVector[2];
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_08()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(staticReturnsTrue())
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct)
{
    void * data = myStruct.structFirst;
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_74bSink(map<int, int *> dataMap)
{
    /* copy data out of dataMap */
    int * data = dataMap[2];
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_33()
{
    void * data;
    void * &dataRef = data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    {
        void * data = dataRef;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy((wchar_t *)dest, (wchar_t *)data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()
{
    void * data;
    void * dataArray[5];
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_34_unionType myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a()
{
    twoIntsStruct * data;
    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65aSink;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_04()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
        data = dataGoodBuffer;
    }
    if(STATIC_CONST_TRUE)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_44Sink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_01()
{
    int data;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_16()
{
    int64_t * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            size_t i;
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_34()
{
    int * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73a()
{
    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static int CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_42Source(int data)
{
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_09()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_33()
{
    char * data;
    char * &dataRef = data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            strncat(data, source, 100);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_16()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    while(1)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_06()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_environment_21Source(char * data)
{
    if(CWE114_Process_Control__w32_char_environment_21Static)
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = strlen(data);
            char * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                strncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68a()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_08()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(staticReturnsTrue())
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_17()
{
    int k;
    for(k = 0; k < 1; k++)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */
            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
            free(structCharVoid);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_16()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_06()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_02()
{
    int64_t * data;
    data = NULL;
    if(1)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_53c_CWE114_Process_Control__w32_char_relativePath_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_relativePath_53d_CWE114_Process_Control__w32_char_relativePath_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_03()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(5==5)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_07()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_03()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(5==5)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_13()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_53c_CWE114_Process_Control__w32_char_console_53cSink(char * data)
{
    CWE114_Process_Control__w32_char_console_53d_CWE114_Process_Control__w32_char_console_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_64a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_01()
{
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid->voidSecond */
        printLine((char *)structCharVoid->voidSecond);
        /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */
        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
        free(structCharVoid);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_53dSink(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_08()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticReturnsTrue())
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_08()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(staticReturnsTrue())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_73bSink(list<void *> dataList)
{
    void * data = dataList.back();
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy((char *)dest, (char *)data);
        printLine((char *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_17()
{
    int h,j;
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    for(h = 0; h < 1; h++)
    {
        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
        data = dataGoodBuffer;
    }
    for(j = 0; j < 1; j++)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_01()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)
{
    int data = myStruct.structFirst;
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54eSink_e(char * data)
{
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    {
        char * data = *dataPtr1;
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68bSink()
{
    int * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68bData;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41Sink(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_53b_CWE114_Process_Control__w32_wchar_t_relativePath_53bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_53c_CWE114_Process_Control__w32_wchar_t_relativePath_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65aSink;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 0; /* false */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = new wchar_t[100];
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t dest[50] = L"""";
            size_t i, dataLen;
            dataLen = wcslen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_34_unionType myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66bSink(int * dataArray[])
{
    /* copy data out of dataArray */
    int * data = dataArray[2];
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(wchar_t * data)
{
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_63a()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_char_relativePath_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_73bSink(list<wchar_t *> dataList)
{
    wchar_t * data = dataList.back();
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_34_unionType myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            wcscpy(data, source);
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_01()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_41Sink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_02()
{
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE114_Process_Control__w32_wchar_t_relativePath_21Source(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_relativePath_21Static)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_17()
{
    int h;
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE114_Process_Control__w32_wchar_t_console_21Source(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_console_21Static)
    {
        {
            /* Read input from the console */
            size_t dataLen = wcslen(data);
            /* if there is room in data, read into it from the console */
            if (100-dataLen > 1)
            {
                /* POTENTIAL FLAW: Read data from the console */
                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgetws() */
                    dataLen = wcslen(data);
                    if (dataLen > 0 && data[dataLen-1] == L'\n')
                    {
                        data[dataLen-1] = L'\0';
                    }
                }
                else
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_44Sink;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"char * CWE114_Process_Control__w32_char_connect_socket_22_CWE114_Process_Control__w32_char_connect_socket_22bSource(char * data)
{
    if(CWE114_Process_Control__w32_char_connect_socket_22_CWE114_Process_Control__w32_char_connect_socket_22bGlobal)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Specify the full pathname for the library */
        strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_02()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Specify the full pathname for the library */
        strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_02()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_41Sink(wchar_t * data)
{
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink()
{
    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_31()
{
    char * data;
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_31()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strncat(dest, data, strlen(data));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_51a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_73bSink(list<wchar_t *> dataList)
{
    wchar_t * data = dataList.back();
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_02()
{
    int * data;
    data = NULL;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t * data = dataRef;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            wcsncpy(data, source, 100-1);
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_18()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_18()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    goto source;
source:
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_33()
{
    int * data;
    int * &dataRef = data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int * data = dataRef;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34_unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_64a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15()
{
    wchar_t * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_12()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_02()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(1)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_53b_CWE114_Process_Control__w32_char_file_53bSink(char * data)
{
    CWE114_Process_Control__w32_char_file_53c_CWE114_Process_Control__w32_char_file_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_12()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_04()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_17()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_16()
{
    char * data;
    data = new char[100];
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_12()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    else
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Source(char * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Static)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67a()
{
    char * data;
    structType myStruct;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()
{
    void * data;
    /* define a function pointer */
    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    switch(6)
    {
    case 6:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink()
{
    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34_unionType myUnion;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_15()
{
    int64_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61bSource(int * data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_73a()
{
    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_18()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    goto source;
source:
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE114_Process_Control__w32_wchar_t_relativePath_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22a()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_18()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_wchar_t_relativePath_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_06()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_52bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_33()
{
    char * data;
    char * &dataRef = data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    {
        char * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68a()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_wchar_t_environment_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74a()
{
    char * data;
    map<int, char *> dataMap;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74a()
{
    int64_t * data;
    map<int, int64_t *> dataMap;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[10] = {0};
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            for (i = 0; i < 10; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22a()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_13()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_16()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_17()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_18()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_72a()
{
    int64_t * data;
    vector<int64_t *> dataVector;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54dSink_d(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    {
        char * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strncpy(data, source, strlen(source) + 1);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_67a()
{
    char * data;
    CWE114_Process_Control__w32_char_file_67_structType myStruct;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = strlen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_char_file_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_41()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    CWE114_Process_Control__w32_char_connect_socket_41_CWE114_Process_Control__w32_char_connect_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_62bSource(wchar_t * &data)
{
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_01()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34_unionType myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_03()
{
    int data;
    /* Initialize data */
    data = -1;
    if(5!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
         * access an index of the array in the sink that is out-of-bounds */
        data = 7;
    }
    if(5==5)
    {
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_02()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_16()
{
    TwoIntsClass * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
        break;
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67_structType myStruct;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_char_environment_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65a()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65aSink;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])
{
    void * data = dataArray[2];
    {
        /* FIX: treating pointer like a wchar_t*  */
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_67bSink(structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_08()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(staticReturnsTrue())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(int * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_06()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_42()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()
{
    void * data;
    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65b_CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_11()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(globalReturnsTrue())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74a()
{
    int64_t * data;
    map<int, int64_t *> dataMap;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_22a()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    CWE114_Process_Control__w32_char_connect_socket_22aGlobal = 1; /* true */
    data = CWE114_Process_Control__w32_char_connect_socket_22aSource(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_06()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_18()
{
    wchar_t * data;
    data = NULL;
    goto source;
source:
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68a()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_08()
{
    int * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_07()
{
    wchar_t * data;
    data = NULL;
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54dSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_42Source(int data)
{
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_74bSink(map<int, wchar_t *> dataMap)
{
    wchar_t * data = dataMap[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()
{
    void * data;
    void * dataArray[5];
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_68a()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_68_CWE121_Stack_Based_Buffer_Overflow__CWE135_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_68b_CWE121_Stack_Based_Buffer_Overflow__CWE135_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_18()
{
    char * data;
    data = new char[100];
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_13()
{
    int64_t * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_53b_CWE114_Process_Control__w32_char_environment_53bSink(char * data)
{
    CWE114_Process_Control__w32_char_environment_53c_CWE114_Process_Control__w32_char_environment_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53dSink(int64_t * data)
{
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_07()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(staticFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_12()
{
    void * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    else
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
    else
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67_structType myStruct;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_06()
{
    char * data;
    data = new char[100];
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_01()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_09()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(GLOBAL_CONST_TRUE)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_wchar_t_connect_socket_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_06()
{
    int * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_34()
{
    char * data;
    unionType myUnion;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_43Source(char * &data)
{
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_char_console_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73bSink(list<int *> dataList)
{
    int * data = dataList.back();
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_02()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_03()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(5==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17()
{
    int h;
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_02()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_17()
{
    int i;
    char * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_03()
{
    int * data;
    data = NULL;
    if(5!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_02()
{
    int64_t * data;
    data = NULL;
    if(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Data;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_06()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22a()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22aSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_04()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21Source(data);
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_01()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_02()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_72a()
{
    char * data;
    vector<char *> dataVector;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_34()
{
    wchar_t * data;
    unionType myUnion;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
            wcsncat(dest, data, wcslen(data));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44()
{
    int * data;
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44Sink;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_03()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(5==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_16()
{
    wchar_t * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54dSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    {
        char * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memmove(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_33()
{
    void * data;
    void * &dataRef = data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    {
        void * data = dataRef;
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy((wchar_t *)dest, (wchar_t *)data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_42()
{
    char * data;
    data = new char[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_12()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44()
{
    int data;
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44Sink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_18()
{
    wchar_t * data;
    data = new wchar_t[100];
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22a()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Sink()
{
    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Data;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44Sink;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_07()
{
    int * data;
    data = NULL;
    if(staticFive==5)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_72bSink(vector<twoIntsStruct *> dataVector)
{
    /* copy data out of dataVector */
    twoIntsStruct * data = dataVector[2];
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_41()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_41_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_41Sink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44Sink;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_01()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_34_unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Static = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67_structType myStruct;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_15()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54dSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73a()
{
    int * data;
    list<int *> dataList;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE114_Process_Control__w32_char_console_22_CWE114_Process_Control__w32_char_console_22bSource(char * data)
{
    if(CWE114_Process_Control__w32_char_console_22_CWE114_Process_Control__w32_char_console_22bGlobal)
    {
        /* FIX: Specify the full pathname for the library */
        strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_53b_CWE114_Process_Control__w32_char_connect_socket_53bSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_53c_CWE114_Process_Control__w32_char_connect_socket_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67a()
{
    char * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74bSink(map<int, int> dataMap)
{
    int data = dataMap[2];
    {
        int i;
        int buffer[10] = { 0 };
        /* FIX: Properly validate the array index and prevent a buffer overflow */
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
            wcsncat(data, source, 100);
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_42Source(char * data)
{
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_01()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_53c_CWE114_Process_Control__w32_wchar_t_console_53cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_console_53d_CWE114_Process_Control__w32_wchar_t_console_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73a()
{
    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = strlen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
                fclose(pFile);
            }
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_char_file_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_01()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73a()
{
    TwoIntsClass * data;
    list<TwoIntsClass *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_72bSink(vector<int *> dataVector)
{
    int * data = dataVector[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = wcslen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgetws() */
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                data[dataLen] = L'\0';
            }
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_wchar_t_console_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_34_unionType myUnion;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41Sink(wchar_t * data)
{
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_17()
{
    int i;
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    {
        char * data = *dataPtr1;
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_18()
{
    wchar_t * data;
    data = NULL;
    goto source;
source:
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_environment_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = strlen(data);
        char * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            strncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_char_environment_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_08()
{
    int64_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_12()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_06()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_16()
{
    int * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        break;
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41()
{
    char * data;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22a()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_18()
{
    char * data;
    data = NULL;
    goto source;
source:
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_16()
{
    int64_t * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_16()
{
    while(1)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
        break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_45Data;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strcat(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61a()
{
    char * data;
    data = new char[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bSource(char * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bGlobal)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_52bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_67a()
{
    char * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_16()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    while(1)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22bSink(int data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22bGlobal)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_67a()
{
    TwoIntsClass * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54cSink_c(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44()
{
    int data;
    /* define a function pointer */
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44Sink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_52b_CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_52c_CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44()
{
    int data;
    /* define a function pointer */
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44Sink;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41()
{
    char * data;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_21()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_06()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strncat(data, source, 100);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_wchar_t_environment_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_15()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61a()
{
    TwoIntsClass * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61aSource(data);
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_43Source(char * &data)
{
    /* FIX: Specify the full pathname for the library */
    strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_12()
{
    int * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    else
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = new char[100];
    {
        char * data = *dataPtr1;
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66a()
{
    char * data;
    char * dataArray[5];
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_15()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_15()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Specify just the file name for the library, not the full path */
        strcpy(data, ""winsrv.dll"");
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_18()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34_unionType myUnion;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[10] = {0};
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            for (i = 0; i < 10; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54a()
{
    wchar_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_12()
{
    void * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    else
    {
        /* FIX: Set data to point to a char string */
        data = (void *)CHAR_STRING;
    }
    if(globalReturnsTrueOrFalse())
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
    else
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34_unionType myUnion;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            wcscpy(data, source);
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_connect_socket_42Source(char * data)
{
    /* FIX: Specify the full pathname for the library */
    strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_02()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_06()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_12()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22a()
{
    int64_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22aSource(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_54b_CWE114_Process_Control__w32_wchar_t_connect_socket_54bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_54c_CWE114_Process_Control__w32_wchar_t_connect_socket_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_73bSink(list<twoIntsStruct *> dataList)
{
    twoIntsStruct * data = dataList.back();
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_12()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67_structType myStruct;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_15()
{
    int * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
        break;
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34_unionType myUnion;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_15()
{
    int * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_14()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67bSink(structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72a()
{
    char * data;
    vector<char *> dataVector;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memmove(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_17()
{
    int j;
    for(j = 0; j < 1; j++)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_51a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_17()
{
    int h;
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34_unionType myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            size_t i, dataLen;
            dataLen = strlen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67_structType myStruct;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_41()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Sink()
{
    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Data;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_73a()
{
    char * data;
    list<char *> dataList;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_67bSink(structType myStruct)
{
    TwoIntsClass * data = myStruct.structFirst;
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_34_unionType myUnion;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68a()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_63bSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_01()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68a()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_18()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    goto source;
source:
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_03()
{
    void * data;
    data = NULL;
    if(5==5)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    if(5!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_09()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(GLOBAL_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_04()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_15()
{
    char * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_54b_CWE114_Process_Control__w32_char_connect_socket_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_54c_CWE114_Process_Control__w32_char_connect_socket_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_72a()
{
    int * data;
    vector<int *> dataVector;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65a()
{
    int64_t * data;
    /* define a function pointer */
    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65aSink;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41Sink(int * data)
{
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_34()
{
    char * data;
    unionType myUnion;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_34()
{
    wchar_t * data;
    unionType myUnion;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            size_t i, dataLen;
            dataLen = wcslen(data);
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            for (i = 0; i < dataLen; i++)
            {
                dest[i] = data[i];
            }
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42Source(char * data)
{
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_63a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_16()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    while(1)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_13()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(5==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_04()
{
    char * data;
    data = new char[100];
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61a()
{
    int data;
    /* Initialize data */
    data = -1;
    data = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61aSource(data);
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_16()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_01()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53bSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_53c_CWE121_Stack_Based_Buffer_Overflow__CWE135_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34_unionType myUnion;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strcat(dest, data);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_16()
{
    while(1)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_22a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22aGlobal = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22aGlobal = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    CWE114_Process_Control__w32_wchar_t_connect_socket_21Static = 0; /* false */
    data = CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67_structType myStruct;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_54c_CWE121_Stack_Based_Buffer_Overflow__CWE135_54cSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54d_CWE121_Stack_Based_Buffer_Overflow__CWE135_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            wcsncpy(data, source, 100-1);
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int * * dataPtr = (int * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int * data = (*dataPtr);
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_17()
{
    int h;
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_18()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_16()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()
{
    int data;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_16()
{
    wchar_t * data;
    data = new wchar_t[100];
    while(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53cSink_c(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_45()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_41Sink(int64_t * data)
{
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74a()
{
    char * data;
    map<int, char *> dataMap;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
         * access an index of the array in the sink that is out-of-bounds */
        data = 7;
        break;
    }
    switch(7)
    {
    case 7:
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = wcslen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgetws() */
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                data[dataLen] = L'\0';
            }
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_wchar_t_console_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)
{
    int data = myStruct.structFirst;
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63a()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_02()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    if(1)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_17()
{
    int i,j;
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    for(j = 0; j < 1; j++)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_02()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44Sink;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_07()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(staticFive==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_18()
{
    goto sink;
sink:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printLine((char *)structCharVoid.voidSecond);
        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid.charFirst);
        printLine((char *)structCharVoid.voidSecond);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_03()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34()
{
    wchar_t * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_02()
{
    char * data;
    data = new char[100];
    if(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41()
{
    char * data;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_61bSource(char * data)
{
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_63bSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_41Sink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_74bSink(map<int, wchar_t *> dataMap)
{
    wchar_t * data = dataMap[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67_structType myStruct;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_18()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44Sink;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_16()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_32()
{
    int data;
    int *dataPtr1 = &data;
    int *dataPtr2 = &data;
    /* Initialize data */
    data = -1;
    {
        int data = *dataPtr1;
        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
         * access an index of the array in the sink that is out-of-bounds */
        data = 7;
        *dataPtr1 = data;
    }
    {
        int data = *dataPtr2;
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_34()
{
    int * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
                delete [] data;
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34_unionType myUnion;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, wcslen(data), L""%s"", data);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_16()
{
    char * data;
    data = new char[100];
    while(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_06()
{
    void * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_67a()
{
    int64_t * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_06()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_03()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(5==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_03()
{
    wchar_t * data;
    data = NULL;
    if(5==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_char_console_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_17()
{
    int h;
    char * data;
    data = new char[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_34()
{
    TwoIntsClass * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    myUnion.unionFirst = data;
    {
        TwoIntsClass * data = myUnion.unionSecond;
        {
            TwoIntsClass source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0].intOne);
                delete [] data;
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22a()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54bSink_b(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54dSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_listen_socket_53c_CWE114_Process_Control__w32_wchar_t_listen_socket_53cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_listen_socket_53d_CWE114_Process_Control__w32_wchar_t_listen_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_12()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21()
{
    char * data;
    data = new char[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_03()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(5==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_61bSource(wchar_t * data)
{
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_06()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Sink()
{
    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Data;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_51a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73a()
{
    int * data;
    list<int *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_34_unionType myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            size_t i;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_01()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_15()
{
    wchar_t * data;
    data = new wchar_t[100];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_45Sink()
{
    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_45Data;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_33()
{
    wchar_t * data;
    wchar_t * &dataRef = data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t * data = dataRef;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_listen_socket_54b_CWE114_Process_Control__w32_char_listen_socket_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_listen_socket_54c_CWE114_Process_Control__w32_char_listen_socket_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink()
{
    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_console_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE114_Process_Control__w32_wchar_t_console_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_66a()
{
    int * data;
    int * dataArray[5];
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_62a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_62aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_16()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    while(1)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54a()
{
    char * data;
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_structType myStruct;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66a()
{
    int * data;
    int * dataArray[5];
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_44Sink;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_16()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04()
{
    int data;
    /* Initialize data */
    data = -1;
    if(STATIC_CONST_TRUE)
    {
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
            delete[] buffer;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_73bSink(list<int64_t *> dataList)
{
    int64_t * data = dataList.back();
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_41()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    CWE114_Process_Control__w32_wchar_t_relativePath_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_34_unionType myUnion;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            size_t i;
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_33()
{
    char * data;
    char * &dataRef = data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            strncpy(dest, data, strlen(data));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73a()
{
    int data;
    list<int> dataList;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67_structType myStruct;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_06()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_17()
{
    int h;
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_18()
{
    char * data;
    data = NULL;
    goto source;
source:
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strcat(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68bSink()
{
    int64_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68bData;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink()
{
    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data;
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_62bSource(int64_t * &data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_32()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    {
        int64_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41Sink(int * data)
{
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_05()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(staticFalse)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72bSink(vector<int *> dataVector)
{
    int * data = dataVector[2];
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54dSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_62bSource(int &data)
{
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_54d_CWE121_Stack_Based_Buffer_Overflow__CWE135_54dSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54e_CWE121_Stack_Based_Buffer_Overflow__CWE135_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_53b_CWE114_Process_Control__w32_wchar_t_console_53bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_console_53c_CWE114_Process_Control__w32_wchar_t_console_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65a()
{
    int64_t * data;
    /* define a function pointer */
    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65aSink;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61bSource(TwoIntsClass * data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74bSink(map<int, int64_t *> dataMap)
{
    /* copy data out of dataMap */
    int64_t * data = dataMap[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            size_t i;
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE114_Process_Control__w32_wchar_t_relativePath_22bSource(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_relativePath_22bGlobal)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_13()
{
    char * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_72bSink(vector<wchar_t *> dataVector)
{
    wchar_t * data = dataVector[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_62bSource(void * &data)
{
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_14()
{
    wchar_t * data;
    data = NULL;
    if(globalFive==5)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67_structType myStruct;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_74bSink(map<int, wchar_t *> dataMap)
{
    wchar_t * data = dataMap[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_33()
{
    int data;
    int &dataRef = data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    {
        int data = dataRef;
        {
            int i;
            int * buffer = new int[10];
            /* initialize buffer */
            for (i = 0; i < 10; i++)
            {
                buffer[i] = 0;
            }
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
            delete[] buffer;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_06()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72a()
{
    int * data;
    vector<int *> dataVector;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41Sink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_32()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    data = NULL;
    {
        int64_t * data = *dataPtr1;
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_65a()
{
    int * data;
    void (*funcPtr) (int *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_65aSink;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_04()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcscat(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_54b_CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54c_CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_54d_CWE114_Process_Control__w32_wchar_t_connect_socket_54dSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_54e_CWE114_Process_Control__w32_wchar_t_connect_socket_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_01()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_43Source(char * &data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_66bSink(char * dataArray[])
{
    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65a()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65aSink;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_22bSource(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_22bGlobal)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72bSink(vector<TwoIntsClass *> dataVector)
{
    /* copy data out of dataVector */
    TwoIntsClass * data = dataVector[2];
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = wcslen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_01()
{
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printWLine((wchar_t *)structCharVoid.voidSecond);
        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_01()
{
    char * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_43Source(void * &data)
{
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(globalFive==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_05()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(staticTrue)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53cSink_c(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_17()
{
    int i,j;
    int data;
    /* Initialize data */
    data = -1;
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Use an invalid index */
        data = 10;
    }
    for(j = 0; j < 1; j++)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51a()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_09()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(GLOBAL_CONST_TRUE)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_74a()
{
    char * data;
    map<int, char *> dataMap;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67_structType myStruct;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_15()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(7)
    {
    case 7:
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34_unionType myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memmove(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_63a()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_63b_CWE121_Stack_Based_Buffer_Overflow__CWE135_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67_structType myStruct;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Source(wchar_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22aGlobal = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_13()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_65a()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_65aSink;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_05()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(staticFalse)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51bSink(char * data)
{
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Source(char * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67a()
{
    char * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_15()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67_structType myStruct;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int64_t * data = (*dataPtr);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_15()
{
    char * data;
    data = new char[100];
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_74bSink(map<int, int *> dataMap)
{
    int * data = dataMap[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_01()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    {
        int i;
        int * buffer = new int[10];
        /* initialize buffer */
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        delete[] buffer;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_01()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_63a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_54b_CWE114_Process_Control__w32_char_console_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_console_54c_CWE114_Process_Control__w32_char_console_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_18()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65a()
{
    int64_t * data;
    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65aSink;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53dSink(char * data)
{
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_11()
{
    wchar_t * data;
    data = NULL;
    if(globalReturnsTrue())
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_45Data;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_12()
{
    if(globalReturnsTrueOrFalse())
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
    else
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100];
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aGlobal = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_15()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_52a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_16()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_04()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_45Data;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44Sink;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(5==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_63bSink(wchar_t * * dataPtr)
{
    wchar_t * data = *dataPtr;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_54b_CWE114_Process_Control__w32_char_file_54bSink(char * data)
{
    CWE114_Process_Control__w32_char_file_54c_CWE114_Process_Control__w32_char_file_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_18()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_03()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_01()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67_structType myStruct;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_64b_CWE114_Process_Control__w32_char_connect_socket_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_54c_CWE114_Process_Control__w32_char_console_54cSink(char * data)
{
    CWE114_Process_Control__w32_char_console_54d_CWE114_Process_Control__w32_char_console_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_16()
{
    char * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42()
{
    char * data;
    data = new char[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_52cSink(char * data)
{
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Sink(int data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Static)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66a()
{
    char * data;
    char * dataArray[5];
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_34_unionType myUnion;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = wcslen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_34_unionType myUnion;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            wcsncpy(dest, data, wcslen(data));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74a()
{
    wchar_t * data;
    map<int, wchar_t *> dataMap;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_08()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(staticReturnsTrue())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42()
{
    char * data;
    data = new char[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01()
{
    int * data;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_16()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Sink()
{
    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Data;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcscat(data, source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_16()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41Sink(wchar_t * data)
{
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22bSource(wchar_t * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22bGlobal)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_53b_CWE114_Process_Control__w32_char_relativePath_53bSink(char * data)
{
    CWE114_Process_Control__w32_char_relativePath_53c_CWE114_Process_Control__w32_char_relativePath_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_42()
{
    wchar_t * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_42Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_43Source(wchar_t * &data)
{
    /* FIX: Specify the full pathname for the library */
    wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_18()
{
    char * data;
    data = NULL;
    goto source;
source:
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_66a()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_char_relativePath_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = NULL;
    {
        char * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            size_t i;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54cSink_c(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_45Data;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_04()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_53c_CWE121_Stack_Based_Buffer_Overflow__CWE135_53cSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_53d_CWE121_Stack_Based_Buffer_Overflow__CWE135_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_04()
{
    char * data;
    data = new char[100];
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_33()
{
    char * data;
    char * &dataRef = data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    {
        char * data = dataRef;
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_18()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    goto source;
source:
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_16()
{
    char * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_32()
{
    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    {
        twoIntsStruct * data = *dataPtr1;
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(twoIntsStruct));
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_01()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_73a()
{
    int * data;
    list<int *> dataList;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53bSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_34()
{
    int * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
                delete [] data;
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_06()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_43Source(int &data)
{
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_15()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_74bSink(map<int, int64_t *> dataMap)
{
    int64_t * data = dataMap[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17()
{
    int h;
    char * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_01()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73bSink(list<int *> dataList)
{
    /* copy data out of dataList */
    int * data = dataList.back();
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44Sink;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_16()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_05()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    if(staticTrue)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(staticFalse)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* FIX: data will at least be the sizeof(OneIntClass) */
            OneIntClass * classOne = new(data) OneIntClass;
            /* Initialize and make use of the class */
            classOne->intOne = 5;
            printIntLine(classOne->intOne);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66bSink(int * dataArray[])
{
    int * data = dataArray[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_74bSink(map<int, TwoIntsClass *> dataMap)
{
    /* copy data out of dataMap */
    TwoIntsClass * data = dataMap[2];
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_17()
{
    int h;
    char * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_03()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(5==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_17()
{
    int h;
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_33()
{
    char * data;
    char * &dataRef = data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            strncat(data, source, 100);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_44()
{
    int * data;
    /* define a function pointer */
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_44Sink;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_13()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FLAW: Specify just the file name for the library, not the full path */
        strcpy(data, ""winsrv.dll"");
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryA(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_33()
{
    int64_t * data;
    int64_t * &dataRef = data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t * data = dataRef;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03()
{
    if(5==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52a()
{
    char * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_63bSink(char * * dataPtr)
{
    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44()
{
    int * data;
    /* define a function pointer */
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44Sink;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_15()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22a()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22aGlobal = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22aSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68a()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_54c_CWE114_Process_Control__w32_char_connect_socket_54cSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_54d_CWE114_Process_Control__w32_char_connect_socket_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_15()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    switch(6)
    {
    case 6:
        /* FLAW: Specify just the file name for the library, not the full path */
        wcscpy(data, L""winsrv.dll"");
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_08()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(staticReturnsTrue())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67a()
{
    char * data;
    structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_54c_CWE114_Process_Control__w32_wchar_t_environment_54cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_environment_54d_CWE114_Process_Control__w32_wchar_t_environment_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE114_Process_Control__w32_char_relativePath_61bSource(char * data)
{
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_42()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_42Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_73bSink(list<int *> dataList)
{
    int * data = dataList.back();
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_33()
{
    char * data;
    char * &dataRef = data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    {
        char * data = dataRef;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17()
{
    int i;
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51a()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_17()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22a()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22aGlobal = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_34()
{
    char * data;
    unionType myUnion;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            size_t i;
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73bSink(list<char *> dataList)
{
    /* copy data out of dataList */
    char * data = dataList.back();
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_relativePath_43Source(wchar_t * &data)
{
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_41()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_32()
{
    int64_t * data;
    int64_t * *dataPtr1 = &data;
    int64_t * *dataPtr2 = &data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    {
        int64_t * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        *dataPtr1 = data;
    }
    {
        int64_t * data = *dataPtr2;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72bSink(vector<int *> dataVector)
{
    /* copy data out of dataVector */
    int * data = dataVector[2];
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Static = 0; /* false */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_03()
{
    int64_t * data;
    data = NULL;
    if(5==5)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_12()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_16()
{
    wchar_t * data;
    data = new wchar_t[100];
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_52bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink()
{
    TwoIntsClass * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data;
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_34()
{
    char * data;
    CWE114_Process_Control__w32_char_relativePath_34_unionType myUnion;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryA(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22bSink(void * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22bGlobal)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Source(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strcat(data, source);
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_unionType myUnion;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int64_t * data = myUnion.unionSecond;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memmove(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53dSink(wchar_t * data)
{
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_05()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    if(staticTrue)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_15()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_74bSink(map<int, int> dataMap)
{
    /* copy data out of dataMap */
    int data = dataMap[2];
    {
        int i;
        int * buffer = new int[10];
        /* initialize buffer */
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
        delete[] buffer;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54dSink_d(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_02()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_44()
{
    TwoIntsClass * data;
    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_44Sink;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_54b_CWE114_Process_Control__w32_wchar_t_relativePath_54bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_54c_CWE114_Process_Control__w32_wchar_t_relativePath_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_07()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(staticFive==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_73bSink(list<void *> dataList)
{
    /* copy data out of dataList */
    void * data = dataList.back();
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_17()
{
    int h;
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_17()
{
    int h;
    wchar_t * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_62bSource(wchar_t * &data)
{
    {
        /* Append input from an environment variable to data */
        size_t dataLen = wcslen(data);
        wchar_t * environment = GETENV(ENV_VARIABLE);
        /* If there is data in the environment variable */
        if (environment != NULL)
        {
            /* POTENTIAL FLAW: Read data from an environment variable */
            wcsncat(data+dataLen, environment, 100-dataLen-1);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_16()
{
    while(1)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
        break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_15()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_08()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    if(staticReturnsFalse())
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_07()
{
    int data;
    /* Initialize data */
    data = -1;
    if(staticFive==5)
    {
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
    }
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Sink()
{
    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Data;
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_15()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_74a()
{
    int64_t * data;
    map<int, int64_t *> dataMap;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_connect_socket_21Source(char * data)
{
    if(CWE114_Process_Control__w32_char_connect_socket_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Specify the full pathname for the library */
        strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_74bSink(map<int, int *> dataMap)
{
    int * data = dataMap[2];
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53bSink_b(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_12()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_07()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
                delete [] data;
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            wcscpy(data, source);
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[100] = {0}; /* fill with 0's */
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printIntLine(data[0]);
                delete [] data;
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44()
{
    int data;
    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44Sink;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_72bSink(vector<int *> dataVector)
{
    /* copy data out of dataVector */
    int * data = dataVector[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_45Data;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67a()
{
    wchar_t * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_06()
{
    int64_t * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strncpy(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_01()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_73a()
{
    char * data;
    list<char *> dataList;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_char_connect_socket_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_06()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_17()
{
    int h;
    char * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_31()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    {
        int64_t * dataCopy = data;
        int64_t * data = dataCopy;
        {
            int64_t source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int64_t));
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53cSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    data = new char[100];
    {
        char * data = *dataPtr1;
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_15()
{
    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53cSink_c(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_05()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(staticTrue)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_16()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_18()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    goto source;
source:
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_13()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_01()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54dSink(int data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54e_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_34_unionType myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            strcat(data, source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static int CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_42Source(int data)
{
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54bSink_b(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_34()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_34_unionType myUnion;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(twoIntsStruct));
            printStructLine(&data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_72a()
{
    char * data;
    vector<char *> dataVector;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_15()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    switch(6)
    {
    case 6:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15()
{
    wchar_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)
{
    /* copy data out of dataVector */
    wchar_t * data = dataVector[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43Source(int * &data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67_structType myStruct;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_04()
{
    wchar_t * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new wchar_t[50];
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_67a()
{
    char * data;
    structType myStruct;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72bSink(vector<int *> dataVector)
{
    int * data = dataVector[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_15()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_13()
{
    TwoIntsClass * data;
    data = NULL;
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new TwoIntsClass[100];
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_12()
{
    char * data;
    data = NULL;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54bSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_04()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67_structType myStruct;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_52a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_15()
{
    void * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        /* FIX: treating pointer like a wchar_t*  */
        size_t dataLen = wcslen((wchar_t *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printWLine((wchar_t *)dest);
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_34_unionType myUnion;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            SNPRINTF(data, 100, ""%s"", source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aGlobal = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void * CWE121_Stack_Based_Buffer_Overflow__CWE135_61bSource(void * data)
{
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_67a()
{
    int * data;
    structType myStruct;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_console_21Source(char * data)
{
    if(CWE114_Process_Control__w32_char_console_21Static)
    {
        {
            /* Read input from the console */
            size_t dataLen = strlen(data);
            /* if there is room in data, read into it from the console */
            if (100-dataLen > 1)
            {
                /* POTENTIAL FLAW: Read data from the console */
                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
                {
                    /* The next few lines remove the carriage return from the string that is
                     * inserted by fgets() */
                    dataLen = strlen(data);
                    if (dataLen > 0 && data[dataLen-1] == '\n')
                    {
                        data[dataLen-1] = '\0';
                    }
                }
                else
                {
                    printLine(""fgets() failed"");
                    /* Restore NUL terminator if fgets fails */
                    data[dataLen] = '\0';
                }
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Sink()
{
    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Data;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_13()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_31()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            wcsncat(data, source, 100);
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_environment_02()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(1)
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printStructLine(&data[0]);
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73bSink(list<TwoIntsClass *> dataList)
{
    /* copy data out of dataList */
    TwoIntsClass * data = dataList.back();
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strcat(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_45Sink()
{
    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_45Data;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22a()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22aSource(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_02()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_67bSink(structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_06()
{
    void * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_18()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52a()
{
    int * data;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_03()
{
    int * data;
    data = NULL;
    if(5!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_33()
{
    int * data;
    int * &dataRef = data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    {
        int * data = dataRef;
        {
            int source[10] = {0};
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            memmove(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_54b_CWE114_Process_Control__w32_wchar_t_console_54bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_console_54c_CWE114_Process_Control__w32_wchar_t_console_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54dSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34_unionType myUnion;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_53c_CWE114_Process_Control__w32_wchar_t_connect_socket_53cSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_53d_CWE114_Process_Control__w32_wchar_t_connect_socket_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printLine((char *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid.charFirst);
            printLine((char *)structCharVoid.voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_63bSink(TwoIntsClass * * dataPtr)
{
    TwoIntsClass * data = *dataPtr;
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51a()
{
    int64_t * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int64_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_61a()
{
    char * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_61aSource(data);
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_54d_CWE114_Process_Control__w32_char_connect_socket_54dSink(char * data)
{
    CWE114_Process_Control__w32_char_connect_socket_54e_CWE114_Process_Control__w32_char_connect_socket_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    void * * dataPtr = (void * *)dataVoidPtr;
    /* dereference dataPtr into data */
    void * data = (*dataPtr);
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
        (void)wcscpy(dest, data);
        printLine((char *)dest);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_01()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    {
        int i;
        int buffer[10] = { 0 };
        /* FIX: Properly validate the array index and prevent a buffer overflow */
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_34()
{
    void * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    myUnion.unionFirst = data;
    {
        void * data = myUnion.unionSecond;
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_08()
{
    int64_t * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_15()
{
    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67bSink(structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_02()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    if(1)
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_13()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66a()
{
    int64_t * data;
    int64_t * dataArray[5];
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myUnion.unionFirst = data;
    {
        twoIntsStruct * data = myUnion.unionSecond;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printStructLine(&data[0]);
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_17()
{
    int h;
    wchar_t * data;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = new wchar_t[100];
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
            wcsncat(dest, data, wcslen(data));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_06()
{
    wchar_t * data;
    data = new wchar_t[100];
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Specify the full pathname for the library */
    strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_char_connect_socket_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_34()
{
    int * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_34_unionType myUnion;
    int dataBadBuffer[50];
    int dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myUnion.unionFirst = data;
    {
        int * data = myUnion.unionSecond;
        {
            int source[100] = {0}; /* fill with 0's */
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_01()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strncat(dest, data, strlen(data));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_42()
{
    wchar_t * data;
    data = new wchar_t[100];
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_42Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_12()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    if(globalReturnsTrueOrFalse())
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        wmemset(data, L'A', 50-1); /* fill with L'A's */
        data[50-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67_structType myStruct;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE114_Process_Control__w32_wchar_t_file_21Source(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_file_21Static)
    {
        {
            /* Read input from a file */
            size_t dataLen = wcslen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgetws() failed"");
                        /* Restore NUL terminator if fgetws fails */
                        data[dataLen] = L'\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_18()
{
    char * data;
    data = new char[100];
    goto source;
source:
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_18()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_31()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    {
        wchar_t * dataCopy = data;
        wchar_t * data = dataCopy;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            wcsncpy(dest, data, wcslen(data));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_02()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Sink()
{
    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Data;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_16()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_02()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(1)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_34_unionType myUnion;
    wchar_t dataBadBuffer[50];
    wchar_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            wcsncat(data, source, 100);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static wchar_t * CWE114_Process_Control__w32_wchar_t_environment_21Source(wchar_t * data)
{
    if(CWE114_Process_Control__w32_wchar_t_environment_21Static)
    {
        {
            /* Append input from an environment variable to data */
            size_t dataLen = wcslen(data);
            wchar_t * environment = GETENV(ENV_VARIABLE);
            /* If there is data in the environment variable */
            if (environment != NULL)
            {
                /* POTENTIAL FLAW: Read data from an environment variable */
                wcsncat(data+dataLen, environment, 100-dataLen-1);
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66bSink(int * dataArray[])
{
    /* copy data out of dataArray */
    int * data = dataArray[2];
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44Sink;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bSource(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bGlobal)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43()
{
    int * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43Source(data);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_66bSink(twoIntsStruct * dataArray[])
{
    twoIntsStruct * data = dataArray[2];
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_01()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Source(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_74bSink(map<int, wchar_t *> dataMap)
{
    /* copy data out of dataMap */
    wchar_t * data = dataMap[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    data = NULL;
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_52b_CWE114_Process_Control__w32_wchar_t_relativePath_52bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_relativePath_52c_CWE114_Process_Control__w32_wchar_t_relativePath_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_01()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a()
{
    int64_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67_structType myStruct;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52a()
{
    char * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_18()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    goto source;
source:
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    goto sink;
sink:
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_67bSink(structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memmove(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_52b_CWE121_Stack_Based_Buffer_Overflow__CWE135_52bSink(void * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE135_52c_CWE121_Stack_Based_Buffer_Overflow__CWE135_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_62bSource(char * &data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54cSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_listen_socket_52b_CWE114_Process_Control__w32_wchar_t_listen_socket_52bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_listen_socket_52c_CWE114_Process_Control__w32_wchar_t_listen_socket_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_01()
{
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_14()
{
    wchar_t * data;
    data = NULL;
    if(globalFive==5)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    {
        wchar_t * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            wcscpy(data, source);
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE114_Process_Control__w32_char_file_21Source(char * data)
{
    if(CWE114_Process_Control__w32_char_file_21Static)
    {
        {
            /* Read input from a file */
            size_t dataLen = strlen(data);
            FILE * pFile;
            /* if there is room in data, attempt to read the input from a file */
            if (100-dataLen > 1)
            {
                pFile = fopen(FILENAME, ""r"");
                if (pFile != NULL)
                {
                    /* POTENTIAL FLAW: Read data from a file */
                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                    {
                        printLine(""fgets() failed"");
                        /* Restore NUL terminator if fgets fails */
                        data[dataLen] = '\0';
                    }
                    fclose(pFile);
                }
            }
        }
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54dSink_d(int * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_01()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_41Sink(twoIntsStruct * data)
{
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Data;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_67b_CWE121_Stack_Based_Buffer_Overflow__CWE135_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct)
{
    void * data = myStruct.structFirst;
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44()
{
    twoIntsStruct * data;
    /* define a function pointer */
    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44Sink;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_65a()
{
    char * data;
    /* define a function pointer */
    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_65aSink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_34()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_34_unionType myUnion;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myUnion.unionFirst = data;
    {
        int data = myUnion.unionSecond;
        {
            int i;
            int buffer[10] = { 0 };
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static int CWE121_Stack_Based_Buffer_Overflow__CWE129_large_42Source(int data)
{
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memmove(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()
{
    int i,k;
    void * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    for(k = 0; k < 1; k++)
    {
        {
            /* FIX: treating pointer like a wchar_t*  */
            size_t dataLen = wcslen((wchar_t *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printWLine((wchar_t *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_74bSink(map<int, void *> dataMap)
{
    void * data = dataMap[2];
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy((char *)dest, (char *)data);
        printLine((char *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcscat(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int * * dataPtr = (int * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int * data = (*dataPtr);
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_34()
{
    char * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new char[10];
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strncpy(data, source, strlen(source) + 1);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_18()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_13()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_18()
{
    goto sink;
sink:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printWLine((wchar_t *)structCharVoid.voidSecond);
        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66bSink(int64_t * dataArray[])
{
    /* copy data out of dataArray */
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_73bSink(list<int *> dataList)
{
    int * data = dataList.back();
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_34()
{
    wchar_t * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = wcslen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_52c_CWE121_Stack_Based_Buffer_Overflow__CWE135_52cSink(void * data)
{
    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
        printLine((char *)dest);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_02()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    if(1)
    {
        /* FIX: Specify the full pathname for the library */
        wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_16()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    while(1)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_char_connect_socket_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        char * data = *dataPtr1;
        /* FIX: Specify the full pathname for the library */
        strcpy(data, ""C:\\Windows\\System32\\winsrv.dll"");
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryA(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06()
{
    int data;
    /* Initialize data */
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        /* POTENTIAL FLAW: Read data from the console using fscanf() */
        fscanf(stdin, ""%d"", &data);
    }
    if(STATIC_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* FIX: Properly validate the array index and prevent a buffer overflow */
            if (data >= 0 && data < (10))
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is out-of-bounds"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()
{
    int h,j;
    void * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Set data to point to a char string */
        data = (void *)CHAR_STRING;
    }
    for(j = 0; j < 1; j++)
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_62bSource(int &data)
{
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_66a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54cSink_c(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_73a()
{
    char * data;
    list<char *> dataList;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45Sink()
{
    char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45Data;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct)
{
    char * data = myStruct.structFirst;
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_52b_CWE114_Process_Control__w32_char_console_52bSink(char * data)
{
    CWE114_Process_Control__w32_char_console_52c_CWE114_Process_Control__w32_char_console_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_68a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_15()
{
    int64_t * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int64_t[50];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_01()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcsncpy(data, source, 100-1);
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_15()
{
    int * data;
    data = NULL;
    switch(6)
    {
    case 6:
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    char * * dataPtr = (char * *)dataVoidPtr;
    /* dereference dataPtr into data */
    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44()
{
    char * data;
    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44Sink;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_14()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    if(globalFive==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
    }
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printStructLine(&data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE114_Process_Control__w32_wchar_t_connect_socket_32()
{
    wchar_t * data;
    wchar_t * *dataPtr1 = &data;
    wchar_t * *dataPtr2 = &data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        wchar_t * data = *dataPtr1;
        /* FIX: Specify the full pathname for the library */
        wcscpy(data, L""C:\\Windows\\System32\\winsrv.dll"");
        *dataPtr1 = data;
    }
    {
        wchar_t * data = *dataPtr2;
        {
            HMODULE hModule;
            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
             * replace his own file with the intended library */
            hModule = LoadLibraryW(data);
            if (hModule != NULL)
            {
                FreeLibrary(hModule);
                printLine(""Library loaded and freed successfully"");
            }
            else
            {
                printLine(""Unable to load library"");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_listen_socket_54b_CWE114_Process_Control__w32_wchar_t_listen_socket_54bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_listen_socket_54c_CWE114_Process_Control__w32_wchar_t_listen_socket_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_33()
{
    char * data;
    char * &dataRef = data;
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
            strcat(dest, data);
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_15()
{
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printWLine((wchar_t *)structCharVoid.voidSecond);
        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
        printWLine((wchar_t *)structCharVoid.charFirst);
        printWLine((wchar_t *)structCharVoid.voidSecond);
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74bSink(map<int, int *> dataMap)
{
    /* copy data out of dataMap */
    int * data = dataMap[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_54d_CWE114_Process_Control__w32_wchar_t_file_54dSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_file_54e_CWE114_Process_Control__w32_wchar_t_file_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_41Sink(int * data)
{
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_73a()
{
    void * data;
    list<void *> dataList;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE135_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_52a()
{
    void * data;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_52b_CWE121_Stack_Based_Buffer_Overflow__CWE135_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    if(STATIC_CONST_TRUE)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42Source(int64_t * data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a()
{
    int * data;
    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65aSink;
    data = NULL;
    /* FIX: Allocate memory using sizeof(int) */
    data = (int *)ALLOCA(10*sizeof(int));
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = wcslen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53aSink_b(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_13()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66bSink(int * dataArray[])
{
    int * data = dataArray[2];
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45()
{
    twoIntsStruct * data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22a()
{
    char * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22aGlobal = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22aSource(data);
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_53b_CWE114_Process_Control__w32_wchar_t_connect_socket_53bSink(wchar_t * data)
{
    CWE114_Process_Control__w32_wchar_t_connect_socket_53c_CWE114_Process_Control__w32_wchar_t_connect_socket_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68a()
{
    twoIntsStruct * data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52a()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_41()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17()
{
    int h;
    int * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54dSink_d(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54eSink_e(char * data)
{
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* FIX: data will at least be the sizeof(OneIntClass) */
        OneIntClass * classOne = new(data) OneIntClass;
        /* Initialize and make use of the class */
        classOne->intOne = 5;
        printIntLine(classOne->intOne);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    {
        char inputBuffer[CHAR_ARRAY_SIZE] = """";
        /* POTENTIAL FLAW: Read data from the console using fgets() */
        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
        {
            /* Convert to int */
            data = atoi(inputBuffer);
        }
        else
        {
            printLine(""fgets() failed."");
        }
    }
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_72bSink(vector<wchar_t *> dataVector)
{
    wchar_t * data = dataVector[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_02()
{
    int * data;
    data = NULL;
    if(1)
    {
        /* FLAW: Allocate memory without using sizeof(int) */
        data = (int *)ALLOCA(10);
    }
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_03()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(5==5)
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        strncpy(data, source, 100-1);
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_17()
{
    int i;
    char * data;
    data = new char[100];
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, strlen(data)*sizeof(char));
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42()
{
    int64_t * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42Source(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_41Sink(char * data)
{
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_15()
{
    switch(6)
    {
    case 6:
    {
        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
        if (structCharVoid == NULL) {exit(-1);}
        structCharVoid->voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid->voidSecond */
        printLine((char *)structCharVoid->voidSecond);
        /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid->charFirst);
        printLine((char *)structCharVoid->voidSecond);
        free(structCharVoid);
    }
    break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67a()
{
    int data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21Source(data);
    {
        wchar_t dest[50] = L"""";
        size_t i, dataLen;
        dataLen = wcslen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_16()
{
    char * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_73bSink(list<int *> dataList)
{
    /* copy data out of dataList */
    int * data = dataList.back();
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, L""%s"", source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_16()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    while(1)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_18()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    goto source;
source:
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_34()
{
    char * data;
    unionType myUnion;
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, strlen(data)*sizeof(char));
            dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        wcsncat(data, source, 100);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21()
{
    wchar_t * data;
    data = new wchar_t[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53dSink(char * data)
{
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66bSink(int64_t * dataArray[])
{
    int64_t * data = dataArray[2];
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73a()
{
    char * data;
    list<char *> dataList;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22a()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22aGlobal = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22aSource(data);
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_74a()
{
    twoIntsStruct * data;
    map<int, twoIntsStruct *> dataMap;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22bSource(TwoIntsClass * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22bGlobal)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67_structType myStruct;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63a()
{
    int64_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int64_t[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67a()
{
    int * data;
    structType myStruct;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_08()
{
    TwoIntsClass * data;
    data = NULL;
    if(staticReturnsTrue())
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_13()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    if(GLOBAL_CONST_FIVE!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_42Source(char * data)
{
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_17()
{
    int i;
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_32()
{
    twoIntsStruct * data;
    twoIntsStruct * *dataPtr1 = &data;
    twoIntsStruct * *dataPtr2 = &data;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    {
        twoIntsStruct * data = *dataPtr1;
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        *dataPtr1 = data;
    }
    {
        twoIntsStruct * data = *dataPtr2;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            memcpy(data, source, 100*sizeof(twoIntsStruct));
            printStructLine(&data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_42()
{
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_42Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_17()
{
    int i;
    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Specify just the file name for the library, not the full path */
        strcpy(data, ""winsrv.dll"");
    }
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Source(char * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Static)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new int[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54dSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_15()
{
    char * data;
    data = NULL;
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
        break;
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_31()
{
    char * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    {
        char * dataCopy = data;
        char * data = dataCopy;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            memcpy(data, source, 100*sizeof(char));
            data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_16()
{
    wchar_t * data;
    data = NULL;
    while(1)
    {
        /* FIX: Allocate space for a null terminator */
        data = new wchar_t[10+1];
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_74bSink(map<int, char *> dataMap)
{
    /* copy data out of dataMap */
    char * data = dataMap[2];
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_06()
{
    TwoIntsClass * data;
    data = NULL;
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE135_73a()
{
    void * data;
    list<void *> dataList;
    data = NULL;
    /* FIX: Set data to point to a char string */
    data = (void *)CHAR_STRING;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE135_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    wmemset(data, L'A', 50-1); /* fill with L'A's */
    data[50-1] = L'\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68a()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_52bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_06()
{
    if(STATIC_CONST_FIVE==5)
    {
        {
            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
            if (structCharVoid == NULL) {exit(-1);}
            structCharVoid->voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid->voidSecond */
            printLine((char *)structCharVoid->voidSecond);
            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */
            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
            printLine((char *)structCharVoid->charFirst);
            printLine((char *)structCharVoid->voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_52bSink_b(TwoIntsClass * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_66a()
{
    char * data;
    char * dataArray[5];
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_06()
{
    int data;
    /* Initialize data */
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        {
            char inputBuffer[CHAR_ARRAY_SIZE] = """";
            /* POTENTIAL FLAW: Read data from the console using fgets() */
            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
            {
                /* Convert to int */
                data = atoi(inputBuffer);
            }
            else
            {
                printLine(""fgets() failed."");
            }
        }
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_console_66a()
{
    char * data;
    char * dataArray[5];
    char dataBuffer[100] = """";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = strlen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgets() */
                dataLen = strlen(data);
                if (dataLen > 0 && data[dataLen-1] == '\n')
                {
                    data[dataLen-1] = '\0';
                }
            }
            else
            {
                printLine(""fgets() failed"");
                /* Restore NUL terminator if fgets fails */
                data[dataLen] = '\0';
            }
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_char_console_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_17()
{
    int h;
    TwoIntsClass * data;
    data = NULL;
    for(h = 0; h < 1; h++)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new TwoIntsClass[100];
    }
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(TwoIntsClass));
        printIntLine(data[0].intOne);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)
{
    wchar_t * data = dataList.back();
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_62bSource(char * &data)
{
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74a()
{
    char * data;
    map<int, char *> dataMap;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_33()
{
    twoIntsStruct * data;
    twoIntsStruct * &dataRef = data;
    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        twoIntsStruct * data = dataRef;
        {
            twoIntsStruct source[100];
            {
                size_t i;
                /* Initialize array */
                for (i = 0; i < 100; i++)
                {
                    source[i].intOne = 0;
                    source[i].intTwo = 0;
                }
            }
            {
                size_t i;
                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
                for (i = 0; i < 100; i++)
                {
                    data[i] = source[i];
                }
                printStructLine(&data[0]);
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_33()
{
    char * data;
    char * &dataRef = data;
    data = new char[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char dest[50] = """";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            SNPRINTF(dest, strlen(data), ""%s"", data);
            printLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_52a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_52aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_18()
{
    int * data;
    data = NULL;
    goto source;
source:
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memmove(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68bSink()
{
    int * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68bData;
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54dSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54dSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_16()
{
    wchar_t * data;
    data = NULL;
    while(1)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
        break;
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_03()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    if(5!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
        data = dataGoodBuffer;
    }
    if(5==5)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    {
        char * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_67a()
{
    int data;
    structType myStruct;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    myStruct.structFirst = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68a()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    /* put data in array */
    dataArray[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_17()
{
    int i;
    wchar_t * data;
    wchar_t dataBuffer[100];
    data = dataBuffer;
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcsncat(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_74a()
{
    void * data;
    map<int, void *> dataMap;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Static = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72bSink(vector<char *> dataVector)
{
    /* copy data out of dataVector */
    char * data = dataVector[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_01()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_34()
{
    wchar_t * data;
    unionType myUnion;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
            SNPRINTF(data, 100, L""%s"", source);
            printWLine(data);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_01()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Data;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcscpy(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54dSink_d(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15()
{
    wchar_t * data;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
        break;
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72a()
{
    char * data;
    vector<char *> dataVector;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54dSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45()
{
    char * data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_34_unionType myUnion;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memmove(data, source, (strlen(source) + 1) * sizeof(char));
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72a()
{
    TwoIntsClass * data;
    vector<TwoIntsClass *> dataVector;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_14()
{
    int64_t * data;
    int64_t dataBadBuffer[50];
    int64_t dataGoodBuffer[100];
    if(globalFive==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44()
{
    wchar_t * data;
    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44Sink;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new wchar_t[10+1];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22a()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aGlobal = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aSource(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        strcpy(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_02()
{
    char * data;
    data = NULL;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new char[100];
        data[0] = '\0'; /* null terminate */
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_04()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strncpy(data, source, strlen(source) + 1);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()
{
    int i,j;
    void * data;
    data = NULL;
    for(i = 0; i < 1; i++)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
    }
    for(j = 0; j < 1; j++)
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Sink()
{
    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Data;
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcsncpy(data, source, wcslen(source) + 1);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_18()
{
    int data;
    /* Initialize data */
    data = -1;
    goto source;
source:
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    goto sink;
sink:
    {
        int i;
        int buffer[10] = { 0 };
        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
        * This code does check to see if the array index is negative */
        if (data >= 0)
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is negative."");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_15()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    switch(5)
    {
    case 6:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        break;
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74a()
{
    char * data;
    map<int, char *> dataMap;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_14()
{
    char * data;
    data = NULL;
    if(globalFive==5)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new char[10];
    }
    {
        char source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (strlen(source) + 1) * sizeof(char));
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_02()
{
    wchar_t * data;
    data = NULL;
    if(1)
    {
        /* FLAW: Did not leave space for a null terminator */
        data = new wchar_t[10];
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_34()
{
    wchar_t * data;
    unionType myUnion;
    data = NULL;
    /* FLAW: Did not leave space for a null terminator */
    data = new wchar_t[10];
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
            delete [] data;
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67_structType myStruct)
{
    wchar_t * data = myStruct.structFirst;
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65a()
{
    TwoIntsClass * data;
    /* define a function pointer */
    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65aSink;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_72a()
{
    void * data;
    vector<void *> dataVector;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE135_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67a()
{
    char * data;
    structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34_unionType myUnion;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t dest[50] = L"""";
            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
            dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66bSink(wchar_t * dataArray[])
{
    /* copy data out of dataArray */
    wchar_t * data = dataArray[2];
    {
        wchar_t source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        wcscpy(data, source);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68a()
{
    int64_t * data;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_54d_CWE114_Process_Control__w32_char_relativePath_54dSink(char * data)
{
    CWE114_Process_Control__w32_char_relativePath_54e_CWE114_Process_Control__w32_char_relativePath_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_02()
{
    char * data;
    data = NULL;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate space for a null terminator */
        data = new char[10+1];
    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_61bSource(char * data)
{
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new char[50];
    data[0] = '\0'; /* null terminate */
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_03()
{
    wchar_t * data;
    data = NULL;
    if(5==5)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21Static = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21Sink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_74bSink(map<int, wchar_t *> dataMap)
{
    wchar_t * data = dataMap[2];
    {
        size_t i;
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_34_unionType myUnion;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_02()
{
    int * data;
    data = NULL;
    if(1)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int[100];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54cSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_32()
{
    int * data;
    int * *dataPtr1 = &data;
    int * *dataPtr2 = &data;
    data = NULL;
    {
        int * data = *dataPtr1;
        /* FIX: Allocate memory using sizeof(int) */
        data = (int *)ALLOCA(10*sizeof(int));
        *dataPtr1 = data;
    }
    {
        int * data = *dataPtr2;
        {
            int source[10] = {0};
            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
            memcpy(data, source, 10*sizeof(int));
            printIntLine(data[0]);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66a()
{
    char * data;
    char * dataArray[5];
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66aSink(dataArray);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)
{
    /* copy data out of dataList */
    wchar_t * data = dataList.back();
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_73bSink(list<wchar_t *> dataList)
{
    wchar_t * data = dataList.back();
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22bSource(char * data)
{
    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22bGlobal)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_61a()
{
    int64_t * data;
    data = NULL;
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_61aSource(data);
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink()
{
    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data;
    {
        int source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0]);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a()
{
    twoIntsStruct * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67_structType myStruct;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_51a()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_51aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_13()
{
    char * data;
    data = new char[100];
    if(GLOBAL_CONST_FIVE==5)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54a()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_file_52b_CWE114_Process_Control__w32_char_file_52bSink(char * data)
{
    CWE114_Process_Control__w32_char_file_52c_CWE114_Process_Control__w32_char_file_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67a()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67_structType myStruct;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67aSink(myStruct);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74a()
{
    int data;
    map<int, int> dataMap;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74aSink(dataMap);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_62bSource(char * &data)
{
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_connect_socket_21()
{
    wchar_t * data;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    CWE114_Process_Control__w32_wchar_t_connect_socket_21Static = 1; /* true */
    data = CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(data);
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryW(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(twoIntsStruct * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_67a()
{
    wchar_t * data;
    CWE114_Process_Control__w32_wchar_t_file_67_structType myStruct;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = wcslen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    myStruct.structFirst = data;
    CWE114_Process_Control__w32_wchar_t_file_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_18()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    goto source;
source:
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    memset(data, 'A', 100-1); /* fill with 'A's */
    data[100-1] = '\0'; /* null terminate */
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63aSink(&data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74bSink(map<int, char *> dataMap)
{
    char * data = dataMap[2];
    {
        /* The Visual C++ compiler generates a warning if you initialize the class with ().
         * This will cause the compile to default-initialize the object.
         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
         */
        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
        TwoIntsClass * classTwo = new(data) TwoIntsClass;
        /* Initialize and make use of the class */
        classTwo->intOne = 5;
        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
        printIntLine(classTwo->intOne);
        /* skip printing classTwo->intTwo since that could be a buffer overread */
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct)
{
    int * data = myStruct.structFirst;
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53cSink_c(int64_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34()
{
    char * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34_unionType myUnion;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
     * string copies in the sinks  */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53cSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_02()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    if(0)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
        memset(data, 'A', 50-1); /* fill with 'A's */
        data[50-1] = '\0'; /* null terminate */
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/
        strcat(dest, data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_01()
{
    {
        charVoid structCharVoid;
        structCharVoid.voidSecond = (void *)SRC_STR;
        /* Print the initial block pointed to by structCharVoid.voidSecond */
        printLine((char *)structCharVoid.voidSecond);
        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; /* null terminate the string */
        printLine((char *)structCharVoid.charFirst);
        printLine((char *)structCharVoid.voidSecond);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_64a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53cSink_c(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_relativePath_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    wcscpy(data, L""winsrv.dll"");
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_wchar_t_relativePath_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_33()
{
    char * data;
    char * &dataRef = data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    data[0] = '\0'; /* null terminate */
    {
        char * data = dataRef;
        {
            char source[100];
            memset(source, 'C', 100-1); /* fill with 'C's */
            source[100-1] = '\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
            strcat(data, source);
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    int * * dataPtr = (int * *)dataVoidPtr;
    /* dereference dataPtr into data */
    int * data = (*dataPtr);
    {
        int source[10] = {0};
        size_t i;
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        for (i = 0; i < 10; i++)
        {
            data[i] = source[i];
        }
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_02()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));
    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));
    if(1)
    {
        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */
        data = dataBadBuffer;
    }
    if(1)
    {
        {
            /* The Visual C++ compiler generates a warning if you initialize the class with ().
             * This will cause the compile to default-initialize the object.
             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx
             */
            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */
            TwoIntsClass * classTwo = new(data) TwoIntsClass;
            /* Initialize and make use of the class */
            classTwo->intOne = 5;
            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */
            printIntLine(classTwo->intOne);
            /* skip printing classTwo->intTwo since that could be a buffer overread */
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54dSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    {
        char * data = *dataPtr1;
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            size_t i, sourceLen;
            sourceLen = strlen(source);
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            for (i = 0; i < sourceLen + 1; i++)
            {
                data[i] = source[i];
            }
            printLine(data);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66bSink(int * dataArray[])
{
    /* copy data out of dataArray */
    int * data = dataArray[2];
    {
        int source[10] = {0};
        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */
        memcpy(data, source, 10*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_21()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    goodG2bStatic = 1; /* true */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_21Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_66bSink(char * dataArray[])
{
    /* copy data out of dataArray */
    char * data = dataArray[2];
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_console_66a()
{
    wchar_t * data;
    wchar_t * dataArray[5];
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from the console */
        size_t dataLen = wcslen(data);
        /* if there is room in data, read into it from the console */
        if (100-dataLen > 1)
        {
            /* POTENTIAL FLAW: Read data from the console */
            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
            {
                /* The next few lines remove the carriage return from the string that is
                 * inserted by fgetws() */
                dataLen = wcslen(data);
                if (dataLen > 0 && data[dataLen-1] == L'\n')
                {
                    data[dataLen-1] = L'\0';
                }
            }
            else
            {
                printLine(""fgetws() failed"");
                /* Restore NUL terminator if fgetws fails */
                data[dataLen] = L'\0';
            }
        }
    }
    /* put data in array */
    dataArray[2] = data;
    CWE114_Process_Control__w32_wchar_t_console_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_06()
{
    int data;
    /* Initialize data */
    data = -1;
    if(STATIC_CONST_FIVE==5)
    {
        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
         * access an index of the array in the sink that is out-of-bounds */
        data = 7;
    }
    if(STATIC_CONST_FIVE==5)
    {
        {
            int i;
            int buffer[10] = { 0 };
            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound
            * This code does check to see if the array index is negative */
            if (data >= 0)
            {
                buffer[data] = 1;
                /* Print the array values */
                for(i = 0; i < 10; i++)
                {
                    printIntLine(buffer[i]);
                }
            }
            else
            {
                printLine(""ERROR: Array index is negative."");
            }
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_52bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_52bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_16()
{
    char * data;
    char dataBuffer[100];
    data = dataBuffer;
    while(1)
    {
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        memset(data, 'A', 100-1); /* fill with 'A's */
        data[100-1] = '\0'; /* null terminate */
        break;
    }
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_03()
{
    int * data;
    data = NULL;
    if(5==5)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new int[50];
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int));
        printIntLine(data[0]);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73a()
{
    twoIntsStruct * data;
    list<twoIntsStruct *> dataList;
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72bSink(vector<wchar_t *> dataVector)
{
    wchar_t * data = dataVector[2];
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_73a()
{
    int64_t * data;
    list<int64_t *> dataList;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68a()
{
    int * data;
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_65a()
{
    wchar_t * data;
    /* define a function pointer */
    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_65aSink;
    data = new wchar_t[100];
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    /* use the function pointer */
    funcPtr(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72a()
{
    int64_t * data;
    vector<int64_t *> dataVector;
    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_18()
{
    wchar_t * data;
    data = NULL;
    goto source;
source:
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        memmove(data, source, 100*sizeof(wchar_t));
        data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_64a()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_64aSink(&data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        wcsncpy(dest, data, wcslen(data));
        dest[50-1] = L'\0'; /* Ensure the destination buffer is null terminated */
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21()
{
    char * data;
    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Static = 0; /* false */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Source(data);
    {
        char dest[50] = """";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, strlen(data), ""%s"", data);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_connect_socket_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        HMODULE hModule;
        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to
         * replace his own file with the intended library */
        hModule = LoadLibraryA(data);
        if (hModule != NULL)
        {
            FreeLibrary(hModule);
            printLine(""Library loaded and freed successfully"");
        }
        else
        {
            printLine(""Unable to load library"");
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68a()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = '\0'; /* null terminate */
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_05()
{
    wchar_t * data;
    data = NULL;
    if(staticFalse)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new wchar_t[100];
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        wcsncat(data, source, 100);
        printWLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54bSink_b(int data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_72a()
{
    char * data;
    vector<char *> dataVector;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: Specify just the file name for the library, not the full path */
    strcpy(data, ""winsrv.dll"");
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE114_Process_Control__w32_char_relativePath_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53cSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53cSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_15()
{
    int data;
    /* Initialize data */
    data = -1;
    switch(6)
    {
    case 6:
        /* POTENTIAL FLAW: Set data to a random value */
        data = RAND32();
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    switch(8)
    {
    case 7:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    default:
    {
        int i;
        int * buffer = new int[10];
        /* initialize buffer */
        for (i = 0; i < 10; i++)
        {
            buffer[i] = 0;
        }
        /* FIX: Properly validate the array index and prevent a buffer overflow */
        if (data >= 0 && data < (10))
        {
            buffer[data] = 1;
            /* Print the array values */
            for(i = 0; i < 10; i++)
            {
                printIntLine(buffer[i]);
            }
        }
        else
        {
            printLine(""ERROR: Array index is out-of-bounds"");
        }
        delete[] buffer;
    }
    break;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Source(TwoIntsClass * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Static)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new TwoIntsClass[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54dSink_d(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_73bSink(list<twoIntsStruct *> dataList)
{
    /* copy data out of dataList */
    twoIntsStruct * data = dataList.back();
    {
        twoIntsStruct source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(twoIntsStruct));
        printStructLine(&data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_06()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(STATIC_CONST_FIVE==5)
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        size_t i;
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        for (i = 0; i < 100; i++)
        {
            data[i] = source[i];
        }
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64bSink(void * dataVoidPtr)
{
    /* cast void pointer to a pointer of the appropriate type */
    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;
    /* dereference dataPtr into data */
    wchar_t * data = (*dataPtr);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/
        wcscat(dest, data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45()
{
    TwoIntsClass * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45Sink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74a()
{
    TwoIntsClass * data;
    map<int, TwoIntsClass *> dataMap;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new TwoIntsClass[50];
    /* Put data in a map */
    dataMap[0] = data;
    dataMap[1] = data;
    dataMap[2] = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74aSink(dataMap);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54dSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_char_relativePath_52b_CWE114_Process_Control__w32_char_relativePath_52bSink(char * data)
{
    CWE114_Process_Control__w32_char_relativePath_52c_CWE114_Process_Control__w32_char_relativePath_52bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a()
{
    int * data;
    int * dataArray[5];
    data = NULL;
    /* FLAW: Allocate memory without using sizeof(int) */
    data = (int *)ALLOCA(10);
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to
     * access an index of the array in the sink that is out-of-bounds */
    data = 7;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41()
{
    char * data;
    data = new char[100];
    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */
    memset(data, 'A', 50-1); /* fill with 'A's */
    data[50-1] = '\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41Sink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_15()
{
    int * data;
    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
    switch(6)
    {
    case 6:
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        int source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memcpy(data, source, 100*sizeof(int));
        printIntLine(data[0]);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_15()
{
    wchar_t * data;
    data = new wchar_t[100];
    switch(6)
    {
    case 6:
        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
        wmemset(data, L'A', 100-1); /* fill with L'A's */
        data[100-1] = L'\0'; /* null terminate */
        break;
    default:
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
        break;
    }
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21()
{
    TwoIntsClass * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Static = 0; /* false */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Source(data);
    {
        TwoIntsClass source[100];
        {
            size_t i;
            /* Initialize array */
            for (i = 0; i < 100; i++)
            {
                source[i].intOne = 0;
                source[i].intTwo = 0;
            }
        }
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printIntLine(data[0].intOne);
            delete [] data;
        }
    }
    ;
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_72a()
{
    wchar_t * data;
    vector<wchar_t *> dataVector;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new wchar_t[100];
    data[0] = L'\0'; /* null terminate */
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_72aSink(dataVector);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, ""%d"", &data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aData = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_16()
{
    void * data;
    data = NULL;
    while(1)
    {
        /* POTENTIAL FLAW: Set data to point to a wide string */
        data = (void *)WIDE_STRING;
        break;
    }
    while(1)
    {
        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
            (void)wcscpy(dest, data);
            printLine((char *)dest);
        }
        break;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52aSink_b(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_12()
{
    char * data;
    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
    if(globalReturnsTrueOrFalse())
    {
        /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
         * buffer in various memory copying functions using a ""large"" source buffer. */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        SNPRINTF(data, 100, ""%s"", source);
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_66a()
{
    int data;
    int dataArray[5];
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_04()
{
    char * data;
    data = NULL;
    if(STATIC_CONST_TRUE)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new char[50];
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */
        strncat(data, source, 100);
        printLine(data);
        delete [] data;
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE135_22a()
{
    void * data;
    data = NULL;
    /* POTENTIAL FLAW: Set data to point to a wide string */
    data = (void *)WIDE_STRING;
    CWE121_Stack_Based_Buffer_Overflow__CWE135_22aGlobal = 1; /* true */
    CWE121_Stack_Based_Buffer_Overflow__CWE135_22aSink(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_07()
{
    char * data;
    char dataBadBuffer[50];
    char dataGoodBuffer[100];
    if(staticFive!=5)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */
        strncat(data, source, 100);
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54dSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54dSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Source(TwoIntsClass * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Static)
    {
        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
        data = new TwoIntsClass[50];
    }
    return data;
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54bSink(int * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54dSink_d(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54dSink_e(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21()
{
    wchar_t * data;
    data = NULL;
    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21Static = 1; /* true */
    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21Source(data);
    {
        wchar_t source[100];
        wmemset(source, L'C', 100-1); /* fill with L'C's */
        source[100-1] = L'\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */
        wcscpy(data, source);
        printWLine(data);
        delete [] data;
    }
    ;
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Set data to a random value */
    data = RAND32();
    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54aSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45()
{
    char * data;
    char dataBadBuffer[sizeof(OneIntClass)];
    char dataGoodBuffer[sizeof(TwoIntsClass)];
    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */
    data = dataGoodBuffer;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Data = data;
    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_65a()
{
    char * data;
    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_65aSink;
    data = NULL;
    /* FIX: Allocate space for a null terminator */
    data = new char[10+1];
    funcPtr(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03()
{
    if(5==5)
    {
        {
            charVoid structCharVoid;
            structCharVoid.voidSecond = (void *)SRC_STR;
            /* Print the initial block pointed to by structCharVoid.voidSecond */
            printWLine((wchar_t *)structCharVoid.voidSecond);
            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */
            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; /* null terminate the string */
            printWLine((wchar_t *)structCharVoid.charFirst);
            printWLine((wchar_t *)structCharVoid.voidSecond);
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21()
{
    wchar_t * data;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Static = 1; /* true */
    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Source(data);
    {
        wchar_t dest[50] = L"""";
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        SNPRINTF(dest, wcslen(data), L""%s"", data);
        printWLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(int64_t * data)
{
    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static)
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    return data;
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68a()
{
    wchar_t * data;
    data = NULL;
    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */
    data = new wchar_t[50];
    data[0] = L'\0'; /* null terminate */
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68aSink();
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68a()
{
    int * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new int[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aData = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aSink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_72bSink(vector<char *> dataVector)
{
    char * data = dataVector[2];
    {
        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
        memcpy(data, source, 100*sizeof(char));
        data[100-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53bSink(wchar_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_17()
{
    int i;
    char * data;
    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
    for(i = 0; i < 1; i++)
    {
        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataBadBuffer;
        data[0] = '\0'; /* null terminate */
    }
    {
        char source[10+1] = SRC_STRING;
        size_t i, sourceLen;
        sourceLen = strlen(source);
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        for (i = 0; i < sourceLen + 1; i++)
        {
            data[i] = source[i];
        }
        printLine(data);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72a()
{
    int data;
    vector<int> dataVector;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Use an invalid index */
    data = 10;
    /* Put data in a vector */
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    dataVector.insert(dataVector.end(), 1, data);
    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72aSink(dataVector);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45()
{
    TwoIntsClass * data;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new TwoIntsClass[100];
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data = data;
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink();
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct)
{
    int64_t * data = myStruct.structFirst;
    {
        int64_t source[100] = {0}; /* fill with 0's */
        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
        memmove(data, source, 100*sizeof(int64_t));
        printLongLongLine(data[0]);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66a()
{
    twoIntsStruct * data;
    twoIntsStruct * dataArray[5];
    twoIntsStruct dataBadBuffer[50];
    twoIntsStruct dataGoodBuffer[100];
    /* FLAW: Set a pointer to a ""small"" buffer. This buffer will be used in the sinks as a destination
     * buffer in various memory copying functions using a ""large"" source buffer. */
    data = dataBadBuffer;
    /* put data in array */
    dataArray[2] = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66aSink(dataArray);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54bSink_b(wchar_t * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32()
{
    char * data;
    char * *dataPtr1 = &data;
    char * *dataPtr2 = &data;
    char dataBadBuffer[10];
    char dataGoodBuffer[10+1];
    {
        char * data = *dataPtr1;
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = '\0'; /* null terminate */
        *dataPtr1 = data;
    }
    {
        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* Copy length + 1 to include NUL terminator from source */
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strncpy(data, source, strlen(source) + 1);
            printLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53bSink(char * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53bSink(data);
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53cSink_c(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53cSink_d(data);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73a()
{
    char * data;
    list<char *> dataList;
    data = NULL;
    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
    data = new char[100];
    data[0] = '\0'; /* null terminate */
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73aSink(dataList);
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_10()
{
    wchar_t * data;
    wchar_t dataBadBuffer[10];
    wchar_t dataGoodBuffer[10+1];
    if(globalTrue)
    {
        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing
         * string copies in the sinks  */
        data = dataGoodBuffer;
        data[0] = L'\0'; /* null terminate */
    }
    {
        wchar_t source[10+1] = SRC_STRING;
        /* Copy length + 1 to include NUL terminator from source */
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
        printWLine(data);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE114_Process_Control__w32_wchar_t_file_73a()
{
    wchar_t * data;
    list<wchar_t *> dataList;
    wchar_t dataBuffer[100] = L"""";
    data = dataBuffer;
    {
        /* Read input from a file */
        size_t dataLen = wcslen(data);
        FILE * pFile;
        /* if there is room in data, attempt to read the input from a file */
        if (100-dataLen > 1)
        {
            pFile = fopen(FILENAME, ""r"");
            if (pFile != NULL)
            {
                /* POTENTIAL FLAW: Read data from a file */
                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
                {
                    printLine(""fgetws() failed"");
                    /* Restore NUL terminator if fgetws fails */
                    data[dataLen] = L'\0';
                }
                fclose(pFile);
            }
        }
    }
    /* Put data in a list */
    dataList.push_back(data);
    dataList.push_back(data);
    dataList.push_back(data);
    CWE114_Process_Control__w32_wchar_t_file_73aSink(dataList);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53bSink_b(char * data)
{
    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53bSink_c(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67a()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_structType myStruct;
    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    data = dataBuffer;
    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */
    wmemset(data, L'A', 100-1); /* fill with L'A's */
    data[100-1] = L'\0'; /* null terminate */
    myStruct.structFirst = data;
    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67aSink(myStruct);
}
",1
Detect whether the following code contains vulnerabilities.,"static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_04()
{
    int64_t * data;
    data = NULL;
    if(STATIC_CONST_FALSE)
    {
        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */
        printLine(""Benign, fixed string"");
    }
    else
    {
        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */
        data = new int64_t[100];
    }
    {
        int64_t source[100] = {0}; /* fill with 0's */
        {
            size_t i;
            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */
            for (i = 0; i < 100; i++)
            {
                data[i] = source[i];
            }
            printLongLongLine(data[0]);
            delete [] data;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_73bSink(list<char *> dataList)
{
    char * data = dataList.back();
    {
        char dest[50] = """";
        size_t i, dataLen;
        dataLen = strlen(data);
        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */
        for (i = 0; i < dataLen; i++)
        {
            dest[i] = data[i];
        }
        dest[50-1] = '\0'; /* Ensure the destination buffer is null terminated */
        printLine(data);
        delete [] data;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34()
{
    wchar_t * data;
    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34_unionType myUnion;
    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
    /* FIX: Set a pointer to a ""large"" buffer, thus avoiding buffer overflows in the sinks. */
    data = dataGoodBuffer;
    data[0] = L'\0'; /* null terminate */
    myUnion.unionFirst = data;
    {
        wchar_t * data = myUnion.unionSecond;
        {
            wchar_t source[100];
            wmemset(source, L'C', 100-1); /* fill with L'C's */
            source[100-1] = L'\0'; /* null terminate */
            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */
            memcpy(data, source, 100*sizeof(wchar_t));
            data[100-1] = L'\0'; /* Ensure the destination buffer is null terminated */
            printWLine(data);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54cSink(int64_t * data)
{
    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54cSink(data);
}
",0
