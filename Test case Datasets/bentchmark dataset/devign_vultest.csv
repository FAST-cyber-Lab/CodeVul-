instruction,input,output
Detect whether the following code contains vulnerabilities.,"static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,

                                int pred_order)

{

    int p, porder, psize;

    int i, part_end;

    int count = 0;



    /* subframe header */

    count += 8;



    /* subframe */

    if (sub->type == FLAC_SUBFRAME_CONSTANT) {

        count += sub->obits;

    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {

        count += s->frame.blocksize * sub->obits;

    } else {

        /* warm-up samples */

        count += pred_order * sub->obits;



        /* LPC coefficients */

        if (sub->type == FLAC_SUBFRAME_LPC)

            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;



        /* rice-encoded block */

        count += 2;



        /* partition order */

        porder = sub->rc.porder;

        psize  = s->frame.blocksize >> porder;

        count += 4;



        /* residual */

        i        = pred_order;

        part_end = psize;

        for (p = 0; p < 1 << porder; p++) {

            int k = sub->rc.params[p];

            count += 4;

            count += rice_count_exact(&sub->residual[i], part_end - i, k);

            i = part_end;

            part_end = FFMIN(s->frame.blocksize, part_end + psize);

        }

    }



    return count;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",0
Detect whether the following code contains vulnerabilities.,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"", argv[i]);

			return 0;

		}

		count += len;

	}



	nr_iov = argc - optind;

	qemu_iovec_init(&ctx->qiov, nr_iov);

	ctx->buf = p = qemu_io_alloc(count, pattern);

	for (i = 0; i < nr_iov; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0) {

			printf(""non-numeric length argument -- %s\n"",

				argv[optind]);

			return 0;

		}



		qemu_iovec_add(&ctx->qiov, p, len);

		p += len;

		optind++;

	}



	gettimeofday(&ctx->t1, NULL);

	acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,

			      ctx->qiov.size >> 9, aio_write_done, ctx);

	if (!acb)

		return -EIO;



	return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",1
Detect whether the following code contains vulnerabilities.,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",0
Detect whether the following code contains vulnerabilities.,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",0
Detect whether the following code contains vulnerabilities.,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",1
Detect whether the following code contains vulnerabilities.,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",1
Detect whether the following code contains vulnerabilities.,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,

                                    uint64_t value, unsigned size,

                                    MemTxAttrs attrs)

{

    int ret = 0;

    MSIMessage from = {0}, to = {0};



    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;

    from.data = (uint32_t) value;



    ret = vtd_interrupt_remap_msi(opaque, &from, &to);

    if (ret) {

        /* TODO: report error */

        VTD_DPRINTF(GENERAL, ""int remap fail for addr 0x%""PRIx64

                    "" data 0x%""PRIx32, from.address, from.data);

        /* Drop this interrupt */

        return MEMTX_ERROR;

    }



    VTD_DPRINTF(IR, ""delivering MSI 0x%""PRIx64"":0x%""PRIx32

                "" for device sid 0x%04x"",

                to.address, to.data, sid);



    if (dma_memory_write(&address_space_memory, to.address,

                         &to.data, size)) {

        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64

                    "" value 0x%""PRIx32, to.address, to.data);

    }



    return MEMTX_OK;

}
",1
Detect whether the following code contains vulnerabilities.,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",0
Detect whether the following code contains vulnerabilities.,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0
Detect whether the following code contains vulnerabilities.,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",1
Detect whether the following code contains vulnerabilities.,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",1
Detect whether the following code contains vulnerabilities.,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",1
Detect whether the following code contains vulnerabilities.,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",0
Detect whether the following code contains vulnerabilities.,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",0
Detect whether the following code contains vulnerabilities.,"static int crypto_open(URLContext *h, const char *uri, int flags)

{

    const char *nested_url;

    int ret;

    CryptoContext *c = h->priv_data;



    if (!av_strstart(uri, ""crypto+"", &nested_url) &&

        !av_strstart(uri, ""crypto:"", &nested_url)) {

        av_log(h, AV_LOG_ERROR, ""Unsupported url %s\n"", uri);

        ret = AVERROR(EINVAL);

        goto err;

    }



    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {

        av_log(h, AV_LOG_ERROR, ""Key or IV not set\n"");

        ret = AVERROR(EINVAL);

        goto err;

    }

    if (flags & AVIO_FLAG_WRITE) {

        av_log(h, AV_LOG_ERROR, ""Only decryption is supported currently\n"");

        ret = AVERROR(ENOSYS);

        goto err;

    }

    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {

        av_log(h, AV_LOG_ERROR, ""Unable to open input\n"");

        goto err;

    }

    c->aes = av_mallocz(av_aes_size);

    if (!c->aes) {

        ret = AVERROR(ENOMEM);

        goto err;

    }



    av_aes_init(c->aes, c->key, 128, 1);



    h->is_streamed = 1;



    return 0;

err:

    av_free(c->key);

    av_free(c->iv);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, ""/dev/fd"", NULL) &&

        !strstart(filename, ""/dev/fdset/"", NULL)) {

        prio = 50;

    }



    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    qemu_close(fd);

out:

    return prio;

}
",1
Detect whether the following code contains vulnerabilities.,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
",0
Detect whether the following code contains vulnerabilities.,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

            dest->emw[i] = cpu_to_be32(src->emw[i]);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",1
Detect whether the following code contains vulnerabilities.,"CommandInfoList *qmp_query_commands(Error **errp)

{

    CommandInfoList *list = NULL;



    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);



    return list;

}
",1
Detect whether the following code contains vulnerabilities.,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qoffset = qoffset_intra_tab[b->quant];

    else

        qoffset = qoffset_inter_tab[b->quant];



    buf = b->ibuf + top * b->stride;

    for (y = top; y < bottom; y++) {

        for (x = left; x < right; x++) {

            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */

            if (is_arith)

                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);

            else

                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);

        }

        buf += b->stride;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){

    FFV1Context *f = avctx->priv_data;

    CABACContext * const c= &f->c;

    AVFrame *pict = data;

    const int width= f->width;

    const int height= f->height;

    AVFrame * const p= &f->picture;

    int used_count= 0;



    if(avctx->strict_std_compliance >= 0){

        av_log(avctx, AV_LOG_ERROR, ""this codec is under development, files encoded with it wont be decodeable with future versions!!!\n""

               ""use vstrict=-1 to use it anyway\n"");

        return -1;

    }

        

    ff_init_cabac_encoder(c, buf, buf_size);

    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);

    c->lps_state[2] = 1;

    c->lps_state[3] = 0;

    

    *p = *pict;

    p->pict_type= FF_I_TYPE;

    

    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){

        put_cabac_bypass(c, 1);

        p->key_frame= 1;

        write_header(f);

        clear_state(f);

    }else{

        put_cabac_bypass(c, 0);

        p->key_frame= 0;

    }



    if(!f->ac){

        used_count += put_cabac_terminate(c, 1);

//printf(""pos=%d\n"", used_count);

        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);

    }

    

    if(f->colorspace==0){

        const int chroma_width = -((-width )>>f->chroma_h_shift);

        const int chroma_height= -((-height)>>f->chroma_v_shift);



        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);



        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);

        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);

    }else{

        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);

    }

    emms_c();

    

    f->picture_number++;



    if(f->ac){

        return put_cabac_terminate(c, 1);

    }else{

        flush_put_bits(&f->pb); //nicer padding FIXME

        return used_count + (put_bits_count(&f->pb)+7)/8;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",1
Detect whether the following code contains vulnerabilities.,"void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
",1
Detect whether the following code contains vulnerabilities.,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",1
Detect whether the following code contains vulnerabilities.,"static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,

                        int nb_sectors, QEMUIOVector *qiov)

{

    SheepdogAIOCB *acb;

    int ret;



    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {

        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);

        if (ret < 0) {

            return ret;

        }

        bs->total_sectors = sector_num + nb_sectors;

    }



    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);

    acb->aio_done_func = sd_write_done;

    acb->aiocb_type = AIOCB_WRITE_UDATA;



    ret = sd_co_rw_vector(acb);

    if (ret <= 0) {

        qemu_aio_release(acb);

        return ret;

    }



    qemu_coroutine_yield();



    return acb->ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",0
Detect whether the following code contains vulnerabilities.,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void scsi_write_data(SCSIRequest *req)

{

    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    /* The request is used as the AIO opaque value, so add a ref.  */

    scsi_req_ref(&r->req);

    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {

        DPRINTF(""Data transfer direction invalid\n"");

        scsi_write_complete(r, -EINVAL);

        return;

    }



    if (!r->req.sg && !r->qiov.size) {

        /* Called for the first time.  Ask the driver to send us more data.  */

        r->started = true;

        scsi_write_complete(r, 0);

        return;

    }

    if (s->tray_open) {

        scsi_write_complete(r, -ENOMEDIUM);

        return;

    }



    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||

        r->req.cmd.buf[0] == VERIFY_16) {

        if (r->req.sg) {

            scsi_dma_complete(r, 0);

        } else {

            scsi_write_complete(r, 0);

        }

        return;

    }



    if (r->req.sg) {

        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);

        r->req.resid -= r->req.sg->size;

        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,

                                      scsi_dma_complete, r);

    } else {

        n = r->qiov.size / 512;

        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);

        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,

                                       scsi_write_complete, r);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",1
Detect whether the following code contains vulnerabilities.,"void bios_linker_loader_alloc(GArray *linker,

                              const char *file,

                              uint32_t alloc_align,

                              bool alloc_fseg)

{

    BiosLinkerLoaderEntry entry;



    assert(!(alloc_align & (alloc_align - 1)));



    memset(&entry, 0, sizeof entry);

    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);

    entry.alloc.align = cpu_to_le32(alloc_align);

    entry.alloc.zone = cpu_to_le32(alloc_fseg ?

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);



    /* Alloc entries must come first, so prepend them */

    g_array_prepend_vals(linker, &entry, sizeof entry);

}
",1
Detect whether the following code contains vulnerabilities.,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_size;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",0
Detect whether the following code contains vulnerabilities.,"MigrationState *exec_start_outgoing_migration(const char *command,

                                             int64_t bandwidth_limit,

                                             int async)

{

    FdMigrationState *s;

    FILE *f;



    s = qemu_mallocz(sizeof(*s));

    if (s == NULL) {

        dprintf(""Unable to allocate FdMigrationState\n"");

        goto err;

    }



    f = popen(command, ""w"");

    if (f == NULL) {

        dprintf(""Unable to popen exec target\n"");

        goto err_after_alloc;

    }



    s->fd = fileno(f);

    if (s->fd == -1) {

        dprintf(""Unable to retrieve file descriptor for popen'd handle\n"");

        goto err_after_open;

    }



    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {

        dprintf(""Unable to set nonblocking mode on file descriptor\n"");

        goto err_after_open;

    }



    s->opaque = qemu_popen(f, ""w"");




    s->get_error = file_errno;

    s->write = file_write;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_status = migrate_fd_get_status;

    s->mig_state.release = migrate_fd_release;



    s->state = MIG_STATE_ACTIVE;

    s->detach = !async;

    s->bandwidth_limit = bandwidth_limit;



    if (s->detach == 1) {

        dprintf(""detaching from monitor\n"");

        monitor_suspend();

        s->detach = 2;

    }



    migrate_fd_connect(s);

    return &s->mig_state;



err_after_open:

    pclose(f);

err_after_alloc:

    qemu_free(s);

err:

    return NULL;

}",1
Detect whether the following code contains vulnerabilities.,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",1
Detect whether the following code contains vulnerabilities.,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",1
Detect whether the following code contains vulnerabilities.,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
",1
Detect whether the following code contains vulnerabilities.,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",1
Detect whether the following code contains vulnerabilities.,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"void qmp_blockdev_add(BlockdevOptions *options, Error **errp)

{

    QmpOutputVisitor *ov = qmp_output_visitor_new();

    QObject *obj;

    QDict *qdict;

    Error *local_err = NULL;



    /* Require an ID in the top level */

    if (!options->has_id) {

        error_setg(errp, ""Block device needs an ID"");

        goto fail;

    }



    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with

     * cache.direct=false instead of silently switching to aio=threads, except

     * if called from drive_init.

     *

     * For now, simply forbidding the combination for all drivers will do. */

    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {

        bool direct = options->cache->has_direct && options->cache->direct;

        if (!options->has_cache && !direct) {

            error_setg(errp, ""aio=native requires cache.direct=true"");

            goto fail;

        }

    }



    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),

                               &options, NULL, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



    obj = qmp_output_get_qobject(ov);

    qdict = qobject_to_qdict(obj);



    qdict_flatten(qdict);



    blockdev_init(NULL, qdict, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



fail:

    qmp_output_visitor_cleanup(ov);

}
",1
Detect whether the following code contains vulnerabilities.,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void kvmclock_pre_save(void *opaque)

{

    KVMClockState *s = opaque;

    struct kvm_clock_data data;

    int ret;



    if (s->clock_valid) {

        return;

    }

    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);

    if (ret < 0) {

        fprintf(stderr, ""KVM_GET_CLOCK failed: %s\n"", strerror(ret));

        data.clock = 0;

    }

    s->clock = data.clock;

    /*

     * If the VM is stopped, declare the clock state valid to avoid re-reading

     * it on next vmsave (which would return a different value). Will be reset

     * when the VM is continued.

     */

    s->clock_valid = !runstate_is_running();

}
",1
Detect whether the following code contains vulnerabilities.,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",1
Detect whether the following code contains vulnerabilities.,"static int check_checksum(ByteIOContext *bc){

    unsigned long checksum= get_checksum(bc);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",0
Detect whether the following code contains vulnerabilities.,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",0
Detect whether the following code contains vulnerabilities.,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",0
Detect whether the following code contains vulnerabilities.,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0
Detect whether the following code contains vulnerabilities.,"static void mptsas_scsi_init(PCIDevice *dev, Error **errp)

{

    DeviceState *d = DEVICE(dev);

    MPTSASState *s = MPT_SAS(dev);



    dev->config[PCI_LATENCY_TIMER] = 0;

    dev->config[PCI_INTERRUPT_PIN] = 0x01;



    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,

                          ""mptsas-mmio"", 0x4000);

    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,

                          ""mptsas-io"", 256);

    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,

                          ""mptsas-diag"", 0x10000);



    if (s->msi != ON_OFF_AUTO_OFF &&

        msi_init(dev, 0, 1, true, false) >= 0) {

        /* TODO check for errors */

        s->msi_in_use = true;

    }



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);

    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);

    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);



    if (!s->sas_addr) {

        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |

                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;

        s->sas_addr |= (pci_bus_num(dev->bus) << 16);

        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);

        s->sas_addr |= PCI_FUNC(dev->devfn);

    }

    s->max_devices = MPTSAS_NUM_PORTS;



    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);



    QTAILQ_INIT(&s->pending);



    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, errp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",0
Detect whether the following code contains vulnerabilities.,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    CommitBlockJob *s = container_of(job, CommitBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",1
Detect whether the following code contains vulnerabilities.,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)

{

    int   band, result=0, numSubbands, lastTonal, numBands;



    if (codingMode == JOINT_STEREO && channelNum == 1) {

        if (get_bits(gb,2) != 3) {

            av_log(NULL,AV_LOG_ERROR,""JS mono Sound Unit id != 3.\n"");

            return -1;

        }

    } else {

        if (get_bits(gb,6) != 0x28) {

            av_log(NULL,AV_LOG_ERROR,""Sound Unit id != 0x28.\n"");

            return -1;

        }

    }



    /* number of coded QMF bands */

    pSnd->bandsCoded = get_bits(gb,2);



    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);

    if (result) return result;



    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);

    if (pSnd->numComponents == -1) return -1;



    numSubbands = decodeSpectrum (gb, pSnd->spectrum);



    /* Merge the decoded spectrum and tonal components. */

    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);





    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */

    numBands = (subbandTab[numSubbands] - 1) >> 8;

    if (lastTonal >= 0)

        numBands = FFMAX((lastTonal + 256) >> 8, numBands);





    /* Reconstruct time domain samples. */

    for (band=0; band<4; band++) {

        /* Perform the IMDCT step without overlapping. */

        if (band <= numBands) {

            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);

        } else

            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));



        /* gain compensation and overlapping */

        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),

                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),

                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));

    }



    /* Swap the gain control buffers for the next frame. */

    pSnd->gcBlkSwitch ^= 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",1
Detect whether the following code contains vulnerabilities.,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
",0
Detect whether the following code contains vulnerabilities.,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,

                                          target_phys_addr_t end_addr)

{

    KVMState *s = kvm_state;

    unsigned long size, allocated_size = 0;

    KVMDirtyLog d;

    KVMSlot *mem;

    int ret = 0;



    d.dirty_bitmap = NULL;

    while (start_addr < end_addr) {

        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);

        if (mem == NULL) {

            break;

        }



        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;

        if (!d.dirty_bitmap) {

            d.dirty_bitmap = qemu_malloc(size);

        } else if (size > allocated_size) {

            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);

        }

        allocated_size = size;

        memset(d.dirty_bitmap, 0, allocated_size);



        d.slot = mem->slot;



        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {

            DPRINTF(""ioctl failed %d\n"", errno);

            ret = -1;

            break;

        }



        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,

                                      mem->start_addr, mem->memory_size);

        start_addr = mem->start_addr + mem->memory_size;

    }

    qemu_free(d.dirty_bitmap);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0
Detect whether the following code contains vulnerabilities.,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",0
Detect whether the following code contains vulnerabilities.,"static TranslationBlock *tb_alloc(target_ulong pc)

{

    TranslationBlock *tb;

    TBContext *ctx;



    assert_tb_locked();



    tb = tcg_tb_alloc(&tcg_ctx);

    if (unlikely(tb == NULL)) {

        return NULL;

    }

    ctx = &tcg_ctx.tb_ctx;

    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {

        ctx->tbs_size *= 2;

        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);

    }

    ctx->tbs[ctx->nb_tbs++] = tb;

    tb->pc = pc;

    tb->cflags = 0;

    tb->invalid = false;

    return tb;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eof(&s->desc)) {

            stream_push(tx_dev, txbuf, s->pos, app);

            s->pos = 0;

            stream_complete(s);

        }



        /* Update the descriptor.  */

        s->desc.status = txlen | SDESC_STATUS_COMPLETE;

        stream_desc_store(s, s->regs[R_CURDESC]);



        /* Advance.  */

        prev_d = s->regs[R_CURDESC];

        s->regs[R_CURDESC] = s->desc.nxtdesc;

        if (prev_d == s->regs[R_TAILDESC]) {

            s->regs[R_DMASR] |= DMASR_IDLE;

            break;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)

{

    read_local_name_rp params;

    params.status = HCI_SUCCESS;

    memset(params.name, 0, sizeof(params.name));

    if (hci->device.lmp_name)

        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));



    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);

}
",1
Detect whether the following code contains vulnerabilities.,"static bool vnc_should_update(VncState *vs)

{

    switch (vs->update) {

    case VNC_STATE_UPDATE_NONE:

        break;

    case VNC_STATE_UPDATE_INCREMENTAL:

        /* Only allow incremental updates if the output buffer

         * is empty, or if audio capture is enabled.

         */

        if (!vs->output.offset || vs->audio_cap) {

            return true;

        }

        break;

    case VNC_STATE_UPDATE_FORCE:

        return true;

    }

    return false;

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int kvmppc_reset_htab(int shift_hint)

{

    uint32_t shift = shift_hint;



    if (!kvm_enabled()) {

        /* Full emulation, tell caller to allocate htab itself */

        return 0;

    }

    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {

        int ret;

        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);

        if (ret == -ENOTTY) {

            /* At least some versions of PR KVM advertise the

             * capability, but don't implement the ioctl().  Oops.

             * Return 0 so that we allocate the htab in qemu, as is

             * correct for PR. */

            return 0;

        } else if (ret < 0) {

            return ret;

        }

        return shift;

    }



    /* We have a kernel that predates the htab reset calls.  For PR

     * KVM, we need to allocate the htab ourselves, for an HV KVM of

     * this era, it has allocated a 16MB fixed size hash table already. */

    if (kvmppc_is_pr(kvm_state)) {

        /* PR - tell caller to allocate htab */

        return 0;

    } else {

        /* HV - assume 16MB kernel allocated htab */

        return 24;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",1
Detect whether the following code contains vulnerabilities.,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",1
Detect whether the following code contains vulnerabilities.,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to setup INTx fd: %m\n"");

        return -errno;

    }



    /*

     * Disable mmaps so we can trap on BAR accesses.  We interpret any

     * access as a response to an interrupt and unmask the physical

     * device.  The device will re-assert if the interrupt is still

     * pending.  We'll likely retrigger on the host multiple times per

     * guest interrupt, but without EOI notification it's better than

     * nothing.  Acceleration paths through KVM will avoid this.

     */

    vfio_mmap_set_enabled(vdev, false);



    vdev->interrupt = VFIO_INT_INTx;



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if ((dest + 8 <= src) || (src + 8 <= dest)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version with byte accesses which always work */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_net_device_exit(DeviceState *qdev)

{

    VirtIONet *n = VIRTIO_NET(qdev);

    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);

    int i;



    /* This will stop vhost backend if appropriate. */

    virtio_net_set_status(vdev, 0);



    unregister_savevm(qdev, ""virtio-net"", n);



    if (n->netclient_name) {

        g_free(n->netclient_name);

        n->netclient_name = NULL;

    }

    if (n->netclient_type) {

        g_free(n->netclient_type);

        n->netclient_type = NULL;

    }



    g_free(n->mac_table.macs);

    g_free(n->vlans);



    for (i = 0; i < n->max_queues; i++) {

        VirtIONetQueue *q = &n->vqs[i];

        NetClientState *nc = qemu_get_subqueue(n->nic, i);



        qemu_purge_queued_packets(nc);



        if (q->tx_timer) {

            timer_del(q->tx_timer);

            timer_free(q->tx_timer);

        } else {

            qemu_bh_delete(q->tx_bh);

        }

    }



    g_free(n->vqs);

    qemu_del_nic(n->nic);

    virtio_cleanup(vdev);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)

{

    if (u) {

        switch (size) {

        case 0: gen_helper_neon_widen_u8(dest, src); break;

        case 1: gen_helper_neon_widen_u16(dest, src); break;

        case 2: tcg_gen_extu_i32_i64(dest, src); break;

        default: abort();

        }

    } else {

        switch (size) {

        case 0: gen_helper_neon_widen_s8(dest, src); break;

        case 1: gen_helper_neon_widen_s16(dest, src); break;

        case 2: tcg_gen_ext_i32_i64(dest, src); break;

        default: abort();

        }

    }

    dead_tmp(src);

}
",0
Detect whether the following code contains vulnerabilities.,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void s390_machine_reset(void)

{

    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));



    qemu_devices_reset();

    s390_cmma_reset();

    s390_crypto_reset();



    /* all cpus are stopped - configure and start the ipl cpu only */

    s390_ipl_prepare_cpu(ipl_cpu);

    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);

}
",1
Detect whether the following code contains vulnerabilities.,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)

{

    RTSPState *rt = s->priv_data;

    int i;



    for (i = 0; i < rt->nb_rtsp_streams; i++) {

        RTSPStream *rtsp_st = rt->rtsp_streams[i];

        if (!rtsp_st)

            continue;

        if (rtsp_st->transport_priv) {

            if (s->oformat) {

                AVFormatContext *rtpctx = rtsp_st->transport_priv;

                av_write_trailer(rtpctx);

                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

                    uint8_t *ptr;

                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)

                        ff_rtsp_tcp_write_packet(s, rtsp_st);

                    avio_close_dyn_buf(rtpctx->pb, &ptr);

                    av_free(ptr);

                } else {

                    avio_close(rtpctx->pb);

                }

                avformat_free_context(rtpctx);

            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)

                ff_rdt_parse_close(rtsp_st->transport_priv);

            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)

                ff_rtp_parse_close(rtsp_st->transport_priv);

        }

        rtsp_st->transport_priv = NULL;

        if (rtsp_st->rtp_handle)

            ffurl_close(rtsp_st->rtp_handle);

        rtsp_st->rtp_handle = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;



    assert(p->ep->nr == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            usb_device_handle_control(s, p, request, value, index,

                                      s->setup_len, s->data_buf);

            if (p->status == USB_RET_ASYNC) {

                return;

            }

            s->setup_state = SETUP_STATE_IDLE;

            p->actual_length = 0;

        }

        break;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len) {

                s->setup_state = SETUP_STATE_ACK;

            }

            return;

        }

        s->setup_state = SETUP_STATE_IDLE;

        p->status = USB_RET_STALL;

        break;



    default:

        p->status = USB_RET_STALL;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_video_buffer(AVFrame *frame, int align)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

    int ret, i;



    if (!desc)

        return AVERROR(EINVAL);



    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)

        return ret;



    if (!frame->linesize[0]) {

        ret = av_image_fill_linesizes(frame->linesize, frame->format,

                                      frame->width);

        if (ret < 0)

            return ret;



        for (i = 0; i < 4 && frame->linesize[i]; i++)

            frame->linesize[i] = FFALIGN(frame->linesize[i], align);

    }



    for (i = 0; i < 4 && frame->linesize[i]; i++) {

        int h = FFALIGN(frame->height, 32);

        if (i == 1 || i == 2)

            h = -((-h) >> desc->log2_chroma_h);



        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);

        if (!frame->buf[i])

            goto fail;



        frame->data[i] = frame->buf[i]->data;

    }

    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {

        av_buffer_unref(&frame->buf[1]);

        frame->buf[1] = av_buffer_alloc(1024);

        if (!frame->buf[1])

            goto fail;

        frame->data[1] = frame->buf[1]->data;

    }



    frame->extended_data = frame->data;



    return 0;

fail:

    av_frame_unref(frame);

    return AVERROR(ENOMEM);

}
",0
Detect whether the following code contains vulnerabilities.,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)

{

    int i;



    f->slice_count = f->num_h_slices * f->num_v_slices;

    if (f->slice_count <= 0) {

        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");

        return AVERROR(EINVAL);

    }



    for (i = 0; i < f->slice_count; i++) {

        FFV1Context *fs = av_mallocz(sizeof(*fs));

        int sx          = i % f->num_h_slices;

        int sy          = i / f->num_h_slices;

        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;

        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;

        int sys         = f->avctx->height *  sy      / f->num_v_slices;

        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;

        f->slice_context[i] = fs;

        memcpy(fs, f, sizeof(*fs));

        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));



        fs->slice_width  = sxe - sxs;

        fs->slice_height = sye - sys;

        fs->slice_x      = sxs;

        fs->slice_y      = sys;



        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *

                                      sizeof(*fs->sample_buffer));

        if (!fs->sample_buffer)

            return AVERROR(ENOMEM);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",1
Detect whether the following code contains vulnerabilities.,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",0
Detect whether the following code contains vulnerabilities.,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline bool handler_is_async(const mon_cmd_t *cmd)

{

    return cmd->flags & MONITOR_CMD_ASYNC;

}
",1
Detect whether the following code contains vulnerabilities.,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",1
Detect whether the following code contains vulnerabilities.,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",0
Detect whether the following code contains vulnerabilities.,"static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);

    SCSIDiskReq *r;



    r = scsi_find_request(s, tag);

    if (!r) {

        BADF(""Bad read tag 0x%x\n"", tag);

        /* ??? This is the wrong error.  */

        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    scsi_read_request(r);

}
",0
Detect whether the following code contains vulnerabilities.,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",0
Detect whether the following code contains vulnerabilities.,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)

{

    CPUArchState *env;



    int mmu_idx;



    assert_cpu_is_self(cpu);



    env = cpu->env_ptr;

    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {

        unsigned int i;



        for (i = 0; i < CPU_TLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],

                                  start1, length);

        }



        for (i = 0; i < CPU_VTLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],

                                  start1, length);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",1
Detect whether the following code contains vulnerabilities.,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    return xen_config_dev_all(fe, be);

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void curses_setup(void)

{

    int i, colour_default[8] = {

        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,

        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,

    };



    /* input as raw as possible, let everything be interpreted

     * by the guest system */

    initscr(); noecho(); intrflush(stdscr, FALSE);

    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);

    start_color(); raw(); scrollok(stdscr, FALSE);



    for (i = 0; i < 64; i ++)

        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",0
Detect whether the following code contains vulnerabilities.,"static void v9fs_stat(void *opaque)

{

    int32_t fid;

    V9fsStat v9stat;

    ssize_t err = 0;

    size_t offset = 7;

    struct stat stbuf;

    V9fsFidState *fidp;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""d"", &fid);

    trace_v9fs_stat(pdu->tag, pdu->id, fid);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);

    if (err < 0) {

        goto out;

    }

    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);

    if (err < 0) {

        goto out;

    }

    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);

    err = offset;

    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,

                           v9stat.atime, v9stat.mtime, v9stat.length);

    v9fs_stat_free(&v9stat);

out:

    put_fid(pdu, fidp);

out_nofid:

    complete_pdu(s, pdu, err);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",1
Detect whether the following code contains vulnerabilities.,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",0
Detect whether the following code contains vulnerabilities.,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVRawState *s = bs->opaque;

    int access_flags, create_flags;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    s->type = find_device_type(bs, filename);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    create_flags = OPEN_EXISTING;



#ifdef QEMU_TOOL

    overlapped = FILE_ATTRIBUTE_NORMAL;

#else

    overlapped = FILE_FLAG_OVERLAPPED;

#endif

    s->hfile = CreateFile(filename, access_flags, 

                          FILE_SHARE_READ, NULL,

                          create_flags, overlapped, NULL);

    if (s->hfile == INVALID_HANDLE_VALUE) 

        return -1;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0
Detect whether the following code contains vulnerabilities.,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong tmp;



    tmp = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = tmp;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = tmp;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = tmp; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env->CP0_Status = tmp; break;

    case 33: env->active_tc.LO[0] = tmp; break;

    case 34: env->active_tc.HI[0] = tmp; break;

    case 35: env->CP0_BadVAddr = tmp; break;

    case 36: env->CP0_Cause = tmp; break;

    case 37: env->active_tc.PC = tmp; break;

    case 72: /* fp, ignored */ break;

    default: 

	if (n > 89)

	    return 0;

	/* Other registers are readonly.  Ignore writes.  */

	break;

    }



    return sizeof(target_ulong);

}
",0
Detect whether the following code contains vulnerabilities.,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->cb = cb;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",0
Detect whether the following code contains vulnerabilities.,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",1
Detect whether the following code contains vulnerabilities.,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",1
Detect whether the following code contains vulnerabilities.,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)

{

    IscsiLun *iscsilun = bs->opaque;

    struct IscsiTask iTask;

    struct unmap_list list;

    int r = 0;



    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {

        return -ENOTSUP;

    }



    if (!iscsilun->lbp.lbpu) {

        /* UNMAP is not supported by the target */

        return 0;

    }



    list.lba = offset / iscsilun->block_size;

    list.num = bytes / iscsilun->block_size;



    iscsi_co_init_iscsitask(iscsilun, &iTask);

    qemu_mutex_lock(&iscsilun->mutex);

retry:

    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,

                         iscsi_co_generic_cb, &iTask) == NULL) {

        r = -ENOMEM;

        goto out_unlock;

    }



    while (!iTask.complete) {

        iscsi_set_events(iscsilun);

        qemu_mutex_unlock(&iscsilun->mutex);

        qemu_coroutine_yield();

        qemu_mutex_lock(&iscsilun->mutex);

    }



    if (iTask.task != NULL) {

        scsi_free_scsi_task(iTask.task);

        iTask.task = NULL;

    }



    if (iTask.do_retry) {

        iTask.complete = 0;

        goto retry;

    }



    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {

        /* the target might fail with a check condition if it

           is not happy with the alignment of the UNMAP request

           we silently fail in this case */

        goto out_unlock;

    }



    if (iTask.status != SCSI_STATUS_GOOD) {

        r = iTask.err_code;

        goto out_unlock;

    }



    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,

                               bytes >> BDRV_SECTOR_BITS);



out_unlock:

    qemu_mutex_unlock(&iscsilun->mutex);

    return r;

}
",1
Detect whether the following code contains vulnerabilities.,"int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,

                              int mmu_idx)

{

    MIPSCPU *cpu = MIPS_CPU(cs);

    CPUMIPSState *env = &cpu->env;

#if !defined(CONFIG_USER_ONLY)

    hwaddr physical;

    int prot;

    int access_type;

#endif

    int ret = 0;



#if 0

    log_cpu_state(cs, 0);

#endif

    qemu_log_mask(CPU_LOG_MMU,

              ""%s pc "" TARGET_FMT_lx "" ad %"" VADDR_PRIx "" rw %d mmu_idx %d\n"",

              __func__, env->active_tc.PC, address, rw, mmu_idx);



    /* data access */

#if !defined(CONFIG_USER_ONLY)

    /* XXX: put correct access by using cpu_restore_state()

       correctly */

    access_type = ACCESS_INT;

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    qemu_log_mask(CPU_LOG_MMU,

             ""%s address=%"" VADDR_PRIx "" ret %d physical "" TARGET_FMT_plx

             "" prot %d\n"",

             __func__, address, ret, physical, prot);

    if (ret == TLBRET_MATCH) {

        tlb_set_page(cs, address & TARGET_PAGE_MASK,

                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,

                     mmu_idx, TARGET_PAGE_SIZE);

        ret = 0;

    } else if (ret < 0)

#endif

    {

        raise_mmu_exception(env, address, rw, ret);

        ret = 1;

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
",0
Detect whether the following code contains vulnerabilities.,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)

{

    QXLDevSurfaceCreate surface;



    memset(&surface, 0, sizeof(surface));



    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,

           surface_width(ssd->ds), surface_height(ssd->ds));



    surface.format     = SPICE_SURFACE_FMT_32_xRGB;

    surface.width      = surface_width(ssd->ds);

    surface.height     = surface_height(ssd->ds);

    surface.stride     = -surface.width * 4;

    surface.mouse_mode = true;

    surface.flags      = 0;

    surface.type       = 0;

    surface.mem        = (uintptr_t)ssd->buf;

    surface.group_id   = MEMSLOT_GROUP_HOST;



    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);

}
",1
Detect whether the following code contains vulnerabilities.,"static void init_proc_750fx (CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(env);

    /* Thermal management */

    gen_spr_thrm(env);

    /* XXX : not implemented */

    spr_register(env, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Memory management */

    gen_low_BATs(env);

    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */

    gen_high_BATs(env);

    init_excp_7x0(env);

    env->dcache_line_size = 32;

    env->icache_line_size = 32;

    /* Allocate hardware IRQ controller */

    ppc6xx_irq_init(env);

}
",1
Detect whether the following code contains vulnerabilities.,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
",1
Detect whether the following code contains vulnerabilities.,"e1000_can_receive(void *opaque)

{

    E1000State *s = opaque;



    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||

            s->mac_reg[RDH] != s->mac_reg[RDT]);

}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned tget(const uint8_t **p, int type, int le)

{

    switch (type) {

    case TIFF_BYTE:

        return *(*p)++;

    case TIFF_SHORT:

        return tget_short(p, le);

    case TIFF_LONG:

        return tget_long(p, le);

    default:

        return UINT_MAX;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_hq_slice(AVCodecContext *avctx, void *arg)

{

    int i, quant, level, orientation, quant_idx;

    uint8_t quants[MAX_DWT_LEVELS][4];

    DiracContext *s = avctx->priv_data;

    DiracSlice *slice = arg;

    GetBitContext *gb = &slice->gb;



    skip_bits_long(gb, 8*s->highquality.prefix_bytes);

    quant_idx = get_bits(gb, 8);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);

            quants[level][orientation] = quant;

        }

    }



    /* Luma + 2 Chroma planes */

    for (i = 0; i < 3; i++) {

        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);

        int64_t bits_left = 8 * length;

        int64_t bits_end = get_bits_count(gb) + bits_left;



        if (bits_end >= INT_MAX) {

            av_log(s->avctx, AV_LOG_ERROR, ""end too far away\n"");

            return AVERROR_INVALIDDATA;

        }



        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,

                               &s->plane[i].band[level][orientation], NULL);

            }

        }

        skip_bits_long(gb, bits_end - get_bits_count(gb));

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int amr_wb_encode_init(AVCodecContext *avctx)

{

    AMRWBContext *s = avctx->priv_data;



    if (avctx->sample_rate != 16000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 16000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);

    s->last_bitrate    = avctx->bit_rate;



    avctx->frame_size  = 320;

    avctx->coded_frame = avcodec_alloc_frame();





    s->state     = E_IF_init();



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + off >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + off < s->cur_frame_end[i])

                break;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_lswi(DisasContext *ctx)

{

    TCGv t0;

    TCGv_i32 t1, t2;

    int nb = NB(ctx->opcode);

    int start = rD(ctx->opcode);

    int ra = rA(ctx->opcode);

    int nr;



    if (nb == 0)

        nb = 32;

    nr = (nb + 3) / 4;

    if (unlikely(lsw_reg_in_range(start, nr, ra))) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

        return;

    }

    gen_set_access_type(ctx, ACCESS_INT);

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    t0 = tcg_temp_new();

    gen_addr_register(ctx, t0);

    t1 = tcg_const_i32(nb);

    t2 = tcg_const_i32(start);

    gen_helper_lsw(cpu_env, t0, t1, t2);

    tcg_temp_free(t0);

    tcg_temp_free_i32(t1);

    tcg_temp_free_i32(t2);

}
",1
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",1
Detect whether the following code contains vulnerabilities.,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	strcpy(term_cmd_buf, term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_printf(""\n"");

    term_print_cmdline(term_cmd_buf);

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)

{

    QSVFrame *cur;

    AVPacket pkt;

    int ret = 0;

    mfxVideoParam param = { { 0 } };



    if (q->reinit_pending) {

        close_decoder(q);

    } else if (q->engine_ready) {

        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode get param error %d\n"", ret);

        }



        ret = MFXVideoDECODE_Reset(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode reset error %d\n"", ret);

        }



        /* Free all frames*/

        cur = q->work_frames;

        while (cur) {

            q->work_frames = cur->next;

            av_frame_free(&cur->frame);

            av_freep(&cur);

            cur = q->work_frames;

        }

    }



    /* Reset output surfaces */

    av_fifo_reset(q->async_fifo);



    /* Reset input packets fifo */

    while (av_fifo_size(q->pkt_fifo)) {

        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);

        av_packet_unref(&pkt);

    }



    /* Reset input bitstream fifo */

    av_fifo_reset(q->input_fifo);

}
",1
Detect whether the following code contains vulnerabilities.,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void xhci_reset(DeviceState *dev)

{

    XHCIState *xhci = XHCI(dev);

    int i;



    trace_usb_xhci_reset();

    if (!(xhci->usbsts & USBSTS_HCH)) {

        DPRINTF(""xhci: reset while running!\n"");

    }



    xhci->usbcmd = 0;

    xhci->usbsts = USBSTS_HCH;

    xhci->dnctrl = 0;

    xhci->crcr_low = 0;

    xhci->crcr_high = 0;

    xhci->dcbaap_low = 0;

    xhci->dcbaap_high = 0;

    xhci->config = 0;



    for (i = 0; i < xhci->numslots; i++) {

        xhci_disable_slot(xhci, i+1);

    }



    for (i = 0; i < xhci->numports; i++) {

        xhci_port_update(xhci->ports + i, 0);

    }



    for (i = 0; i < xhci->numintrs; i++) {

        xhci->intr[i].iman = 0;

        xhci->intr[i].imod = 0;

        xhci->intr[i].erstsz = 0;

        xhci->intr[i].erstba_low = 0;

        xhci->intr[i].erstba_high = 0;

        xhci->intr[i].erdp_low = 0;

        xhci->intr[i].erdp_high = 0;

        xhci->intr[i].msix_used = 0;



        xhci->intr[i].er_ep_idx = 0;

        xhci->intr[i].er_pcs = 1;

        xhci->intr[i].er_full = 0;

        xhci->intr[i].ev_buffer_put = 0;

        xhci->intr[i].ev_buffer_get = 0;

    }



    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);

    xhci_mfwrap_update(xhci);

}
",1
Detect whether the following code contains vulnerabilities.,"int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)

{

    int i, ret;



    ret = -1;

    *def = NULL;

    for (i = 0; ppc_defs[i].name != NULL; i++) {

        if ((pvr & ppc_defs[i].pvr_mask) ==

            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {

            *def = &ppc_defs[i];

            ret = 0;

            break;

        }

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",0
Detect whether the following code contains vulnerabilities.,"static void nvme_instance_init(Object *obj)

{

    object_property_add(obj, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(obj, -1, ""bootindex"", NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(opts);

    return ret;
",1
Detect whether the following code contains vulnerabilities.,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,

        .mbps = -1,

    };



    return &current_migration;

}
",1
Detect whether the following code contains vulnerabilities.,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",1
Detect whether the following code contains vulnerabilities.,"static int qcow2_change_backing_file(BlockDriverState *bs,

    const char *backing_file, const char *backing_fmt)

{

    return qcow2_update_ext_header(bs, backing_file, backing_fmt);

}
",1
Detect whether the following code contains vulnerabilities.,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)

{

    return s->iq_tail == 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,

                                     const uint8_t *src_in[4],

                                     int srcW, int xInc, const int16_t *hChrFilter,

                                     const int16_t *hChrFilterPos, int hChrFilterSize,

                                     uint8_t *formatConvBuffer, uint32_t *pal)

{

    const uint8_t *src1 = src_in[1], *src2 = src_in[2];

    if (c->chrToYV12) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= buf2;

    } else if (c->readChrPlanar) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);

        src1= formatConvBuffer;

        src2= buf2;

    }



    if (!c->hcscale_fast) {

        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);

    }



    if (c->chrConvertRange)

        c->chrConvertRange(dst1, dst2, dstWidth);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    virtio_scsi_common_unrealize(dev, errp);
}",1
Detect whether the following code contains vulnerabilities.,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,

                             unsigned size)

{

    icp_pit_state *s = (icp_pit_state *)opaque;

    int n;



    /* ??? Don't know the PrimeCell ID for this device.  */

    n = offset >> 8;

    if (n > 3) {

        hw_error(""sp804_read: Bad timer %d\n"", n);

    }



    return arm_timer_read(s->timer[n], offset & 0xff);

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",1
Detect whether the following code contains vulnerabilities.,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",1
Detect whether the following code contains vulnerabilities.,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)

{

    AVStream       *video_st    = s->streams[0];

    AVCodecParameters *video_par = s->streams[0]->codecpar;

    AVCodecParameters *audio_par = s->streams[1]->codecpar;

    int audio_rate = audio_par->sample_rate;

    // TODO: should be avg_frame_rate

    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);

    int audio_kbitrate = audio_par->bit_rate / 1000;

    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);



    avio_wb32(pb, 0x94); /* size */

    ffio_wfourcc(pb, ""uuid"");

    ffio_wfourcc(pb, ""PROF"");



    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */

    avio_wb32(pb, 0xbb88695c);

    avio_wb32(pb, 0xfac9c740);



    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x3);  /* 3 sections ? */



    avio_wb32(pb, 0x14); /* size */

    ffio_wfourcc(pb, ""FPRF"");

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */



    avio_wb32(pb, 0x2c);  /* size */

    ffio_wfourcc(pb, ""APRF""); /* audio */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x2);   /* TrackID */

    ffio_wfourcc(pb, ""mp4a"");

    avio_wb32(pb, 0x20f);

    avio_wb32(pb, 0x0);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_rate);

    avio_wb32(pb, audio_par->channels);



    avio_wb32(pb, 0x34);  /* size */

    ffio_wfourcc(pb, ""VPRF"");   /* video */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x1);    /* TrackID */

    if (video_par->codec_id == AV_CODEC_ID_H264) {

        ffio_wfourcc(pb, ""avc1"");

        avio_wb16(pb, 0x014D);

        avio_wb16(pb, 0x0015);

    } else {

        ffio_wfourcc(pb, ""mp4v"");

        avio_wb16(pb, 0x0000);

        avio_wb16(pb, 0x0103);

    }

    avio_wb32(pb, 0x0);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, frame_rate);

    avio_wb32(pb, frame_rate);

    avio_wb16(pb, video_par->width);

    avio_wb16(pb, video_par->height);

    avio_wb32(pb, 0x010001); /* ? */

}
",1
Detect whether the following code contains vulnerabilities.,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_prevvalues,

               bps * s->cdlms[ich][ilms].order);

        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_updates,

               bps * s->cdlms[ich][ilms].order);

        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,

                         const char *filt_name, const char *args, AVClass *log_ctx)

{

    AVFilter *filt;

    char inst_name[30];

    char tmp_args[256];

    int ret;



    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);



    filt = avfilter_get_by_name(filt_name);



    if (!filt) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""No such filter: '%s'\n"", filt_name);

        return AVERROR(EINVAL);

    }



    ret = avfilter_open(filt_ctx, filt, inst_name);

    if (!*filt_ctx) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error creating filter '%s'\n"", filt_name);

        return ret;

    }



    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {

        avfilter_free(*filt_ctx);

        return ret;

    }



    if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {

        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",

                 args, ctx->scale_sws_opts);

        args = tmp_args;

    }



    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error initializing filter '%s' with args '%s'\n"", filt_name, args);

        return ret;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return mode;

}
",0
Detect whether the following code contains vulnerabilities.,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",0
Detect whether the following code contains vulnerabilities.,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(other_job);

        assert(other_job->completed);

    }

    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {

        ctx = blk_get_aio_context(other_job->blk);

        block_job_completed_single(other_job);

        aio_context_release(ctx);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",0
Detect whether the following code contains vulnerabilities.,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
",0
Detect whether the following code contains vulnerabilities.,"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)

{

    struct cow_header_v2 cow_header;

    struct stat st;

    int64_t image_sectors = 0;

    char *image_filename = NULL;

    Error *local_err = NULL;

    int ret;

    BlockDriverState *cow_bs;



    /* Read out options */

    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;

    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);



    ret = bdrv_create_file(filename, opts, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    cow_bs = NULL;

    ret = bdrv_open(&cow_bs, filename, NULL, NULL,

                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    memset(&cow_header, 0, sizeof(cow_header));

    cow_header.magic = cpu_to_be32(COW_MAGIC);

    cow_header.version = cpu_to_be32(COW_VERSION);

    if (image_filename) {

        /* Note: if no file, we put a dummy mtime */

        cow_header.mtime = cpu_to_be32(0);



        if (stat(image_filename, &st) != 0) {

            goto mtime_fail;

        }

        cow_header.mtime = cpu_to_be32(st.st_mtime);

    mtime_fail:

        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),

                image_filename);

    }

    cow_header.sectorsize = cpu_to_be32(512);

    cow_header.size = cpu_to_be64(image_sectors * 512);

    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));

    if (ret < 0) {

        goto exit;

    }



    /* resize to include at least all the bitmap */

    ret = bdrv_truncate(cow_bs,

        sizeof(cow_header) + ((image_sectors + 7) >> 3));

    if (ret < 0) {

        goto exit;

    }



exit:

    g_free(image_filename);

    bdrv_unref(cow_bs);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

    av_parser_close(parser);



final:

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
",0
Detect whether the following code contains vulnerabilities.,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",0
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
",0
Detect whether the following code contains vulnerabilities.,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);



    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, s->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];



    menelaus_reset(&s->i2c);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,

                         int base, int16_t offset)

{

    const char *opn = ""st_cond"";

    TCGv t0, t1;



    t0 = tcg_temp_local_new();



    gen_base_offset_addr(ctx, t0, base, offset);

    /* Don't do NOP if destination is zero: we must perform the actual

       memory access. */



    t1 = tcg_temp_local_new();

    gen_load_gpr(t1, rt);

    switch (opc) {

#if defined(TARGET_MIPS64)

    case OPC_SCD:

        save_cpu_state(ctx, 0);

        op_st_scd(t1, t0, rt, ctx);

        opn = ""scd"";

        break;

#endif

    case OPC_SC:

        save_cpu_state(ctx, 1);

        op_st_sc(t1, t0, rt, ctx);

        opn = ""sc"";

        break;

    }

    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);

    tcg_temp_free(t1);

    tcg_temp_free(t0);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
",1
Detect whether the following code contains vulnerabilities.,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
",1
Detect whether the following code contains vulnerabilities.,"static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,

                                 bool query_backing)

{

    BlockStats *s = NULL;



    s = g_malloc0(sizeof(*s));

    s->stats = g_malloc0(sizeof(*s->stats));



    if (!bs) {

        return s;

    }



    if (bdrv_get_node_name(bs)[0]) {

        s->has_node_name = true;

        s->node_name = g_strdup(bdrv_get_node_name(bs));

    }



    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);



    if (bs->file) {

        s->has_parent = true;

        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);

    }



    if (query_backing && bs->backing) {

        s->has_backing = true;

        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);

    }



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)

{

    CachedL2Table *entry;



    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);

    if (entry) {

        qed_unref_l2_cache_entry(entry);

        qed_unref_l2_cache_entry(l2_table);

        return;

    }



    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {

        entry = QTAILQ_FIRST(&l2_cache->entries);

        QTAILQ_REMOVE(&l2_cache->entries, entry, node);

        l2_cache->n_entries--;

        qed_unref_l2_cache_entry(entry);

    }



    l2_cache->n_entries++;

    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,

                                     AVCodecContext *avctx,

                                     unsigned high_bit_depth)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_MMX(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_mmx;


        c->diff_pixels = ff_diff_pixels_mmx;

    }



    if (EXTERNAL_SSE2(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_sse2;


        c->diff_pixels = ff_diff_pixels_sse2;

    }

}",1
Detect whether the following code contains vulnerabilities.,"static USBDevice *usb_net_init(const char *cmdline)

{

    USBDevice *dev;

    QemuOpts *opts;

    int idx;



    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);

    if (!opts) {



    qemu_opt_set(opts, ""type"", ""nic"");

    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);

    qdev_init_nofail(&dev->qdev);

    return dev;
",1
Detect whether the following code contains vulnerabilities.,"static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,

                              int dump_payload, AVRational time_base)

{

    HEXDUMP_PRINT(""stream #%d:\n"", pkt->stream_index);

    HEXDUMP_PRINT(""  keyframe=%d\n"", (pkt->flags & AV_PKT_FLAG_KEY) != 0);

    HEXDUMP_PRINT(""  duration=%0.3f\n"", pkt->duration * av_q2d(time_base));

    /* DTS is _always_ valid after av_read_frame() */

    HEXDUMP_PRINT(""  dts="");

    if (pkt->dts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->dts * av_q2d(time_base));

    /* PTS may not be known if B-frames are present. */

    HEXDUMP_PRINT(""  pts="");

    if (pkt->pts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->pts * av_q2d(time_base));

    HEXDUMP_PRINT(""\n"");

    HEXDUMP_PRINT(""  size=%d\n"", pkt->size);

    if (dump_payload)

        av_hex_dump(f, pkt->data, pkt->size);

}
",1
Detect whether the following code contains vulnerabilities.,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}
",0
Detect whether the following code contains vulnerabilities.,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
",1
Detect whether the following code contains vulnerabilities.,"int av_packet_split_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){

        int i;

        unsigned int size;

        uint8_t *p;



        p = pkt->data + pkt->size - 8 - 5;

        for (i=1; ; i++){

            size = AV_RB32(p);

            if (size>INT_MAX || p - pkt->data < size)

                return 0;

            if (p[4]&128)

                break;

            p-= size+5;

        }



        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));

        if (!pkt->side_data)

            return AVERROR(ENOMEM);



        p= pkt->data + pkt->size - 8 - 5;

        for (i=0; ; i++){

            size= AV_RB32(p);

            av_assert0(size<=INT_MAX && p - pkt->data >= size);

            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);

            pkt->side_data[i].size = size;

            pkt->side_data[i].type = p[4]&127;

            if (!pkt->side_data[i].data)

                return AVERROR(ENOMEM);

            memcpy(pkt->side_data[i].data, p-size, size);

            pkt->size -= size + 5;

            if(p[4]&128)

                break;

            p-= size+5;

        }

        pkt->size -= 8;

        pkt->side_data_elems = i+1;

        return 1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
",1
Detect whether the following code contains vulnerabilities.,"ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,

                                uint32_t flags)

{

    ram_addr_t bdloc;

    int i, n;



    /* We put the bd structure at the top of memory */

    if (bd->bi_memsize >= 0x01000000UL)

        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);

    else

        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);

    stl_phys(bdloc + 0x00, bd->bi_memstart);

    stl_phys(bdloc + 0x04, bd->bi_memsize);

    stl_phys(bdloc + 0x08, bd->bi_flashstart);

    stl_phys(bdloc + 0x0C, bd->bi_flashsize);

    stl_phys(bdloc + 0x10, bd->bi_flashoffset);

    stl_phys(bdloc + 0x14, bd->bi_sramstart);

    stl_phys(bdloc + 0x18, bd->bi_sramsize);

    stl_phys(bdloc + 0x1C, bd->bi_bootflags);

    stl_phys(bdloc + 0x20, bd->bi_ipaddr);

    for (i = 0; i < 6; i++)

        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);

    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);

    stl_phys(bdloc + 0x2C, bd->bi_intfreq);

    stl_phys(bdloc + 0x30, bd->bi_busfreq);

    stl_phys(bdloc + 0x34, bd->bi_baudrate);

    for (i = 0; i < 4; i++)

        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);

    for (i = 0; i < 32; i++)

        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);

    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);

    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);

    for (i = 0; i < 6; i++)

        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);

    n = 0x6A;

    if (flags & 0x00000001) {

        for (i = 0; i < 6; i++)

            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);

    }

    stl_phys(bdloc + n, bd->bi_opbfreq);

    n += 4;

    for (i = 0; i < 2; i++) {

        stl_phys(bdloc + n, bd->bi_iic_fast[i]);

        n += 4;

    }



    return bdloc;

}
",1
Detect whether the following code contains vulnerabilities.,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
",0
Detect whether the following code contains vulnerabilities.,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)

{

    int got_frame;

    int ret;



    av_assert0(!avctx->internal->buffer_frame->buf[0]);



    if (!pkt)

        pkt = avctx->internal->buffer_pkt;



    // This is the lesser evil. The field is for compatibility with legacy users

    // of the legacy API, and users using the new API should not be forced to

    // even know about this field.

    avctx->refcounted_frames = 1;



    // Some codecs (at least wma lossless) will crash when feeding drain packets

    // after EOF was signaled.

    if (avctx->internal->draining_done)

        return AVERROR_EOF;



    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {

        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))

            ret = pkt->size;

    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

    } else {

        ret = AVERROR(EINVAL);

    }



    if (ret == AVERROR(EAGAIN))

        ret = pkt->size;



    if (ret < 0)

        return ret;



    if (avctx->internal->draining && !got_frame)

        avctx->internal->draining_done = 1;



    if (ret >= pkt->size) {

        av_packet_unref(avctx->internal->buffer_pkt);

    } else {

        int consumed = ret;



        if (pkt != avctx->internal->buffer_pkt) {

            av_packet_unref(avctx->internal->buffer_pkt);

            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)

                return ret;

        }



        avctx->internal->buffer_pkt->data += consumed;

        avctx->internal->buffer_pkt->size -= consumed;

        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;

        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;

    }



    if (got_frame)

        av_assert0(avctx->internal->buffer_frame->buf[0]);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",0
Detect whether the following code contains vulnerabilities.,"static void vfio_bar_write(void *opaque, hwaddr addr,

                           uint64_t data, unsigned size)

{

    VFIOBAR *bar = opaque;

    union {

        uint8_t byte;

        uint16_t word;

        uint32_t dword;

        uint64_t qword;

    } buf;



    switch (size) {

    case 1:

        buf.byte = data;

        break;

    case 2:

        buf.word = cpu_to_le16(data);

        break;

    case 4:

        buf.dword = cpu_to_le32(data);

        break;

    default:

        hw_error(""vfio: unsupported write size, %d bytes\n"", size);

        break;

    }



    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {

        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",

                     __func__, addr, data, size);

    }



    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",

            __func__, bar->nr, addr, data, size);



    /*

     * A read or write to a BAR always signals an INTx EOI.  This will

     * do nothing if not pending (including not in INTx mode).  We assume

     * that a BAR access is in response to an interrupt and that BAR

     * accesses will service the interrupt.  Unfortunately, we don't know

     * which access will service the interrupt, so we're potentially

     * getting quite a few host interrupts per guest interrupt.

     */

    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));

}
",0
Detect whether the following code contains vulnerabilities.,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline uint64_t ldq_phys_internal(hwaddr addr,

                                         enum device_endian endian)

{

    uint8_t *ptr;

    uint64_t val;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!(memory_region_is_ram(section->mr) ||

          memory_region_is_romd(section->mr))) {

        /* I/O case */

        addr = memory_region_section_addr(section, addr);



        /* XXX This is broken when device endian != cpu endian.

               Fix and add ""endian"" variable check */

#ifdef TARGET_WORDS_BIGENDIAN

        val = io_mem_read(section->mr, addr, 4) << 32;

        val |= io_mem_read(section->mr, addr + 4, 4);

#else

        val = io_mem_read(section->mr, addr, 4);

        val |= io_mem_read(section->mr, addr + 4, 4) << 32;

#endif

    } else {

        /* RAM case */

        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)

                                & TARGET_PAGE_MASK)

                               + memory_region_section_addr(section, addr));

        switch (endian) {

        case DEVICE_LITTLE_ENDIAN:

            val = ldq_le_p(ptr);

            break;

        case DEVICE_BIG_ENDIAN:

            val = ldq_be_p(ptr);

            break;

        default:

            val = ldq_p(ptr);

            break;

        }

    }

    return val;

}
",0
Detect whether the following code contains vulnerabilities.,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

       them.  */

    qemu_bh_poll();



}
",0
Detect whether the following code contains vulnerabilities.,"void bdrv_invalidate_cache_all(Error **errp)

{

    BlockDriverState *bs;

    Error *local_err = NULL;

    BdrvNextIterator *it = NULL;



    while ((it = bdrv_next(it, &bs)) != NULL) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);

        bdrv_invalidate_cache(bs, &local_err);

        aio_context_release(aio_context);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",1
Detect whether the following code contains vulnerabilities.,"static void cpu_x86_dump_state(FILE *f)

{

    int eflags;

    char cc_op_name[32];

    eflags = cc_table[CC_OP].compute_all();

    eflags |= (DF & DF_MASK);

    if ((unsigned)env->cc_op < CC_OP_NB)

        strcpy(cc_op_name, cc_op_str[env->cc_op]);

    else

        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);

    fprintf(f, 

            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""

            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""

            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""

            ""EIP=%08x\n"",

            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 

            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 

            env->cc_src, env->cc_dst, cc_op_name,

            eflags & DF_MASK ? 'D' : '-',

            eflags & CC_O ? 'O' : '-',

            eflags & CC_S ? 'S' : '-',

            eflags & CC_Z ? 'Z' : '-',

            eflags & CC_A ? 'A' : '-',

            eflags & CC_P ? 'P' : '-',

            eflags & CC_C ? 'C' : '-',

            env->eip);

#if 1

    fprintf(f, ""ST0=%f ST1=%f ST2=%f ST3=%f\n"", 

            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,

                             int buf_size, void *data)

{

    AlacEncodeContext *s = avctx->priv_data;

    PutBitContext *pb = &s->pbctx;

    int i, out_bytes, verbatim_flag = 0;



    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {

        av_log(avctx, AV_LOG_ERROR, ""input frame size exceeded\n"");

        return -1;

    }



    if (buf_size < 2 * s->max_coded_frame_size) {

        av_log(avctx, AV_LOG_ERROR, ""buffer size is too small\n"");

        return -1;

    }



verbatim:

    init_put_bits(pb, frame, buf_size);



    if (s->compression_level == 0 || verbatim_flag) {

        // Verbatim mode

        const int16_t *samples = data;

        write_frame_header(s, 1);

        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {

            put_sbits(pb, 16, *samples++);

        }

    } else {

        init_sample_buffers(s, data);

        write_frame_header(s, 0);

        write_compressed_frame(s);

    }



    put_bits(pb, 3, 7);

    flush_put_bits(pb);

    out_bytes = put_bits_count(pb) >> 3;



    if (out_bytes > s->max_coded_frame_size) {

        /* frame too large. use verbatim mode */

        if (verbatim_flag || s->compression_level == 0) {

            /* still too large. must be an error. */

            av_log(avctx, AV_LOG_ERROR, ""error encoding frame\n"");

            return -1;

        }

        verbatim_flag = 1;

        goto verbatim;

    }



    return out_bytes;

}
",0
Detect whether the following code contains vulnerabilities.,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",1
Detect whether the following code contains vulnerabilities.,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
",1
Detect whether the following code contains vulnerabilities.,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",0
Detect whether the following code contains vulnerabilities.,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int estimate_qp(MpegEncContext *s, int dry_run){

    if (s->next_lambda){

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = s->next_lambda;

        if(!dry_run) s->next_lambda= 0;

    } else if (!s->fixed_qscale) {

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);

        if (s->current_picture.f.quality < 0)

            return -1;

    }



    if(s->adaptive_quant){

        switch(s->codec_id){

        case AV_CODEC_ID_MPEG4:

            if (CONFIG_MPEG4_ENCODER)

                ff_clean_mpeg4_qscales(s);

            break;

        case AV_CODEC_ID_H263:

        case AV_CODEC_ID_H263P:

        case AV_CODEC_ID_FLV1:

            if (CONFIG_H263_ENCODER)

                ff_clean_h263_qscales(s);

            break;

        default:

            ff_init_qscale_tab(s);

        }



        s->lambda= s->lambda_table[0];

        //FIXME broken

    }else

        s->lambda = s->current_picture.f.quality;

    update_qscale(s);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)

{

#ifdef CONFIG_KVM

    struct kvm_irqfd irqfd = {

        .fd = event_notifier_get_fd(&vdev->intx.interrupt),

        .gsi = vdev->intx.route.irq,

        .flags = KVM_IRQFD_FLAG_RESAMPLE,

    };

    struct vfio_irq_set *irq_set;

    int ret, argsz;

    int32_t *pfd;



    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||

        vdev->intx.route.mode != PCI_INTX_ENABLED ||

        !kvm_resamplefds_enabled()) {

        return;

    }



    /* Get to a known interrupt state */

    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);

    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

    vdev->intx.pending = false;

    pci_irq_deassert(&vdev->pdev);



    /* Get an eventfd for resample/unmask */

    if (event_notifier_init(&vdev->intx.unmask, 0)) {

        error_report(""vfio: Error: event_notifier_init failed eoi"");

        goto fail;

    }



    /* KVM triggers it, VFIO listens for it */

    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);



    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {

        error_report(""vfio: Error: Failed to setup resample irqfd: %m"");

        goto fail_irqfd;

    }



    argsz = sizeof(*irq_set) + sizeof(*pfd);



    irq_set = g_malloc0(argsz);

    irq_set->argsz = argsz;

    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;

    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;

    irq_set->start = 0;

    irq_set->count = 1;

    pfd = (int32_t *)&irq_set->data;



    *pfd = irqfd.resamplefd;



    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);

    g_free(irq_set);

    if (ret) {

        error_report(""vfio: Error: Failed to setup INTx unmask fd: %m"");

        goto fail_vfio;

    }



    /* Let'em rip */

    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);



    vdev->intx.kvm_accel = true;



    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);



    return;



fail_vfio:

    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;

    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);

fail_irqfd:

    event_notifier_cleanup(&vdev->intx.unmask);

fail:

    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);

    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,

                                unsigned size)

{

    IMXTimerGState *s = (IMXTimerGState *)opaque;



    DPRINTF(""g-read(offset=%x)"", offset >> 2);

    switch (offset >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x\n"", s->cr);

        return s->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x\n"", s->pr);

        return s->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x\n"", s->sr);

        return s->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x\n"", s->ir);

        return s->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x\n"", s->ocr1);

        return s->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(s);

        DPRINTF("" cnt = %x\n"", s->cnt);

        return s->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x\n"",

            (int)offset >> 2);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp)

{

    BDRVBlkdebugState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto out;

    }



    /* Read rules from config file or command line options */

    s->config_file = g_strdup(qemu_opt_get(opts, ""config""));

    ret = read_config(s, s->config_file, options, errp);

    if (ret) {

        goto out;

    }



    /* Set initial state */

    s->state = 1;



    /* Open the image file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options, ""image"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto out;

    }



    bs->supported_write_flags = BDRV_REQ_FUA &

        bs->file->bs->supported_write_flags;

    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &

        bs->file->bs->supported_zero_flags;

    ret = -EINVAL;



    /* Set request alignment */

    s->align = qemu_opt_get_size(opts, ""align"", 0);

    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {

        error_setg(errp, ""Cannot meet constraints with align %"" PRIu64,

                   s->align);

        goto out;

    }



    ret = 0;

out:

    if (ret < 0) {

        g_free(s->config_file);

    }

    qemu_opts_del(opts);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"static int packet_enqueue(CompareState *s, int mode)

{

    ConnectionKey key;

    Packet *pkt = NULL;

    Connection *conn;



    if (mode == PRIMARY_IN) {

        pkt = packet_new(s->pri_rs.buf,

                         s->pri_rs.packet_len,

                         s->pri_rs.vnet_hdr_len);

    } else {

        pkt = packet_new(s->sec_rs.buf,

                         s->sec_rs.packet_len,

                         s->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pkt)) {

        packet_destroy(pkt, NULL);

        pkt = NULL;

        return -1;

    }

    fill_connection_key(pkt, &key);



    conn = connection_get(s->connection_track_table,

                          &key,

                          &s->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&s->conn_list, conn);

        conn->processing = true;

    }



    if (mode == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pkt)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&conn->secondary_list, pkt)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ide_atapi_identify(IDEState *s)

{

    uint16_t *p;



    if (s->identify_set) {

	memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));

	return;

    }



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    /* Removable CDROM, 50us response, 12 byte packets */

    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));

    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */

    put_le16(p + 20, 3); /* buffer type */

    put_le16(p + 21, 512); /* cache size in sectors */

    put_le16(p + 22, 4); /* ecc bytes */

    padstr((char *)(p + 23), s->version, 8); /* firmware version */

    padstr((char *)(p + 27), ""QEMU DVD-ROM"", 40); /* model */

    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */

#ifdef USE_DMA_CDROM

    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */

    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */

    put_le16(p + 62, 7);  /* single word dma0-2 supported */

    put_le16(p + 63, 7);  /* mdma0-2 supported */

#else

    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */

    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */

    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */

#endif

    put_le16(p + 64, 3); /* pio3-4 supported */

    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */

    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */

    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */

    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */



    put_le16(p + 71, 30); /* in ns */

    put_le16(p + 72, 30); /* in ns */



    if (s->ncq_queues) {

        put_le16(p + 75, s->ncq_queues - 1);

        /* NCQ supported */

        put_le16(p + 76, (1 << 8));

    }



    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */

#ifdef USE_DMA_CDROM

    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */

#endif

    memcpy(s->identify_data, p, sizeof(s->identify_data));

    s->identify_set = 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_put_xsave(CPUState *env)

{

#ifdef KVM_CAP_XSAVE

    int i, r;

    struct kvm_xsave* xsave;

    uint16_t cwd, swd, twd, fop;



    if (!kvm_has_xsave())

        return kvm_put_fpu(env);



    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));

    memset(xsave, 0, sizeof(struct kvm_xsave));

    cwd = swd = twd = fop = 0;

    swd = env->fpus & ~(7 << 11);

    swd |= (env->fpstt & 7) << 11;

    cwd = env->fpuc;

    for (i = 0; i < 8; ++i)

        twd |= (!env->fptags[i]) << i;

    xsave->region[0] = (uint32_t)(swd << 16) + cwd;

    xsave->region[1] = (uint32_t)(fop << 16) + twd;

    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,

            sizeof env->fpregs);

    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,

            sizeof env->xmm_regs);

    xsave->region[XSAVE_MXCSR] = env->mxcsr;

    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;

    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,

            sizeof env->ymmh_regs);

    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);

    qemu_free(xsave);

    return r;

#else

    return kvm_put_fpu(env);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int numLines, int levelFix)

{

	int i;

	if(levelFix)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""

						""pxor %%mm4, %%mm4	\n\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""psubusb %%mm2, %%mm0	\n\t""\

						""psubusb %%mm2, %%mm1	\n\t""\

						""movq %%mm0, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm0 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm0	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm0	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm0	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm1 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm1	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm1	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm1	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

	else

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""



#define SIMPLE_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

}
",1
Detect whether the following code contains vulnerabilities.,"build_tpm2(GArray *table_data, BIOSLinker *linker)

{

    Acpi20TPM2 *tpm2_ptr;



    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);



    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);

    tpm2_ptr->control_area_address = cpu_to_le64(0);

    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);



    build_header(linker, table_data,

                 (void *)tpm2_ptr, ""TPM2"", sizeof(*tpm2_ptr), 4, NULL, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

    switch(ret) {

    case JNI_EDETACHED:

        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {

            av_log(log_ctx, AV_LOG_ERROR, ""Failed to attach the JNI environment to the current thread\n"");

            env = NULL;

        } else {

            *attached = 1;

        }

        break;

    case JNI_OK:

        break;

    case JNI_EVERSION:

        av_log(log_ctx, AV_LOG_ERROR, ""The specified JNI version is not supported\n"");

        break;

    default:

        av_log(log_ctx, AV_LOG_ERROR, ""Failed to get the JNI environment attached to this thread"");

        break;

    }



    return env;

}
",0
Detect whether the following code contains vulnerabilities.,"void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}
",0
Detect whether the following code contains vulnerabilities.,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
",1
Detect whether the following code contains vulnerabilities.,"void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)

{

    if (!s->started) {

        return;

    }

    s->started = false;

    trace_virtio_blk_data_plane_stop(s);



    /* Stop thread or cancel pending thread creation BH */

    if (s->start_bh) {

        qemu_bh_delete(s->start_bh);

        s->start_bh = NULL;

    } else {

        event_poll_notify(&s->event_poll);

        qemu_thread_join(&s->thread);

    }



    ioq_cleanup(&s->ioqueue);



    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);



    event_poll_cleanup(&s->event_poll);



    /* Clean up guest notifier (irq) */

    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);



    vring_teardown(&s->vring);

}
",1
Detect whether the following code contains vulnerabilities.,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,

                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)

{

    MpegDemuxContext *vobsub = s->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (stream_index == -1 && s->nb_streams != 1) {

        int i, ret = 0;

        AVRational time_base = s->streams[0]->time_base;

        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);

        min_ts = av_rescale_rnd(min_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        max_ts = av_rescale_rnd(max_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (i = 0; i < s->nb_streams; i++) {

            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,

                                            min_ts, ts, max_ts, flags);

            if (r < 0)

                ret = r;

        }

        return ret;

    }





    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,

                                   min_ts, ts, max_ts, flags);

}",1
Detect whether the following code contains vulnerabilities.,"static void colo_process_checkpoint(MigrationState *s)
{
    QIOChannelBuffer *bioc;
    QEMUFile *fb = NULL;
    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *local_err = NULL;
    int ret;
    failover_init_state();
    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
    if (!s->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(s->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);
    if (local_err) {
    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));
    object_unref(OBJECT(bioc));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (s->state == MIGRATION_STATUS_COLO) {
        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
        if (current_time - checkpoint_time <
            s->parameters.x_checkpoint_delay) {
            int64_t delay_ms;
            delay_ms = s->parameters.x_checkpoint_delay -
                       (current_time - checkpoint_time);
            g_usleep(delay_ms * 1000);
        ret = colo_do_checkpoint_transaction(s, bioc, fb);
        if (ret < 0) {
        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
out:
    /* Throw the unreported error message after exited from loop */
    if (local_err) {
        error_report_err(local_err);
    if (fb) {
        qemu_fclose(fb);
    if (s->rp_state.from_dst_file) {
        qemu_fclose(s->rp_state.from_dst_file);",1
Detect whether the following code contains vulnerabilities.,"uint32_t wm8750_adc_dat(void *opaque)

{

    WM8750State *s = (WM8750State *) opaque;

    uint32_t *data;



    if (s->idx_in >= sizeof(s->data_in))

        wm8750_in_load(s);



    data = (uint32_t *) &s->data_in[s->idx_in];

    s->req_in -= 4;

    s->idx_in += 4;

    return *data;

}
",0
Detect whether the following code contains vulnerabilities.,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
",0
Detect whether the following code contains vulnerabilities.,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
",0
Detect whether the following code contains vulnerabilities.,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)

{

    uint32_t v, spf;

    MPADecodeHeader c;

    int vbrtag_size = 0;

    MP3DecContext *mp3 = s->priv_data;



    ffio_init_checksum(s->pb, ff_crcA001_update, 0);



    v = avio_rb32(s->pb);

    if(ff_mpa_check_header(v) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&c, v) == 0)

        vbrtag_size = c.frame_size;

    if(c.layer != 3)

        return -1;



    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



    mp3->frames = 0;

    mp3->size   = 0;



    mp3_parse_info_tag(s, st, &c, spf);

    mp3_parse_vbri_tag(s, st, base);



    if (!mp3->frames && !mp3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);



    if (mp3->frames)

        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},

                                    st->time_base);

    if (mp3->size && mp3->frames && !mp3->is_cbr)

        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,

                                 unsigned size)

{

    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;

    uint32_t ret;

    int bank;

    if (offset >= 0x200)

        return 0;



    bank = pxa2xx_gpio_regs[offset].bank;

    switch (pxa2xx_gpio_regs[offset].reg) {

    case GPDR:		/* GPIO Pin-Direction registers */

        return s->dir[bank];



    case GPSR:		/* GPIO Pin-Output Set registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPSR\n"");

        return 0;



    case GPCR:		/* GPIO Pin-Output Clear registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPCR\n"");

        return 0;



    case GRER:		/* GPIO Rising-Edge Detect Enable registers */

        return s->rising[bank];



    case GFER:		/* GPIO Falling-Edge Detect Enable registers */

        return s->falling[bank];



    case GAFR_L:	/* GPIO Alternate Function registers */

        return s->gafr[bank * 2];



    case GAFR_U:	/* GPIO Alternate Function registers */

        return s->gafr[bank * 2 + 1];



    case GPLR:		/* GPIO Pin-Level registers */

        ret = (s->olevel[bank] & s->dir[bank]) |

                (s->ilevel[bank] & ~s->dir[bank]);

        qemu_irq_raise(s->read_notify);

        return ret;



    case GEDR:		/* GPIO Edge Detect Status registers */

        return s->status[bank];



    default:

        hw_error(""%s: Bad offset "" REG_FMT ""\n"", __FUNCTION__, offset);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;",1
Detect whether the following code contains vulnerabilities.,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
",0
Detect whether the following code contains vulnerabilities.,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    virtio_queue_set_addr(vdev, index, addr);

    if (!addr) {

        virtio_queue_set_vector(vdev, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(vdev, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *dst, *rule, *vnc, *acl, *listen;

    QObject *child, *res;

    QList *rules;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    dst = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(dst), ==, 1);



    child = qdict_get(dst, ""vnc"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    vnc = qobject_to_qdict(child);



    child = qdict_get(vnc, ""listen"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    listen = qobject_to_qdict(child);

    g_assert_cmpstr(""127.0.0.1"", ==, qdict_get_str(listen, ""addr""));

    g_assert_cmpstr(""5901"", ==, qdict_get_str(listen, ""port""));



    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qobject_to_qdict(child);



    child = qdict_get(acl, ""rules"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);

    rules = qobject_to_qlist(child);

    g_assert_cmpint(qlist_size(rules), ==, 2);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""fred"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""allow"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""bob"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""deny"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    /* With recursive crumpling, we should see all names unescaped */

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(vnc, ""acl.name""));

    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qdict_get_qdict(vnc, ""acl"");

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(acl, ""rule.name""));



    QDECREF(src);

    QDECREF(dst);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_validate_fail_alternate(TestInputVisitorData *data,

                                         const void *unused)

{

    UserDefAlternate *tmp;

    Visitor *v;

    Error *err = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAlternate(v, NULL, &tmp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefAlternate(tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",1
Detect whether the following code contains vulnerabilities.,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}",1
Detect whether the following code contains vulnerabilities.,"static void do_send_key(const char *string)

{

    char keybuf[16], *q;

    uint8_t keycodes[16];

    const char *p;

    int nb_keycodes, keycode, i;



    nb_keycodes = 0;

    p = string;

    while (*p != '\0') {

        q = keybuf;

        while (*p != '\0' && *p != '-') {

            if ((q - keybuf) < sizeof(keybuf) - 1) {

                *q++ = *p;

            }

            p++;

        }

        *q = '\0';

        keycode = get_keycode(keybuf);

        if (keycode < 0) {

            term_printf(""unknown key: '%s'\n"", keybuf);

            return;

        }

        keycodes[nb_keycodes++] = keycode;

        if (*p == '\0')

            break;

        p++;

    }

    /* key down events */

    for(i = 0; i < nb_keycodes; i++) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode & 0x7f);

    }

    /* key up events */

    for(i = nb_keycodes - 1; i >= 0; i--) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode | 0x80);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",0
Detect whether the following code contains vulnerabilities.,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)

{

    VirtQueueElement elem;

    VirtQueue *vq;



    vq = vser->c_ivq;

    if (!virtio_queue_ready(vq)) {

        return 0;

    }

    if (!virtqueue_pop(vq, &elem)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);



    virtqueue_push(vq, &elem, len);

    virtio_notify(VIRTIO_DEVICE(vser), vq);

    return len;

}
",0
Detect whether the following code contains vulnerabilities.,"void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,

                  qemu_irq sci_irq)

{

    memory_region_init(&pm->io, OBJECT(lpc_pci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&pm->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_pci),

                                0, &pm->io);



    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);



    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);



    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,

                          ""acpi-smi"", 8);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);



    pm->irq = sci_irq;

    qemu_register_reset(pm_reset, pm);

    pm->powerdown_notifier.notify = pm_powerdown_req;

    qemu_register_powerdown_notifier(&pm->powerdown_notifier);



    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),

                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);



    if (pm->acpi_memory_hotplug.is_enabled) {

        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),

                                 &pm->acpi_memory_hotplug);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
",1
Detect whether the following code contains vulnerabilities.,"static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)

{

    int i;



    for (i = 0; i < nb_coefs; i++) {

        int e;

        int v = abs(coef[i]);

        if (v == 0)

            e = 24;

        else {

            e = 23 - av_log2(v);

            if (e >= 24) {

                e = 24;

                coef[i] = 0;

            }

            av_assert2(e >= 0);

        }

        exp[i] = e;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
",0
Detect whether the following code contains vulnerabilities.,"static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,

                               TCGMemOp s_bits, int which)

{

    const TCGReg r0 = TCG_REG_O0;

    const TCGReg r1 = TCG_REG_O1;

    const TCGReg r2 = TCG_REG_O2;

    int tlb_ofs;



    /* Shift the page number down.  */

    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);



    /* Mask out the page offset, except for the required alignment.  */

    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,

                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));



    /* Mask the tlb index.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);

    

    /* Mask page, part 2.  */

    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);



    /* Shift the tlb index into place.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);



    /* Relative to the current ENV.  */

    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);



    /* Find a base address that can load both tlb comparator and addend.  */

    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);

    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {

        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);

        tlb_ofs &= 0x3ff;

    }



    /* Load the tlb comparator and the addend.  */

    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);

    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));



    /* subcc arg0, arg2, %g0 */

    tcg_out_cmp(s, r0, r2, 0);



    /* If the guest address must be zero-extended, do so now.  */

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);

        return r0;

    }

    return addr;

}
",0
Detect whether the following code contains vulnerabilities.,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)

{

#if defined(HAVE_MMX2) || defined(HAVE_MMX)

    if(c->flags & SWS_CPU_CAPS_MMX2){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX2;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX2;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX2;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX2;

	}

    }

    if(c->flags & SWS_CPU_CAPS_MMX){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX;

	}

    }

#endif

#ifdef HAVE_MLIB

    {

	SwsFunc t= yuv2rgb_init_mlib(c);

	if(t) return t;

    }

#endif

#ifdef HAVE_ALTIVEC

    if (c->flags & SWS_CPU_CAPS_ALTIVEC)

    {

	SwsFunc t = yuv2rgb_init_altivec(c);

	if(t) return t;

    }

#endif



    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");



    switch(c->dstFormat){

    case PIX_FMT_BGR32:

    case PIX_FMT_RGB32: return yuv2rgb_c_32;

    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;

    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;

    case PIX_FMT_RGB565:

    case PIX_FMT_BGR565:

    case PIX_FMT_RGB555:

    case PIX_FMT_BGR555: return yuv2rgb_c_16;

    case PIX_FMT_RGB8:

    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;

    case PIX_FMT_RGB4:

    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;

    case PIX_FMT_RGB4_BYTE:

    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;

    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;

    default:

    	assert(0);

    }

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_set_share_mode(VncState *vs, VncShareMode mode)

{

#ifdef _VNC_DEBUG

    static const char *mn[] = {

        [0]                           = ""undefined"",

        [VNC_SHARE_MODE_CONNECTING]   = ""connecting"",

        [VNC_SHARE_MODE_SHARED]       = ""shared"",

        [VNC_SHARE_MODE_EXCLUSIVE]    = ""exclusive"",

        [VNC_SHARE_MODE_DISCONNECTED] = ""disconnected"",

    };

    fprintf(stderr, ""%s/%d: %s -> %s\n"", __func__,

            vs->csock, mn[vs->share_mode], mn[mode]);

#endif



    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive--;

    }

    vs->share_mode = mode;

    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive++;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)

        scratch ^= *((const uint32_t*)buf);



    scratch = xor_32_to_8(scratch);



    for (; buf < buf_end; buf++)




    return scratch;

}",1
Detect whether the following code contains vulnerabilities.,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,

                         const uint32_t *intbit_to_level,

                         qemu_irq **irq, qemu_irq **cpu_irq,

                         unsigned int cputimer)



{

    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;

    SLAVIO_INTCTLState *s;



    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));

    if (!s)

        return NULL;



    s->intbit_to_level = intbit_to_level;

    for (i = 0; i < MAX_CPUS; i++) {

	slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);

	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,

                                     slavio_intctl_io_memory);

    }



    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);

    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);



    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_save, slavio_intctl_load, s);

    qemu_register_reset(slavio_intctl_reset, s);

    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);



    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);

    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];

    slavio_intctl_reset(s);

    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)

{

    int ret = 0;

    if (av_strstart(p, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &p)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(p) * 6 / 8;

        char *buf = av_mallocz(len);

        AVInputFormat *iformat;



        if (!buf)

            return AVERROR(ENOMEM);

        av_base64_decode(buf, p, len);



        if (rtp_asf_fix_header(buf, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize\n"");

        init_packetizer(&pb, buf, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(buf);

            return AVERROR(ENOMEM);

        }

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, ""no_resync_search"", ""1"", 0);



        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {

            av_dict_free(&opts);

            return ret;

        }



        ret = avformat_open_input(&rt->asf_ctx, """", iformat, &opts);

        av_dict_free(&opts);

        if (ret < 0) {

            av_free(buf);

            return ret;

        }

        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(buf);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int dmg_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVDMGState *s = bs->opaque;

    off_t info_begin,info_end,last_in_offset,last_out_offset;

    uint32_t count;

    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;

    int64_t offset;



    s->fd = open(filename, O_RDONLY | O_BINARY);

    if (s->fd < 0)

        return -errno;

    bs->read_only = 1;

    s->n_chunks = 0;

    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;



    /* read offset of info blocks */

    offset = lseek(s->fd, -0x1d8, SEEK_END);

    if (offset < 0) {

        goto fail;

    }



    info_begin = read_off(s->fd, offset);

    if (info_begin == 0) {

	goto fail;

    }



    if (read_uint32(s->fd, info_begin) != 0x100) {

        goto fail;

    }



    count = read_uint32(s->fd, info_begin + 4);

    if (count == 0) {

        goto fail;

    }

    info_end = info_begin + count;



    offset = info_begin + 0x100;



    /* read offsets */

    last_in_offset = last_out_offset = 0;

    while (offset < info_end) {

        uint32_t type;



	count = read_uint32(s->fd, offset);

	if(count==0)

	    goto fail;

        offset += 4;



	type = read_uint32(s->fd, offset);

	if (type == 0x6d697368 && count >= 244) {

	    int new_size, chunk_count;



            offset += 4;

            offset += 200;



	    chunk_count = (count-204)/40;

	    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);

	    s->types = qemu_realloc(s->types, new_size/2);

	    s->offsets = qemu_realloc(s->offsets, new_size);

	    s->lengths = qemu_realloc(s->lengths, new_size);

	    s->sectors = qemu_realloc(s->sectors, new_size);

	    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);



	    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {

		s->types[i] = read_uint32(s->fd, offset);

		offset += 4;

		if(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {

		    if(s->types[i]==0xffffffff) {

			last_in_offset = s->offsets[i-1]+s->lengths[i-1];

			last_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];

		    }

		    chunk_count--;

		    i--;

		    offset += 36;

		    continue;

		}

		offset += 4;



		s->sectors[i] = last_out_offset+read_off(s->fd, offset);

		offset += 8;



		s->sectorcounts[i] = read_off(s->fd, offset);

		offset += 8;



		s->offsets[i] = last_in_offset+read_off(s->fd, offset);

		offset += 8;



		s->lengths[i] = read_off(s->fd, offset);

		offset += 8;



		if(s->lengths[i]>max_compressed_size)

		    max_compressed_size = s->lengths[i];

		if(s->sectorcounts[i]>max_sectors_per_chunk)

		    max_sectors_per_chunk = s->sectorcounts[i];

	    }

	    s->n_chunks+=chunk_count;

	}

    }



    /* initialize zlib engine */

    s->compressed_chunk = qemu_malloc(max_compressed_size+1);

    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);

    if(inflateInit(&s->zstream) != Z_OK)

	goto fail;



    s->current_chunk = s->n_chunks;



    return 0;

fail:

    close(s->fd);

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
",1
Detect whether the following code contains vulnerabilities.,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",1
Detect whether the following code contains vulnerabilities.,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",1
Detect whether the following code contains vulnerabilities.,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",0
Detect whether the following code contains vulnerabilities.,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
",1
Detect whether the following code contains vulnerabilities.,"static int rtp_open(URLContext *h, const char *uri, int flags)

{

    RTPContext *s;

    int port, is_output, ttl, local_port;

    char hostname[256];

    char buf[1024];

    char path[1024];

    const char *p;



    is_output = (flags & URL_WRONLY);



    s = av_mallocz(sizeof(RTPContext));

    if (!s)

        return AVERROR(ENOMEM);

    h->priv_data = s;



    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,

              path, sizeof(path), uri);

    /* extract parameters */

    ttl = -1;

    local_port = -1;

    p = strchr(uri, '?');

    if (p) {

        if (find_info_tag(buf, sizeof(buf), ""ttl"", p)) {

            ttl = strtol(buf, NULL, 10);

        }

        if (find_info_tag(buf, sizeof(buf), ""localport"", p)) {

            local_port = strtol(buf, NULL, 10);

        }

    }



    build_udp_url(buf, sizeof(buf),

                  hostname, port, local_port, ttl);

    if (url_open(&s->rtp_hd, buf, flags) < 0)

        goto fail;

    local_port = udp_get_local_port(s->rtp_hd);

    /* XXX: need to open another connection if the port is not even */



    /* well, should suppress localport in path */



    build_udp_url(buf, sizeof(buf),

                  hostname, port + 1, local_port + 1, ttl);

    if (url_open(&s->rtcp_hd, buf, flags) < 0)

        goto fail;



    /* just to ease handle access. XXX: need to suppress direct handle

       access */

    s->rtp_fd = udp_get_file_handle(s->rtp_hd);

    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);



    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);

    h->is_streamed = 1;

    return 0;



 fail:

    if (s->rtp_hd)

        url_close(s->rtp_hd);

    if (s->rtcp_hd)

        url_close(s->rtcp_hd);

    av_free(s);

    return AVERROR(EIO);

}
",0
Detect whether the following code contains vulnerabilities.,"QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)

{

    JSONParserContext ctxt = {};

    QList *working = qlist_copy(tokens);

    QObject *result;



    result = parse_value(&ctxt, &working, ap);



    QDECREF(working);



    error_propagate(errp, ctxt.err);



    return result;

}
",1
Detect whether the following code contains vulnerabilities.,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    switch (buf[0]) {

    /* stream commands */

    case ERASE_12:

    case ERASE_16:

        cmd->xfer = 0;

        break;

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case WRITE_6:

        cmd->len = 6;

        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case READ_16:

    case READ_REVERSE_16:

    case VERIFY_16:

    case WRITE_16:

        cmd->len = 16;

        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case REWIND:

    case LOAD_UNLOAD:

        cmd->len = 6;

        cmd->xfer = 0;

        break;

    case SPACE_16:

        cmd->xfer = buf[13] | (buf[12] << 8);

        break;

    case READ_POSITION:

        cmd->xfer = buf[8] | (buf[7] << 8);

        break;

    case FORMAT_UNIT:

        cmd->xfer = buf[4] | (buf[3] << 8);

        break;

    /* generic commands */

    default:

        return scsi_req_length(cmd, dev, buf);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)

{

	int arith_opt, move_opt;



	/* TODO: optimize more condition codes.  */



	/*

	 * If the flags are live, we've gotta look into the bits of CCS.

	 * Otherwise, if we just did an arithmetic operation we try to

	 * evaluate the condition code faster.

	 *

	 * When this function is done, T0 should be non-zero if the condition

	 * code is true.

	 */

	arith_opt = arith_cc(dc) && !dc->flags_uptodate;

	move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;

	switch (cond) {

		case CC_EQ:

			if (arith_opt || move_opt) {

				/* If cc_result is zero, T0 should be 

				   non-zero otherwise T0 should be zero.  */

				int l1;

				l1 = gen_new_label();

				tcg_gen_movi_tl(cc, 0);

				tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 

						   0, l1);

				tcg_gen_movi_tl(cc, 1);

				gen_set_label(l1);

			}

			else {

				cris_evaluate_flags(dc);

				tcg_gen_andi_tl(cc, 

						cpu_PR[PR_CCS], Z_FLAG);

			}

			break;

		case CC_NE:

			if (arith_opt || move_opt)

				tcg_gen_mov_tl(cc, cc_result);

			else {

				cris_evaluate_flags(dc);

				tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

						Z_FLAG);

				tcg_gen_andi_tl(cc, cc, Z_FLAG);

			}

			break;

		case CC_CS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);

			break;

		case CC_CC:

			cris_evaluate_flags(dc);

			tcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);

			tcg_gen_andi_tl(cc, cc, C_FLAG);

			break;

		case CC_VS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);

			break;

		case CC_VC:

			cris_evaluate_flags(dc);

			tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

					V_FLAG);

			tcg_gen_andi_tl(cc, cc, V_FLAG);

			break;

		case CC_PL:

			if (arith_opt || move_opt) {

				int bits = 31;



				if (dc->cc_size == 1)

					bits = 7;

				else if (dc->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(cc, cc_result, bits);

				tcg_gen_xori_tl(cc, cc, 1);

			} else {

				cris_evaluate_flags(dc);

				tcg_gen_xori_tl(cc, cpu_PR[PR_CCS],

						N_FLAG);

				tcg_gen_andi_tl(cc, cc, N_FLAG);

			}

			break;

		case CC_MI:

			if (arith_opt || move_opt) {

				int bits = 31;



				if (dc->cc_size == 1)

					bits = 7;

				else if (dc->cc_size == 2)

					bits = 15;	



				tcg_gen_shri_tl(cc, cc_result, 31);

			}

			else {

				cris_evaluate_flags(dc);

				tcg_gen_andi_tl(cc, cpu_PR[PR_CCS],

						N_FLAG);

			}

			break;

		case CC_LS:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS],

					C_FLAG | Z_FLAG);

			break;

		case CC_HI:

			cris_evaluate_flags(dc);

			{

				TCGv tmp;



				tmp = tcg_temp_new(TCG_TYPE_TL);

				tcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],

						C_FLAG | Z_FLAG);

				/* Overlay the C flag on top of the Z.  */

				tcg_gen_shli_tl(cc, tmp, 2);

				tcg_gen_and_tl(cc, tmp, cc);

				tcg_gen_andi_tl(cc, cc, Z_FLAG);



				tcg_temp_free(tmp);

			}

			break;

		case CC_GE:

			cris_evaluate_flags(dc);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(cc,

				       cpu_PR[PR_CCS], cc);

			tcg_gen_andi_tl(cc, cc, N_FLAG);

			tcg_gen_xori_tl(cc, cc, N_FLAG);

			break;

		case CC_LT:

			cris_evaluate_flags(dc);

			/* Overlay the V flag on top of the N.  */

			tcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);

			tcg_gen_xor_tl(cc,

				       cpu_PR[PR_CCS], cc);

			tcg_gen_andi_tl(cc, cc, N_FLAG);

			break;

		case CC_GT:

			cris_evaluate_flags(dc);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);

				/* invert Z.  */

				tcg_gen_xori_tl(z, z, 2);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_xori_tl(n, n, 2);

				tcg_gen_and_tl(cc, z, n);

				tcg_gen_andi_tl(cc, cc, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_LE:

			cris_evaluate_flags(dc);

			{

				TCGv n, z;



				n = tcg_temp_new(TCG_TYPE_TL);

				z = tcg_temp_new(TCG_TYPE_TL);



				/* To avoid a shift we overlay everything on

				   the V flag.  */

				tcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);

				tcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);



				tcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);

				tcg_gen_or_tl(cc, z, n);

				tcg_gen_andi_tl(cc, cc, 2);



				tcg_temp_free(n);

				tcg_temp_free(z);

			}

			break;

		case CC_P:

			cris_evaluate_flags(dc);

			tcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);

			break;

		case CC_A:

			tcg_gen_movi_tl(cc, 1);

			break;

		default:

			BUG();

			break;

	};

}
",0
Detect whether the following code contains vulnerabilities.,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)

{

#if HAVE_7REGS && HAVE_TEN_OPERANDS

    c->mlp_filter_channel = mlp_filter_channel_x86;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    enc->height = avctx->height;
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTempdata));
    enc->this_motion4 =
        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));
    enc->last_motion4 =
        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));
    enc->this_motion8 =
        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));
    enc->last_motion8 =
        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));
    return 0;",1
Detect whether the following code contains vulnerabilities.,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)

{

    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);

    void *dst;

    if (o_out)

        *o_out= o;

    if (!o || o->offset<=0)

        return AVERROR_OPTION_NOT_FOUND;



    if (o->max*den < num*intnum || o->min*den > num*intnum) {

        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);

        return AVERROR(ERANGE);

    }



    dst= ((uint8_t*)obj) + o->offset;



    switch (o->type) {

    case FF_OPT_TYPE_FLAGS:

    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_RATIONAL:

        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};

        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);

        break;

    default:

        return AVERROR(EINVAL);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
",0
Detect whether the following code contains vulnerabilities.,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)

{

    const QDictEntry *ent;

    const char *arg_name;

    const QObject *arg_obj;

    bool has_exec_key = false;

    QDict *dict = NULL;



    if (qobject_type(request) != QTYPE_QDICT) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,

                   ""request is not a dictionary"");

        return NULL;

    }



    dict = qobject_to_qdict(request);



    for (ent = qdict_first(dict); ent;

         ent = qdict_next(dict, ent)) {

        arg_name = qdict_entry_key(ent);

        arg_obj = qdict_entry_value(ent);



        if (!strcmp(arg_name, ""execute"")) {

            if (qobject_type(arg_obj) != QTYPE_QSTRING) {

                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",

                           ""string"");

                return NULL;

            }

            has_exec_key = true;

        } else if (strcmp(arg_name, ""arguments"")) {

            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);

            return NULL;

        }

    }



    if (!has_exec_key) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");

        return NULL;

    }



    return dict;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void acpi_build_update(void *build_opaque, uint32_t offset)

{

    AcpiBuildState *build_state = build_opaque;

    AcpiBuildTables tables;



    /* No state to update or already patched? Nothing to do. */

    if (!build_state || build_state->patched) {

        return;

    }

    build_state->patched = 1;



    acpi_build_tables_init(&tables);



    acpi_build(build_state->guest_info, &tables);



    assert(acpi_data_len(tables.table_data) == build_state->table_size);

    memcpy(build_state->table_ram, tables.table_data->data,

           build_state->table_size);



    acpi_build_tables_cleanup(&tables, true);

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int amr_nb_encode_init(AVCodecContext *avctx)

{

    AMRContext *s = avctx->priv_data;



    if (avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 8000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    avctx->frame_size  = 160;

    avctx->coded_frame = avcodec_alloc_frame();





    s->enc_state = Encoder_Interface_init(s->enc_dtx);

    if (!s->enc_state) {

        av_log(avctx, AV_LOG_ERROR, ""Encoder_Interface_init error\n"");


        return -1;

    }



    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

    s->enc_bitrate = avctx->bit_rate;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    exit(1);

}
",1
Detect whether the following code contains vulnerabilities.,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
",1
Detect whether the following code contains vulnerabilities.,"static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)

{

    int i;

    int ret = av_frame_ref(dst, src);

    if (ret < 0)

        return ret;



    if (!h->sps.crop)

        return 0;



    for (i = 0; i < 3; i++) {

        int hshift = (i > 0) ? h->chroma_x_shift : 0;

        int vshift = (i > 0) ? h->chroma_y_shift : 0;

        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +

            (h->sps.crop_top  >> vshift) * dst->linesize[i];

        dst->data[i] += off;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void bdrv_remove_aio_context_notifier(BlockDriverState *bs,

                                      void (*attached_aio_context)(AioContext *,

                                                                   void *),

                                      void (*detach_aio_context)(void *),

                                      void *opaque)

{

    BdrvAioNotifier *ban, *ban_next;



    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {

        if (ban->attached_aio_context == attached_aio_context &&

            ban->detach_aio_context   == detach_aio_context   &&

            ban->opaque               == opaque)

        {

            QLIST_REMOVE(ban, list);

            g_free(ban);



            return;

        }

    }



    abort();

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t status;

    uint8_t *buf;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    buf = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpbuf, 0x55, len);



    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpbuf, 0xaa, len);



    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);





    g_free(buf);

    g_free(cmpbuf);

}
",1
Detect whether the following code contains vulnerabilities.,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_system_reset(void)

{

    QEMUResetEntry *re, *nre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {

        re->func(re->opaque);

    }


}",1
Detect whether the following code contains vulnerabilities.,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void phys_page_set(AddressSpaceDispatch *d,

                          target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static int flv_write_trailer(AVFormatContext *s)

{

    int64_t file_size;



    AVIOContext *pb = s->pb;

    FLVContext *flv = s->priv_data;

    int i;



    /* Add EOS tag */

    for (i = 0; i < s->nb_streams; i++) {

        AVCodecContext *enc = s->streams[i]->codec;

        FLVStreamContext *sc = s->streams[i]->priv_data;

        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&

            enc->codec_id == AV_CODEC_ID_H264)

            put_avc_eos_tag(pb, sc->last_ts);

    }



    file_size = avio_tell(pb);



    /* update information */

    avio_seek(pb, flv->duration_offset, SEEK_SET);

    put_amf_double(pb, flv->duration / (double)1000);

    avio_seek(pb, flv->filesize_offset, SEEK_SET);

    put_amf_double(pb, file_size);



    avio_seek(pb, file_size, SEEK_SET);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,

                                     const void *match_data, hwaddr *load_addr)

{

    BostonState *s = BOSTON(opaque);

    MachineState *machine = s->mach;

    const char *cmdline;

    int err;

    void *fdt;

    size_t fdt_sz, ram_low_sz, ram_high_sz;



    fdt_sz = fdt_totalsize(fdt_orig) * 2;

    fdt = g_malloc0(fdt_sz);



    err = fdt_open_into(fdt_orig, fdt, fdt_sz);

    if (err) {

        fprintf(stderr, ""unable to open FDT\n"");

        return NULL;

    }



    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])

            ? machine->kernel_cmdline : "" "";

    err = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", cmdline);

    if (err < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs\n"");

        return NULL;

    }



    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);

    ram_high_sz = machine->ram_size - ram_low_sz;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",

                                 1, 0x00000000, 1, ram_low_sz,

                                 1, 0x90000000, 1, ram_high_sz);



    fdt = g_realloc(fdt, fdt_totalsize(fdt));

    qemu_fdt_dumpdtb(fdt, fdt_sz);



    s->fdt_base = *load_addr;



    return fdt;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

#if CONFIG_ZLIB

    AVIOContext ctx;

    uint8_t *cmov_data;

    uint8_t *moov_data; /* uncompressed data */

    long cmov_len, moov_len;

    int ret = -1;



    avio_rb32(pb); /* dcom atom */

    if (avio_rl32(pb) != MKTAG('d','c','o','m'))

        return AVERROR_INVALIDDATA;

    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {

        av_log(c->fc, AV_LOG_ERROR, ""unknown compression for cmov atom !"");

        return AVERROR_INVALIDDATA;

    }

    avio_rb32(pb); /* cmvd atom */

    if (avio_rl32(pb) != MKTAG('c','m','v','d'))

        return AVERROR_INVALIDDATA;

    moov_len = avio_rb32(pb); /* uncompressed size */

    cmov_len = atom.size - 6 * 4;



    cmov_data = av_malloc(cmov_len);

    if (!cmov_data)

        return AVERROR(ENOMEM);

    moov_data = av_malloc(moov_len);

    if (!moov_data) {

        av_free(cmov_data);

        return AVERROR(ENOMEM);

    }

    avio_read(pb, cmov_data, cmov_len);

    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)

        goto free_and_return;

    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)

        goto free_and_return;

    atom.type = MKTAG('m','o','o','v');

    atom.size = moov_len;

    ret = mov_read_default(c, &ctx, atom);

free_and_return:

    av_free(moov_data);

    av_free(cmov_data);

    return ret;

#else

    av_log(c->fc, AV_LOG_ERROR, ""this file requires zlib support compiled in\n"");

    return AVERROR(ENOSYS);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int read_ffserver_streams(AVFormatContext *s, const char *filename)

{

    int i, err;

    AVFormatContext *ic;

    int nopts = 0;



    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);

    if (err < 0)

        return err;

    /* copy stream format */

    s->nb_streams = ic->nb_streams;

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st;

        AVCodec *codec;



        // FIXME: a more elegant solution is needed

        st = av_mallocz(sizeof(AVStream));

        memcpy(st, ic->streams[i], sizeof(AVStream));

        st->codec = avcodec_alloc_context();

        if (!st->codec) {

            print_error(filename, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(st->codec, ic->streams[i]->codec);

        s->streams[i] = st;



        codec = avcodec_find_encoder(st->codec->codec_id);

        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_sample_fmt(st, codec);

        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

            if (video_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_pixel_fmt(st, codec);

        }



        if(!st->codec->thread_count)

            st->codec->thread_count = 1;

        if(st->codec->thread_count>1)

            avcodec_thread_init(st->codec, st->codec->thread_count);



        if(st->codec->flags & CODEC_FLAG_BITEXACT)

            nopts = 1;

    }



    if (!nopts)

        s->timestamp = av_gettime();



    av_close_input_file(ic);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}",1
Detect whether the following code contains vulnerabilities.,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_max_ns);



        if (max_ns) {

            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    return false;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",0
Detect whether the following code contains vulnerabilities.,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int status;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate\n"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s\n"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.\n"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.\n"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.\n"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm\n"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!\n"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))

	return -1;



    for (i = 0 ; i < nCerts ; i++) {

	gnutls_x509_crt_t cert;

	VNC_DEBUG (""Checking certificate chain %d\n"", i);

	if (gnutls_x509_crt_init (&cert) < 0)

	    return -1;



	if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (cert) < now) {

	    VNC_DEBUG(""The certificate has expired\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	gnutls_x509_crt_deinit (cert);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,

                        void *callback_opaque, uint8_t *data, size_t len)

{

    FWCfgState *s = opaque;

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    key &= FW_CFG_ENTRY_MASK;



    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)

        || len > 65535)

        return 0;



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int calculate_bitrate(AVFormatContext *s)

{

    AVIContext *avi = s->priv_data;

    int i, j;

    int64_t lensum = 0;

    int64_t maxpos = 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];



        if (!st->nb_index_entries)

            continue;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;

        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);

        lensum += len;

    }

    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file

        return 0;

    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch

        return 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];

        int64_t duration;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;



        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)

            continue;

        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;

        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);

    }

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
",1
Detect whether the following code contains vulnerabilities.,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",1
Detect whether the following code contains vulnerabilities.,"static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,

                                                 Error **errp)

{

    struct addrinfo ai, *res;

    int rc;

    Error *err = NULL;



    memset(&ai, 0, sizeof(ai));



    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return NULL;

    }



    if (saddr->host == NULL || saddr->port == NULL) {

        error_setg(errp, ""host and/or port not specified"");

        return NULL;

    }



    /* lookup */

    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);

    if (rc != 0) {

        error_setg(errp, ""address resolution failed for %s:%s: %s"",

                   saddr->host, saddr->port, gai_strerror(rc));

        return NULL;

    }

    return res;

}
",1
Detect whether the following code contains vulnerabilities.,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,

                  uint64_t low, uint64_t high)

{

    uintptr_t ra = GETPC();



    if (parallel_cpus) {

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);

#else

        int mem_idx = cpu_mmu_index(env, false);

        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(low, high);

        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);

#endif

    } else {

        check_alignment(env, addr, 16, ra);



        cpu_stq_data_ra(env, addr + 0, high, ra);

        cpu_stq_data_ra(env, addr + 8, low, ra);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)

{

#ifdef HAVE_MMX

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%3, %%""REG_a"")	\n\t""

		""movd %%mm1, (%2, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= src1[4*i + 1];

		dstV[i]= src1[4*i + 3];

	}

#endif

        assert(src1 == src2);

}
",1
Detect whether the following code contains vulnerabilities.,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",1
Detect whether the following code contains vulnerabilities.,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
",1
Detect whether the following code contains vulnerabilities.,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
",1
Detect whether the following code contains vulnerabilities.,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",1
Detect whether the following code contains vulnerabilities.,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
",0
Detect whether the following code contains vulnerabilities.,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",1
Detect whether the following code contains vulnerabilities.,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#elif defined(TARGET_S390X)

    CPUState *cs;

    S390CPU *cpu;



    CPU_FOREACH(cs) {

        cpu = S390_CPU(cs);

        if (cpu->env.cpu_num == monitor_get_cpu_index()) {

            if (s390_cpu_restart(S390_CPU(cs)) == -1) {

                error_set(errp, QERR_UNSUPPORTED);

                return;

            }

            break;

        }

    }

#else

    error_set(errp, QERR_UNSUPPORTED);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
",1
Detect whether the following code contains vulnerabilities.,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);



    if (con->chr) {

        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(con->chr);

    }

    xen_be_unbind_evtchn(&con->xendev);



    if (con->sring) {

        if (!xendev->dev) {

            munmap(con->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);

        }

        con->sring = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
",1
Detect whether the following code contains vulnerabilities.,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};",1
Detect whether the following code contains vulnerabilities.,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,

                                   ImageInfoSpecific *info_spec)

{

    QObject *obj, *data;

    Visitor *v = qmp_output_visitor_new(&obj);



    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);

    visit_complete(v, &obj);

    assert(qobject_type(obj) == QTYPE_QDICT);

    data = qdict_get(qobject_to_qdict(obj), ""data"");

    dump_qobject(func_fprintf, f, 1, data);


    visit_free(v);

}",1
Detect whether the following code contains vulnerabilities.,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
",0
Detect whether the following code contains vulnerabilities.,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
",1
Detect whether the following code contains vulnerabilities.,"static void keyword_literal(void)

{

    QObject *obj;

    QBool *qbool;

    QObject *null;

    QString *str;



    obj = qobject_from_json(""true"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == true);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""true"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    obj = qobject_from_json(""false"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""false"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", false));

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);

    QDECREF(qbool);



    /* Test that non-zero values other than 1 get collapsed to true */

    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", 2));

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == true);

    QDECREF(qbool);



    obj = qobject_from_json(""null"", NULL);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QNULL);



    null = qnull();

    g_assert(null == obj);



    qobject_decref(obj);

    qobject_decref(null);

}
",1
Detect whether the following code contains vulnerabilities.,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
",0
Detect whether the following code contains vulnerabilities.,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    uint32_t r = 0;



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int alac_set_info(ALACContext *alac)

{

    GetByteContext gb;



    bytestream2_init(&gb, alac->avctx->extradata,

                     alac->avctx->extradata_size);



    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4



    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);

    if (alac->max_samples_per_frame >= UINT_MAX/4){

        av_log(alac->avctx, AV_LOG_ERROR,

               ""max_samples_per_frame too large\n"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gb, 1);  // compatible version

    alac->sample_size          = bytestream2_get_byteu(&gb);

    alac->rice_history_mult    = bytestream2_get_byteu(&gb);

    alac->rice_initial_history = bytestream2_get_byteu(&gb);

    alac->rice_limit           = bytestream2_get_byteu(&gb);

    alac->channels             = bytestream2_get_byteu(&gb);

    bytestream2_get_be16u(&gb); // maxRun

    bytestream2_get_be32u(&gb); // max coded frame size

    bytestream2_get_be32u(&gb); // average bitrate

    bytestream2_get_be32u(&gb); // samplerate



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
",0
Detect whether the following code contains vulnerabilities.,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
",0
Detect whether the following code contains vulnerabilities.,"static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,

                                               VirtQueue *vq,

                                               EventNotifierHandler *handler,

                                               int n)

{

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);

    int rc;



    /* Set up virtqueue notify */

    rc = k->set_host_notifier(qbus->parent, n, true);

    if (rc != 0) {

        fprintf(stderr, ""virtio-scsi: Failed to set host notifier (%d)\n"",

                rc);

        exit(1);

    }

    r->host_notifier = *virtio_queue_get_host_notifier(vq);

    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);

    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);



    r->parent = s;



    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {

        fprintf(stderr, ""virtio-scsi: VRing setup failed\n"");

        exit(1);

    }

    return r;

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)

{

    NetPacket *packet, *next;



    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {

        if (packet->sender == from) {

            QTAILQ_REMOVE(&queue->packets, packet, entry);


            g_free(packet);

        }

    }

}",1
Detect whether the following code contains vulnerabilities.,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int slice_end(AVCodecContext *avctx, AVFrame *pict)

{

    Mpeg1Context *s1  = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;



    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)

        return 0;



    if (s->avctx->hwaccel) {

        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)

            av_log(avctx, AV_LOG_ERROR,

                   ""hardware accelerator failed to decode picture\n"");

    }



#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)

        ff_xvmc_field_end(s);

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    /* end of slice reached */

    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {

        /* end of image */



        ff_er_frame_end(&s->er);



        ff_MPV_frame_end(s);



        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);

            if (ret < 0)

                return ret;

            ff_print_debug_info(s, s->current_picture_ptr);

        } else {

            if (avctx->active_thread_type & FF_THREAD_FRAME)

                s->picture_number++;

            /* latency of 1 frame for I- and P-frames */

            /* XXX: use another variable than picture_number */

            if (s->last_picture_ptr != NULL) {

                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);

                if (ret < 0)

                    return ret;

                ff_print_debug_info(s, s->last_picture_ptr);

            }

        }



        return 1;

    } else {

        return 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",0
Detect whether the following code contains vulnerabilities.,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",1
Detect whether the following code contains vulnerabilities.,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,

    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)

{

    size_t fetched = 0;

    struct iovec *src = pkt->vec;



    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;



    while (fetched < pkt->virt_hdr.gso_size) {



        /* no more place in fragment iov */

        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {

            break;

        }



        /* no more data in iovec */

        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {

            break;

        }





        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;

        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,

            pkt->virt_hdr.gso_size - fetched);



        *src_offset += dst[*dst_idx].iov_len;

        fetched += dst[*dst_idx].iov_len;



        if (*src_offset == src[*src_idx].iov_len) {

            *src_offset = 0;

            (*src_idx)++;

        }



        (*dst_idx)++;

    }



    return fetched;

}
",0
Detect whether the following code contains vulnerabilities.,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,

                          uint64_t val, unsigned size)

{

    LSIState *s = opaque;

    uint32_t newval;

    uint32_t mask;

    int shift;



    newval = s->script_ram[addr >> 2];

    shift = (addr & 3) * 8;

    mask = ((uint64_t)1 << (size * 8)) - 1;

    newval &= ~(mask << shift);

    newval |= val << shift;

    s->script_ram[addr >> 2] = newval;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)

{

    char *argstr_flat;

    wchar_t **argv_w;

    int i, buffsize = 0, offset = 0;



    if (win32_argv_utf8) {

        *argc_ptr = win32_argc;

        *argv_ptr = win32_argv_utf8;

        return;

    }



    win32_argc = 0;

    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);

    if (win32_argc <= 0 || !argv_w)

        return;



    /* determine the UTF-8 buffer size (including NULL-termination symbols) */

    for (i = 0; i < win32_argc; i++)

        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,

                                        NULL, 0, NULL, NULL);



    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);

    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);

    if (win32_argv_utf8 == NULL) {

        LocalFree(argv_w);

        return;

    }



    for (i = 0; i < win32_argc; i++) {

        win32_argv_utf8[i] = &argstr_flat[offset];

        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,

                                      &argstr_flat[offset],

                                      buffsize - offset, NULL, NULL);

    }

    win32_argv_utf8[i] = NULL;

    LocalFree(argv_w);



    *argc_ptr = win32_argc;

    *argv_ptr = win32_argv_utf8;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int res;



    if (!s->chr_sync_read) {

        return 0;

    }

    

    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            res = s->chr_sync_read(s, buf + offset, len - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!counter--) {

            break;

        }

    }



    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_b_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status;



    bitplane_decoding(&v->skip_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    if (v->mv_mode == MV_PMODE_MIXED_MV)

    {

        status = bitplane_decoding(&v->mv_type_mb_plane, v);

        if (status < 0)

            return -1;

#if TRACE

        av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: ""

               ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif

    }



    //bitplane

    status = bitplane_decoding(&v->direct_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    av_log(v->s.avctx, AV_LOG_DEBUG, ""Skip MB plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    /* FIXME: what is actually chosen for B frames ? */

    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables

    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];



    if (v->dquant)

    {

        vop_dquant_decoding(v);

    }



    if (v->vstransform)

    {

        v->ttmbf = get_bits(gb, 1);

        if (v->ttmbf)

        {

            v->ttfrm = get_bits(gb, 2);

            av_log(v->s.avctx, AV_LOG_INFO, ""Transform used: %ix%i\n"",

                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);

        }

    }

    /* Epilog (AC/DC syntax) should be done in caller */

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)

{

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""movq (%2, %%""REG_a"",4), %%mm2	\n\t""

		""movq 8(%2, %%""REG_a"",4), %%mm3	\n\t""

		PAVGB(%%mm2, %%mm0)

		PAVGB(%%mm3, %%mm1)

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%4, %%""REG_a"")	\n\t""

		""movd %%mm1, (%3, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" ((long)-width), ""r"" (src1+width*4), ""r"" (src2+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;

		dstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;

	}

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,

                               struct qht_bucket *head, void *p, uint32_t hash,

                               bool *needs_resize)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == p)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {

        *needs_resize = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head->sequence);

    if (new) {

        atomic_rcu_set(&prev->next, b);

    }

    b->hashes[i] = hash;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[i], p);

    seqlock_write_end(&head->sequence);

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,

			     int mmu_idx, int is_softmmu)

{

    target_ulong physical;

    int prot, ret, access_type;



    access_type = ACCESS_INT;

    ret =

	get_physical_address(env, &physical, &prot, address, rw,

			     access_type);



    if (ret != MMU_OK) {

	env->tea = address;

	switch (ret) {

	case MMU_ITLB_MISS:

	case MMU_DTLB_MISS_READ:

	    env->exception_index = 0x040;

	    break;

	case MMU_DTLB_MULTIPLE:

	case MMU_ITLB_MULTIPLE:

	    env->exception_index = 0x140;

	    break;

	case MMU_ITLB_VIOLATION:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_MISS_WRITE:

	    env->exception_index = 0x060;

	    break;

	case MMU_DTLB_INITIAL_WRITE:

	    env->exception_index = 0x080;

	    break;

	case MMU_DTLB_VIOLATION_READ:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_VIOLATION_WRITE:

	    env->exception_index = 0x0c0;

	    break;

	case MMU_IADDR_ERROR:

	case MMU_DADDR_ERROR_READ:

	    env->exception_index = 0x0c0;

	    break;

	case MMU_DADDR_ERROR_WRITE:

	    env->exception_index = 0x100;

	    break;

	default:

	    assert(0);

	}

	return 1;

    }



    address &= TARGET_PAGE_MASK;

    physical &= TARGET_PAGE_MASK;



    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",1
Detect whether the following code contains vulnerabilities.,"static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)

{

    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);

    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);

    int ret;



    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {

        DPRINTF(""Unimplemented LUN %d\n"", req->lun);

        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));

        scsi_req_complete(&r->req, CHECK_CONDITION);

        return 0;

    }



    if (-1 == scsi_req_parse(&r->req, cmd)) {

        BADF(""Unsupported command length, command %x\n"", cmd[0]);

        scsi_command_complete(r, -EINVAL);

        return 0;

    }

    scsi_req_fixup(&r->req);



    DPRINTF(""Command: lun=%d tag=0x%x len %zd data=0x%02x"", lun, tag,

            r->req.cmd.xfer, cmd[0]);



#ifdef DEBUG_SCSI

    {

        int i;

        for (i = 1; i < r->req.cmd.len; i++) {

            printf("" 0x%02x"", cmd[i]);

        }

        printf(""\n"");

    }

#endif



    if (r->req.cmd.xfer == 0) {

        if (r->buf != NULL)

            qemu_free(r->buf);

        r->buflen = 0;

        r->buf = NULL;

        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);

        if (ret < 0) {

            scsi_command_complete(r, ret);

            return 0;

        }

        return 0;

    }



    if (r->buflen != r->req.cmd.xfer) {

        if (r->buf != NULL)

            qemu_free(r->buf);

        r->buf = qemu_malloc(r->req.cmd.xfer);

        r->buflen = r->req.cmd.xfer;

    }



    memset(r->buf, 0, r->buflen);

    r->len = r->req.cmd.xfer;

    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {

        r->len = 0;

        return -r->req.cmd.xfer;

    } else {

        return r->req.cmd.xfer;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
",0
Detect whether the following code contains vulnerabilities.,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_ext_interrupt(CPUS390XState *env)

{

    S390CPU *cpu = s390_env_get_cpu(env);

    uint64_t mask, addr;

    LowCore *lowcore;

    ExtQueue *q;



    if (!(env->psw.mask & PSW_MASK_EXT)) {

        cpu_abort(CPU(cpu), ""Ext int w/o ext mask\n"");

    }



    lowcore = cpu_map_lowcore(env);



    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;

    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;

    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {

        g_assert(env->ext_index >= 0);

        /*

         * FIXME: floating IRQs should be considered by all CPUs and

         *        shuld not get cleared by CPU reset.

         */

        q = &env->ext_queue[env->ext_index];

        lowcore->ext_int_code = cpu_to_be16(q->code);

        lowcore->ext_params = cpu_to_be32(q->param);

        lowcore->ext_params2 = cpu_to_be64(q->param64);

        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);

        env->ext_index--;

        if (env->ext_index == -1) {

            env->pending_int &= ~INTERRUPT_EXT_SERVICE;

        }

    } else {

        g_assert_not_reached();

    }



    mask = be64_to_cpu(lowcore->external_new_psw.mask);

    addr = be64_to_cpu(lowcore->external_new_psw.addr);

    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));

    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);



    cpu_unmap_lowcore(lowcore);



    DPRINTF(""%s: %"" PRIx64 "" %"" PRIx64 ""\n"", __func__,

            env->psw.mask, env->psw.addr);



    load_psw(env, mask, addr);

}
",0
Detect whether the following code contains vulnerabilities.,"static void verdex_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t verdex_rom = 0x02000000;

    uint32_t verdex_ram = 0x10000000;



    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, verdex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 99 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(cpu->gpio, 99));

}
",0
Detect whether the following code contains vulnerabilities.,"static int bochs_open(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp)
{
    BDRVBochsState *s = bs->opaque;
    uint32_t i;
    struct bochs_header bochs;
    int ret;
    bs->read_only = 1; // no write support yet
    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));
    if (ret < 0) {
        return ret;
    if (strcmp(bochs.magic, HEADER_MAGIC) ||
        strcmp(bochs.type, REDOLOG_TYPE) ||
        strcmp(bochs.subtype, GROWING_TYPE) ||
	((le32_to_cpu(bochs.version) != HEADER_VERSION) &&
	(le32_to_cpu(bochs.version) != HEADER_V1))) {
        error_setg(errp, ""Image not in Bochs format"");
        return -EINVAL;
    if (le32_to_cpu(bochs.version) == HEADER_V1) {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;
    } else {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;
    s->catalog_size = le32_to_cpu(bochs.catalog);
    s->catalog_bitmap = g_malloc(s->catalog_size * 4);
    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,
                     s->catalog_size * 4);
    if (ret < 0) {
        goto fail;
    for (i = 0; i < s->catalog_size; i++)
	le32_to_cpus(&s->catalog_bitmap[i]);
    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);
    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;
    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;
    s->extent_size = le32_to_cpu(bochs.extent);
    if (s->catalog_size < bs->total_sectors / s->extent_size) {
        error_setg(errp, ""Catalog size is too small for this disk size"");
        ret = -EINVAL;
        goto fail;
    qemu_co_mutex_init(&s->lock);
    return 0;
fail:
    g_free(s->catalog_bitmap);
    return ret;",1
Detect whether the following code contains vulnerabilities.,"offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)

{

    offset_t offset1;

    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));



    if (whence != SEEK_CUR && whence != SEEK_SET)

        return -EINVAL;



    if (whence == SEEK_CUR) {

        offset1 = pos + (s->buf_ptr - s->buffer);

        if (offset == 0)

            return offset1;

        offset += offset1;

    }

    offset1 = offset - pos;

    if (!s->must_flush &&

        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {

        /* can do the seek inside the buffer */

        s->buf_ptr = s->buffer + offset1;

    } else {

        if (!s->seek)

            return -EPIPE;



#ifdef CONFIG_MUXERS

        if (s->write_flag) {

            flush_buffer(s);

            s->must_flush = 1;

        } else

#endif //CONFIG_MUXERS

        {

            s->buf_end = s->buffer;

        }

        s->buf_ptr = s->buffer;

        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)

            return -EPIPE;

        s->pos = offset;

    }

    s->eof_reached = 0;

    return offset;

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",0
Detect whether the following code contains vulnerabilities.,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(area + pagesize * i, 0, 1);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void hotplug(void)

{

    qtest_start(""-device virtio-net-pci"");



    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);

    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);



    test_end();

}
",0
Detect whether the following code contains vulnerabilities.,"static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)

{

    __asm__ volatile(

        ""movdqa   0x10(%1), %%xmm1 \n""

        ""movdqa   0x20(%1), %%xmm2 \n""

        ""movdqa   0x30(%1), %%xmm3 \n""

        ""movdqa   0x50(%1), %%xmm5 \n""

        ""movdqa   0x60(%1), %%xmm6 \n""

        ""movdqa   0x70(%1), %%xmm7 \n""

        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)

        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))

        ""paddw          %4, %%xmm4 \n""

        ""movdqa     %%xmm4, 0x00(%1) \n""

        ""movdqa     %%xmm2, 0x40(%1) \n""

        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)

        ""movdqa     %%xmm6, 0x60(%1) \n""

        ""movdqa     %%xmm7, 0x70(%1) \n""

        ""pxor       %%xmm7, %%xmm7 \n""

        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)

        ""lea     (%0,%2,4), %0 \n""

        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)

        ""movdqa   0x60(%1), %%xmm0 \n""

        ""movdqa   0x70(%1), %%xmm1 \n""

        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)

        :""+r""(dst)

        :""r""(block), ""r""((x86_reg)stride), ""r""((x86_reg)3L*stride), ""m""(ff_pw_32)

    );

}
",0
Detect whether the following code contains vulnerabilities.,"static void ide_identify(IDEState *s)

{

    uint16_t *p;

    unsigned int oldsize;



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    stw(p + 0, 0x0040);

    stw(p + 1, s->cylinders); 

    stw(p + 3, s->heads);

    stw(p + 4, 512 * s->sectors); /* sectors */

    stw(p + 5, 512); /* sector size */

    stw(p + 6, s->sectors); 

    stw(p + 20, 3); /* buffer type */

    stw(p + 21, 512); /* cache size in sectors */

    stw(p + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(p + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(p + 47, MAX_MULT_SECTORS);

#endif

    stw(p + 48, 1); /* dword I/O */

    stw(p + 49, 1 << 9); /* LBA supported, no DMA */

    stw(p + 51, 0x200); /* PIO transfer cycle */

    stw(p + 52, 0x200); /* DMA transfer cycle */

    stw(p + 54, s->cylinders);

    stw(p + 55, s->heads);

    stw(p + 56, s->sectors);

    oldsize = s->cylinders * s->heads * s->sectors;

    stw(p + 57, oldsize);

    stw(p + 58, oldsize >> 16);

    if (s->mult_sectors)

        stw(p + 59, 0x100 | s->mult_sectors);

    stw(p + 60, s->nb_sectors);

    stw(p + 61, s->nb_sectors >> 16);

    stw(p + 80, (1 << 1) | (1 << 2));

    stw(p + 82, (1 << 14));

    stw(p + 83, (1 << 14));

    stw(p + 84, (1 << 14));

    stw(p + 85, (1 << 14));

    stw(p + 86, 0);

    stw(p + 87, (1 << 14));

}
",0
Detect whether the following code contains vulnerabilities.,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = get_bits(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *dst = link->dstpad;

    int i;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);



    if (!(filter_samples = dst->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||

        dst->rej_perms & samplesref->perms) {



        av_log(link->dst, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",

               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,

                                                          samplesref->audio->nb_samples);

        link->cur_buf->pts                = samplesref->pts;

        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;



        /* Copy actual data into new samples buffer */

        for (i = 0; samplesref->data[i]; i++)

            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);



        avfilter_unref_buffer(samplesref);

    } else

        link->cur_buf = samplesref;



    filter_samples(link, link->cur_buf);

}
",0
Detect whether the following code contains vulnerabilities.,"static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,

                                   qemu_irq **irqs)

{

    qemu_irq *mpic;

    DeviceState *dev;

    SysBusDevice *s;

    int i, j, k;



    mpic = g_new(qemu_irq, 256);

    dev = qdev_create(NULL, ""openpic"");

    qdev_prop_set_uint32(dev, ""nb_cpus"", smp_cpus);

    qdev_prop_set_uint32(dev, ""model"", params->mpic_version);

    qdev_init_nofail(dev);

    s = SYS_BUS_DEVICE(dev);



    k = 0;

    for (i = 0; i < smp_cpus; i++) {

        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {

            sysbus_connect_irq(s, k++, irqs[i][j]);

        }

    }



    for (i = 0; i < 256; i++) {

        mpic[i] = qdev_get_gpio_in(dev, i);

    }



    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,

                                s->mmio[0].memory);



    return mpic;

}
",0
Detect whether the following code contains vulnerabilities.,"CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))

{

    const char *p;

    CharDriverState *chr;

    QemuOpts *opts;

    Error *err = NULL;



    if (strstart(filename, ""chardev:"", &p)) {

        return qemu_chr_find(p);

    }



    opts = qemu_chr_parse_compat(label, filename);

    if (!opts)

        return NULL;



    chr = qemu_chr_new_from_opts(opts, init, &err);

    if (err) {

        error_report_err(err);

    }

    if (chr && qemu_opt_get_bool(opts, ""mux"", 0)) {

        qemu_chr_fe_claim_no_fail(chr);

        monitor_init(chr, MONITOR_USE_READLINE);

    }

    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
",0
Detect whether the following code contains vulnerabilities.,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",0
Detect whether the following code contains vulnerabilities.,"Visitor *qobject_input_visitor_new_keyval(QObject *obj)

{

    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);



    v->visitor.type_int64 = qobject_input_type_int64_keyval;

    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;

    v->visitor.type_bool = qobject_input_type_bool_keyval;

    v->visitor.type_str = qobject_input_type_str;

    v->visitor.type_number = qobject_input_type_number_keyval;

    v->visitor.type_any = qobject_input_type_any;

    v->visitor.type_null = qobject_input_type_null;

    v->visitor.type_size = qobject_input_type_size_keyval;



    return &v->visitor;

}
",1
Detect whether the following code contains vulnerabilities.,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,

                                  float **plevel_table, uint16_t **pint_table,

                                  const CoefVLCTable *vlc_table)

{

    int n                        = vlc_table->n;

    const uint8_t  *table_bits   = vlc_table->huffbits;

    const uint32_t *table_codes  = vlc_table->huffcodes;

    const uint16_t *levels_table = vlc_table->levels;

    uint16_t *run_table, *level_table, *int_table;

    float *flevel_table;

    int i, l, j, k, level;



    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);



    run_table    = av_malloc(n * sizeof(uint16_t));

    level_table  = av_malloc(n * sizeof(uint16_t));

    flevel_table = av_malloc(n * sizeof(*flevel_table));

    int_table    = av_malloc(n * sizeof(uint16_t));

    i            = 2;

    level        = 1;

    k            = 0;

    while (i < n) {

        int_table[k] = i;

        l            = levels_table[k++];

        for (j = 0; j < l; j++) {

            run_table[i]    = j;

            level_table[i]  = level;

            flevel_table[i] = level;

            i++;

        }

        level++;

    }

    *prun_table   = run_table;

    *plevel_table = flevel_table;

    *pint_table   = int_table;

    av_free(level_table);

}
",0
Detect whether the following code contains vulnerabilities.,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",0
Detect whether the following code contains vulnerabilities.,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
",1
Detect whether the following code contains vulnerabilities.,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)

{

    AVStream *st;

    OutputStream *ost;

    AVCodecContext *audio_enc;



    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);

    st  = ost->st;



    audio_enc = st->codec;

    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;



    if (!ost->stream_copy) {

        char *sample_fmt = NULL;



        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);



        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);

        if (sample_fmt &&

            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt);

            exit_program(1);

        }



        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);

    }



    return ost;

}
",1
Detect whether the following code contains vulnerabilities.,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
",0
Detect whether the following code contains vulnerabilities.,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
",1
Detect whether the following code contains vulnerabilities.,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",0
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn is_allocated_base(BlockDriverState *top,

                                          BlockDriverState *base,

                                          int64_t sector_num,

                                          int nb_sectors, int *pnum)

{

    BlockDriverState *intermediate;

    int ret, n;



    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);

    if (ret) {

        *pnum = n;

        return ret;

    }



    /*

     * Is the unallocated chunk [sector_num, n] also

     * unallocated between base and top?

     */

    intermediate = top->backing_hd;



    while (intermediate != base) {

        int pnum_inter;



        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,

                                   &pnum_inter);

        if (ret < 0) {

            return ret;

        } else if (ret) {

            *pnum = pnum_inter;

            return 0;

        }



        /*

         * [sector_num, nb_sectors] is unallocated on top but intermediate

         * might have

         *

         * [sector_num+x, nr_sectors] allocated.

         */

        if (n > pnum_inter) {

            n = pnum_inter;

        }



        intermediate = intermediate->backing_hd;

    }



    *pnum = n;

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",0
Detect whether the following code contains vulnerabilities.,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);

    cmd->frame = NULL;

    cmd->pa = 0;

    clear_bit(cmd->index, s->frame_map);

}
",0
Detect whether the following code contains vulnerabilities.,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
",0
Detect whether the following code contains vulnerabilities.,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_tlbsx_440(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    TCGv t0;

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    t0 = tcg_temp_new();

    gen_addr_reg_index(ctx, t0);

    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);

    tcg_temp_free(t0);

    if (Rc(ctx->opcode)) {

        int l1 = gen_new_label();

        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);

        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);

        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);

        gen_set_label(l1);

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,

                hwaddr addr, int *miny, int *maxy)

{

    DisplaySurface *surface = qemu_console_surface(s->con);

    int src_width, dest_width;

    drawfn fn = NULL;

    if (s->dest_width)

        fn = s->line_fn[s->transp][s->bpp];

    if (!fn)

        return;



    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */

    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)

        src_width *= 3;

    else if (s->bpp > pxa_lcdc_16bpp)

        src_width *= 4;

    else if (s->bpp > pxa_lcdc_8bpp)

        src_width *= 2;



    dest_width = s->xres * s->dest_width;

    *miny = 0;

    framebuffer_update_display(surface, s->sysmem,

                               addr, s->xres, s->yres,

                               src_width, dest_width, s->dest_width,

                               s->invalidated,

                               fn, s->dma_ch[0].palette, miny, maxy);

}
",0
Detect whether the following code contains vulnerabilities.,"build_dmar_q35(GArray *table_data, GArray *linker)

{

    int dmar_start = table_data->len;



    AcpiTableDmar *dmar;

    AcpiDmarHardwareUnit *drhd;



    dmar = acpi_data_push(table_data, sizeof(*dmar));

    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;

    dmar->flags = 0;    /* No intr_remap for now */



    /* DMAR Remapping Hardware Unit Definition structure */

    drhd = acpi_data_push(table_data, sizeof(*drhd));

    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);

    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */

    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;

    drhd->pci_segment = cpu_to_le16(0);

    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);



    build_header(linker, table_data, (void *)(table_data->data + dmar_start),

                 ""DMAR"", table_data->len - dmar_start, 1, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)

{

    GtkWidget *machine_menu;

    GtkWidget *separator;



    machine_menu = gtk_menu_new();

    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);



    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);



    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));

    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),

                                 ""<QEMU>/Machine/Quit"");

    gtk_accel_map_add_entry(""<QEMU>/Machine/Quit"",

                            GDK_KEY_q, GDK_CONTROL_MASK);

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);



    return machine_menu;

}
",0
Detect whether the following code contains vulnerabilities.,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
",1
Detect whether the following code contains vulnerabilities.,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",1
Detect whether the following code contains vulnerabilities.,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *data = opaque;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,

                              int access_type, int mmu_idx, int is_softmmu)

{

    uint32_t phys_addr;

    target_ulong page_size;

    int prot;

    int ret, is_user;



    is_user = mmu_idx == MMU_USER_IDX;

    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,

                        &page_size);

    if (ret == 0) {

        /* Map a single [sub]page.  */

        phys_addr &= ~(uint32_t)0x3ff;

        address &= ~(uint32_t)0x3ff;

        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,

                      page_size);

        return 0;

    }



    if (access_type == 2) {

        env->cp15.c5_insn = ret;

        env->cp15.c6_insn = address;

        env->exception_index = EXCP_PREFETCH_ABORT;

    } else {

        env->cp15.c5_data = ret;

        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))

            env->cp15.c5_data |= (1 << 11);

        env->cp15.c6_data = address;

        env->exception_index = EXCP_DATA_ABORT;

    }

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)

{

    struct omap_l4_s *bus = g_malloc0(

                    sizeof(*bus) + ta_num * sizeof(*bus->ta));



    bus->ta_num = ta_num;

    bus->base = base;



#ifdef L4_MUX_HACK

    omap_l4_io_entries = 1;

    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));



    omap_cpu_io_entry =

            cpu_register_io_memory(omap_l4_io_readfn,

                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);

# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)

    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);

#endif



    return bus;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
",0
Detect whether the following code contains vulnerabilities.,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_get_buffer) {

        err = avctx->get_buffer(avctx, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!avctx->codec->update_thread_context)

            ff_thread_finish_setup(avctx);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",1
Detect whether the following code contains vulnerabilities.,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",0
Detect whether the following code contains vulnerabilities.,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
",0
Detect whether the following code contains vulnerabilities.,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUState *env)

{

	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));

	int err = 0;



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))

            return 1;

#endif

	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);

	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);

	err |= copy_siginfo_to_user(&frame->info, info);



	/* Clear all the bits of the ucontext we don't use.  */

	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));



	err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/

				env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));



	if (err == 0)

		err = setup_return(env, ka, &frame->retcode, frame, usig);



	if (err == 0) {

		/*

		 * For realtime signals we must also set the second and third

		 * arguments for the signal handler.

		 *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06

		 */

            env->regs[1] = (target_ulong)frame->pinfo;

            env->regs[2] = (target_ulong)frame->puc;

	}



        //	return err;

}
",0
Detect whether the following code contains vulnerabilities.,"static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,

                                uint64_t *buid, hwaddr *pio,

                                hwaddr *mmio32, hwaddr *mmio64,

                                unsigned n_dma, uint32_t *liobns, Error **errp)

{

    /*

     * New-style PHB window placement.

     *

     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window

     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO

     * windows.

     *

     * Some guest kernels can't work with MMIO windows above 1<<46

     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB

     *

     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each

     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the

     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the

     * 1TiB 64-bit MMIO windows for each PHB.

     */

    const uint64_t base_buid = 0x800000020000000ULL;

    const int max_phbs =

        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;

    int i;



    /* Sanity check natural alignments */

    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);

    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);

    /* Sanity check bounds */

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);

    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);



    if (index >= max_phbs) {

        error_setg(errp, ""\""index\"" for PAPR PHB is too large (max %u)"",

                   max_phbs - 1);

        return;

    }



    *buid = base_buid + index;

    for (i = 0; i < n_dma; ++i) {

        liobns[i] = SPAPR_PCI_LIOBN(index, i);

    }



    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;

    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;

    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
",1
Detect whether the following code contains vulnerabilities.,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",1
Detect whether the following code contains vulnerabilities.,"static av_cold int ac3_decode_init(AVCodecContext *avctx)

{

    AC3DecodeContext *s = avctx->priv_data;

    s->avctx = avctx;



    ff_ac3_common_init();

    ac3_tables_init();

    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);

    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);

    ff_kbd_window_init(s->window, 5.0, 256);

    dsputil_init(&s->dsp, avctx);

    ff_fmt_convert_init(&s->fmt_conv, avctx);

    av_lfg_init(&s->dith_state, 0);



    /* set scale value for float to int16 conversion */

    s->mul_bias = 32767.0f;



    /* allow downmixing to stereo or mono */

    if (avctx->channels > 0 && avctx->request_channels > 0 &&

            avctx->request_channels < avctx->channels &&

            avctx->request_channels <= 2) {

        avctx->channels = avctx->request_channels;

    }

    s->downmixed = 1;



    /* allocate context input buffer */

    if (avctx->error_recognition >= FF_ER_CAREFUL) {

        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!s->input_buffer)

            return AVERROR(ENOMEM);

    }



    avctx->sample_fmt = AV_SAMPLE_FMT_S16;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int main()

{

    int rd, rt, dsp;

    int result, resultdsp;



    rt        = 0x12345678;

    result    = 0xA000C000;

    resultdsp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(rd), ""=r""(dsp)

         : ""r""(rt)

        );

    dsp = (dsp >> 22) & 0x01;

    assert(dsp == resultdsp);

    assert(rd  == result);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)

{

    int count, x;

    uint8_t *out;



    out = outbuf;





        for(x = 0; x < w; x += count) {

            /* see if we can encode the next set of pixels with RLE */

            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (count ^ xor) + add;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                count = count_pixels(ptr, w-x, bpp, 0);

                *out++ = count - 1;



                if(out + bpp*count > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * count);

                out += bpp * count;

        }



        ptr += count * bpp;

    }



    return out - outbuf;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vdpau_frames_init(AVHWFramesContext *ctx)

{

    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;

    VDPAUFramesContext        *priv = ctx->internal->priv;



    int i;



    switch (ctx->sw_format) {

    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;

    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;

    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;

    default:

        av_log(ctx, AV_LOG_ERROR, ""Unsupported data layout: %s\n"",

               av_get_pix_fmt_name(ctx->sw_format));

        return AVERROR(ENOSYS);

    }



    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {

        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {

            priv->chroma_idx  = i;

            priv->pix_fmts    = device_priv->pix_fmts[i];

            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];

            break;

        }

    }

    if (!priv->pix_fmts) {

        av_log(ctx, AV_LOG_ERROR, ""Unsupported chroma type: %d\n"", priv->chroma_type);

        return AVERROR(ENOSYS);

    }



    if (!ctx->pool) {

        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,

                                                            vdpau_pool_alloc, NULL);

        if (!ctx->internal->pool_internal)

            return AVERROR(ENOMEM);

    }



    priv->get_data = device_priv->get_data;

    priv->put_data = device_priv->put_data;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int vm_stop(RunState state)

{

    if (qemu_in_vcpu_thread()) {


        qemu_system_vmstop_request(state);

        /*

         * FIXME: should not return to device code in case

         * vm_stop() has been requested.

         */

        cpu_stop_current();

        return 0;

    }



    return do_vm_stop(state);

}",1
Detect whether the following code contains vulnerabilities.,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])

{

    S390CPU *cpu = s390_env_get_cpu(env);

    const unsigned long *features = cpu->model->features;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, features)) {

        /* z/Architecture is always active if around */

        words[0] = 1ull << (63 - 2);

    }



    for (feat = find_first_bit(features, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            words[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
",0
Detect whether the following code contains vulnerabilities.,"static int nbd_establish_connection(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;

    int sock;

    int ret;

    off_t size;

    size_t blocksize;



    if (s->host_spec[0] == '/') {

        sock = unix_socket_outgoing(s->host_spec);

    } else {

        sock = tcp_socket_outgoing_spec(s->host_spec);

    }



    /* Failed to establish connection */

    if (sock < 0) {

        logout(""Failed to establish connection to NBD server\n"");

        return -errno;

    }



    /* NBD handshake */

    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,

                                &blocksize);

    if (ret < 0) {

        logout(""Failed to negotiate with the NBD server\n"");

        closesocket(sock);

        return -errno;

    }



    /* Now that we're connected, set the socket to be non-blocking and

     * kick the reply mechanism.  */

    socket_set_nonblock(sock);

    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,

                            nbd_have_request, NULL, s);



    s->sock = sock;

    s->size = size;

    s->blocksize = blocksize;



    logout(""Established connection with NBD server\n"");

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
",0
Detect whether the following code contains vulnerabilities.,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
",0
Detect whether the following code contains vulnerabilities.,"static void type_initialize_interface(TypeImpl *ti, const char *parent)

{

    InterfaceClass *new_iface;

    TypeInfo info = { };

    TypeImpl *iface_impl;



    info.parent = parent;

    info.name = g_strdup_printf(""%s::%s"", ti->name, info.parent);

    info.abstract = true;



    iface_impl = type_register(&info);

    type_initialize(iface_impl);

    g_free((char *)info.name);



    new_iface = (InterfaceClass *)iface_impl->class;

    new_iface->concrete_class = ti->class;



    ti->class->interfaces = g_slist_append(ti->class->interfaces,

                                           iface_impl->class);

}
",1
Detect whether the following code contains vulnerabilities.,"static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        w = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    is->width = screen->w;

    is->height = screen->h;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    struct nand_state_t *s = opaque;

    uint32_t r;

    int rdy;



    r = nand_getio(s->nand);

    nand_getpins(s->nand, &rdy);

    s->rdy = rdy;



    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));

    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
",0
Detect whether the following code contains vulnerabilities.,"void block_job_resume_all(void)

{

    BlockJob *job = NULL;

    while ((job = block_job_next(job))) {

        AioContext *aio_context = blk_get_aio_context(job->blk);



        aio_context_acquire(aio_context);

        block_job_resume(job);

        aio_context_release(aio_context);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int write_option(void *optctx, const OptionDef *po, const char *opt,

                        const char *arg)

{

    /* new-style options contain an offset into optctx, old-style address of

     * a global var*/

    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?

                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;

    int *dstcount;



    if (po->flags & OPT_SPEC) {

        SpecifierOpt **so = dst;

        char *p = strchr(opt, ':');



        dstcount = (int *)(so + 1);

        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);

        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : """");

        dst = &(*so)[*dstcount - 1].u;

    }



    if (po->flags & OPT_STRING) {

        char *str;

        str = av_strdup(arg);

        av_freep(dst);

        *(char **)dst = str;

    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {

        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);

    } else if (po->flags & OPT_INT64) {

        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);

    } else if (po->flags & OPT_TIME) {

        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);

    } else if (po->flags & OPT_FLOAT) {

        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);

    } else if (po->flags & OPT_DOUBLE) {

        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);

    } else if (po->u.func_arg) {

        int ret = po->u.func_arg(optctx, opt, arg);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR,

                   ""Failed to set value '%s' for option '%s'\n"", arg, opt);

            return ret;

        }

    }

    if (po->flags & OPT_EXIT)

        exit_program(0);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
",1
Detect whether the following code contains vulnerabilities.,"static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,

                                target_ulong avpn,

                                target_ulong flags,

                                target_ulong *vp, target_ulong *rp)

{

    CPUPPCState *env = &cpu->env;

    uint64_t token;

    target_ulong v, r, rb;



    if (!valid_pte_index(env, ptex)) {

        return REMOVE_PARM;

    }



    token = ppc_hash64_start_access(cpu, ptex);

    v = ppc_hash64_load_hpte0(cpu, token, 0);

    r = ppc_hash64_load_hpte1(cpu, token, 0);

    ppc_hash64_stop_access(token);



    if ((v & HPTE64_V_VALID) == 0 ||

        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||

        ((flags & H_ANDCOND) && (v & avpn) != 0)) {

        return REMOVE_NOT_FOUND;

    }

    *vp = v;

    *rp = r;

    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);

    rb = compute_tlbie_rb(v, r, ptex);

    ppc_tlb_invalidate_one(env, rb);

    return REMOVE_SUCCESS;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qemu_tcg_init_vcpu(CPUState *cpu)

{

    char thread_name[VCPU_THREAD_NAME_SIZE];

    static QemuCond *tcg_halt_cond;

    static QemuThread *tcg_cpu_thread;



    /* share a single thread for all cpus with TCG */

    if (!tcg_cpu_thread) {

        cpu->thread = g_malloc0(sizeof(QemuThread));

        cpu->halt_cond = g_malloc0(sizeof(QemuCond));

        qemu_cond_init(cpu->halt_cond);

        tcg_halt_cond = cpu->halt_cond;

        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",

                 cpu->cpu_index);

        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,

                           cpu, QEMU_THREAD_JOINABLE);

#ifdef _WIN32

        cpu->hThread = qemu_thread_get_handle(cpu->thread);

#endif

        while (!cpu->created) {

            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);

        }

        tcg_cpu_thread = cpu->thread;

    } else {

        cpu->thread = tcg_cpu_thread;

        cpu->halt_cond = tcg_halt_cond;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",1
Detect whether the following code contains vulnerabilities.,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
",0
Detect whether the following code contains vulnerabilities.,"static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)

{

    unsigned access_size_min = mr->ops->impl.min_access_size;

    unsigned access_size_max = mr->ops->impl.max_access_size;



    /* Regions are assumed to support 1-4 byte accesses unless

       otherwise specified.  */

    if (access_size_min == 0) {

        access_size_min = 1;

    }

    if (access_size_max == 0) {

        access_size_max = 4;

    }



    /* Bound the maximum access by the alignment of the address.  */

    if (!mr->ops->impl.unaligned) {

        unsigned align_size_max = addr & -addr;

        if (align_size_max != 0 && align_size_max < access_size_max) {

            access_size_max = align_size_max;

        }

    }



    /* Don't attempt accesses larger than the maximum.  */

    if (l > access_size_max) {

        l = access_size_max;

    }

    /* ??? The users of this function are wrong, not supporting minimums larger

       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */

    assert(l >= access_size_min);



    return l;

}
",1
Detect whether the following code contains vulnerabilities.,"static void stellaris_enet_save(QEMUFile *f, void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;

    int i;



    qemu_put_be32(f, s->ris);

    qemu_put_be32(f, s->im);

    qemu_put_be32(f, s->rctl);

    qemu_put_be32(f, s->tctl);

    qemu_put_be32(f, s->thr);

    qemu_put_be32(f, s->mctl);

    qemu_put_be32(f, s->mdv);

    qemu_put_be32(f, s->mtxd);

    qemu_put_be32(f, s->mrxd);

    qemu_put_be32(f, s->np);

    qemu_put_be32(f, s->tx_fifo_len);

    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));

    for (i = 0; i < 31; i++) {

        qemu_put_be32(f, s->rx[i].len);

        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));



    }

    qemu_put_be32(f, s->next_packet);

    qemu_put_be32(f, s->rx_fifo_offset);

}
",1
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
",1
Detect whether the following code contains vulnerabilities.,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",0
Detect whether the following code contains vulnerabilities.,"static void check_refcounts(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int64_t size;

    int nb_clusters, refcount1, refcount2, i;

    QCowSnapshot *sn;

    uint16_t *refcount_table;



    size = bdrv_getlength(s->hd);

    nb_clusters = size_to_clusters(s, size);

    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));



    /* header */

    inc_refcounts(bs, refcount_table, nb_clusters,

                  0, s->cluster_size);



    check_refcounts_l1(bs, refcount_table, nb_clusters,

                       s->l1_table_offset, s->l1_size, 1);



    /* snapshots */

    for(i = 0; i < s->nb_snapshots; i++) {

        sn = s->snapshots + i;

        check_refcounts_l1(bs, refcount_table, nb_clusters,

                           sn->l1_table_offset, sn->l1_size, 0);

    }

    inc_refcounts(bs, refcount_table, nb_clusters,

                  s->snapshots_offset, s->snapshots_size);



    /* refcount data */

    inc_refcounts(bs, refcount_table, nb_clusters,

                  s->refcount_table_offset,

                  s->refcount_table_size * sizeof(uint64_t));

    for(i = 0; i < s->refcount_table_size; i++) {

        int64_t offset;

        offset = s->refcount_table[i];

        if (offset != 0) {

            inc_refcounts(bs, refcount_table, nb_clusters,

                          offset, s->cluster_size);

        }

    }



    /* compare ref counts */

    for(i = 0; i < nb_clusters; i++) {

        refcount1 = get_refcount(bs, i);

        refcount2 = refcount_table[i];

        if (refcount1 != refcount2)

            fprintf(stderr, ""ERROR cluster %d refcount=%d reference=%d\n"",

                   i, refcount1, refcount2);

    }



    qemu_free(refcount_table);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ipoctal_init(IPackDevice *ip)

{

    IPOctalState *s = IPOCTAL(ip);

    unsigned i;



    for (i = 0; i < N_CHANNELS; i++) {

        SCC2698Channel *ch = &s->ch[i];

        ch->ipoctal = s;



        /* Redirect IP-Octal channels to host character devices */

        if (ch->devpath) {

            const char chr_name[] = ""ipoctal"";

            char label[ARRAY_SIZE(chr_name) + 2];

            static int index;



            snprintf(label, sizeof(label), ""%s%d"", chr_name, index);



            ch->dev = qemu_chr_new(label, ch->devpath, NULL);



            if (ch->dev) {

                index++;


                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,

                                      hostdev_receive, hostdev_event, ch);

                DPRINTF(""Redirecting channel %u to %s (%s)\n"",

                        i, ch->devpath, label);

            } else {

                DPRINTF(""Could not redirect channel %u to %s\n"",

                        i, ch->devpath);

            }

        }

    }



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
",1
Detect whether the following code contains vulnerabilities.,"static int64_t do_strtosz(const char *nptr, char **end,

                          const char default_suffix, int64_t unit)

{

    int64_t retval;

    char *endptr;

    unsigned char c;

    int mul_required = 0;

    double val, mul, integral, fraction;



    errno = 0;

    val = strtod(nptr, &endptr);

    if (isnan(val) || endptr == nptr || errno != 0) {

        retval = -EINVAL;

        goto out;

    }

    fraction = modf(val, &integral);

    if (fraction != 0) {

        mul_required = 1;

    }

    c = *endptr;

    mul = suffix_mul(c, unit);

    if (mul >= 0) {

        endptr++;

    } else {

        mul = suffix_mul(default_suffix, unit);

        assert(mul >= 0);

    }

    if (mul == 1 && mul_required) {

        retval = -EINVAL;

        goto out;

    }

    if ((val * mul >= INT64_MAX) || val < 0) {

        retval = -ERANGE;

        goto out;

    }

    retval = val * mul;



out:

    if (end) {

        *end = endptr;

    } else if (*endptr) {

        retval = -EINVAL;

    }



    return retval;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int onenand_erase(OneNANDState *s, int sec, int num)

{

    uint8_t *blankbuf, *tmpbuf;

    blankbuf = g_malloc(512);

    if (!blankbuf) {

        return 1;

    }

    tmpbuf = g_malloc(512);

    if (!tmpbuf) {

        g_free(blankbuf);

        return 1;

    }

    memset(blankbuf, 0xff, 512);

    for (; num > 0; num--, sec++) {

        if (s->bdrv_cur) {

            int erasesec = s->secs_cur + (sec >> 5);

            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {

                goto fail;

            }

            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {

                goto fail;

            }

            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);

            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {

                goto fail;

            }

        } else {

            if (sec + 1 > s->secs_cur) {

                goto fail;

            }

            memcpy(s->current + (sec << 9), blankbuf, 512);

            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),

                   blankbuf, 1 << 4);

        }

    }



    g_free(tmpbuf);

    g_free(blankbuf);

    return 0;



fail:

    g_free(tmpbuf);

    g_free(blankbuf);

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int default_lockmgr_cb(void **arg, enum AVLockOp op)

{

    void * volatile * mutex = arg;

    int err;



    switch (op) {

    case AV_LOCK_CREATE:

        return 0;

    case AV_LOCK_OBTAIN:

        if (!*mutex) {

            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));

            if (!tmp)

                return AVERROR(ENOMEM);

            if ((err = pthread_mutex_init(tmp, NULL))) {

                av_free(tmp);

                return AVERROR(err);

            }

            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {

                pthread_mutex_destroy(tmp);

                av_free(tmp);

            }

        }



        if ((err = pthread_mutex_lock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_RELEASE:

        if ((err = pthread_mutex_unlock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_DESTROY:

        if (*mutex)

            pthread_mutex_destroy(*mutex);

        av_free(*mutex);

        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);

        return 0;

    }

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vfio_load_rom(VFIODevice *vdev)

{

    uint64_t size = vdev->rom_size;

    char name[32];

    off_t off = 0, voff = vdev->rom_offset;

    ssize_t bytes;

    void *ptr;



    /* If loading ROM from file, pci handles it */

    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {

        return 0;

    }



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    snprintf(name, sizeof(name), ""vfio[%04x:%02x:%02x.%x].rom"",

             vdev->host.domain, vdev->host.bus, vdev->host.slot,

             vdev->host.function);

    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);

    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);

    memset(ptr, 0xff, size);



    while (size) {

        bytes = pread(vdev->fd, ptr + off, size, voff + off);

        if (bytes == 0) {

            break; /* expect that we could get back less than the ROM BAR */

        } else if (bytes > 0) {

            off += bytes;

            size -= bytes;

        } else {

            if (errno == EINTR || errno == EAGAIN) {

                continue;

            }

            error_report(""vfio: Error reading device ROM: %m"");

            memory_region_destroy(&vdev->pdev.rom);

            return -errno;

        }

    }



    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);

    vdev->pdev.has_rom = true;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
",0
Detect whether the following code contains vulnerabilities.,"static int rle_unpack(const unsigned char *src, int src_len, int src_count,

                      unsigned char *dest, int dest_len)

{

    const unsigned char *ps;

    const unsigned char *ps_end;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    ps_end = src + src_len;

    pd = dest;

    if (src_count & 1) {

        if (ps_end - ps < 1)

            return 0;

        *pd++ = *ps++;

    }



    src_count >>= 1;

    i = 0;

    do {

        if (ps_end - ps < 1)

            break;

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end || ps_end - ps < l)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end || ps_end - ps < 2)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_count);



    return ps - src;

}
",1
Detect whether the following code contains vulnerabilities.,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",1
Detect whether the following code contains vulnerabilities.,"static void apic_update_irq(APICState *s)

{

    int irrv, ppr;

    if (!(s->spurious_vec & APIC_SV_ENABLE))

        return;

    irrv = get_highest_priority_int(s->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(s);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;

    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

}
",0
Detect whether the following code contains vulnerabilities.,"setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,

		 CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)

{

    CPUState *cs = CPU(x86_env_get_cpu(env));

    int err = 0;

    uint16_t magic;



	/* already locked in setup_frame() */

    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);

    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);

    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);

    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);

    __put_user(env->regs[R_EDI], &sc->edi);

    __put_user(env->regs[R_ESI], &sc->esi);

    __put_user(env->regs[R_EBP], &sc->ebp);

    __put_user(env->regs[R_ESP], &sc->esp);

    __put_user(env->regs[R_EBX], &sc->ebx);

    __put_user(env->regs[R_EDX], &sc->edx);

    __put_user(env->regs[R_ECX], &sc->ecx);

    __put_user(env->regs[R_EAX], &sc->eax);

    __put_user(cs->exception_index, &sc->trapno);

    __put_user(env->error_code, &sc->err);

    __put_user(env->eip, &sc->eip);

    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);

    __put_user(env->eflags, &sc->eflags);

    __put_user(env->regs[R_ESP], &sc->esp_at_signal);

    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);



        cpu_x86_fsave(env, fpstate_addr, 1);

        fpstate->status = fpstate->sw;

        magic = 0xffff;

    __put_user(magic, &fpstate->magic);

    __put_user(fpstate_addr, &sc->fpstate);



	/* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);

    __put_user(env->cr[2], &sc->cr2);

	return err;

}
",0
Detect whether the following code contains vulnerabilities.,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs);

        } else if (s->header.features & QED_F_NEED_CHECK) {

            qed_start_need_check_timer(s);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,

                                          int *beta, int *tc, uint8_t *no_p,

                                          uint8_t *no_q)

{

    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),

                                beta, tc, no_p, no_q);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,

                           TCGArg b, bool b_const, TCGLabel *l)

{

    intptr_t offset;

    bool need_cmp;



    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {

        need_cmp = false;

    } else {

        need_cmp = true;

        tcg_out_cmp(s, ext, a, b, b_const);

    }



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);

        offset = tcg_in32(s) >> 5;

    } else {

        offset = l->u.value_ptr - s->code_ptr;

        assert(offset == sextract64(offset, 0, 19));

    }



    if (need_cmp) {

        tcg_out_insn(s, 3202, B_C, c, offset);

    } else if (c == TCG_COND_EQ) {

        tcg_out_insn(s, 3201, CBZ, ext, a, offset);

    } else {

        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)

{

    AMFDataType type;

    AVStream *stream, *astream, *vstream;

    AVIOContext *ioc;

    int i;

    // only needs to hold the string ""onMetaData"".

    // Anything longer is something we don't want.

    char buffer[11];



    astream = NULL;

    vstream = NULL;

    ioc     = s->pb;



    // first object needs to be ""onMetaData"" string

    type = avio_r8(ioc);

    if (type != AMF_DATA_TYPE_STRING ||

        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)

        return -1;



    if (!strcmp(buffer, ""onTextData""))

        return 1;



    if (strcmp(buffer, ""onMetaData""))

        return -1;



    // find the streams now so that amf_parse_object doesn't need to do

    // the lookup every time it is called.

    for (i = 0; i < s->nb_streams; i++) {

        stream = s->streams[i];

        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)

            astream = stream;

        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)

            vstream = stream;

    }



    // parse the second object (we want a mixed array)

    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)

        return -1;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)

{

    int i;

    GICState *s = KVM_ARM_GIC(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);

    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);



    kgc->parent_realize(dev, errp);

    if (error_is_set(errp)) {

        return;

    }



    i = s->num_irq - GIC_INTERNAL;

    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.

     * GPIO array layout is thus:

     *  [0..N-1] SPIs

     *  [N..N+31] PPIs for CPU 0

     *  [N+32..N+63] PPIs for CPU 1

     *   ...

     */

    i += (GIC_INTERNAL * s->num_cpu);

    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);

    /* We never use our outbound IRQ lines but provide them so that

     * we maintain the same interface as the non-KVM GIC.

     */

    for (i = 0; i < s->num_cpu; i++) {

        sysbus_init_irq(sbd, &s->parent_irq[i]);

    }

    /* Distributor */

    memory_region_init_reservation(&s->iomem, OBJECT(s),

                                   ""kvm-gic_dist"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    kvm_arm_register_device(&s->iomem,

                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)

                            | KVM_VGIC_V2_ADDR_TYPE_DIST);

    /* CPU interface for current core. Unlike arm_gic, we don't

     * provide the ""interface for core #N"" memory regions, because

     * cores with a VGIC don't have those.

     */

    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),

                                   ""kvm-gic_cpu"", 0x1000);

    sysbus_init_mmio(sbd, &s->cpuiomem[0]);

    kvm_arm_register_device(&s->cpuiomem[0],

                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)

                            | KVM_VGIC_V2_ADDR_TYPE_CPU);

}
",0
Detect whether the following code contains vulnerabilities.,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"char *qemu_find_file(int type, const char *name)

{

    int len;

    const char *subdir;

    char *buf;



    /* If name contains path separators then try it as a straight path.  */

    if ((strchr(name, '/') || strchr(name, '\\'))

        && access(name, R_OK) == 0) {

        return g_strdup(name);

    }

    switch (type) {

    case QEMU_FILE_TYPE_BIOS:

        subdir = """";

        break;

    case QEMU_FILE_TYPE_KEYMAP:

        subdir = ""keymaps/"";

        break;

    default:

        abort();

    }

    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;

    buf = g_malloc0(len);

    snprintf(buf, len, ""%s/%s%s"", data_dir, subdir, name);

    if (access(buf, R_OK)) {

        g_free(buf);

        return NULL;

    }

    return buf;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
",0
Detect whether the following code contains vulnerabilities.,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""\n"", cluster_offset);

                res->corruptions++;

            }

        }

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",1
Detect whether the following code contains vulnerabilities.,"static int gif_image_write_image(AVCodecContext *avctx,

                                 uint8_t **bytestream, uint8_t *end,

                                 const uint8_t *buf, int linesize)

{

    GIFContext *s = avctx->priv_data;

    int len, height;

    const uint8_t *ptr;

    /* image block */



    bytestream_put_byte(bytestream, 0x2c);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, avctx->width);

    bytestream_put_le16(bytestream, avctx->height);

    bytestream_put_byte(bytestream, 0x00); /* flags */

    /* no local clut */



    bytestream_put_byte(bytestream, 0x08);



    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,

                       12, FF_LZW_GIF, put_bits);



    ptr = buf;

    for (height = avctx->height; height--;) {

        len += ff_lzw_encode(s->lzw, ptr, avctx->width);

        ptr += linesize;

    }

    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);



    ptr = s->buf;

    while (len > 0) {

        int size = FFMIN(255, len);

        bytestream_put_byte(bytestream, size);

        if (end - *bytestream < size)

            return -1;

        bytestream_put_buffer(bytestream, ptr, size);

        ptr += size;

        len -= size;

    }

    bytestream_put_byte(bytestream, 0x00); /* end of image block */

    bytestream_put_byte(bytestream, 0x3b);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""stbl"");

    mov_write_stsd_tag(pb, track);

    mov_write_stts_tag(pb, track);

    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||

         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&

        track->has_keyframes && track->has_keyframes < track->entry)

        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);

    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)

        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);

    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&

        track->flags & MOV_TRACK_CTTS && track->entry)

        mov_write_ctts_tag(pb, track);

    mov_write_stsc_tag(pb, track);

    mov_write_stsz_tag(pb, track);

    mov_write_stco_tag(pb, track);

    return update_size(pb, pos);

}
",1
Detect whether the following code contains vulnerabilities.,"uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,

    int *num)

{

    BDRVQcowState *s = bs->opaque;

    int l1_index, l2_index;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int l1_bits, c;

    int index_in_cluster, nb_available, nb_needed, nb_clusters;



    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);

    nb_needed = *num + index_in_cluster;



    l1_bits = s->l2_bits + s->cluster_bits;



    /* compute how many bytes there are between the offset and

     * the end of the l1 entry

     */



    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));



    /* compute the number of available sectors */



    nb_available = (nb_available >> 9) + index_in_cluster;



    if (nb_needed > nb_available) {

        nb_needed = nb_available;

    }



    cluster_offset = 0;



    /* seek the the l2 offset in the l1 table */



    l1_index = offset >> l1_bits;

    if (l1_index >= s->l1_size)

        goto out;



    l2_offset = s->l1_table[l1_index];



    /* seek the l2 table of the given l2 offset */



    if (!l2_offset)

        goto out;



    /* load the l2 table in memory */



    l2_offset &= ~QCOW_OFLAG_COPIED;

    l2_table = l2_load(bs, l2_offset);

    if (l2_table == NULL)

        return 0;



    /* find the cluster offset for the given disk offset */



    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);

    cluster_offset = be64_to_cpu(l2_table[l2_index]);

    nb_clusters = size_to_clusters(s, nb_needed << 9);



    if (!cluster_offset) {

        /* how many empty clusters ? */

        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);

    } else {

        /* how many allocated clusters ? */

        c = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);

    }



   nb_available = (c * s->cluster_sectors);

out:

    if (nb_available > nb_needed)

        nb_available = nb_needed;



    *num = nb_available - index_in_cluster;



    return cluster_offset & ~QCOW_OFLAG_COPIED;

}
",1
Detect whether the following code contains vulnerabilities.,"void memory_region_add_eventfd(MemoryRegion *mr,

                               hwaddr addr,

                               unsigned size,

                               bool match_data,

                               uint64_t data,

                               EventNotifier *e)

{

    MemoryRegionIoeventfd mrfd = {

        .addr.start = int128_make64(addr),

        .addr.size = int128_make64(size),

        .match_data = match_data,

        .data = data,

        .e = e,

    };

    unsigned i;



    adjust_endianness(mr, &mrfd.data, size);

    memory_region_transaction_begin();

    for (i = 0; i < mr->ioeventfd_nb; ++i) {

        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {

            break;

        }

    }

    ++mr->ioeventfd_nb;

    mr->ioeventfds = g_realloc(mr->ioeventfds,

                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);

    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],

            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));

    mr->ioeventfds[i] = mrfd;

    ioeventfd_update_pending |= mr->enabled;

    memory_region_transaction_commit();

}
",1
Detect whether the following code contains vulnerabilities.,"enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)

{

    if (codec && codec->pix_fmts) {

        const enum AVPixelFormat *p = codec->pix_fmts;

        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;

        enum AVPixelFormat best= AV_PIX_FMT_NONE;

        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {

            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {

                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };

            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {

                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,

                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };

            }

        }

        for (; *p != AV_PIX_FMT_NONE; p++) {

            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);

            if (*p == target)

                break;

        }

        if (*p == AV_PIX_FMT_NONE) {

            if (target != AV_PIX_FMT_NONE)

                av_log(NULL, AV_LOG_WARNING,

                       ""Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\n"",

                       av_get_pix_fmt_name(target),

                       codec->name,

                       av_get_pix_fmt_name(best));

            return best;

        }

    }

    return target;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gic_set_irq(void *opaque, int irq, int level)

{

    /* Meaning of the 'irq' parameter:

     *  [0..N-1] : external interrupts

     *  [N..N+31] : PPI (internal) interrupts for CPU 0

     *  [N+32..N+63] : PPI (internal interrupts for CPU 1

     *  ...

     */

    GICState *s = (GICState *)opaque;

    int cm, target;

    if (irq < (s->num_irq - GIC_INTERNAL)) {

        /* The first external input line is internal interrupt 32.  */

        cm = ALL_CPU_MASK;

        irq += GIC_INTERNAL;

        target = GIC_TARGET(irq);

    } else {

        int cpu;

        irq -= (s->num_irq - GIC_INTERNAL);

        cpu = irq / GIC_INTERNAL;

        irq %= GIC_INTERNAL;

        cm = 1 << cpu;

        target = cm;

    }



    assert(irq >= GIC_NR_SGIS);



    if (level == GIC_TEST_LEVEL(irq, cm)) {

        return;

    }



    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

        gic_set_irq_11mpcore(s, irq, level, cm, target);

    } else {

        gic_set_irq_generic(s, irq, level, cm, target);

    }




    gic_update(s);

}",1
Detect whether the following code contains vulnerabilities.,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        /* Hack for kernel early debug, which always specifies reg==0.
         * We search all VIO devices, and grab the vty with the lowest
         * reg.  This attempts to mimic existing PowerVM behaviour
         * (early debug does work there, despite having no vty with
         * reg==0. */
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;",1
Detect whether the following code contains vulnerabilities.,"void coroutine_fn block_job_pause_point(BlockJob *job)

{

    assert(job && block_job_started(job));



    if (!block_job_should_pause(job)) {

        return;

    }

    if (block_job_is_cancelled(job)) {

        return;

    }



    if (job->driver->pause) {

        job->driver->pause(job);

    }



    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {

        job->paused = true;

        job->busy = false;

        qemu_coroutine_yield(); /* wait for block_job_resume() */

        job->busy = true;

        job->paused = false;

    }



    if (job->driver->resume) {

        job->driver->resume(job);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}",1
Detect whether the following code contains vulnerabilities.,"int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,

                             int max_size)

{

    uint32_t mrk;

    int i, tmp;

    const uint16_t *ssrc = (const uint16_t *) src;

    uint16_t *sdst = (uint16_t *) dst;

    PutBitContext pb;



    if ((unsigned) src_size > (unsigned) max_size)

        src_size = max_size;



    mrk = AV_RB32(src);

    switch (mrk) {

    case DCA_SYNCWORD_CORE_BE:

        memcpy(dst, src, src_size);

        return src_size;

    case DCA_SYNCWORD_CORE_LE:

        for (i = 0; i < (src_size + 1) >> 1; i++)

            *sdst++ = av_bswap16(*ssrc++);

        return src_size;

    case DCA_SYNCWORD_CORE_14B_BE:

    case DCA_SYNCWORD_CORE_14B_LE:

        init_put_bits(&pb, dst, max_size);

        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {

            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;

            put_bits(&pb, 14, tmp);

        }

        flush_put_bits(&pb);

        return (put_bits_count(&pb) + 7) >> 3;

    default:

        return AVERROR_INVALIDDATA;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",1
Detect whether the following code contains vulnerabilities.,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void slirp_socket_save(QEMUFile *f, struct socket *so)

{

    qemu_put_be32(f, so->so_urgc);

    qemu_put_be16(f, so->so_ffamily);

    switch (so->so_ffamily) {

    case AF_INET:

        qemu_put_be32(f, so->so_faddr.s_addr);

        qemu_put_be16(f, so->so_fport);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to save so_faddr and so_fport\n"");

    }

    qemu_put_be16(f, so->so_lfamily);

    switch (so->so_lfamily) {

    case AF_INET:

        qemu_put_be32(f, so->so_laddr.s_addr);

        qemu_put_be16(f, so->so_lport);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to save so_laddr and so_lport\n"");

    }

    qemu_put_byte(f, so->so_iptos);

    qemu_put_byte(f, so->so_emu);

    qemu_put_byte(f, so->so_type);

    qemu_put_be32(f, so->so_state);

    slirp_sbuf_save(f, &so->so_rcv);

    slirp_sbuf_save(f, &so->so_snd);

    slirp_tcp_save(f, so->so_tcpcb);

}
",0
Detect whether the following code contains vulnerabilities.,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++)

        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);

    memset(output[2], 0, sizeof(output[2]));

    memset(output[3], 0, sizeof(output[3]));

    memset(output[4], 0, sizeof(output[4]));

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstV, dstU, src1, width);

}
",0
Detect whether the following code contains vulnerabilities.,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
",0
Detect whether the following code contains vulnerabilities.,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)

{

    Mp4Descr *descr = d->active_descr;

    int predefined;

    if (!descr)

        return -1;



    predefined = avio_r8(&d->pb);

    if (!predefined) {

        int lengths;

        int flags = avio_r8(&d->pb);

        descr->sl.use_au_start       = !!(flags & 0x80);

        descr->sl.use_au_end         = !!(flags & 0x40);

        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);

        descr->sl.use_padding        = !!(flags & 0x08);

        descr->sl.use_timestamps     = !!(flags & 0x04);

        descr->sl.use_idle           = !!(flags & 0x02);

        descr->sl.timestamp_res      = avio_rb32(&d->pb);

                                       avio_rb32(&d->pb);

        descr->sl.timestamp_len      = avio_r8(&d->pb);






        descr->sl.ocr_len            = avio_r8(&d->pb);

        descr->sl.au_len             = avio_r8(&d->pb);

        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);

        lengths                      = avio_rb16(&d->pb);

        descr->sl.degr_prior_len     = lengths >> 12;

        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;

        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;

    } else {

        avpriv_report_missing_feature(d->s, ""Predefined SLConfigDescriptor"");


    return 0;
",1
Detect whether the following code contains vulnerabilities.,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
",1
Detect whether the following code contains vulnerabilities.,"POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);



    dc->fw_name = ""PowerPC,POWER8"";

    dc->desc = ""POWER8"";

    pcc->pvr = CPU_POWERPC_POWER8_BASE;

    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;

    pcc->init_proc = init_proc_POWER7;

    pcc->check_pow = check_pow_nocheck;

    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |

                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |

                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |

                       PPC_FLOAT_STFIWX |


                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |

                       PPC_MEM_SYNC | PPC_MEM_EIEIO |

                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |

                       PPC_64B | PPC_ALTIVEC |

                       PPC_SEGMENT_64B | PPC_SLBI |

                       PPC_POPCNTB | PPC_POPCNTWD;

    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |

                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |

                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;

    pcc->msr_mask = 0x800000000284FF36ULL;

    pcc->mmu_model = POWERPC_MMU_2_06;

#if defined(CONFIG_SOFTMMU)

    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;

#endif

    pcc->excp_model = POWERPC_EXCP_POWER7;

    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;

    pcc->bfd_mach = bfd_mach_ppc64;

    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |

                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |

                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |

                 POWERPC_FLAG_VSX;

    pcc->l1_dcache_size = 0x8000;

    pcc->l1_icache_size = 0x8000;

}",1
Detect whether the following code contains vulnerabilities.,"static int qemu_signalfd_compat(const sigset_t *mask)

{

    pthread_attr_t attr;

    pthread_t tid;

    struct sigfd_compat_info *info;

    int fds[2];



    info = malloc(sizeof(*info));

    if (info == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(info);

        return -1;

    }



    memcpy(&info->mask, mask, sizeof(*mask));

    info->fd = fds[1];



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &attr, sigwait_compat, info);



    pthread_attr_destroy(&attr);



    return fds[0];

}
",1
Detect whether the following code contains vulnerabilities.,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
",0
Detect whether the following code contains vulnerabilities.,"AVFilterFormats *avfilter_all_colorspaces(void)

{

    return avfilter_make_format_list(35,

                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,

                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,

                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,

                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,

                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,

                PIX_FMT_RGB32,    PIX_FMT_BGR32,

                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,

                PIX_FMT_RGB24,    PIX_FMT_BGR24,

                PIX_FMT_RGB565,   PIX_FMT_BGR565,

                PIX_FMT_RGB555,   PIX_FMT_BGR555,

                PIX_FMT_RGB8,     PIX_FMT_BGR8,

                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,

                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,

                PIX_FMT_GRAY8,    PIX_FMT_PAL8,

                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK

                PIX_FMT_NV12,     PIX_FMT_NV21);

}
",0
Detect whether the following code contains vulnerabilities.,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *s;

    SerialState *d;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", 0);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", chrB);

    qdev_prop_set_chr(dev, ""chrA"", chrA);

    qdev_prop_set_uint32(dev, ""chnBtype"", ser);

    qdev_prop_set_uint32(dev, ""chnAtype"", ser);

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irqB);

    sysbus_connect_irq(s, 1, irqA);

    if (base) {

        sysbus_mmio_map(s, 0, base);

    }



    d = FROM_SYSBUS(SerialState, s);

    return &d->mmio;

}
",0
Detect whether the following code contains vulnerabilities.,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}",1
Detect whether the following code contains vulnerabilities.,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
",1
Detect whether the following code contains vulnerabilities.,"PCIBus *pci_pmac_init(qemu_irq *pic)

{

    DeviceState *dev;

    SysBusDevice *s;

    UNINState *d;



    /* Use values found on a real PowerMac */

    /* Uninorth main bus */

    dev = qdev_create(NULL, ""Uni-north main"");

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    d = FROM_SYSBUS(UNINState, s);

    d->host_state.bus = pci_register_bus(&d->busdev.qdev, ""pci"",

                                         pci_unin_set_irq, pci_unin_map_irq,

                                         pic, 11 << 3, 4);



    pci_create_simple(d->host_state.bus, 11 << 3, ""Uni-north main"");



    sysbus_mmio_map(s, 0, 0xf2800000);

    sysbus_mmio_map(s, 1, 0xf2c00000);



    /* DEC 21154 bridge */

#if 0

    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */

    pci_create_simple(d->host_state.bus, 12 << 3, ""DEC 21154"");

#endif



    /* Uninorth AGP bus */

    pci_create_simple(d->host_state.bus, 13 << 3, ""Uni-north AGP"");



    /* Uninorth internal bus */

#if 0

    /* XXX: not needed for now */

    pci_create_simple(d->host_state.bus, 14 << 3, ""Uni-north internal"");

#endif



    return d->host_state.bus;

}
",1
Detect whether the following code contains vulnerabilities.,"static void json_message_process_token(JSONLexer *lexer, GString *input,

                                       JSONTokenType type, int x, int y)

{

    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);

    QDict *dict;



    switch (type) {

    case JSON_LCURLY:

        parser->brace_count++;

        break;

    case JSON_RCURLY:

        parser->brace_count--;

        break;

    case JSON_LSQUARE:

        parser->bracket_count++;

        break;

    case JSON_RSQUARE:

        parser->bracket_count--;

        break;

    default:

        break;

    }



    dict = qdict_new();

    qdict_put(dict, ""type"", qint_from_int(type));

    qdict_put(dict, ""token"", qstring_from_str(input->str));

    qdict_put(dict, ""x"", qint_from_int(x));

    qdict_put(dict, ""y"", qint_from_int(y));



    parser->token_size += input->len;



    g_queue_push_tail(parser->tokens, dict);



    if (type == JSON_ERROR) {

        goto out_emit_bad;

    } else if (parser->brace_count < 0 ||

        parser->bracket_count < 0 ||

        (parser->brace_count == 0 &&

         parser->bracket_count == 0)) {

        goto out_emit;

    } else if (parser->token_size > MAX_TOKEN_SIZE ||

               parser->bracket_count + parser->brace_count > MAX_NESTING) {

        /* Security consideration, we limit total memory allocated per object

         * and the maximum recursion depth that a message can force.

         */

        goto out_emit_bad;

    }



    return;



out_emit_bad:

    /*

     * Clear out token list and tell the parser to emit an error

     * indication by passing it a NULL list

     */

    json_message_free_tokens(parser);

out_emit:

    /* send current list of tokens to parser and reset tokenizer */

    parser->brace_count = 0;

    parser->bracket_count = 0;

    /* parser->emit takes ownership of parser->tokens.  */

    parser->emit(parser, parser->tokens);

    parser->tokens = g_queue_new();

    parser->token_size = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"void pci_bridge_initfn(PCIDevice *dev, const char *typename)

{

    PCIBus *parent = dev->bus;

    PCIBridge *br = PCI_BRIDGE(dev);

    PCIBus *sec_bus = &br->sec_bus;



    pci_word_test_and_set_mask(dev->config + PCI_STATUS,

                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);



    /*

     * TODO: We implement VGA Enable in the Bridge Control Register

     * therefore per the PCI to PCI bridge spec we must also implement

     * VGA Palette Snooping.  When done, set this bit writable:

     *

     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,

     *                            PCI_COMMAND_VGA_PALETTE);

     */



    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);

    dev->config[PCI_HEADER_TYPE] =

        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;

    pci_set_word(dev->config + PCI_SEC_STATUS,

                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);



    /*

     * If we don't specify the name, the bus will be addressed as <id>.0, where

     * id is the device id.

     * Since PCI Bridge devices have a single bus each, we don't need the index:

     * let users address the bus using the device name.

     */

    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {

	    br->bus_name = dev->qdev.id;

    }



    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),

                        br->bus_name);

    sec_bus->parent_dev = dev;

    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;

    sec_bus->address_space_mem = &br->address_space_mem;

    memory_region_init(&br->address_space_mem, OBJECT(br), ""pci_bridge_pci"", UINT64_MAX);

    sec_bus->address_space_io = &br->address_space_io;

    memory_region_init(&br->address_space_io, OBJECT(br), ""pci_bridge_io"", 65536);

    br->windows = pci_bridge_region_init(br);

    QLIST_INIT(&sec_bus->child);

    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, width, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t val, int len)

{

    pci_bridge_write_config(d, address, val, len);

    msi_write_config(d, address, val, len);

    shpc_cap_write_config(d, address, val, len);

}
",1
Detect whether the following code contains vulnerabilities.,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
",0
Detect whether the following code contains vulnerabilities.,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",0
Detect whether the following code contains vulnerabilities.,"static int validate_guest_space(unsigned long guest_base,

                                unsigned long guest_size)

{

    unsigned long real_start, test_page_addr;



    /* We need to check that we can force a fault on access to the

     * commpage at 0xffff0fxx

     */

    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);



    /* If the commpage lies within the already allocated guest space,

     * then there is no way we can allocate it.

     */

    if (test_page_addr >= guest_base

        && test_page_addr <= (guest_base + guest_size)) {

        return -1;

    }



    /* Note it needs to be writeable to let us initialise it */

    real_start = (unsigned long)

                 mmap((void *)test_page_addr, qemu_host_page_size,

                     PROT_READ | PROT_WRITE,

                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);



    /* If we can't map it then try another address */

    if (real_start == -1ul) {

        return 0;

    }



    if (real_start != test_page_addr) {

        /* OS didn't put the page where we asked - unmap and reject */

        munmap((void *)real_start, qemu_host_page_size);

        return 0;

    }



    /* Leave the page mapped

     * Populate it (mmap should have left it all 0'd)

     */



    /* Kernel helper versions */

    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));



    /* Now it's populated make it RO */

    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {

        perror(""Protecting guest commpage"");

        exit(-1);

    }



    return 1; /* All good */

}
",0
Detect whether the following code contains vulnerabilities.,"long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
",1
Detect whether the following code contains vulnerabilities.,"static void usbredir_interrupt_packet(void *priv, uint32_t id,

    struct usb_redir_interrupt_packet_header *interrupt_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = interrupt_packet->endpoint;



    DPRINTF(""interrupt-in status %d ep %02X len %d id %u\n"",

            interrupt_packet->status, ep, data_len, id);



    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {

        ERROR(""received int packet for non interrupt endpoint %02X\n"", ep);

        free(data);

        return;

    }



    if (ep & USB_DIR_IN) {

        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {

            DPRINTF(""received int packet while not started ep %02X\n"", ep);

            free(data);

            return;

        }



        /* bufp_alloc also adds the packet to the ep queue */

        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);

    } else {

        int len = interrupt_packet->length;



        AsyncURB *aurb = async_find(dev, id);

        if (!aurb) {

            return;

        }



        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {

            ERROR(""return int packet mismatch, please report this!\n"");

            len = USB_RET_NAK;

        }



        if (aurb->packet) {

            aurb->packet->len = usbredir_handle_status(dev,

                                               interrupt_packet->status, len);

            usb_packet_complete(&dev->dev, aurb->packet);

        }

        async_free(dev, aurb);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)

{

	unsigned i;

#ifdef HAVE_MMX

	long mmx_size= 23 - src_size;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	\n\t""

		""jns 2f				\n\t""

		""movq ""MANGLE(mask24r)"", %%mm5	\n\t""

		""movq ""MANGLE(mask24g)"", %%mm6	\n\t""

		""movq ""MANGLE(mask24b)"", %%mm7	\n\t""

		ASMALIGN(4)

		""1:				\n\t""

		PREFETCH"" 32(%1, %%""REG_a"")	\n\t""

		""movq   (%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	\n\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	\n\t"" // R BGR BGR B

		""psllq $16, %%mm0		\n\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		\n\t""

		""pand %%mm6, %%mm1		\n\t""

		""pand %%mm7, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")\n\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	\n\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	\n\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		\n\t""

		""pand %%mm5, %%mm1		\n\t""

		""pand %%mm6, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq 14(%1, %%""REG_a""), %%mm0	\n\t"" // R BGR BGR B

		MOVNTQ"" %%mm1,  8(%2, %%""REG_a"")\n\t"" // B RGB RGB R

		""movq 16(%1, %%""REG_a""), %%mm1	\n\t"" // GR BGR BGR

		""movq 18(%1, %%""REG_a""), %%mm2	\n\t"" // BGR BGR BG

		""pand %%mm6, %%mm0		\n\t""

		""pand %%mm7, %%mm1		\n\t""

		""pand %%mm5, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		MOVNTQ"" %%mm1, 16(%2, %%""REG_a"")\n\t""

		""add $24, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		""2:				\n\t""

		: ""+a"" (mmx_size)

		: ""r"" (src-mmx_size), ""r""(dst-mmx_size)

	);



	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");



	if(mmx_size==23) return; //finihsed, was multiple of 8



	src+= src_size;

	dst+= src_size;

	src_size= 23-mmx_size;

	src-= src_size;

	dst-= src_size;

#endif

	for(i=0; i<src_size; i+=3)

	{

		register uint8_t x;

		x          = src[i + 2];

		dst[i + 1] = src[i + 1];

		dst[i + 2] = src[i + 0];

		dst[i + 0] = x;

	}

}
",1
Detect whether the following code contains vulnerabilities.,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",1
Detect whether the following code contains vulnerabilities.,"GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)

{

    GIOStatus status = G_IO_STATUS_NORMAL;

    size_t count;



    while (size) {

        status = ga_channel_write(c, buf, size, &count);

        if (status == G_IO_STATUS_NORMAL) {

            size -= count;

            buf += count;

        } else if (status != G_IO_STATUS_AGAIN) {

            break;

        }

    }



    return status;

}
",1
Detect whether the following code contains vulnerabilities.,"static int channelmap_query_formats(AVFilterContext *ctx)

{

    ChannelMapContext *s = ctx->priv;



    ff_set_common_formats(ctx, ff_planar_sample_fmts());

    ff_set_common_samplerates(ctx, ff_all_samplerates());

    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);

    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",0
Detect whether the following code contains vulnerabilities.,"int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)

{

    /* On non-x86 we don't do PCI hotplug */

    monitor_printf(mon, ""Can't hot-add drive to type %d\n"", dinfo->type);

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {

  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;

  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = c->srcW;

  const int height = srcSliceH;

  const int lumStride = srcStride[0];

  const int chromStride = srcStride[1];

  const int dstStride = dstStride_a[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int y;



  if(width&15){

    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1) dst is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8

  */



  for(y=0; y<height; y++)

    {

      int i;

      for (i = 0; i < width - 31; i+= 32) {

	const unsigned int j = i >> 1;

	vector unsigned char v_yA = vec_ld(i, ysrc);

	vector unsigned char v_yB = vec_ld(i + 16, ysrc);

	vector unsigned char v_yC = vec_ld(i + 32, ysrc);

	vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);

	vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);

	vector unsigned char v_uA = vec_ld(j, usrc);

	vector unsigned char v_uB = vec_ld(j + 16, usrc);

	vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));

	vector unsigned char v_vA = vec_ld(j, vsrc);

	vector unsigned char v_vB = vec_ld(j + 16, vsrc);

	vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_uv_b = vec_mergel(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);

	vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

	vec_st(v_yuy2_2, (i << 1) + 32, dst);

	vec_st(v_yuy2_3, (i << 1) + 48, dst);

      }

      if (i < width) {

	const unsigned int j = i >> 1;

	vector unsigned char v_y1 = vec_ld(i, ysrc);

	vector unsigned char v_u = vec_ld(j, usrc);

	vector unsigned char v_v = vec_ld(j, vsrc);

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

      }

      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )

	{

	  usrc += chromStride;

	  vsrc += chromStride;

	}

      ysrc += lumStride;

      dst += dstStride;

    }



  return srcSliceH;

}
",1
Detect whether the following code contains vulnerabilities.,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)

{

    uint16_t cmd;

    int i, sz, offset, code;

    unsigned char *dst_end = dst + dst_size;

    const unsigned char *src_end = src + src_size;



    while (src < src_end && dst < dst_end) {

        code = *src++;

        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {

            if (code & (1 << i)) {

                *dst++ = *src++;

            } else {

                cmd = AV_RL16(src); src += 2;

                offset = cmd >> 4;

                sz = (cmd & 0xF) + 2;

                /* don't use memcpy/memmove here as the decoding routine (ab)uses */

                /* buffer overlappings to repeat bytes in the destination */

                sz = FFMIN(sz, dst_end - dst);

                while (sz--) {

                    *dst = *(dst - offset - 1);

                    ++dst;

                }

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)

{

    int i;



    for (i = 0; i < 256; i++) {

        int r, g, b;



        switch (pix_fmt) {

        case AV_PIX_FMT_RGB8:

            r = (i>>5    )*36;

            g = ((i>>2)&7)*36;

            b = (i&3     )*85;

            break;

        case AV_PIX_FMT_BGR8:

            b = (i>>6    )*85;

            g = ((i>>3)&7)*36;

            r = (i&7     )*36;

            break;

        case AV_PIX_FMT_RGB4_BYTE:

            r = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            b = (i&1     )*255;

            break;

        case AV_PIX_FMT_BGR4_BYTE:

            b = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            r = (i&1     )*255;

            break;

        case AV_PIX_FMT_GRAY8:

            r = b = g = i;

            break;

        default:

            return AVERROR(EINVAL);

        }

        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void qmp_transaction(TransactionActionList *dev_list, Error **errp)

{

    TransactionActionList *dev_entry = dev_list;

    BlkTransactionState *state, *next;

    Error *local_err = NULL;



    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;

    QSIMPLEQ_INIT(&snap_bdrv_states);



    /* drain all i/o before any operations */

    bdrv_drain_all();



    /* We don't do anything in this loop that commits us to the operations */

    while (NULL != dev_entry) {

        TransactionAction *dev_info = NULL;

        const BdrvActionOps *ops;



        dev_info = dev_entry->value;

        dev_entry = dev_entry->next;



        assert(dev_info->kind < ARRAY_SIZE(actions));



        ops = &actions[dev_info->kind];

        assert(ops->instance_size > 0);



        state = g_malloc0(ops->instance_size);

        state->ops = ops;

        state->action = dev_info;

        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);



        state->ops->prepare(state, &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            goto delete_and_fail;

        }

    }



    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->commit) {

            state->ops->commit(state);

        }

    }



    /* success */

    goto exit;



delete_and_fail:

    /* failure, and it is all-or-none; roll back all operations */

    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->abort) {

            state->ops->abort(state);

        }

    }

exit:

    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {

        if (state->ops->clean) {

            state->ops->clean(state);

        }

        g_free(state);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int intel_hda_init(PCIDevice *pci)

{

    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);

    uint8_t *conf = d->pci.config;



    d->name = d->pci.qdev.info->name;



    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(conf, 0x2668);

    pci_config_set_revision(conf, 1);

    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);

    pci_config_set_interrupt_pin(conf, 1);



    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */

    conf[0x40] = 0x01;



    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,

                                          intel_hda_mmio_write, d,

                                          DEVICE_NATIVE_ENDIAN);

    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);

    if (d->msi) {

        msi_init(&d->pci, 0x50, 1, true, false);

    }



    hda_codec_bus_init(&d->pci.qdev, &d->codecs,

                       intel_hda_response, intel_hda_xfer);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,

                                     TCGv cmp, int32_t disp)

{

    uint64_t dest = ctx->pc + (disp << 2);

    int lab_true = gen_new_label();



    if (use_goto_tb(ctx, dest)) {

        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);



        tcg_gen_goto_tb(0);

        tcg_gen_movi_i64(cpu_pc, ctx->pc);

        tcg_gen_exit_tb((uintptr_t)ctx->tb);



        gen_set_label(lab_true);

        tcg_gen_goto_tb(1);

        tcg_gen_movi_i64(cpu_pc, dest);

        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);



        return EXIT_GOTO_TB;

    } else {

        TCGv_i64 z = tcg_const_i64(0);

        TCGv_i64 d = tcg_const_i64(dest);

        TCGv_i64 p = tcg_const_i64(ctx->pc);



        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);



        tcg_temp_free_i64(z);

        tcg_temp_free_i64(d);

        tcg_temp_free_i64(p);

        return EXIT_PC_UPDATED;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,

                                 uint32_t token, uint32_t nargs,

                                 target_ulong args,

                                 uint32_t nret, target_ulong rets)

{

    struct tm tm;



    if (nret != 8) {

        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);

        return;

    }



    qemu_get_timedate(&tm, spapr->rtc_offset);



    rtas_st(rets, 0, RTAS_OUT_SUCCESS);

    rtas_st(rets, 1, tm.tm_year + 1900);

    rtas_st(rets, 2, tm.tm_mon + 1);

    rtas_st(rets, 3, tm.tm_mday);

    rtas_st(rets, 4, tm.tm_hour);

    rtas_st(rets, 5, tm.tm_min);

    rtas_st(rets, 6, tm.tm_sec);

    rtas_st(rets, 7, 0); /* we don't do nanoseconds */

}
",1
Detect whether the following code contains vulnerabilities.,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int create_stream(AVFormatContext *s)

{

    XCBGrabContext *c = s->priv_data;

    AVStream *st      = avformat_new_stream(s, NULL);

    xcb_get_geometry_cookie_t gc;

    xcb_get_geometry_reply_t *geo;

    int ret;



    if (!st)

        return AVERROR(ENOMEM);



    ret = av_parse_video_size(&c->width, &c->height, c->video_size);

    if (ret < 0)

        return ret;



    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);

    if (ret < 0)

        return ret;



    avpriv_set_pts_info(st, 64, 1, 1000000);



    gc  = xcb_get_geometry(c->conn, c->screen->root);

    geo = xcb_get_geometry_reply(c->conn, gc, NULL);



    c->width      = FFMIN(geo->width, c->width);

    c->height     = FFMIN(geo->height, c->height);

    c->time_base  = (AVRational){ st->avg_frame_rate.den,

                                  st->avg_frame_rate.num };

    c->time_frame = av_gettime();



    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;

    st->codec->width      = c->width;

    st->codec->height     = c->height;

    st->codec->time_base  = c->time_base;



    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);



    free(geo);



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void process_incoming_migration(QEMUFile *f)

{

    if (qemu_loadvm_state(f) < 0) {

        fprintf(stderr, ""load of migration failed\n"");

        exit(0);

    }

    qemu_announce_self();

    DPRINTF(""successfully loaded vm state\n"");



    incoming_expected = false;



    if (autostart) {

        vm_start();

    } else {

        runstate_set(RSTATE_PRE_LAUNCH);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int rv40_decode_mb_info(RV34DecContext *r)

{

    MpegEncContext *s = &r->s;

    GetBitContext *gb = &s->gb;

    int q, i;

    int prev_type = 0;

    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;

    int blocks[RV34_MB_TYPES] = {0};

    int count = 0;



    if(!r->s.mb_skip_run)

        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;



    if(--r->s.mb_skip_run)

         return RV34_MB_SKIP;



    if(r->avail_cache[6-1])

        blocks[r->mb_type[mb_pos - 1]]++;

    if(r->avail_cache[6-4]){

        blocks[r->mb_type[mb_pos - s->mb_stride]]++;

        if(r->avail_cache[6-2])

            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;

        if(r->avail_cache[6-5])

            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;

    }



    for(i = 0; i < RV34_MB_TYPES; i++){

        if(blocks[i] > count){

            count = blocks[i];

            prev_type = i;

        }

    }

    if(s->pict_type == AV_PICTURE_TYPE_P){

        prev_type = block_num_to_ptype_vlc_num[prev_type];

        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);

        if(q < PBTYPE_ESCAPE)

            return q;

        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);

        av_log(s->avctx, AV_LOG_ERROR, ""Dquant for P-frame\n"");

    }else{

        prev_type = block_num_to_btype_vlc_num[prev_type];

        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);

        if(q < PBTYPE_ESCAPE)

            return q;

        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);

        av_log(s->avctx, AV_LOG_ERROR, ""Dquant for B-frame\n"");

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_presentation_segment(AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size,

                                      int64_t pts)

{

    PGSSubContext *ctx = avctx->priv_data;



    int x, y, ret;



    int w = bytestream_get_be16(&buf);

    int h = bytestream_get_be16(&buf);



    ctx->presentation.pts = pts;



    av_dlog(avctx, ""Video Dimensions %dx%d\n"",

            w, h);

    ret = ff_set_dimensions(avctx, w, h);

    if (ret < 0)

        return ret;



    /* Skip 1 bytes of unknown, frame rate? */

    buf++;



    ctx->presentation.id_number = bytestream_get_be16(&buf);



    /*

     * Skip 3 bytes of unknown:

     *     state

     *     palette_update_flag (0x80),

     *     palette_id_to_use,

     */

    buf += 3;



    ctx->presentation.object_number = bytestream_get_byte(&buf);

    ctx->presentation.composition_flag = 0;

    if (!ctx->presentation.object_number)

        return 0;



    /*

     * Skip 3 bytes of unknown:

     *     object_id_ref (2 bytes),

     *     window_id_ref,

     */

    buf += 3;

    ctx->presentation.composition_flag = bytestream_get_byte(&buf);



    x = bytestream_get_be16(&buf);

    y = bytestream_get_be16(&buf);



    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/



    av_dlog(avctx, ""Subtitle Placement x=%d, y=%d\n"", x, y);



    if (x > avctx->width || y > avctx->height) {

        av_log(avctx, AV_LOG_ERROR, ""Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n"",

               x, y, avctx->width, avctx->height);

        x = 0; y = 0;

    }



    /* Fill in dimensions */

    ctx->presentation.x = x;

    ctx->presentation.y = y;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
",0
Detect whether the following code contains vulnerabilities.,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        float_raise( float_flag_invalid STATUS_VAR);

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
",0
Detect whether the following code contains vulnerabilities.,"static int tpm_passthrough_unix_tx_bufs(int tpm_fd,

                                        const uint8_t *in, uint32_t in_len,

                                        uint8_t *out, uint32_t out_len)

{

    int ret;



    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);

    if (ret != in_len) {

        error_report(""tpm_passthrough: error while transmitting data ""

                     ""to TPM: %s (%i)\n"",

                     strerror(errno), errno);

        goto err_exit;

    }



    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);

    if (ret < 0) {

        error_report(""tpm_passthrough: error while reading data from ""

                     ""TPM: %s (%i)\n"",

                     strerror(errno), errno);

    } else if (ret < sizeof(struct tpm_resp_hdr) ||

               tpm_passthrough_get_size_from_buffer(out) != ret) {

        ret = -1;

        error_report(""tpm_passthrough: received invalid response ""

                     ""packet from TPM\n"");

    }



err_exit:

    if (ret < 0) {

        tpm_write_fatal_error_response(out, out_len);

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                qemu_irq *irq, qemu_irq dma, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static int send_sub_rect(VncState *vs, int x, int y, int w, int h)

{

    VncPalette *palette = &color_count_palette;

    uint32_t bg = 0, fg = 0;

    int colors;

    int ret = 0;

#ifdef CONFIG_VNC_JPEG

    bool force_jpeg = false;

    bool allow_jpeg = true;

#endif



    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);



    vnc_tight_start(vs);

    vnc_raw_send_framebuffer_update(vs, x, y, w, h);

    vnc_tight_stop(vs);



#ifdef CONFIG_VNC_JPEG

    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {

        double freq = vnc_update_freq(vs, x, y, w, h);



        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {

            allow_jpeg = false;

        }

        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {

            force_jpeg = true;

            vnc_sent_lossy_rect(vs, x, y, w, h);

        }

    }

#endif



    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);



#ifdef CONFIG_VNC_JPEG

    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {

        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,

                                 force_jpeg);

    } else {

        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);

    }

#else

    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);

#endif



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
",0
Detect whether the following code contains vulnerabilities.,"void test_fcmp(double a, double b)

{

    long eflags, fpus;



    fpu_clear_exceptions();

    asm(""fcom %2\n""

        ""fstsw %%ax\n""

        : ""=a"" (fpus)

        : ""t"" (a), ""u"" (b));

    printf(""fcom(%f %f)=%04lx \n"",

           a, b, fpus & (0x4500 | FPUS_EMASK));

    fpu_clear_exceptions();

    asm(""fucom %2\n""

        ""fstsw %%ax\n""

        : ""=a"" (fpus)

        : ""t"" (a), ""u"" (b));

    printf(""fucom(%f %f)=%04lx\n"",

           a, b, fpus & (0x4500 | FPUS_EMASK));

    if (TEST_FCOMI) {

        /* test f(u)comi instruction */

        fpu_clear_exceptions();

        asm(""fcomi %3, %2\n""

            ""fstsw %%ax\n""

            ""pushf\n""

            ""pop %0\n""

            : ""=r"" (eflags), ""=a"" (fpus)

            : ""t"" (a), ""u"" (b));

        printf(""fcomi(%f %f)=%04lx %02lx\n"",

               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));

        fpu_clear_exceptions();

        asm(""fucomi %3, %2\n""

            ""fstsw %%ax\n""

            ""pushf\n""

            ""pop %0\n""

            : ""=r"" (eflags), ""=a"" (fpus)

            : ""t"" (a), ""u"" (b));

        printf(""fucomi(%f %f)=%04lx %02lx\n"",

               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));

    }

    fpu_clear_exceptions();

    asm volatile(""fxam\n""

                 ""fstsw %%ax\n""

                 : ""=a"" (fpus)

                 : ""t"" (a));

    printf(""fxam(%f)=%04lx\n"", a, fpus & 0x4700);

    fpu_clear_exceptions();

}
",0
Detect whether the following code contains vulnerabilities.,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
",0
Detect whether the following code contains vulnerabilities.,"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)

{

    CharDriverState *chr = opaque;

    NetCharDriver *s = chr->opaque;

    gsize bytes_read = 0;

    GIOStatus status;



    if (s->max_size == 0)

        return FALSE;

    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),

                                     &bytes_read, NULL);

    s->bufcnt = bytes_read;

    s->bufptr = s->bufcnt;

    if (status != G_IO_STATUS_NORMAL) {

        return FALSE;

    }



    s->bufptr = 0;

    while (s->max_size > 0 && s->bufptr < s->bufcnt) {

        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);

        s->bufptr++;

        s->max_size = qemu_chr_be_can_write(chr);

    }



    return TRUE;

}
",0
Detect whether the following code contains vulnerabilities.,"PCIBus *pci_prep_init(qemu_irq *pic)

{

    PREPPCIState *s;

    PCIDevice *d;

    int PPC_io_memory;



    s = qemu_mallocz(sizeof(PREPPCIState));

    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);



    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);

    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);



    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);

    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);

    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);

    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);

    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);

    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);



    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,

                                           PPC_PCIIO_write, s);

    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);



    /* PCI host bridge */

    d = pci_register_device(s->bus, ""PREP Host Bridge - Motorola Raven"",

                            sizeof(PCIDevice), 0, NULL, NULL);

    d->config[0x00] = 0x57; // vendor_id : Motorola

    d->config[0x01] = 0x10;

    d->config[0x02] = 0x01; // device_id : Raven

    d->config[0x03] = 0x48;

    d->config[0x08] = 0x00; // revision

    d->config[0x0A] = 0x00; // class_sub = pci host

    d->config[0x0B] = 0x06; // class_base = PCI_bridge

    d->config[0x0C] = 0x08; // cache_line_size

    d->config[0x0D] = 0x10; // latency_timer

    d->config[0x0E] = 0x00; // header_type

    d->config[0x34] = 0x00; // capabilities_pointer



    return s->bus;

}
",1
Detect whether the following code contains vulnerabilities.,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int page_unprotect(target_ulong address, uintptr_t pc, void *puc)

{

    unsigned int prot;

    PageDesc *p;

    target_ulong host_start, host_end, addr;



    /* Technically this isn't safe inside a signal handler.  However we

       know this only ever happens in a synchronous SEGV handler, so in

       practice it seems to be ok.  */

    mmap_lock();



    p = page_find(address >> TARGET_PAGE_BITS);

    if (!p) {

        mmap_unlock();

        return 0;

    }



    /* if the page was really writable, then we change its

       protection back to writable */

    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {

        host_start = address & qemu_host_page_mask;

        host_end = host_start + qemu_host_page_size;



        prot = 0;

        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {

            p = page_find(addr >> TARGET_PAGE_BITS);

            p->flags |= PAGE_WRITE;

            prot |= p->flags;



            /* and since the content will be modified, we must invalidate

               the corresponding translated code. */

            tb_invalidate_phys_page(addr, pc, puc);

#ifdef DEBUG_TB_CHECK

            tb_invalidate_check(addr);

#endif

        }

        mprotect((void *)g2h(host_start), qemu_host_page_size,

                 prot & PAGE_BITS);



        mmap_unlock();

        return 1;

    }

    mmap_unlock();

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,

                       unsigned int size, int mem_index)

{

    int l1 = gen_new_label();

    TCGv taddr = tcg_temp_local_new();

    TCGv tval = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    dc->postinc = 0;

    cris_evaluate_flags(dc);



    tcg_gen_mov_tl(taddr, addr);

    tcg_gen_mov_tl(tval, val);



    /* Store only if F flag isn't set */

    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);

    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

    if (size == 1) {

        tcg_gen_qemu_st8(tval, taddr, mem_index);

    } else if (size == 2) {

        tcg_gen_qemu_st16(tval, taddr, mem_index);

    } else {

        tcg_gen_qemu_st32(tval, taddr, mem_index);

    }

    gen_set_label(l1);

    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */

    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/

    tcg_temp_free(t1);

    tcg_temp_free(tval);

    tcg_temp_free(taddr);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
",0
Detect whether the following code contains vulnerabilities.,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *ctx = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = av_frame_copy_props(ctx->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(ctx->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, ctx->tmp_frame);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}
",0
Detect whether the following code contains vulnerabilities.,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;
",1
Detect whether the following code contains vulnerabilities.,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)

{

    if (bin < 7) {

        if ((b0 + 256) == b1)

            a = 384;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else if (bin < 20) {

        if ((b0 + 256) == b1)

            a = 320;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else {

        a = FFMAX(0, a - 128);

    }



    return a;

}
",0
Detect whether the following code contains vulnerabilities.,"static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,

                                                  const char *name,

                                                  BlockDriverState **pbs,

                                                  AioContext **paio,

                                                  Error **errp)

{

    BlockDriverState *bs;

    BdrvDirtyBitmap *bitmap;

    AioContext *aio_context;



    if (!node) {

        error_setg(errp, ""Node cannot be NULL"");

        return NULL;

    }

    if (!name) {

        error_setg(errp, ""Bitmap name cannot be NULL"");

        return NULL;

    }

    bs = bdrv_lookup_bs(node, node, NULL);

    if (!bs) {

        error_setg(errp, ""Node '%s' not found"", node);

        return NULL;

    }



    aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(aio_context);



    bitmap = bdrv_find_dirty_bitmap(bs, name);

    if (!bitmap) {

        error_setg(errp, ""Dirty bitmap '%s' not found"", name);

        goto fail;

    }



    if (pbs) {

        *pbs = bs;

    }

    if (paio) {

        *paio = aio_context;

    } else {

        aio_context_release(aio_context);

    }



    return bitmap;



 fail:

    aio_context_release(aio_context);

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)

{

    int prefix = 0;

    int suffix = 0;

    int last_coeff_abs_level_remaining;

    int i;



    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))

        prefix++;



    if (prefix < 3) {

        for (i = 0; i < rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;

    } else {

        int prefix_minus3 = prefix - 3;



        if (prefix == CABAC_MAX_BIN) {

            av_log(s->avctx, AV_LOG_ERROR, ""CABAC_MAX_BIN : %d\n"", prefix);

            return 0;

        }



        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)

                                              << rc_rice_param) + suffix;

    }

    return last_coeff_abs_level_remaining;

}
",1
Detect whether the following code contains vulnerabilities.,"static int segment_hls_window(AVFormatContext *s, int last)

{

    SegmentContext *seg = s->priv_data;

    int i, ret = 0;

    char buf[1024];



    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,

                              &s->interrupt_callback, NULL)) < 0)

        goto fail;



    avio_printf(seg->pb, ""#EXTM3U\n"");

    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");

    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);

    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",

                FFMAX(0, seg->number - seg->size));



    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",

           FFMAX(0, seg->number - seg->size));



    for (i = FFMAX(0, seg->number - seg->size);

         i < seg->number; i++) {

        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);

        if (seg->entry_prefix) {

            avio_printf(seg->pb, ""%s"", seg->entry_prefix);

        }

        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);

        if (ret < 0) {

            ret = AVERROR(EINVAL);

            goto fail;

        }

        avio_printf(seg->pb, ""%s\n"", buf);

    }



    if (last)

        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");

fail:

    avio_closep(&seg->pb);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)
{
    if (get_bits(&ctx->gb, 5) != 0x1F) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid picture start code!\n"");
        return -1;
    ctx->prev_frame_type = ctx->frame_type;
    ctx->frame_type      = get_bits(&ctx->gb, 3);
    if (ctx->frame_type >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid frame type: %d \n"", ctx->frame_type);
        return -1;
    ctx->frame_num = get_bits(&ctx->gb, 8);
    if (ctx->frame_type == FRAMETYPE_INTRA) {
        ctx->gop_invalid = 1;
        if (decode_gop_header(ctx, avctx))
            return -1;
        ctx->gop_invalid = 0;
    if (ctx->frame_type != FRAMETYPE_NULL) {
        ctx->frame_flags = get_bits(&ctx->gb, 8);
        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;
        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;
        /* skip unknown extension if any */
        if (ctx->frame_flags & 0x20)
            skip_hdr_extension(&ctx->gb); /* XXX: untested */
        /* decode macroblock huffman codebook */
        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))
            return -1;
        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */
    align_get_bits(&ctx->gb);
    return 0;",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 

                    offsetof(CPUX86State,segs[seg_reg].selector));

    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], cpu_env, 

                  offsetof(CPUX86State,segs[seg_reg].base));

}
",0
Detect whether the following code contains vulnerabilities.,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,

                                        QGuestAllocator *alloc, uint16_t entry)

{

    uint16_t vector;

    uint32_t control;

    void *addr;



    g_assert(d->pdev->msix_enabled);

    addr = d->pdev->msix_table + (entry * 16);



    g_assert_cmpint(entry, >=, 0);

    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));

    d->config_msix_entry = entry;



    d->config_msix_data = 0x12345678;

    d->config_msix_addr = guest_alloc(alloc, 4);



    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    d->config_msix_addr & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (d->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);



    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,

                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);



    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);

    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);

    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_rdhwr(DisasContext *ctx, int rt, int rd)

{

    TCGv t0;



#if !defined(CONFIG_USER_ONLY)

    /* The Linux kernel will emulate rdhwr if it's not supported natively.

       Therefore only check the ISA in system mode.  */

    check_insn(ctx, ISA_MIPS32R2);

#endif

    t0 = tcg_temp_new();



    switch (rd) {

    case 0:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_cpunum(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 1:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_synci_step(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 2:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_cc(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 3:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_ccres(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 29:

#if defined(CONFIG_USER_ONLY)

        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));

        gen_store_gpr(t0, rt);

        break;

#else

        /* XXX: Some CPUs implement this in hardware.

           Not supported yet. */

#endif

    default:            /* Invalid */

        MIPS_INVAL(""rdhwr"");

        generate_exception(ctx, EXCP_RI);

        break;

    }

    tcg_temp_free(t0);

}
",1
Detect whether the following code contains vulnerabilities.,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
",1
Detect whether the following code contains vulnerabilities.,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}
",1
Detect whether the following code contains vulnerabilities.,"static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&s->picture;



    s->frame_width = avctx->width;

    s->frame_height = avctx->height;



    s->y_block_width = (s->frame_width + 15) / 16;

    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    s->c_block_height = (s->frame_height / 4 + 15) / 16;



    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void csrhci_reset(struct csrhci_s *s)

{

    s->out_len = 0;

    s->out_size = FIFO_LEN;

    s->in_len = 0;

    s->baud_delay = NANOSECONDS_PER_SECOND;

    s->enable = 0;

    s->in_hdr = INT_MAX;

    s->in_data = INT_MAX;



    s->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    s->modem_state |= CHR_TIOCM_CTS;



    memset(&s->bd_addr, 0, sizeof(bdaddr_t));

}
",1
Detect whether the following code contains vulnerabilities.,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",1
Detect whether the following code contains vulnerabilities.,"int net_init_vhost_user(const Netdev *netdev, const char *name,

                        NetClientState *peer, Error **errp)

{

    int queues;

    const NetdevVhostUserOptions *vhost_user_opts;

    CharDriverState *chr;



    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);

    vhost_user_opts = &netdev->u.vhost_user;



    chr = net_vhost_parse_chardev(vhost_user_opts, errp);

    if (!chr) {

        return -1;

    }



    /* verify net frontend */

    if (qemu_opts_foreach(qemu_find_opts(""device""), net_vhost_check_net,

                          (char *)name, errp)) {

        return -1;

    }



    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;

    if (queues < 1 || queues > MAX_QUEUE_NUM) {

        error_setg(errp,

                   ""vhost-user number of queues must be in range [1, %d]"",

                   MAX_QUEUE_NUM);

        return -1;

    }



    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);

}
",1
Detect whether the following code contains vulnerabilities.,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void check_add_res(HEVCDSPContext h, int bit_depth)

{

    int i;

    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);

    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);

    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);

    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);



    for (i = 2; i <= 5; i++) {

        int block_size = 1 << i;

        int size = block_size * block_size;

        ptrdiff_t stride = block_size << (bit_depth > 8);

        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);



        randomize_buffers(res0, size);

        randomize_buffers2(dst0, size);

        memcpy(res1, res0, sizeof(*res0) * size);

        memcpy(dst1, dst0, size);



        if (check_func(h.add_residual[i - 2], ""add_res_%dx%d_%d"", block_size, block_size, bit_depth)) {

            call_ref(dst0, res0, stride);

            call_new(dst1, res1, stride);

            if (memcmp(dst0, dst1, size))

                fail();

            bench_new(dst1, res1, stride);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
",0
Detect whether the following code contains vulnerabilities.,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

#if defined(DEBUG_MMU)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        tlb_flush(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        env->hflags |= HF_OSFXSR_MASK;

    else

        env->hflags &= ~HF_OSFXSR_MASK;



    env->cr[4] = new_cr4;

}
",0
Detect whether the following code contains vulnerabilities.,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                              const AVFrame *pict, int *got_packet)

{

    LJpegEncContext *s = avctx->priv_data;

    PutBitContext pb;

    const int width  = avctx->width;

    const int height = avctx->height;

    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];

    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];

    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;

    int ret, header_bits;



    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)

        max_pkt_size += width * height * 3 * 3;

    else {

        max_pkt_size += mb_width * mb_height * 3 * 4

                        * s->hsample[0] * s->vsample[0];

    }

    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet of size %d.\n"", max_pkt_size);

        return ret;

    }



    init_put_bits(&pb, pkt->data, pkt->size);



    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,

                                   s->matrix);



    header_bits = put_bits_count(&pb);



    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)

        ret = ljpeg_encode_bgr(avctx, &pb, pict);

    else

        ret = ljpeg_encode_yuv(avctx, &pb, pict);

    if (ret < 0)

        return ret;



    emms_c();



    ff_mjpeg_encode_picture_trailer(&pb, header_bits);



    flush_put_bits(&pb);

    pkt->size   = put_bits_ptr(&pb) - pb.buf;

    pkt->flags |= AV_PKT_FLAG_KEY;

    *got_packet = 1;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)

{

    trace_qxl_spice_monitors_config(qxl->id);

    if (replay) {

        /*

         * don't use QXL_COOKIE_TYPE_IO:

         *  - we are not running yet (post_load), we will assert

         *    in send_events

         *  - this is not a guest io, but a reply, so async_io isn't set.

         */

        spice_qxl_monitors_config_async(&qxl->ssd.qxl,

                qxl->guest_monitors_config,

                MEMSLOT_GROUP_GUEST,

                (uintptr_t)qxl_cookie_new(

                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,

                    0));

    } else {

#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */

        if (qxl->max_outputs) {

            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,

                                                qxl->max_outputs);

        }

#endif

        qxl->guest_monitors_config = qxl->ram->monitors_config;

        spice_qxl_monitors_config_async(&qxl->ssd.qxl,

                qxl->ram->monitors_config,

                MEMSLOT_GROUP_GUEST,

                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,

                                          QXL_IO_MONITORS_CONFIG_ASYNC));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
",0
Detect whether the following code contains vulnerabilities.,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void frame_start(H264Context *h){

    MpegEncContext * const s = &h->s;

    int i;



    MPV_frame_start(s, s->avctx);

    ff_er_frame_start(s);



    assert(s->linesize && s->uvlinesize);



    for(i=0; i<16; i++){

        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);

        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);

    }

    for(i=0; i<4; i++){

        h->block_offset[16+i]=

        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);

        h->block_offset[24+16+i]=

        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);

    }



    /* can't be in alloc_tables because linesize isn't known there.

     * FIXME: redo bipred weight to not require extra buffer? */

    if(!s->obmc_scratchpad)

        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);



//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",1
Detect whether the following code contains vulnerabilities.,"void qmp_guest_file_flush(int64_t handle, Error **errp)

{

    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);

    FILE *fh;

    int ret;



    if (!gfh) {

        return;

    }



    fh = gfh->fh;

    ret = fflush(fh);

    if (ret == EOF) {

        error_setg_errno(errp, errno, ""failed to flush file"");



    }

}",1
Detect whether the following code contains vulnerabilities.,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    int j, old_ref, rfield;

    int start= mbafi ? 16                      : 0;

    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];

    int interl= mbafi || s->picture_structure != PICT_FRAME;



    /* bogus; fills in for missing frames */

    memset(map[list], 0, sizeof(map[list]));



    for(rfield=0; rfield<2; rfield++){

        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){

            int poc = ref1->ref_poc[colfield][list][old_ref];



            if     (!interl)

                poc |= 3;

            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed

                poc= (poc&~3) + rfield + 1;



            for(j=start; j<end; j++){

                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {

                    int cur_ref= mbafi ? (j-16)^field : j;

                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;

                    if(rfield == field || !interl)

                        map[list][old_ref] = cur_ref;

                    break;

                }

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)

{

    BlockDriver *drv = bs->drv;

    if (!drv) {

        return -ENOMEDIUM;

    }

    if (drv->bdrv_snapshot_delete) {

        return drv->bdrv_snapshot_delete(bs, snapshot_id);

    }

    if (bs->file) {

        return bdrv_snapshot_delete(bs->file, snapshot_id);

    }

    return -ENOTSUP;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)

{

    uint32_t val;



    val = bswap32(cpu_inl(addr & IOPORTS_MASK));

    return val;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qemu_fill_buffer(QEMUFile *f)

{

    int len;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fseek(f->outfile, f->buf_offset, SEEK_SET);

        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (len < 0)

            len = 0;

    }

    f->buf_index = 0;

    f->buf_size = len;

    f->buf_offset += len;

}
",0
Detect whether the following code contains vulnerabilities.,"void net_hub_check_clients(void)

{

    NetHub *hub;

    NetHubPort *port;

    NetClientState *peer;



    QLIST_FOREACH(hub, &hubs, next) {

        int has_nic = 0, has_host_dev = 0;



        QLIST_FOREACH(port, &hub->ports, next) {

            peer = port->nc.peer;

            if (!peer) {

                fprintf(stderr, ""Warning: hub port %s has no peer\n"",

                        port->nc.name);

                continue;

            }



            switch (peer->info->type) {

            case NET_CLIENT_DRIVER_NIC:

                has_nic = 1;

                break;

            case NET_CLIENT_DRIVER_USER:

            case NET_CLIENT_DRIVER_TAP:

            case NET_CLIENT_DRIVER_SOCKET:

            case NET_CLIENT_DRIVER_VDE:

            case NET_CLIENT_DRIVER_VHOST_USER:

                has_host_dev = 1;

                break;

            default:

                break;

            }

        }

        if (has_host_dev && !has_nic) {

            warn_report(""vlan %d with no nics"", hub->id);

        }

        if (has_nic && !has_host_dev) {

            fprintf(stderr,

                    ""Warning: vlan %d is not connected to host network\n"",

                    hub->id);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"DVDemuxContext* dv_init_demux(AVFormatContext *s)

{

    DVDemuxContext *c;



    c = av_mallocz(sizeof(DVDemuxContext));

    if (!c)

        return NULL;



    c->vst = av_new_stream(s, 0);

    c->ast[0] = av_new_stream(s, 0);

    if (!c->vst || !c->ast[0])

        goto fail;

    av_set_pts_info(c->vst, 64, 1, 30000);

    av_set_pts_info(c->ast[0], 64, 1, 30000);



    c->fctx = s;

    c->ast[1] = NULL;

    c->ach = 0;

    c->frames = 0;

    c->abytes = 0;

    c->audio_pkt[0].size = 0;

    c->audio_pkt[1].size = 0;

    

    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;

    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;

    c->vst->codec.bit_rate = 25000000;

    

    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;

    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;

   

    s->ctx_flags |= AVFMTCTX_NOHEADER; 

    

    return c;

    

fail:

    if (c->vst)

        av_free(c->vst);

    if (c->ast[0])

        av_free(c->ast[0]);

    av_free(c);

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",0
Detect whether the following code contains vulnerabilities.,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tosa_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *rom = g_new(MemoryRegion, 1);

    PXA2xxState *mpu;

    TC6393xbState *tmio;

    DeviceState *scp0, *scp1;



    if (!cpu_model)

        cpu_model = ""pxa255"";



    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);



    memory_region_init_ram(rom, NULL, ""tosa.rom"", TOSA_ROM, &error_abort);

    vmstate_register_ram_global(rom);

    memory_region_set_readonly(rom, true);

    memory_region_add_subregion(address_space_mem, 0, rom);



    tmio = tc6393xb_init(address_space_mem, 0x10000000,

            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));



    scp0 = sysbus_create_simple(""scoop"", 0x08800000, NULL);

    scp1 = sysbus_create_simple(""scoop"", 0x14800040, NULL);



    tosa_gpio_setup(mpu, scp0, scp1, tmio);



    tosa_microdrive_attach(mpu);



    tosa_tg_init(mpu);



    tosa_binfo.kernel_filename = kernel_filename;

    tosa_binfo.kernel_cmdline = kernel_cmdline;

    tosa_binfo.initrd_filename = initrd_filename;

    tosa_binfo.board_id = 0x208;

    arm_load_kernel(mpu->cpu, &tosa_binfo);

    sl_bootparam_write(SL_PXA_PARAM_BASE);

}
",1
Detect whether the following code contains vulnerabilities.,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",1
Detect whether the following code contains vulnerabilities.,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)

{

    VHDDynDiskHeader *dyndisk_header =

        (VHDDynDiskHeader *) buf;

    size_t block_size, num_bat_entries;

    int i;

    int ret = -EIO;



    // Write the footer (twice: at the beginning and at the end)

    block_size = 0x200000;

    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);



    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {

        goto fail;

    }

    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    // Write the initial BAT

    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {

        goto fail;

    }



    memset(buf, 0xFF, 512);

    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {

        if (write(fd, buf, 512) != 512) {

            goto fail;

        }

    }



    // Prepare the Dynamic Disk Header

    memset(buf, 0, 1024);



    memcpy(dyndisk_header->magic, ""cxsparse"", 8);



    /*

     * Note: The spec is actually wrong here for data_offset, it says

     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.

     */

    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);

    dyndisk_header->table_offset = be64_to_cpu(3 * 512);

    dyndisk_header->version = be32_to_cpu(0x00010000);

    dyndisk_header->block_size = be32_to_cpu(block_size);

    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);



    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));



    // Write the header

    if (lseek(fd, 512, SEEK_SET) < 0) {

        goto fail;

    }



    if (write(fd, buf, 1024) != 1024) {

        goto fail;

    }

    ret = 0;



 fail:

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int qemu_rbd_snap_list(BlockDriverState *bs,

                              QEMUSnapshotInfo **psn_tab)

{

    BDRVRBDState *s = bs->opaque;

    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;

    int i, snap_count;

    rbd_snap_info_t *snaps;

    int max_snaps = RBD_MAX_SNAPS;



    do {

        snaps = g_malloc(sizeof(*snaps) * max_snaps);

        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);

        if (snap_count < 0) {

            g_free(snaps);

        }

    } while (snap_count == -ERANGE);



    if (snap_count <= 0) {

        return snap_count;

    }



    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));



    for (i = 0; i < snap_count; i++) {

        const char *snap_name = snaps[i].name;



        sn_info = sn_tab + i;

        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);

        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);



        sn_info->vm_state_size = snaps[i].size;

        sn_info->date_sec = 0;

        sn_info->date_nsec = 0;

        sn_info->vm_clock_nsec = 0;

    }

    rbd_snap_list_end(snaps);



    *psn_tab = sn_tab;

    return snap_count;

}
",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,

                           uint64_t off, uint32_t max_count)

{

    ssize_t err;

    size_t offset = 7;

    int read_count;

    int64_t xattr_len;

    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);

    VirtQueueElement *elem = v->elems[pdu->idx];



    xattr_len = fidp->fs.xattr.len;

    read_count = xattr_len - off;

    if (read_count > max_count) {

        read_count = max_count;

    } else if (read_count < 0) {

        /*

         * read beyond XATTR value

         */

        read_count = 0;

    }

    err = pdu_marshal(pdu, offset, ""d"", read_count);

    if (err < 0) {

        return err;

    }

    offset += err;



    err = v9fs_pack(elem->in_sg, elem->in_num, offset,

                    ((char *)fidp->fs.xattr.value) + off,

                    read_count);

    if (err < 0) {

        return err;

    }

    offset += err;

    return offset;

}
",1
Detect whether the following code contains vulnerabilities.,"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,

                                      const uint8_t *buf, int nb_sectors)

{

    int ret;

    BDRVVmdkState *s = bs->opaque;

    qemu_co_mutex_lock(&s->lock);

    ret = vmdk_write(bs, sector_num, buf, nb_sectors);

    qemu_co_mutex_unlock(&s->lock);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {

    float enc_window[256];

    int i;



    /* Generate the mdct window, for details see

     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */

    for (i=0 ; i<256; i++)

        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;



    if (!mdct_window[0])

        for (i=0 ; i<256; i++) {

            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);

            mdct_window[511-i] = mdct_window[i];

        }



    /* Initialize the MDCT transform. */

    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
",1
Detect whether the following code contains vulnerabilities.,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,

                                    AVPacket *pkt, uint64_t display_duration)

{

    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;

    for (; *ptr!=',' && ptr<end-1; ptr++);

    if (*ptr == ',')

        layer = ++ptr;

    for (; *ptr!=',' && ptr<end-1; ptr++);

    if (*ptr == ',') {

        int64_t end_pts = pkt->pts + display_duration;

        int sc = matroska->time_scale * pkt->pts / 10000000;

        int ec = matroska->time_scale * end_pts  / 10000000;

        int sh, sm, ss, eh, em, es, len;

        sh = sc/360000;  sc -= 360000*sh;

        sm = sc/  6000;  sc -=   6000*sm;

        ss = sc/   100;  sc -=    100*ss;

        eh = ec/360000;  ec -= 360000*eh;

        em = ec/  6000;  ec -=   6000*em;

        es = ec/   100;  ec -=    100*es;

        *ptr++ = '\0';

        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;

        if (!(line = av_malloc(len)))

            return;

        snprintf(line,len,""Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s"",

                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);

        av_free(pkt->data);

        pkt->data = line;

        pkt->size = strlen(line);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_vc1_decode_blocks(VC1Context *v)

{



    v->s.esc3_level_length = 0;

    if (v->x8_type) {

        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);



        ff_er_add_slice(&v->s.er, 0, 0,

                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,

                        ER_MB_END);

    } else {

        v->cur_blk_idx     =  0;

        v->left_blk_idx    = -1;

        v->topleft_blk_idx =  1;

        v->top_blk_idx     =  2;

        switch (v->s.pict_type) {

        case AV_PICTURE_TYPE_I:

            if (v->profile == PROFILE_ADVANCED)

                vc1_decode_i_blocks_adv(v);

            else

                vc1_decode_i_blocks(v);

            break;

        case AV_PICTURE_TYPE_P:

            if (v->p_frame_skipped)

                vc1_decode_skip_blocks(v);

            else

                vc1_decode_p_blocks(v);

            break;

        case AV_PICTURE_TYPE_B:

            if (v->bi_type) {

                if (v->profile == PROFILE_ADVANCED)

                    vc1_decode_i_blocks_adv(v);

                else

                    vc1_decode_i_blocks(v);

            } else

                vc1_decode_b_blocks(v);

            break;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"paint_mouse_pointer(XImage *image, struct x11_grab *s)

{

    int x_off = s->x_off;

    int y_off = s->y_off;

    int width = s->width;

    int height = s->height;

    Display *dpy = s->dpy;

    XFixesCursorImage *xcim;

    int x, y;

    int line, column;

    int to_line, to_column;

    int image_addr, xcim_addr;



    xcim = XFixesGetCursorImage(dpy);



    x = xcim->x - xcim->xhot;

    y = xcim->y - xcim->yhot;



    to_line = FFMIN((y + xcim->height), (height + y_off));

    to_column = FFMIN((x + xcim->width), (width + x_off));



    for (line = FFMAX(y, y_off); line < to_line; line++) {

        for (column = FFMAX(x, x_off); column < to_column; column++) {

            xcim_addr = (line - y) * xcim->width + column - x;



            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel

                image_addr = ((line - y_off) * width + column - x_off) * 4;



                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);

                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);

                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);

            }

        }

    }



    XFree(xcim);

    xcim = NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t boston_platreg_read(void *opaque, hwaddr addr,

                                    unsigned size)

{

    BostonState *s = opaque;

    uint32_t gic_freq, val;



    if (size != 4) {

        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);

        return 0;

    }



    switch (addr & 0xffff) {

    case PLAT_FPGA_BUILD:

    case PLAT_CORE_CL:

    case PLAT_WRAPPER_CL:

        return 0;

    case PLAT_DDR3_STATUS:

        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;

    case PLAT_MMCM_DIV:

        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;

        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;

        return val;

    case PLAT_BUILD_CFG:

        val = PLAT_BUILD_CFG_PCIE0_EN;

        val |= PLAT_BUILD_CFG_PCIE1_EN;

        val |= PLAT_BUILD_CFG_PCIE2_EN;

        return val;

    case PLAT_DDR_CFG:

        val = s->mach->ram_size / G_BYTE;

        assert(!(val & ~PLAT_DDR_CFG_SIZE));

        val |= PLAT_DDR_CFG_MHZ;

        return val;

    default:

        qemu_log_mask(LOG_UNIMP, ""Read platform register 0x%"" HWADDR_PRIx,

                      addr & 0xffff);

        return 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,

                                             ptrdiff_t buf_stride,

                                             ptrdiff_t src_stride,

                                             int block_w, int block_h,

                                             int src_x, int src_y, int w, int h)

{

    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,

                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,

                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);

}
",0
Detect whether the following code contains vulnerabilities.,"static void msmouse_chr_close (struct CharDriverState *chr)

{

    MouseState *mouse = chr->opaque;



    qemu_input_handler_unregister(mouse->hs);

    g_free(mouse);

    g_free(chr);

}
",1
Detect whether the following code contains vulnerabilities.,"int qemu_init_main_loop(void)

{

    int ret;



    ret = qemu_signal_init();

    if (ret) {

        return ret;

    }



    qemu_init_sigbus();



    return qemu_event_init();

}
",1
Detect whether the following code contains vulnerabilities.,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t ac;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(block, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        ac = get_sbits(gb, 2);

        if (ac == -2)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        ac = get_sbits(gb, 4);

        if (ac == -8)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 8 bits per coefficient

    ALIGN(8);

    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)


    while (coeff) {

        ac = get_sbits(gb, 8);

        PUT_COEFF(ac);

    }



    PUT_COEFF(dc);

    return 1;

}",1
Detect whether the following code contains vulnerabilities.,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
",1
Detect whether the following code contains vulnerabilities.,"static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)

{

    if (buf_size < 13)

        return AVERROR_INVALIDDATA;

    if (memcmp(buf, ""FLV"", 3))

        return AVERROR_INVALIDDATA;

    buf      += 13;

    buf_size -= 13;

    while (buf_size >= 11 + 4) {

        int type = buf[0];

        int size = AV_RB24(&buf[1]) + 11 + 4;

        if (size > buf_size)

            return AVERROR_INVALIDDATA;

        if (type == 8 || type == 9) {

            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))

                return AVERROR_INVALIDDATA;

            os->extra_packet_sizes[os->nb_extra_packets] = size;

            os->extra_packets[os->nb_extra_packets] = av_malloc(size);

            if (!os->extra_packets[os->nb_extra_packets])

                return AVERROR(ENOMEM);

            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);

            os->nb_extra_packets++;

        } else if (type == 0x12) {

            if (os->metadata)

                return AVERROR_INVALIDDATA;

            os->metadata_size = size - 11 - 4;

            os->metadata      = av_malloc(os->metadata_size);

            if (!os->metadata)

                return AVERROR(ENOMEM);

            memcpy(os->metadata, buf + 11, os->metadata_size);

        }

        buf      += size;

        buf_size -= size;

    }

    if (!os->metadata)

        return AVERROR_INVALIDDATA;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)

{

    int err = 0;

    int i;



    __get_user(regs->CP0_EPC, &sc->sc_pc);



    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);

    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);



    for (i = 1; i < 32; ++i) {

        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);

    }



    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);

    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);

    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);

    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);

    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);

    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);

    {

        uint32_t dsp;

        __get_user(dsp, &sc->sc_dsp);

        cpu_wrdsp(dsp, 0x3ff, regs);

    }



    for (i = 0; i < 32; ++i) {

        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);

    }



    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"static void sdhci_write_block_to_card(SDHCIState *s)

{

    int index = 0;



    if (s->prnsts & SDHC_SPACE_AVAILABLE) {

        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {

            s->norintsts |= SDHC_NIS_WBUFRDY;

        }

        sdhci_update_irq(s);

        return;

    }



    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {

        if (s->blkcnt == 0) {

            return;

        } else {

            s->blkcnt--;

        }

    }



    for (index = 0; index < (s->blksize & 0x0fff); index++) {

        sd_write_data(s->card, s->fifo_buffer[index]);

    }



    /* Next data can be written through BUFFER DATORT register */

    s->prnsts |= SDHC_SPACE_AVAILABLE;



    /* Finish transfer if that was the last block of data */

    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||

            ((s->trnmod & SDHC_TRNS_MULTI) &&

            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {

        SDHCI_GET_CLASS(s)->end_data_transfer(s);

    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {

        s->norintsts |= SDHC_NIS_WBUFRDY;

    }



    /* Generate Block Gap Event if requested and if not the last block */

    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&

            s->blkcnt > 0) {

        s->prnsts &= ~SDHC_DOING_WRITE;

        if (s->norintstsen & SDHC_EISEN_BLKGAP) {

            s->norintsts |= SDHC_EIS_BLKGAP;

        }

        SDHCI_GET_CLASS(s)->end_data_transfer(s);

    }



    sdhci_update_irq(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static AHCIQState *ahci_boot(void)

{

    AHCIQState *s;

    const char *cli;



    s = g_malloc0(sizeof(AHCIQState));



    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    s->dev = get_ahci_device(&s->fingerprint);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"mst_fpga_readb(void *opaque, target_phys_addr_t addr)

{

	mst_irq_state *s = (mst_irq_state *) opaque;



	switch (addr) {

	case MST_LEDDAT1:

		return s->leddat1;

	case MST_LEDDAT2:

		return s->leddat2;

	case MST_LEDCTRL:

		return s->ledctrl;

	case MST_GPSWR:

		return s->gpswr;

	case MST_MSCWR1:

		return s->mscwr1;

	case MST_MSCWR2:

		return s->mscwr2;

	case MST_MSCWR3:

		return s->mscwr3;

	case MST_MSCRD:

		return s->mscrd;

	case MST_INTMSKENA:

		return s->intmskena;

	case MST_INTSETCLR:

		return s->intsetclr;

	case MST_PCMCIA0:

		return s->pcmcia0;

	case MST_PCMCIA1:

		return s->pcmcia1;

	default:

		printf(""Mainstone - mst_fpga_readb: Bad register offset ""

			""0x"" TARGET_FMT_plx "" \n"", addr);

	}

	return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)

{

    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);

    int ret;



    if (nvram->blk) {

        nvram->size = blk_getlength(nvram->blk);



        ret = blk_set_perm(nvram->blk,

                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,

                           BLK_PERM_ALL, errp);

        if (ret < 0) {

            return;

        }

    } else {

        nvram->size = DEFAULT_NVRAM_SIZE;

    }



    nvram->buf = g_malloc0(nvram->size);



    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {

        error_setg(errp, ""spapr-nvram must be between %d and %d bytes in size"",

                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);

        return;

    }



    if (nvram->blk) {

        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);



        if (alen != nvram->size) {

            error_setg(errp, ""can't read spapr-nvram contents"");

            return;

        }

    } else if (nb_prom_envs > 0) {

        /* Create a system partition to pass the -prom-env variables */

        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);

        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],

                                         nvram->size - MIN_NVRAM_SIZE / 4);

    }



    spapr_rtas_register(RTAS_NVRAM_FETCH, ""nvram-fetch"", rtas_nvram_fetch);

    spapr_rtas_register(RTAS_NVRAM_STORE, ""nvram-store"", rtas_nvram_store);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);












    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstU, dstV, src1, width);

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!blk->conf.bs) {

        error_report(""drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(blk->conf.bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!blk->serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(blk->conf.bs);

        if (*dinfo->serial) {

            blk->serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = blk->conf.bs;

    s->conf = &blk->conf;

    s->blk = blk;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(s->conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",0
Detect whether the following code contains vulnerabilities.,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,

                             uint64_t value)

{

    if (ri->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[ri->crm] = value;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)

{

    return telldir(fs->dir);

}
",0
Detect whether the following code contains vulnerabilities.,"static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)

{

    AResampleContext *aresample = inlink->dst->priv;

    const int n_in  = insamplesref->audio->nb_samples;

    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);

    AVFilterLink *const outlink = inlink->dst->outputs[0];

    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);

    int ret;



    if(!outsamplesref)

        return AVERROR(ENOMEM);



    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);

    outsamplesref->format                = outlink->format;

    outsamplesref->audio->channel_layout = outlink->channel_layout;

    outsamplesref->audio->sample_rate    = outlink->sample_rate;



    if(insamplesref->pts != AV_NOPTS_VALUE) {

        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);

        int64_t outpts= swr_next_pts(aresample->swr, inpts);

        aresample->next_pts =

        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;

    } else {

        outsamplesref->pts  = AV_NOPTS_VALUE;

    }



    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,

                                 (void *)insamplesref->extended_data, n_in);

    if (n_out <= 0) {

        avfilter_unref_buffer(outsamplesref);

        avfilter_unref_buffer(insamplesref);

        return 0;

    }



    outsamplesref->audio->nb_samples  = n_out;



    ret = ff_filter_samples(outlink, outsamplesref);

    aresample->req_fullfilled= 1;

    avfilter_unref_buffer(insamplesref);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];

    MOVStreamContext *sc = st->priv_data;

    unsigned int i, entries;



    get_byte(pb); /* version */

    get_be24(pb); /* flags */

    entries = get_be32(pb);

    if(entries >= UINT_MAX / sizeof(MOV_stts_t))

        return -1;



    sc->ctts_count = entries;

    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));

    if (!sc->ctts_data)

        return -1;

    dprintf(c->fc, ""track[%i].ctts.entries = %i\n"", c->fc->nb_streams-1, entries);



    for(i=0; i<entries; i++) {

        int count    =get_be32(pb);

        int duration =get_be32(pb);



        if (duration < 0) {

            av_log(c->fc, AV_LOG_ERROR, ""negative ctts, ignoring\n"");

            sc->ctts_count = 0;

            url_fskip(pb, 8 * (entries - i - 1));

            break;

        }

        sc->ctts_data[i].count   = count;

        sc->ctts_data[i].duration= duration;



        sc->time_rate= ff_gcd(sc->time_rate, duration);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",1
Detect whether the following code contains vulnerabilities.,"void commit_active_start(BlockDriverState *bs, BlockDriverState *base,

                         int64_t speed,

                         BlockdevOnError on_error,

                         BlockDriverCompletionFunc *cb,

                         void *opaque, Error **errp)

{

    int64_t length, base_length;

    int orig_base_flags;



    orig_base_flags = bdrv_get_flags(base);



    if (bdrv_reopen(base, bs->open_flags, errp)) {

        return;

    }



    length = bdrv_getlength(bs);

    if (length < 0) {

        error_setg(errp, ""Unable to determine length of %s"", bs->filename);

        goto error_restore_flags;

    }



    base_length = bdrv_getlength(base);

    if (base_length < 0) {

        error_setg(errp, ""Unable to determine length of %s"", base->filename);

        goto error_restore_flags;

    }



    if (length > base_length) {

        if (bdrv_truncate(base, length) < 0) {

            error_setg(errp, ""Top image %s is larger than base image %s, and ""

                             ""resize of base image failed"",

                             bs->filename, base->filename);

            goto error_restore_flags;

        }

    }



    bdrv_ref(base);

    mirror_start_job(bs, base, speed, 0, 0,

                     on_error, on_error, cb, opaque, errp,

                     &commit_active_job_driver, false, base);

    if (error_is_set(errp)) {

        goto error_restore_flags;

    }



    return;



error_restore_flags:

    /* ignore error and errp for bdrv_reopen, because we want to propagate

     * the original error */

    bdrv_reopen(base, orig_base_flags, NULL);

    return;

}
",1
Detect whether the following code contains vulnerabilities.,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_serial_init_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);

    VirtIODevice *vdev;



    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&

        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */

        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */

        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;



    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);

    if (!vdev) {

        return -1;

    }

    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED

                                        ? proxy->serial.max_virtserial_ports + 1

                                        : proxy->nvectors;

    virtio_init_pci(proxy, vdev,

                    PCI_VENDOR_ID_REDHAT_QUMRANET,

                    PCI_DEVICE_ID_VIRTIO_CONSOLE,

                    proxy->class_code, 0x00);

    proxy->nvectors = vdev->nvectors;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (fd < 0) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

}
",0
Detect whether the following code contains vulnerabilities.,"void alpha_pci_vga_setup(PCIBus *pci_bus)

{

    switch (vga_interface_type) {

#ifdef CONFIG_SPICE

    case VGA_QXL:

        pci_create_simple(pci_bus, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        pci_cirrus_vga_init(pci_bus);

        return;

    case VGA_VMWARE:

        if (pci_vmsvga_init(pci_bus)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != VGA_NONE) {

        pci_vga_init(pci_bus);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)

{

    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);

    struct omap_uart_s *s = omap_uart_init(base, irq,

                    fclk, iclk, txdma, rxdma, chr);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    omap_uart_writefn, s);



    s->ta = ta;

    s->base = base;



    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)

{

    target_ulong old, val, mask;

    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;

    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {

        mask |= 1 << CP0EnHi_EHINV;

    }



    /* 1k pages not implemented */

#if defined(TARGET_MIPS64)

    if (env->insn_flags & ISA_MIPS32R6) {

        int entryhi_r = extract64(arg1, 62, 2);

        int config0_at = extract32(env->CP0_Config0, 13, 2);

        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;

        if ((entryhi_r == 2) ||

            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {

            /* skip EntryHi.R field if new value is reserved */

            mask &= ~(0x3ull << 62);

        }

    }

    mask &= env->SEGMask;

#endif

    old = env->CP0_EntryHi;

    val = (arg1 & mask) | (old & ~mask);

    env->CP0_EntryHi = val;

    if (env->CP0_Config3 & (1 << CP0C3_MT)) {

        sync_c0_entryhi(env, env->current_tc);

    }

    /* If the ASID changes, flush qemu's TLB.  */

    if ((old & env->CP0_EntryHi_ASID_mask) !=

        (val & env->CP0_EntryHi_ASID_mask)) {

        cpu_mips_tlb_flush(env);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
",1
Detect whether the following code contains vulnerabilities.,"ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)

{

    ram_addr_t ram_addr;



    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {

        fprintf(stderr, ""Bad ram pointer %p\n"", ptr);

        abort();

    }

    return ram_addr;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
",0
Detect whether the following code contains vulnerabilities.,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",1
Detect whether the following code contains vulnerabilities.,"qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;

    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(QIO_CHANNEL(wsource->wioc),

                   (cond & wsource->condition),

                   user_data);

}
",1
Detect whether the following code contains vulnerabilities.,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static MemoryRegionSection address_space_do_translate(AddressSpace *as,

                                                      hwaddr addr,

                                                      hwaddr *xlat,

                                                      hwaddr *plen,

                                                      bool is_write,

                                                      bool is_mmio)

{

    IOMMUTLBEntry iotlb;

    MemoryRegionSection *section;

    MemoryRegion *mr;



    for (;;) {

        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);

        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);

        mr = section->mr;



        if (!mr->iommu_ops) {

            break;

        }



        iotlb = mr->iommu_ops->translate(mr, addr, is_write);

        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)

                | (addr & iotlb.addr_mask));

        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);

        if (!(iotlb.perm & (1 << is_write))) {

            goto translate_fail;

        }



        as = iotlb.target_as;

    }



    *xlat = addr;



    return *section;



translate_fail:

    return (MemoryRegionSection) { .mr = &io_mem_unassigned };

}
",0
Detect whether the following code contains vulnerabilities.,"static void read_guest_mem(void)

{

    uint32_t *guest_mem;

    gint64 end_time;

    int i, j;

    size_t size;



    g_mutex_lock(data_mutex);



    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;

    while (!fds_num) {

        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {

            /* timeout has passed */

            g_assert(fds_num);

            break;

        }

    }



    /* check for sanity */

    g_assert_cmpint(fds_num, >, 0);

    g_assert_cmpint(fds_num, ==, memory.nregions);



    /* iterate all regions */

    for (i = 0; i < fds_num; i++) {



        /* We'll check only the region statring at 0x0*/

        if (memory.regions[i].guest_phys_addr != 0x0) {

            continue;

        }



        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);



        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;



        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,

                         MAP_SHARED, fds[i], 0);



        g_assert(guest_mem != MAP_FAILED);

        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));



        for (j = 0; j < 256; j++) {

            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);

            uint32_t b = guest_mem[j];



            g_assert_cmpint(a, ==, b);

        }



        munmap(guest_mem, memory.regions[i].memory_size);

    }



    g_assert_cmpint(1, ==, 1);

    g_mutex_unlock(data_mutex);

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    uint32_t minor_ver;

    int comp_brand_size;

    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */

    char* comp_brands_str;

    uint8_t type[5] = {0};



    avio_read(pb, type, 4);

    if (strcmp(type, ""qt  ""))

        c->isom = 1;

    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);

    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);

    minor_ver = avio_rb32(pb); /* minor version */

    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);

    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);



    comp_brand_size = atom.size - 8;

    if (comp_brand_size < 0)

        return AVERROR_INVALIDDATA;

    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */

    if (!comp_brands_str)

        return AVERROR(ENOMEM);

    avio_read(pb, comp_brands_str, comp_brand_size);

    comp_brands_str[comp_brand_size] = 0;

    av_dict_set(&c->fc->metadata, ""compatible_brands"", comp_brands_str, 0);

    av_freep(&comp_brands_str);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
",1
Detect whether the following code contains vulnerabilities.,"void scsi_req_cancel(SCSIRequest *req)

{

    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)

{

    fadt->model = 1;

    fadt->reserved1 = 0;

    fadt->sci_int = cpu_to_le16(pm->sci_int);

    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);

    fadt->acpi_enable = pm->acpi_enable_cmd;

    fadt->acpi_disable = pm->acpi_disable_cmd;

    /* EVT, CNT, TMR offset matches hw/acpi/core.c */

    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);

    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);

    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);

    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);

    /* EVT, CNT, TMR length matches hw/acpi/core.c */

    fadt->pm1_evt_len = 4;

    fadt->pm1_cnt_len = 2;

    fadt->pm_tmr_len = 4;

    fadt->gpe0_blk_len = pm->gpe0_blk_len;

    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */

    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */

    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |

                              (1 << ACPI_FADT_F_PROC_C1) |

                              (1 << ACPI_FADT_F_SLP_BUTTON) |

                              (1 << ACPI_FADT_F_RTC_S4));

    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);

    /* APIC destination mode (""Flat Logical"") has an upper limit of 8 CPUs

     * For more than 8 CPUs, ""Clustered Logical"" mode has to be used

     */

    if (max_cpus > 8) {

        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);

    }

    fadt->century = RTC_CENTURY;

}
",0
Detect whether the following code contains vulnerabilities.,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)

{

    QapiDeallocVisitor *qov = to_qov(v);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        g_free(*obj);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j, k;

    int mx, my;

    int avail_index = avail_indexes[0];



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + 2]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];

        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];

    }

    mx = mid_pred(A[0], B[0], C[0]);

    my = mid_pred(A[1], B[1], C[1]);

    mx += r->dmv[0][0];

    my += r->dmv[0][1];

    for(j = 0; j < 2; j++){

        for(i = 0; i < 2; i++){

            for(k = 0; k < 2; k++){

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_paio_init(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = pthread_attr_init(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    TAILQ_INIT(&request_list);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,

                                  DeviceState *dev, Error **errp)

{

    PCIDevice *pci_dev = PCI_DEVICE(dev);

    S390PCIBusDevice *pbdev;

    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)

                                           ->qbus.parent);



    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];



    pbdev->fid = s390_pci_get_pfid(pci_dev);

    pbdev->pdev = pci_dev;

    pbdev->configured = true;

    pbdev->fh = s390_pci_get_pfh(pci_dev);



    s390_pcihost_setup_msix(pbdev);



    if (dev->hotplugged) {

        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,

                                     pbdev->fh, pbdev->fid);

        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,

                                     pbdev->fh, pbdev->fid);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int vhost_verify_ring_mappings(struct vhost_dev *dev,

                                      uint64_t start_addr,

                                      uint64_t size)

{

    int i, j;

    int r = 0;

    const char *part_name[] = {

        ""descriptor table"",

        ""available ring"",

        ""used ring""

    };



    for (i = 0; i < dev->nvqs; ++i) {

        struct vhost_virtqueue *vq = dev->vqs + i;



        j = 0;

        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,

                                           vq->desc_size, start_addr, size);

        if (!r) {

            break;

        }



        j++;

        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,

                                           vq->avail_size, start_addr, size);

        if (!r) {

            break;

        }



        j++;

        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,

                                           vq->used_size, start_addr, size);

        if (!r) {

            break;

        }

    }



    if (r == -ENOMEM) {

        error_report(""Unable to map %s for ring %d"", part_name[j], i);

    } else if (r == -EBUSY) {

        error_report(""%s relocated for ring %d"", part_name[j], i);

    }

    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",1
Detect whether the following code contains vulnerabilities.,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
",1
Detect whether the following code contains vulnerabilities.,"bool bdrv_is_first_non_filter(BlockDriverState *candidate)

{

    BlockDriverState *bs;

    BdrvNextIterator *it = NULL;



    /* walk down the bs forest recursively */

    while ((it = bdrv_next(it, &bs)) != NULL) {

        bool perm;



        /* try to recurse in this top level bs */

        perm = bdrv_recurse_is_first_non_filter(bs, candidate);



        /* candidate is the first non filter */

        if (perm) {

            return true;

        }

    }



    return false;

}
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, qiov, offset);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;



}
",1
Detect whether the following code contains vulnerabilities.,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)

{

    const uint8_t *buf_end = buf + buf_size;



    while(buf + 48 <= buf_end) {

        int dir_length, name_size, first_sector, depth;

        uint64_t file_length;

        const uint8_t *name;

        if (ff_guidcmp(buf, dir_entry_guid)) {

            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""

                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));

            break;

        }

        dir_length  = AV_RL16(buf + 16);

        file_length = AV_RL64(buf + 24);

        name_size   = 2 * AV_RL32(buf + 32);

        if (buf + 48 + name_size > buf_end) {

            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");

            break;

        }

        first_sector = AV_RL32(buf + 40 + name_size);

        depth        = AV_RL32(buf + 44 + name_size);



        /* compare file name; test optional null terminator */

        name = buf + 40;

        if (name_size >= filename_size &&

            !memcmp(name, filename, filename_size) &&

            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))

            return wtvfile_open_sector(first_sector, file_length, depth, s);



        buf += dir_length;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)

{

    int err;

    QObject *obj;

    QDict *input, *args;

    const mon_cmd_t *cmd;

    Monitor *mon = cur_mon;

    const char *cmd_name, *info_item;



    args = NULL;



    obj = json_parser_parse(tokens, NULL);

    if (!obj) {

        // FIXME: should be triggered in json_parser_parse()

        qerror_report(QERR_JSON_PARSING);

        goto err_out;


        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, ""object"");

        qobject_decref(obj);

        goto err_out;

    }



    input = qobject_to_qdict(obj);



    mon->mc->id = qdict_get(input, ""id"");

    qobject_incref(mon->mc->id);



    obj = qdict_get(input, ""execute"");

    if (!obj) {

        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, ""execute"");


    } else if (qobject_type(obj) != QTYPE_QSTRING) {

        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"", ""string"");


    }



    cmd_name = qstring_get_str(qobject_to_qstring(obj));



    if (invalid_qmp_mode(mon, cmd_name)) {

        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);


    }



    /*

     * XXX: We need this special case until we get info handlers

     * converted into 'query-' commands

     */

    if (compare_cmd(cmd_name, ""info"")) {

        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);


    } else if (strstart(cmd_name, ""query-"", &info_item)) {

        cmd = monitor_find_command(""info"");

        qdict_put_obj(input, ""arguments"",

                      qobject_from_jsonf(""{ 'item': %s }"", info_item));

    } else {

        cmd = monitor_find_command(cmd_name);

        if (!cmd || !monitor_handler_ported(cmd)) {

            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);


        }

    }



    obj = qdict_get(input, ""arguments"");

    if (!obj) {

        args = qdict_new();




    } else {

        args = qobject_to_qdict(obj);

        QINCREF(args);

    }



    QDECREF(input);



    err = monitor_check_qmp_args(cmd, args);

    if (err < 0) {

        goto err_out;

    }



    if (monitor_handler_is_async(cmd)) {

        qmp_async_cmd_handler(mon, cmd, args);

    } else {

        monitor_call_handler(mon, cmd, args);

    }

    goto out;



err_input:

    QDECREF(input);

err_out:

    monitor_protocol_emitter(mon, NULL);

out:

    QDECREF(args);

}",1
Detect whether the following code contains vulnerabilities.,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,

                                 uint32_t color, int *w_ptr, int *h_ptr)

{

    int dx, dy, dw, dh;

    int w_prev;

    int w_best = 0, h_best = 0;



    w_prev = w;



    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {



        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);

        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);



        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {

            break;

        }



        for (dx = x + dw; dx < x + w_prev;) {

            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);



            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {

                break;

            }

            dx += dw;

        }



        w_prev = dx - x;

        if (w_prev * (dy + dh - y) > w_best * h_best) {

            w_best = w_prev;

            h_best = dy + dh - y;

        }

    }



    *w_ptr = w_best;

    *h_ptr = h_best;

}
",0
Detect whether the following code contains vulnerabilities.,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
",0
Detect whether the following code contains vulnerabilities.,"static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;



    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !s->in_len;

}
",0
Detect whether the following code contains vulnerabilities.,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,

                                  OGGStreamContext *oggstream, int bitexact)

{

    const char *vendor = bitexact ? ""ffmpeg"" : LIBAVFORMAT_IDENT;

    uint8_t *p;

    if (extradata_size != 34)

        return -1;

    oggstream->header_len[0] = 51;

    oggstream->header[0] = av_mallocz(51); // per ogg flac specs

    p = oggstream->header[0];

    bytestream_put_byte(&p, 0x7F);

    bytestream_put_buffer(&p, ""FLAC"", 4);

    bytestream_put_byte(&p, 1); // major version

    bytestream_put_byte(&p, 0); // minor version

    bytestream_put_be16(&p, 1); // headers packets without this one

    bytestream_put_buffer(&p, ""fLaC"", 4);

    bytestream_put_byte(&p, 0x00); // streaminfo

    bytestream_put_be24(&p, 34);

    bytestream_put_buffer(&p, extradata, 34);

    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;

    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);

    p = oggstream->header[1];

    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment

    bytestream_put_be24(&p, oggstream->header_len[1] - 4);

    bytestream_put_le32(&p, strlen(vendor));

    bytestream_put_buffer(&p, vendor, strlen(vendor));

    bytestream_put_le32(&p, 0); // user comment list length

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void put_subframe(DCAEncContext *c, int subframe)

{

    int i, band, ss, ch;



    /* Subsubframes count */

    put_bits(&c->pb, 2, SUBSUBFRAMES -1);



    /* Partial subsubframe sample count: dummy */

    put_bits(&c->pb, 3, 0);



    /* Prediction mode: no ADPCM, in each channel and subband */

    for (ch = 0; ch < c->fullband_channels; ch++)

        for (band = 0; band < DCAENC_SUBBANDS; band++)

            put_bits(&c->pb, 1, 0);



    /* Prediction VQ address: not transmitted */

    /* Bit allocation index */

    for (ch = 0; ch < c->fullband_channels; ch++)

        for (band = 0; band < DCAENC_SUBBANDS; band++)

            put_bits(&c->pb, 5, c->abits[band][ch]);



    if (SUBSUBFRAMES > 1) {

        /* Transition mode: none for each channel and subband */

        for (ch = 0; ch < c->fullband_channels; ch++)

            for (band = 0; band < DCAENC_SUBBANDS; band++)

                put_bits(&c->pb, 1, 0); /* codebook A4 */

    }



    /* Scale factors */

    for (ch = 0; ch < c->fullband_channels; ch++)

        for (band = 0; band < DCAENC_SUBBANDS; band++)

            put_bits(&c->pb, 7, c->scale_factor[band][ch]);



    /* Joint subband scale factor codebook select: not transmitted */

    /* Scale factors for joint subband coding: not transmitted */

    /* Stereo down-mix coefficients: not transmitted */

    /* Dynamic range coefficient: not transmitted */

    /* Stde information CRC check word: not transmitted */

    /* VQ encoded high frequency subbands: not transmitted */



    /* LFE data: 8 samples and scalefactor */

    if (c->lfe_channel) {

        for (i = 0; i < DCA_LFE_SAMPLES; i++)

            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);

        put_bits(&c->pb, 8, c->lfe_scale_factor);

    }



    /* Audio data (subsubframes) */

    for (ss = 0; ss < SUBSUBFRAMES ; ss++)

        for (ch = 0; ch < c->fullband_channels; ch++)

            for (band = 0; band < DCAENC_SUBBANDS; band++)

                    put_subframe_samples(c, ss, band, ch);



    /* DSYNC */

    put_bits(&c->pb, 16, 0xffff);

}
",0
Detect whether the following code contains vulnerabilities.,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = paddr,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)

{

    uint8_t df = (ctx->opcode >> 21) & 0x3;

    uint8_t wt = (ctx->opcode >> 16) & 0x1f;

    int64_t s16 = (int16_t)ctx->opcode;



    check_msa_access(ctx);



    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {

        generate_exception_end(ctx, EXCP_RI);

        return;

    }

    switch (op1) {

    case OPC_BZ_V:

    case OPC_BNZ_V:

        {

            TCGv_i64 t0 = tcg_temp_new_i64();

            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);

            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?

                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);

            tcg_gen_trunc_i64_tl(bcond, t0);

            tcg_temp_free_i64(t0);

        }

        break;

    case OPC_BZ_B:

    case OPC_BZ_H:

    case OPC_BZ_W:

    case OPC_BZ_D:

        gen_check_zero_element(bcond, df, wt);

        break;

    case OPC_BNZ_B:

    case OPC_BNZ_H:

    case OPC_BNZ_W:

    case OPC_BNZ_D:

        gen_check_zero_element(bcond, df, wt);

        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);

        break;

    }



    ctx->btarget = ctx->pc + (s16 << 2) + 4;



    ctx->hflags |= MIPS_HFLAG_BC;

    ctx->hflags |= MIPS_HFLAG_BDS32;

}
",0
Detect whether the following code contains vulnerabilities.,"static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)

{

    QObject *token, *ret;

    QList *working = qlist_copy(*tokens);



    token = qlist_pop(working);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));

    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    qobject_decref(token);

    QDECREF(*tokens);

    *tokens = working;



    return ret;



out: 

    qobject_decref(token);

    QDECREF(working);



    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}
",0
Detect whether the following code contains vulnerabilities.,"static int encode_frame(FlacEncodeContext *s)

{

    int ch, count;



    count = count_frame_header(s);



    for (ch = 0; ch < s->channels; ch++)

        count += encode_residual_ch(s, ch);



    count += (8 - (count & 7)) & 7; // byte alignment

    count += 16;                    // CRC-16



    return count >> 3;

}
",1
Detect whether the following code contains vulnerabilities.,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",0
Detect whether the following code contains vulnerabilities.,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmxnet3_update_mcast_filters(VMXNET3State *s)

{

    uint16_t list_bytes =

        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,

                                  devRead.rxFilterConf.mfTableLen);



    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);



    s->mcast_list = g_realloc(s->mcast_list, list_bytes);

    if (!s->mcast_list) {

        if (s->mcast_list_len == 0) {

            VMW_CFPRN(""Current multicast list is empty"");

        } else {

            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",

                      s->mcast_list_len);

        }

        s->mcast_list_len = 0;

    } else {

        int i;

        hwaddr mcast_list_pa =

            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,

                                      devRead.rxFilterConf.mfTablePA);



        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);



        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);

        for (i = 0; i < s->mcast_list_len; i++) {

            VMW_CFPRN(""\t"" MAC_FMT, MAC_ARG(s->mcast_list[i].a));

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
",1
Detect whether the following code contains vulnerabilities.,"static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)

{

    cirrus_fill_t rop_func;



    if (blit_is_unsafe(s)) {

        return 0;

    }

    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];

    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),

             s->cirrus_blt_dstpitch,

             s->cirrus_blt_width, s->cirrus_blt_height);

    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,

			     s->cirrus_blt_dstpitch, s->cirrus_blt_width,

			     s->cirrus_blt_height);

    cirrus_bitblt_reset(s);

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int encode_hq_slice(AVCodecContext *avctx, void *arg)

{

    SliceArgs *slice_dat = arg;

    VC2EncContext *s = slice_dat->ctx;

    PutBitContext *pb = &slice_dat->pb;

    const int slice_x = slice_dat->x;

    const int slice_y = slice_dat->y;

    const int quant_idx = slice_dat->quant_idx;

    const int slice_bytes_max = slice_dat->bytes;

    uint8_t quants[MAX_DWT_LEVELS][4];

    int p, level, orientation;



    avpriv_align_put_bits(pb);

    skip_put_bytes(pb, s->prefix_bytes);

    put_bits(pb, 8, quant_idx);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++)

        for (orientation = !!level; orientation < 4; orientation++)

            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);



    /* Luma + 2 Chroma planes */

    for (p = 0; p < 3; p++) {

        int bytes_start, bytes_len, pad_s, pad_c;

        bytes_start = put_bits_count(pb) >> 3;

        put_bits(pb, 8, 0);

        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                encode_subband(s, pb, slice_x, slice_y,

                               &s->plane[p].band[level][orientation],

                               quants[level][orientation]);

            }

        }

        avpriv_align_put_bits(pb);

        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;

        if (p == 2) {

            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);

            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;

            pad_c = (pad_s*s->size_scaler) - bytes_len;

        } else {

            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;

            pad_c = (pad_s*s->size_scaler) - bytes_len;

        }

        pb->buf[bytes_start] = pad_s;

        flush_put_bits(pb);

        skip_put_bytes(pb, pad_c);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
",0
Detect whether the following code contains vulnerabilities.,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
",0
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,

                uint32_t value)

{

    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;

    if (addr > s->pm_base + PCMD31) {

        /* Special case: PWRI2C registers appear in the same range.  */

        pxa2xx_i2c_write(s->i2c[1], addr, value);

        return;

    }

    addr -= s->pm_base;



    switch (addr) {

    case PMCR:

        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);

        s->pm_regs[addr >> 2] |= value & 0x15;

        break;



    case PSSR:	/* Read-clean registers */

    case RCSR:

    case PKSR:

        s->pm_regs[addr >> 2] &= ~value;

        break;



    default:	/* Read-write registers */

        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {

            s->pm_regs[addr >> 2] = value;

            break;

        }



        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}
",0
Detect whether the following code contains vulnerabilities.,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
",0
Detect whether the following code contains vulnerabilities.,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
",0
Detect whether the following code contains vulnerabilities.,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)

{

    int err;

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);

    if (err) {

        return err;

    }

    if (fs_ctx->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp_uid;

        gid_t tmp_gid;

        mode_t tmp_mode;

        dev_t tmp_dev;

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,

                    sizeof(uid_t)) > 0) {

            stbuf->st_uid = tmp_uid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,

                    sizeof(gid_t)) > 0) {

            stbuf->st_gid = tmp_gid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",

                    &tmp_mode, sizeof(mode_t)) > 0) {

            stbuf->st_mode = tmp_mode;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,

                        sizeof(dev_t)) > 0) {

                stbuf->st_rdev = tmp_dev;

        }

    }

    return err;

}
",0
Detect whether the following code contains vulnerabilities.,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
",0
Detect whether the following code contains vulnerabilities.,"bool timer_pending(QEMUTimer *ts)

{

    QEMUTimer *t;

    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {

        if (t == ts) {

            return true;

        }

    }

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static void setup_rt_frame(int sig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUX86State *env)

{

	struct rt_sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif



	err |= __put_user((/*current->exec_domain

		    	   && current->exec_domain->signal_invmap

		    	   && sig < 32

		    	   ? current->exec_domain->signal_invmap[sig]

			   : */sig),

			  &frame->sig);

	err |= __put_user((target_ulong)&frame->info, &frame->pinfo);

	err |= __put_user((target_ulong)&frame->uc, &frame->puc);

	err |= copy_siginfo_to_user(&frame->info, info);

	if (err)

		goto give_sigsegv;



	/* Create the ucontext.  */

	err |= __put_user(0, &frame->uc.uc_flags);

	err |= __put_user(0, &frame->uc.uc_link);

	err |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);

	err |= __put_user(/* sas_ss_flags(regs->esp) */ 0,

			  &frame->uc.uc_stack.ss_flags);

	err |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);

	err |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,

			        env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);

	} else {

		err |= __put_user(frame->retcode, &frame->pretcode);

		/* This is movl $,%eax ; int $0x80 */

		err |= __put_user(0xb8, (char *)(frame->retcode+0));

		err |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));

		err |= __put_user(0x80cd, (short *)(frame->retcode+5));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	env->regs[R_ESP] = (unsigned long) frame;

	env->eip = (unsigned long) ka->sa._sa_handler;



        cpu_x86_load_seg(env, R_DS, __USER_DS);

        cpu_x86_load_seg(env, R_ES, __USER_DS);

        cpu_x86_load_seg(env, R_SS, __USER_DS);

        cpu_x86_load_seg(env, R_CS, __USER_CS);

	env->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (sig == TARGET_SIGSEGV)

		ka->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void blk_delete(BlockBackend *blk)

{

    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);
",1
Detect whether the following code contains vulnerabilities.,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",1
Detect whether the following code contains vulnerabilities.,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}",1
Detect whether the following code contains vulnerabilities.,"static void cpu_handle_ioreq(void *opaque)

{

    XenIOState *state = opaque;

    ioreq_t *req = cpu_get_ioreq(state);



    handle_buffered_iopage(state);

    if (req) {

        ioreq_t copy = *req;



        xen_rmb();

        handle_ioreq(state, &copy);

        req->data = copy.data;



        if (req->state != STATE_IOREQ_INPROCESS) {

            fprintf(stderr, ""Badness in I/O request ... not in service?!: ""

                    ""%x, ptr: %x, port: %""PRIx64"", ""

                    ""data: %""PRIx64"", count: %u, size: %u, type: %u\n"",

                    req->state, req->data_is_ptr, req->addr,

                    req->data, req->count, req->size, req->type);

            destroy_hvm_domain(false);

            return;

        }



        xen_wmb(); /* Update ioreq contents /then/ update state. */



        /*

         * We do this before we send the response so that the tools

         * have the opportunity to pick up on the reset before the

         * guest resumes and does a hlt with interrupts disabled which

         * causes Xen to powerdown the domain.

         */

        if (runstate_is_running()) {

            if (qemu_shutdown_requested_get()) {

                destroy_hvm_domain(false);

            }

            if (qemu_reset_requested_get()) {

                qemu_system_reset(VMRESET_REPORT);

                destroy_hvm_domain(true);

            }

        }



        req->state = STATE_IORESP_READY;

        xenevtchn_notify(state->xce_handle,

                         state->ioreq_local_port[state->send_vcpu]);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int local_open2(FsContext *fs_ctx, const char *path, int flags,

        FsCred *credp)

{

    int fd = -1;

    int err = -1;

    int serrno = 0;



    /* Determine the security model */

    if (fs_ctx->fs_sm == SM_MAPPED) {

        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            return fd;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(rpath(fs_ctx, path), credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {

        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);

        if (fd == -1) {

            return fd;

        }

        err = local_post_create_passthrough(fs_ctx, path, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    return fd;



err_end:

    close(fd);

    remove(rpath(fs_ctx, path));

    errno = serrno;

    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *dest, int dstW, int y)

{

	int i;

	switch(c->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];

			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)dest)[0]= r[Y1];

			((uint8_t*)dest)[1]= g[Y1];

			((uint8_t*)dest)[2]= b[Y1];

			((uint8_t*)dest)[3]= r[Y2];

			((uint8_t*)dest)[4]= g[Y2];

			((uint8_t*)dest)[5]= b[Y2];

			dest+=6;

		}
",1
Detect whether the following code contains vulnerabilities.,"static void read_sgi_header(ByteIOContext *f, SGIInfo *info)
{
    info->magic = (unsigned short) get_be16(f);
    info->rle = get_byte(f);
    info->bytes_per_channel = get_byte(f);
    info->dimension = (unsigned short)get_be16(f);
    info->xsize = (unsigned short) get_be16(f);
    info->ysize = (unsigned short) get_be16(f);
    info->zsize = (unsigned short) get_be16(f);
#ifdef DEBUG
    printf(""sgi header fields:\n"");
    printf(""  magic: %d\n"", info->magic);
    printf(""    rle: %d\n"", info->rle);
    printf(""    bpc: %d\n"", info->bytes_per_channel);
    printf(""    dim: %d\n"", info->dimension);
    printf(""  xsize: %d\n"", info->xsize);
    printf(""  ysize: %d\n"", info->ysize);
    printf(""  zsize: %d\n"", info->zsize);
#endif
    return;
}",1
Detect whether the following code contains vulnerabilities.,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",0
Detect whether the following code contains vulnerabilities.,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold void ff_dct_init_x86(DCTContext *s)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;

    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))

        s->dct32 = ff_dct32_float_avx;

}
",0
Detect whether the following code contains vulnerabilities.,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    } else {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if (dest != (src + 1)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version crossing pages with byte accesses */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_properties(const char *path, bool recurse)

{

    char *child_path;

    QDict *response, *tuple;

    QList *list;

    QListEntry *entry;



    g_test_message(""Obtaining properties of %s"", path);

    response = qmp(""{ 'execute': 'qom-list',""

                   ""  'arguments': { 'path': %s } }"", path);

    g_assert(response);



    if (!recurse) {

        return;

    }



    g_assert(qdict_haskey(response, ""return""));

    list = qobject_to_qlist(qdict_get(response, ""return""));

    QLIST_FOREACH_ENTRY(list, entry) {

        tuple = qobject_to_qdict(qlist_entry_obj(entry));

        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);

        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);



        if (is_child || is_link) {

            child_path = g_strdup_printf(""%s/%s"",

                                         path, qdict_get_str(tuple, ""name""));

            test_properties(child_path, is_child);

            g_free(child_path);

        } else {

            const char *prop = qdict_get_str(tuple, ""name"");

            g_test_message(""Testing property %s.%s"", path, prop);

            response = qmp(""{ 'execute': 'qom-get',""

                           ""  'arguments': { 'path': %s,""

                           ""                 'property': %s } }"",

                           path, prop);

            /* qom-get may fail but should not, e.g., segfault. */

            g_assert(response);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_visitor_out_string(TestOutputVisitorData *data,

                                    const void *unused)

{

    char *string = (char *) ""Q E M U"";

    Error *err = NULL;

    QObject *obj;



    visit_type_str(data->ov, &string, NULL, &err);

    g_assert(!err);



    obj = qmp_output_get_qobject(data->qov);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QSTRING);

    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);



    qobject_decref(obj);

}
",0
Detect whether the following code contains vulnerabilities.,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
",0
Detect whether the following code contains vulnerabilities.,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static gboolean pty_chr_timer(gpointer opaque)

{

    struct CharDriverState *chr = opaque;

    PtyCharDriver *s = chr->opaque;



    if (s->connected) {

        goto out;

    }



    /* Next poll ... */

    pty_chr_update_read_handler(chr);



out:

    s->timer_tag = 0;

    return FALSE;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,

			uint8_t *dst1, uint8_t *dst2,

			long width, long height,

			long srcStride1, long srcStride2,

			long dstStride1, long dstStride2)

{

    long y,x,w,h;

    w=width/2; h=height/2;

#ifdef HAVE_MMX

    asm volatile(

	PREFETCH"" %0\n\t""

	PREFETCH"" %1\n\t""

	::""m""(*(src1+srcStride1)),""m""(*(src2+srcStride2)):""memory"");

#endif

    for(y=0;y<h;y++){

	const uint8_t* s1=src1+srcStride1*(y>>1);

	uint8_t* d=dst1+dstStride1*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s1[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];

    }

    for(y=0;y<h;y++){

	const uint8_t* s2=src2+srcStride2*(y>>1);

	uint8_t* d=dst2+dstStride2*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s2[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];

    }

#ifdef HAVE_MMX

	asm(

		EMMS"" \n\t""

		SFENCE"" \n\t""

		::: ""memory""

		);

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
",1
Detect whether the following code contains vulnerabilities.,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,

                                   int srcW, int xInc, const int16_t *hChrFilter,

                                   const int16_t *hChrFilterPos, int hChrFilterSize,

                                   uint8_t *formatConvBuffer,

                                   uint32_t *pal)

{



    src1 += c->chrSrcOffset;

    src2 += c->chrSrcOffset;



    if (c->chrToYV12) {

        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= formatConvBuffer+VOFW;

    }



    if (!c->hcscale_fast) {

        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);

    }



    if (c->chrConvertRange)

        c->chrConvertRange(dst, dstWidth);

}
",1
Detect whether the following code contains vulnerabilities.,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
",1
Detect whether the following code contains vulnerabilities.,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
",1
Detect whether the following code contains vulnerabilities.,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}",1
Detect whether the following code contains vulnerabilities.,"CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
",0
Detect whether the following code contains vulnerabilities.,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&vring->vr), new, old);

}
",0
Detect whether the following code contains vulnerabilities.,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);

#else

    int i;

    for (i=0; i<width; i++) {

        int b= src[i*3+0];

        int g= src[i*3+1];

        int r= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif /* COMPILE_TEMPLATE_MMX */

}
",1
Detect whether the following code contains vulnerabilities.,"void FUNC(ff_simple_idct)(DCTELEM *block)

{

    int i;



    for (i = 0; i < 8; i++)

        FUNC(idctRowCondDC)(block + i*8);



    for (i = 0; i < 8; i++)

        FUNC(idctSparseCol)(block + i);

}
",1
Detect whether the following code contains vulnerabilities.,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)

{

    if (ohci->async_td &&

        ohci->usb_packet.owner != NULL &&

        ohci->usb_packet.owner->dev == dev) {

        usb_cancel_packet(&ohci->usb_packet);

        ohci->async_td = 0;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
",1
Detect whether the following code contains vulnerabilities.,"static void v9fs_readdir(void *opaque)

{

    int32_t fid;

    V9fsFidState *fidp;

    ssize_t retval = 0;

    size_t offset = 7;

    uint64_t initial_offset;

    int32_t count;

    uint32_t max_count;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);



    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        retval = -EINVAL;

        goto out_nofid;

    }

    if (!fidp->fs.dir) {

        retval = -EINVAL;

        goto out;

    }

    if (initial_offset == 0) {

        v9fs_co_rewinddir(pdu, fidp);

    } else {

        v9fs_co_seekdir(pdu, fidp, initial_offset);

    }

    count = v9fs_do_readdir(pdu, fidp, max_count);

    if (count < 0) {

        retval = count;

        goto out;

    }

    retval = offset;

    retval += pdu_marshal(pdu, offset, ""d"", count);

    retval += count;

    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);

out:

    put_fid(pdu, fidp);

out_nofid:

    complete_pdu(s, pdu, retval);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    uint32_t cc = 0;

    int old_exc = cs->exception_index;

    uint64_t asc = env->psw.mask & PSW_MASK_ASC;

    uint64_t ret;

    int flags;



    /* XXX incomplete - has more corner cases */

    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {

        program_interrupt(env, PGM_SPECIAL_OP, 2);

    }



    cs->exception_index = old_exc;

    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {

        cc = 3;

    }

    if (cs->exception_index == EXCP_PGM) {

        ret = env->int_pgm_code | 0x80000000;

    } else {

        ret |= addr & ~TARGET_PAGE_MASK;

    }

    cs->exception_index = old_exc;



    env->cc_op = cc;

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
",0
Detect whether the following code contains vulnerabilities.,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_host_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);

    struct usbdevfs_urb *urb;

    AsyncURB *aurb;

    int ret;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note request is (bRequestType << 8) | bRequest */

    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);



    switch (request) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_address(s, value);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_config(s, value & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interface(s, index, value);

    }



    /* The rest are asynchronous */



    if (length > sizeof(dev->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer too small (%d > %zu)\n"",

                length, sizeof(dev->data_buf));

        return USB_RET_STALL;

    }



    aurb = async_alloc(s);

    aurb->packet = p;



    /*

     * Setup ctrl transfer.

     *

     * s->ctrl is laid out such that data buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */

    urb = &aurb->urb;



    urb->type     = USBDEVFS_URB_TYPE_CONTROL;

    urb->endpoint = p->devep;



    urb->buffer        = &dev->setup_buf;

    urb->buffer_length = length + 8;



    urb->usercontext = s;



    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,

                              urb->buffer_length, aurb->more);

    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);



    DPRINTF(""husb: submit ctrl. len %u aurb %p\n"", urb->buffer_length, aurb);



    if (ret < 0) {

        DPRINTF(""husb: submit failed. errno %d\n"", errno);

        async_free(aurb);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    return USB_RET_ASYNC;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void s390_machine_initfn(Object *obj)

{

    object_property_add_bool(obj, ""aes-key-wrap"",

                             machine_get_aes_key_wrap,

                             machine_set_aes_key_wrap, NULL);

    object_property_set_description(obj, ""aes-key-wrap"",

            ""enable/disable AES key wrapping using the CPACF wrapping key"",


    object_property_set_bool(obj, true, ""aes-key-wrap"", NULL);



    object_property_add_bool(obj, ""dea-key-wrap"",

                             machine_get_dea_key_wrap,

                             machine_set_dea_key_wrap, NULL);

    object_property_set_description(obj, ""dea-key-wrap"",

            ""enable/disable DEA key wrapping using the CPACF wrapping key"",


    object_property_set_bool(obj, true, ""dea-key-wrap"", NULL);

    object_property_add_str(obj, ""loadparm"",

            machine_get_loadparm, machine_set_loadparm, NULL);

    object_property_set_description(obj, ""loadparm"",

            ""Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted""

            "" to upper case) to pass to machine loader, boot manager,""

            "" and guest kernel"",









}",1
Detect whether the following code contains vulnerabilities.,"static void qemu_spice_display_init_one(QemuConsole *con)

{

    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);



    qemu_spice_display_init_common(ssd);



    ssd->qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_display_interface(&ssd->qxl, con);

    assert(ssd->worker);



    qemu_spice_create_host_memslot(ssd);



    ssd->dcl.ops = &display_listener_ops;

    ssd->dcl.con = con;

    register_displaychangelistener(&ssd->dcl);

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,

                              int64_t wanted_timestamp, int flags)

{

    int a, b, m;

    int64_t timestamp;



    a = -1;

    b = nb_entries;



    // Optimize appending index entries at the end.

    if (b && entries[b - 1].timestamp < wanted_timestamp)

        a = b - 1;



    while (b - a > 1) {

        m         = (a + b) >> 1;



        // Search for the next non-discarded packet.

        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {

            m++;

            if (m == b && entries[m].timestamp >= wanted_timestamp) {

                m = b - 1;

                break;

            }

        }



        timestamp = entries[m].timestamp;

        if (timestamp >= wanted_timestamp)

            b = m;

        if (timestamp <= wanted_timestamp)

            a = m;

    }

    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;



    if (!(flags & AVSEEK_FLAG_ANY))

        while (m >= 0 && m < nb_entries &&

               !(entries[m].flags & AVINDEX_KEYFRAME))

            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;



    if (m == nb_entries)

        return -1;

    return m;

}
",0
Detect whether the following code contains vulnerabilities.,"static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)
{
    InputStream *ist = s->opaque;
    FrameBuffer *buf;
    int ret, i;
    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)
        return ret;
    buf              = ist->buffer_pool;
    ist->buffer_pool = buf->next;
    buf->next        = NULL;
    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {
        av_freep(&buf->base[0]);
        av_free(buf);
        ist->dr1 = 0;
        if ((ret = alloc_buffer(s, ist, &buf)) < 0)
            return ret;
    }
    buf->refcount++;
    frame->opaque        = buf;
    frame->type          = FF_BUFFER_TYPE_USER;
    frame->extended_data = frame->data;
    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;
    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {
        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't
        frame->data[i]     = buf->data[i];
        frame->linesize[i] = buf->linesize[i];
    }
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void test_visitor_in_native_list_int32(TestInputVisitorData *data,

                                              const void *unused)

{

    test_native_list_integer_helper(data, unused,

                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
",0
Detect whether the following code contains vulnerabilities.,"void stl_phys_notdirty(hwaddr addr, uint32_t val)

{

    uint8_t *ptr;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!memory_region_is_ram(section->mr) || section->readonly) {

        addr = memory_region_section_addr(section, addr);

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

        io_mem_write(section->mr, addr, val, 4);

    } else {

        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)

                               & TARGET_PAGE_MASK)

            + memory_region_section_addr(section, addr);

        ptr = qemu_get_ram_ptr(addr1);

        stl_p(ptr, val);



        if (unlikely(in_migration)) {

            if (!cpu_physical_memory_is_dirty(addr1)) {

                /* invalidate code */

                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);

                /* set dirty bit */

                cpu_physical_memory_set_dirty_flags(

                    addr1, (0xff & ~CODE_DIRTY_FLAG));

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void compute_antialias_float(MPADecodeContext *s,

                              GranuleDef *g)

{

    float *ptr;

    int n, i;



    /* we antialias only ""long"" bands */

    if (g->block_type == 2) {

        if (!g->switch_point)

            return;

        /* XXX: check this for 8000Hz case */

        n = 1;

    } else {

        n = SBLIMIT - 1;

    }



    ptr = g->sb_hybrid + 18;

    for(i = n;i > 0;i--) {

        float tmp0, tmp1;

        float *csa = &csa_table_float[0][0];

#define FLOAT_AA(j)\

        tmp0= ptr[-1-j];\

        tmp1= ptr[   j];\

        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\

        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];



        FLOAT_AA(0)

        FLOAT_AA(1)

        FLOAT_AA(2)

        FLOAT_AA(3)

        FLOAT_AA(4)

        FLOAT_AA(5)

        FLOAT_AA(6)

        FLOAT_AA(7)



        ptr += 18;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)

{

    DeviceState *dev;

    PCIBus *b;

    PCIDevice *d;

    I440FXState *s;

    PIIX3State *piix3;



    dev = qdev_create(NULL, ""i440FX-pcihost"");

    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));

    b = pci_bus_new(&s->busdev.qdev, NULL, 0);

    s->bus = b;

    qdev_init_nofail(dev);



    d = pci_create_simple(b, 0, ""i440FX"");

    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);



    piix3 = DO_UPCAST(PIIX3State, dev,

                                 pci_create_simple(b, -1, ""PIIX3""));

    piix3->pic = pic;

    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);

    (*pi440fx_state)->piix3 = piix3;



    *piix3_devfn = piix3->dev.devfn;



    ram_size = ram_size / 8 / 1024 / 1024;

    if (ram_size > 255)

        ram_size = 255;

    (*pi440fx_state)->dev.config[0x57]=ram_size;



    return b;

}
",1
Detect whether the following code contains vulnerabilities.,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_init_mp3on4(AVCodecContext * avctx)

{

    MP3On4DecodeContext *s = avctx->priv_data;

    int i;



    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {

        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");

        return -1;

    }



    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;

    s->frames = mp3Frames[s->chan_cfg];

    if(!s->frames) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");

        return -1;

    }

    avctx->channels = mp3Channels[s->chan_cfg];



    /* Init the first mp3 decoder in standard way, so that all tables get builded

     * We replace avctx->priv_data with the context of the first decoder so that

     * decode_init() does not have to be changed.

     * Other decoders will be inited here copying data from the first context

     */

    // Allocate zeroed memory for the first decoder context

    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));

    // Put decoder context in place to make init_decode() happy

    avctx->priv_data = s->mp3decctx[0];

    decode_init(avctx);

    // Restore mp3on4 context pointer

    avctx->priv_data = s;

    s->mp3decctx[0]->adu_mode = 1; // Set adu mode



    /* Create a separate codec/context for each frame (first is already ok).

     * Each frame is 1 or 2 channels - up to 5 frames allowed

     */

    for (i = 1; i < s->frames; i++) {

        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));

        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;

        s->mp3decctx[i]->adu_mode = 1;

        s->mp3decctx[i]->avctx = avctx;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
",0
Detect whether the following code contains vulnerabilities.,"static void curl_readv_bh_cb(void *p)

{

    CURLState *state;

    int running;



    CURLAIOCB *acb = p;

    BDRVCURLState *s = acb->common.bs->opaque;



    qemu_bh_delete(acb->bh);

    acb->bh = NULL;



    size_t start = acb->sector_num * SECTOR_SIZE;

    size_t end;



    // In case we have the requested data already (e.g. read-ahead),

    // we can just call the callback and be done.

    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {

        case FIND_RET_OK:

            qemu_aio_release(acb);

            // fall through

        case FIND_RET_WAIT:

            return;

        default:

            break;

    }



    // No cache found, so let's start a new request

    state = curl_init_state(s);

    if (!state) {

        acb->common.cb(acb->common.opaque, -EIO);

        qemu_aio_release(acb);

        return;

    }



    acb->start = 0;

    acb->end = (acb->nb_sectors * SECTOR_SIZE);



    state->buf_off = 0;

    g_free(state->orig_buf);

    state->buf_start = start;

    state->buf_len = acb->end + s->readahead_size;

    end = MIN(start + state->buf_len, s->len) - 1;

    state->orig_buf = g_malloc(state->buf_len);

    state->acb[0] = acb;



    snprintf(state->range, 127, ""%zd-%zd"", start, end);

    DPRINTF(""CURL (AIO): Reading %d at %zd (%s)\n"",

            (acb->nb_sectors * SECTOR_SIZE), start, state->range);

    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);



    curl_multi_add_handle(s->multi, state->curl);



    /* Tell curl it needs to kick things off */

    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void menelaus_rtc_stop(struct menelaus_s *s)

{

    qemu_del_timer(s->rtc.hz);

    s->rtc.next =- qemu_get_clock(rt_clock);

    if (s->rtc.next < 1)

        s->rtc.next = 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void gic_complete_irq(gic_state * s, int cpu, int irq)

{

    int update = 0;

    int cm = 1 << cpu;

    DPRINTF(""EOI %d\n"", irq);

    if (s->running_irq[cpu] == 1023)

        return; /* No active IRQ.  */

    if (irq != 1023) {

        /* Mark level triggered interrupts as pending if they are still

           raised.  */

        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)

                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {

            DPRINTF(""Set %d pending mask %x\n"", irq, cm);

            GIC_SET_PENDING(irq, cm);

            update = 1;

        }

    }

    if (irq != s->running_irq[cpu]) {

        /* Complete an IRQ that is not currently running.  */

        int tmp = s->running_irq[cpu];

        while (s->last_active[tmp][cpu] != 1023) {

            if (s->last_active[tmp][cpu] == irq) {

                s->last_active[tmp][cpu] = s->last_active[irq][cpu];

                break;

            }

            tmp = s->last_active[tmp][cpu];

        }

        if (update) {

            gic_update(s);

        }

    } else {

        /* Complete the current running IRQ.  */

        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}",1
Detect whether the following code contains vulnerabilities.,"PPC_OP(set_T0)

{

    T0 = PARAM(1);

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_validate_fail_struct_nested(TestInputVisitorData *data,

                                              const void *unused)

{

    UserDefTwo *udp = NULL;

    Error *err = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}"");



    visit_type_UserDefTwo(v, NULL, &udp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefTwo(udp);

}
",1
Detect whether the following code contains vulnerabilities.,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",1
Detect whether the following code contains vulnerabilities.,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,

                                  size_t *count)

{

    GIOStatus status;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, buf, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    status = G_IO_STATUS_AGAIN;

                } else {

                    status = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                status = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            status = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        status = G_IO_STATUS_NORMAL;

        *count = written;








    return status;
",1
Detect whether the following code contains vulnerabilities.,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
",0
Detect whether the following code contains vulnerabilities.,"sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,

                                   uint64_t bus_offset,

                                   uint32_t page_shift,

                                   uint32_t nb_table,

                                   bool vfio_accel)

{

    sPAPRTCETable *tcet;

    char tmp[64];



    if (spapr_tce_find_by_liobn(liobn)) {

        fprintf(stderr, ""Attempted to create TCE table with duplicate""

                "" LIOBN 0x%x\n"", liobn);

        return NULL;

    }



    if (!nb_table) {

        return NULL;

    }



    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));

    tcet->liobn = liobn;

    tcet->bus_offset = bus_offset;

    tcet->page_shift = page_shift;

    tcet->nb_table = nb_table;

    tcet->vfio_accel = vfio_accel;



    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);

    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);



    object_property_set_bool(OBJECT(tcet), true, ""realized"", NULL);



    return tcet;

}
",0
Detect whether the following code contains vulnerabilities.,"static void debug_print_fis(uint8_t *fis, int cmd_len)

{

#ifdef DEBUG_AHCI

    int i;



    fprintf(stderr, ""fis:"");

    for (i = 0; i < cmd_len; i++) {

        if ((i & 0xf) == 0) {

            fprintf(stderr, ""\n%02x:"",i);

        }

        fprintf(stderr, ""%02x "",fis[i]);

    }

    fprintf(stderr, ""\n"");

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)

{

#ifdef HAVE_MMX

  register const char* s=src+src_size;

  register char* d=dst+src_size;

  register int offs=-src_size;

  __asm __volatile(PREFETCH""	%0""::""m""(*(s+offs)):""memory"");

  __asm __volatile(

	""movq	%0, %%mm4\n\t""

	""movq	%1, %%mm5""

	::""m""(mask15b), ""m""(mask15rg):""memory"");

  while(offs<0)

  {

	__asm __volatile(

		PREFETCH""	32%1\n\t""

		""movq	%1, %%mm0\n\t""

		""movq	8%1, %%mm2\n\t""

		""movq	%%mm0, %%mm1\n\t""

		""movq	%%mm2, %%mm3\n\t""

		""pand	%%mm4, %%mm0\n\t""

		""pand	%%mm5, %%mm1\n\t""

		""pand	%%mm4, %%mm2\n\t""

		""pand	%%mm5, %%mm3\n\t""

		""psllq	$1, %%mm1\n\t""

		""psllq	$1, %%mm3\n\t""

		""por	%%mm1, %%mm0\n\t""

		""por	%%mm3, %%mm2\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm2, 8%0""

		:""=m""(*(d+offs))

		:""m""(*(s+offs))

		:""memory"");

	offs+=16;

  }

  __asm __volatile(SFENCE:::""memory"");

  __asm __volatile(EMMS:::""memory"");

#else

   const uint16_t *s1=( uint16_t * )src;

   uint16_t *d1=( uint16_t * )dst;

   uint16_t *e=((uint8_t *)s1)+src_size;

   while( s1<e ){

     register int x=*( s1++ );

     /* rrrrrggggggbbbbb

        0rrrrrgggggbbbbb

        0111 1111 1110 0000=0x7FE0

        00000000000001 1111=0x001F */

     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );

   }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
",0
Detect whether the following code contains vulnerabilities.,"static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                        const uint8_t **poutbuf, int *poutbuf_size,

                        const uint8_t *buf, int buf_size)

{

    VorbisParseContext *s = s1->priv_data;

    int duration;



    if (!s->vp && avctx->extradata && avctx->extradata_size) {

        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);

        if (!s->vp)

            goto end;

    }



    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)

        s1->duration = duration;



end:

    /* always return the full packet. this parser isn't doing any splitting or

       combining, only packet analysis */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pci_spapr_set_irq(void *opaque, int irq_num, int level)

{

    /*

     * Here we use the number returned by pci_spapr_map_irq to find a

     * corresponding qemu_irq.

     */

    sPAPRPHBState *phb = opaque;



    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);

    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);

}
",1
Detect whether the following code contains vulnerabilities.,"static int alloc_sequence_buffers(DiracContext *s)

{

    int sbwidth  = DIVRNDUP(s->source.width,  4);

    int sbheight = DIVRNDUP(s->source.height, 4);

    int i, w, h, top_padding;



    /* todo: think more about this / use or set Plane here */

    for (i = 0; i < 3; i++) {

        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);

        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);

        w = s->source.width  >> (i ? s->chroma_x_shift : 0);

        h = s->source.height >> (i ? s->chroma_y_shift : 0);



        /* we allocate the max we support here since num decompositions can

         * change from frame to frame. Stride is aligned to 16 for SIMD, and

         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding

         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that

         * on each side */

        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);

        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */

        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;



        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));

        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));

        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;

        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)

            return AVERROR(ENOMEM);

    }



    w = s->source.width;

    h = s->source.height;



    /* fixme: allocate using real stride here */

    s->sbsplit  = av_malloc(sbwidth * sbheight);

    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));

    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);



    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));

    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);



    if (!s->sbsplit || !s->blmotion)

        return AVERROR(ENOMEM);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int cinepak_decode_frame(AVCodecContext *avctx,

                                void *data, int *got_frame,

                                AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int ret = 0, buf_size = avpkt->size;

    CinepakContext *s = avctx->priv_data;



    s->data = buf;

    s->size = buf_size;



    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)

        return ret;



    if (s->palette_video) {

        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);

        if (pal) {

            s->frame->palette_has_changed = 1;

            memcpy(s->pal, pal, AVPALETTE_SIZE);

        }

    }



    if ((ret = cinepak_decode(s)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");

    }



    if (s->palette_video)

        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);



    if ((ret = av_frame_ref(data, s->frame)) < 0)

        return ret;



    *got_frame = 1;



    /* report that the buffer was completely consumed */

    return buf_size;

}
",0
Detect whether the following code contains vulnerabilities.,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,

                            uint64_t *data)

{

    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);

    uint32_t val;



    switch(addr) {

    case 0x00:

        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);

        break;

    case 0x02:

        val = s->ar.pm1.evt.en;

        break;

    case 0x04:

        val = s->ar.pm1.cnt.cnt;

        break;

    case 0x08:

        val = acpi_pm_tmr_get(&s->ar);

        break;

    default:

        val = 0;

        break;

    }

    PIIX4_DPRINTF(""PM readw port=0x%04x val=0x%04x\n"", (unsigned int)addr, val);

    *data = val;

}
",1
Detect whether the following code contains vulnerabilities.,"static int update_dimensions(VP8Context *s, int width, int height)

{

    if (width  != s->avctx->width ||

        height != s->avctx->height) {

        if (av_image_check_size(width, height, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, height);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    s->macroblocks        = s->macroblocks_base + 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t tmp[146 + 60], *ptr0, *ptr1;

    const int16_t *filter;

    int i, t, off;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    }

}",1
Detect whether the following code contains vulnerabilities.,"static void scsi_disk_purge_requests(SCSIDiskState *s)

{

    SCSIDiskReq *r;



    while (!QTAILQ_EMPTY(&s->qdev.requests)) {

        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));

        if (r->req.aiocb) {

            bdrv_aio_cancel(r->req.aiocb);

        }

        scsi_remove_request(r);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&address_space_memory, addr, buf, len, is_write);

}
",0
Detect whether the following code contains vulnerabilities.,"static void v9fs_link(void *opaque)

{

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;

    int32_t dfid, oldfid;

    V9fsFidState *dfidp, *oldfidp;

    V9fsString name;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfidp = get_fid(pdu, oldfid);

    if (oldfidp == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&name);

    complete_pdu(s, pdu, err);

}
",0
Detect whether the following code contains vulnerabilities.,"int dxva2_init(AVCodecContext *s)

{

    InputStream *ist = s->opaque;

    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;

    DXVA2Context *ctx;

    int ret;



    if (!ist->hwaccel_ctx) {

        ret = dxva2_alloc(s);

        if (ret < 0)

            return ret;

    }

    ctx = ist->hwaccel_ctx;



    if (s->codec_id == AV_CODEC_ID_H264 &&

        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {

        av_log(NULL, loglevel, ""Unsupported H.264 profile for DXVA2 HWAccel: %d\n"", s->profile);

        return AVERROR(EINVAL);

    }



    if (s->codec_id == AV_CODEC_ID_HEVC &&

        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {

        av_log(NULL, loglevel, ""Unsupported HEVC profile for DXVA2 HWAccel: %d\n"", s->profile);

        return AVERROR(EINVAL);

    }



    av_buffer_unref(&ctx->hw_frames_ctx);



    ret = dxva2_create_decoder(s);

    if (ret < 0) {

        av_log(NULL, loglevel, ""Error creating the DXVA2 decoder\n"");

        return ret;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,

                                         XenPTRegInfo *reg)

{

    PCIDevice *d = &s->dev;

    XenPTRegion *region = NULL;

    PCIIORegion *r;

    int index = 0;



    /* check 64bit BAR */

    index = xen_pt_bar_offset_to_index(reg->offset);

    if ((0 < index) && (index < PCI_ROM_SLOT)) {

        int type = s->real_device.io_regions[index - 1].type;



        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)

            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {

            region = &s->bases[index - 1];

            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {

                return XEN_PT_BAR_FLAG_UPPER;

            }

        }

    }



    /* check unused BAR */

    r = &d->io_regions[index];

    if (!xen_pt_get_bar_size(r)) {

        return XEN_PT_BAR_FLAG_UNUSED;

    }



    /* for ExpROM BAR */

    if (index == PCI_ROM_SLOT) {

        return XEN_PT_BAR_FLAG_MEM;

    }



    /* check BAR I/O indicator */

    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {

        return XEN_PT_BAR_FLAG_IO;

    } else {

        return XEN_PT_BAR_FLAG_MEM;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int g726_encode_init(AVCodecContext *avctx)

{

    G726Context* c = avctx->priv_data;



    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&

        avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Sample rates other than 8kHz are not ""

               ""allowed when the compliance level is higher than unofficial. ""

               ""Resample or reduce the compliance level.\n"");

        return AVERROR(EINVAL);

    }

    if (avctx->sample_rate <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""Samplerate is invalid\n"");

        return -1;

    }



    if(avctx->channels != 1){

        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");

        return -1;

    }



    if (avctx->bit_rate % avctx->sample_rate) {

        av_log(avctx, AV_LOG_ERROR, ""Bitrate - Samplerate combination is invalid\n"");

        return AVERROR(EINVAL);

    }

    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;

    if (c->code_size < 2 || c->code_size > 5) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of bits %d\n"", c->code_size);

        return AVERROR(EINVAL);

    }

    avctx->bits_per_coded_sample = c->code_size;



    g726_reset(c, c->code_size - 2);



    avctx->coded_frame = avcodec_alloc_frame();

    if (!avctx->coded_frame)

        return AVERROR(ENOMEM);

    avctx->coded_frame->key_frame = 1;



    /* select a frame size that will end on a byte boundary and have a size of

       approximately 1024 bytes */

    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int flags)

{

    RawDVContext *r   = s->priv_data;

    DVDemuxContext *c = r->dv_demux;

    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);



    dv_offset_reset(c, offset / c->sys->frame_size);



    offset = avio_seek(s->pb, offset, SEEK_SET);

    return (offset < 0) ? offset : 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,

                                     DeviceState *plugged_dev, Error **errp)

{

    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));

    PCIDevice *pdev = PCI_DEVICE(plugged_dev);

    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);

    Error *local_err = NULL;



    /* if DR is disabled we don't need to do anything in the case of

     * hotplug or coldplug callbacks

     */

    if (!phb->dr_enabled) {

        /* if this is a hotplug operation initiated by the user

         * we need to let them know it's not enabled

         */

        if (plugged_dev->hotplugged) {

            error_setg(errp, QERR_BUS_NO_HOTPLUG,

                       object_get_typename(OBJECT(phb)));

        }

        return;

    }



    g_assert(drc);



    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (plugged_dev->hotplugged) {

        spapr_hotplug_req_add_by_index(drc);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int libquvi_read_header(AVFormatContext *s)

{

    int i, ret;

    quvi_t q;

    quvi_media_t m;

    QUVIcode rc;

    LibQuviContext *qc = s->priv_data;

    char *media_url, *pagetitle;



    rc = quvi_init(&q);

    if (rc != QUVI_OK)

        goto quvi_fail;



    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);



    rc = quvi_parse(q, s->filename, &m);

    if (rc != QUVI_OK)

        goto quvi_fail;



    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);

    if (rc != QUVI_OK)

        goto quvi_fail;



    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);

    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);

    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);



    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);

    if (ret < 0)

        goto end;



    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);

    if (rc == QUVI_OK)

        av_dict_set(&s->metadata, ""title"", pagetitle, 0);



    for (i = 0; i < qc->fmtctx->nb_streams; i++) {

        AVStream *st = avformat_new_stream(s, NULL);

        AVStream *ist = qc->fmtctx->streams[i];

        if (!st) {

            ret = AVERROR(ENOMEM);

            goto end;

        }

        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);

        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);

    }



    return 0;



quvi_fail:

    av_log(s, AV_LOG_ERROR, ""%s\n"", quvi_strerror(q, rc));

    ret = AVERROR_EXTERNAL;



end:

    quvi_parse_close(&m);

    quvi_close(&q);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_flush_queued_packets(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = TAILQ_FIRST(&vc->vlan->send_queue);

        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int seqvideo_decode_init(AVCodecContext *avctx)
{
    SeqVideoContext *seq = avctx->priv_data;
    seq->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    seq->frame = av_frame_alloc();
    if (!seq->frame)
        return AVERROR(ENOMEM);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,

                                         int64_t sector_num,

                                         QEMUIOVector *qiov,

                                         int nb_sectors,

                                         BdrvRequestFlags flags,

                                         BlockCompletionFunc *cb,

                                         void *opaque,

                                         bool is_write)

{

    Coroutine *co;

    BlockAIOCBCoroutine *acb;



    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);

    acb->child = child;

    acb->need_bh = true;

    acb->req.error = -EINPROGRESS;

    acb->req.sector = sector_num;

    acb->req.nb_sectors = nb_sectors;

    acb->req.qiov = qiov;

    acb->req.flags = flags;

    acb->is_write = is_write;



    co = qemu_coroutine_create(bdrv_co_do_rw);

    qemu_coroutine_enter(co, acb);



    bdrv_co_maybe_schedule_bh(acb);

    return &acb->common;

}
",1
Detect whether the following code contains vulnerabilities.,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void ccw_machine_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);

    NMIClass *nc = NMI_CLASS(oc);

    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->ri_allowed = true;

    s390mc->cpu_model_allowed = true;

    s390mc->css_migration_enabled = true;

    s390mc->gs_allowed = true;

    mc->init = ccw_init;

    mc->reset = s390_machine_reset;

    mc->hot_add_cpu = s390_hot_add_cpu;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

    mc->no_floppy = 1;

    mc->no_serial = 1;

    mc->no_parallel = 1;

    mc->no_sdcard = 1;

    mc->use_sclp = 1;

    mc->max_cpus = S390_MAX_CPUS;

    mc->has_hotpluggable_cpus = true;

    mc->get_hotplug_handler = s390_get_hotplug_handler;

    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;

    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    mc->default_cpu_type = S390_CPU_TYPE_NAME(""qemu"");

    hc->plug = s390_machine_device_plug;

    hc->unplug_request = s390_machine_device_unplug_request;

    nc->nmi_monitor_handler = s390_nmi;

}
",1
Detect whether the following code contains vulnerabilities.,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"const AVOption *av_opt_next(void *obj, const AVOption *last)

{

    AVClass *class = *(AVClass**)obj;

    if (!last && class->option[0].name) return class->option;

    if (last && last[1].name)           return ++last;

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
",0
Detect whether the following code contains vulnerabilities.,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)

{

        return kvm_dirty_pages_log_change(phys_addr, size,

                                          KVM_MEM_LOG_DIRTY_PAGES,

                                          KVM_MEM_LOG_DIRTY_PAGES);

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
",0
Detect whether the following code contains vulnerabilities.,"static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)

{

    HEVCContext *s  = avctxt->priv_data;

    int ctb_size    = 1 << s->sps->log2_ctb_size;

    int more_data   = 1;

    int x_ctb       = 0;

    int y_ctb       = 0;

    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];



    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {

        av_log(s->avctx, AV_LOG_ERROR, ""Impossible initial tile.\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->sh.dependent_slice_segment_flag) {

        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];

        if (s->tab_slice_address[prev_rs] == -1) {

            av_log(s->avctx, AV_LOG_ERROR, ""Previous slice segment missing\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    while (more_data && ctb_addr_ts < s->sps->ctb_size) {

        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];



        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;

        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;

        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);



        ff_hevc_cabac_init(s, ctb_addr_ts);



        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);



        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;

        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;

        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;



        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);

        if (more_data < 0) {

            s->tab_slice_address[ctb_addr_rs] = -1;

            return more_data;

        }





        ctb_addr_ts++;

        ff_hevc_save_states(s, ctb_addr_ts);

        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);

    }



    if (x_ctb + ctb_size >= s->sps->width &&

        y_ctb + ctb_size >= s->sps->height)

        ff_hevc_hls_filter(s, x_ctb, y_ctb);



    return ctb_addr_ts;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int init(AVFilterContext *ctx, const char *args)

{

    GradFunContext *gf = ctx->priv;

    float thresh = 1.2;

    int radius = 16;



    if (args)

        sscanf(args, ""%f:%d"", &thresh, &radius);



    thresh = av_clipf(thresh, 0.51, 255);

    gf->thresh = (1 << 15) / thresh;

    gf->radius = av_clip((radius + 1) & ~1, 4, 32);



    gf->blur_line = ff_gradfun_blur_line_c;

    gf->filter_line = ff_gradfun_filter_line_c;



    if (ARCH_X86)

        ff_gradfun_init_x86(gf);



    av_log(ctx, AV_LOG_VERBOSE, ""threshold:%.2f radius:%d\n"", thresh, gf->radius);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *chr;

    FDCharDriver *s;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(FDCharDriver));

    s->fd_in = io_channel_from_fd(fd_in);

    s->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);

    s->chr = chr;

    chr->opaque = s;

    chr->chr_add_watch = fd_chr_add_watch;

    chr->chr_write = fd_chr_write;

    chr->chr_update_read_handler = fd_chr_update_read_handler;

    chr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(chr);



    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);

    *got_packet_ptr = 1;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)

{

    int16_t *block = ctx->dct_block;

    unsigned int pos;



    ctx->bdsp.clear_block(block);



    block[0] = get_bits(&ctx->gb, 8) << 3;



    for (pos = 1; pos < num_coeffs; pos++) {

        uint32_t vlc, num_bits;

        int value;

        int coeff;



        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);

        if (!vlc) /* end-of-block code */

            return 0;

        if (vlc == -1)

            return AVERROR_INVALIDDATA;



        /* pos_add and num_bits are coded in the vlc code */

        pos     += vlc & 15; // pos_add

        num_bits = vlc >> 4; // num_bits



        if (pos >= 64)

            return AVERROR_INVALIDDATA;



        value = get_bits(&ctx->gb, num_bits);



        /* FFmpeg's IDCT behaves somewhat different from the original code, so

         * a factor of 4 was added to the input */



        coeff = vlcdec_lookup[num_bits][value];

        if (pos < 3)

            coeff *= 16;

        else /* TODO Use >> 10 instead of / 1001 */

            coeff = (coeff * qscale) / 1001;



        block[ctx->scantable.permutated[pos]] = coeff;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int rl2_decode_init(AVCodecContext *avctx)

{

    Rl2Context *s = avctx->priv_data;

    int back_size;

    int i;

    s->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_PAL8;

    avcodec_get_frame_defaults(&s->frame);



    /** parse extra data */

    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){

        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");

        return -1;

    }



    /** get frame_offset */

    s->video_base = AV_RL16(&avctx->extradata[0]);

    s->clr_count = AV_RL32(&avctx->extradata[2]);



    if(s->video_base >= avctx->width * avctx->height){

        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");

        return -1;

    }



    /** initialize palette */

    for(i=0;i<AVPALETTE_COUNT;i++)

        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);



    /** decode background frame if present */

    back_size = avctx->extradata_size - EXTRADATA1_SIZE;



    if(back_size > 0){

        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);

        if(!back_frame)

            return -1;

        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,

                           back_frame,avctx->width,0);

        s->back_frame = back_frame;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void picmemset(PicContext *s, AVFrame *frame, int value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    int mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,

                                         uint32_t val)

{

    UNINState *s = opaque;



    UNIN_DPRINTF(""config_writel addr "" TARGET_FMT_plx "" val %x\n"", addr, val);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif



    s->config_reg = val;

}
",1
Detect whether the following code contains vulnerabilities.,"vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)
{
    struct vhost_vring_addr *vra = &vmsg->payload.addr;
    unsigned int index = vra->index;
    VubrVirtq *vq = &dev->vq[index];
    DPRINT(""vhost_vring_addr:\n"");
    DPRINT(""    index:  %d\n"", vra->index);
    DPRINT(""    flags:  %d\n"", vra->flags);
    DPRINT(""    desc_user_addr:   0x%016llx\n"", vra->desc_user_addr);
    DPRINT(""    used_user_addr:   0x%016llx\n"", vra->used_user_addr);
    DPRINT(""    avail_user_addr:  0x%016llx\n"", vra->avail_user_addr);
    DPRINT(""    log_guest_addr:   0x%016llx\n"", vra->log_guest_addr);
    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);
    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);
    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);
    vq->log_guest_addr = vra->log_guest_addr;
    DPRINT(""Setting virtq addresses:\n"");
    DPRINT(""    vring_desc  at %p\n"", vq->desc);
    DPRINT(""    vring_used  at %p\n"", vq->used);
    DPRINT(""    vring_avail at %p\n"", vq->avail);
    vq->last_used_index = vq->used->idx;
    return 0;",1
Detect whether the following code contains vulnerabilities.,"static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)

{

    PCIDevice *pd = PCI_DEVICE(br);

    PCIBus *parent = pd->bus;

    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);

    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);



    pci_bridge_init_alias(br, &w->alias_pref_mem,

                          PCI_BASE_ADDRESS_MEM_PREFETCH,

                          ""pci_bridge_pref_mem"",

                          &br->address_space_mem,

                          parent->address_space_mem,

                          cmd & PCI_COMMAND_MEMORY);

    pci_bridge_init_alias(br, &w->alias_mem,

                          PCI_BASE_ADDRESS_SPACE_MEMORY,

                          ""pci_bridge_mem"",

                          &br->address_space_mem,

                          parent->address_space_mem,

                          cmd & PCI_COMMAND_MEMORY);

    pci_bridge_init_alias(br, &w->alias_io,

                          PCI_BASE_ADDRESS_SPACE_IO,

                          ""pci_bridge_io"",

                          &br->address_space_io,

                          parent->address_space_io,

                          cmd & PCI_COMMAND_IO);



    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);



    return w;

}
",0
Detect whether the following code contains vulnerabilities.,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",1
Detect whether the following code contains vulnerabilities.,"static int check_bind(const char *hostname, bool *has_proto)

{

    int fd = -1;

    struct addrinfo ai, *res = NULL;

    int rc;

    int ret = -1;



    memset(&ai, 0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = AF_UNSPEC;

    ai.ai_socktype = SOCK_STREAM;



    /* lookup */

    rc = getaddrinfo(hostname, NULL, &ai, &res);

    if (rc != 0) {

        if (rc == EAI_ADDRFAMILY ||

            rc == EAI_FAMILY) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);

    if (fd < 0) {

        goto cleanup;

    }



    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {

        if (errno == EADDRNOTAVAIL) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    *has_proto = true;

 done:

    ret = 0;



 cleanup:

    if (fd != -1) {

        close(fd);

    }

    if (res) {

        freeaddrinfo(res);

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)

{

    bool progress = false;

    int64_t end_time;



    assert(ctx->notify_me);

    assert(ctx->walking_handlers > 0);

    assert(ctx->poll_disable_cnt == 0);



    trace_run_poll_handlers_begin(ctx, max_ns);



    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;



    do {

        AioHandler *node;



        QLIST_FOREACH(node, &ctx->aio_handlers, node) {

            if (!node->deleted && node->io_poll &&

                node->io_poll(node->opaque)) {

                progress = true;

            }



            /* Caller handles freeing deleted nodes.  Don't do it here. */

        }

    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);



    trace_run_poll_handlers_end(ctx, progress);



    return progress;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
",1
Detect whether the following code contains vulnerabilities.,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
",1
Detect whether the following code contains vulnerabilities.,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
",1
Detect whether the following code contains vulnerabilities.,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
",1
Detect whether the following code contains vulnerabilities.,"void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    memory_region_transaction_begin();

    memory_region_update_pending = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_coroutine_adjust_pool_size(int n)

{

    qemu_mutex_lock(&pool_lock);



    pool_max_size += n;



    /* Callers should never take away more than they added */

    assert(pool_max_size >= POOL_DEFAULT_SIZE);



    /* Trim oversized pool down to new max */

    while (pool_size > pool_max_size) {

        Coroutine *co = QSLIST_FIRST(&pool);

        QSLIST_REMOVE_HEAD(&pool, pool_next);

        pool_size--;

        qemu_coroutine_delete(co);

    }



    qemu_mutex_unlock(&pool_lock);

}
",0
Detect whether the following code contains vulnerabilities.,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

#if HAVE_YASM

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;

        }

#endif



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)

{

    uint32_t msg_type;

    le32 *tmp = (le32 *) data;



    msg_type = le32_to_cpup(tmp);



    switch (msg_type) {

    case RNDIS_INITIALIZE_MSG:

        s->rndis_state = RNDIS_INITIALIZED;

        return rndis_init_response(s, (rndis_init_msg_type *) data);



    case RNDIS_HALT_MSG:

        s->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case RNDIS_QUERY_MSG:

        return rndis_query_response(s, (rndis_query_msg_type *) data, length);



    case RNDIS_SET_MSG:

        return rndis_set_response(s, (rndis_set_msg_type *) data, length);



    case RNDIS_RESET_MSG:

        rndis_clear_responsequeue(s);

        s->out_ptr = s->in_ptr = s->in_len = 0;

        return rndis_reset_response(s, (rndis_reset_msg_type *) data);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);

    }



    return USB_RET_STALL;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
",0
Detect whether the following code contains vulnerabilities.,"static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void realize(DeviceState *d, Error **errp)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    Object *root_container;

    char link_name[256];

    gchar *child_name;

    Error *err = NULL;



    trace_spapr_drc_realize(spapr_drc_index(drc));

    /* NOTE: we do this as part of realize/unrealize due to the fact

     * that the guest will communicate with the DRC via RTAS calls

     * referencing the global DRC index. By unlinking the DRC

     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it

     * inaccessible by the guest, since lookups rely on this path

     * existing in the composition tree

     */

    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);

    snprintf(link_name, sizeof(link_name), ""%x"", spapr_drc_index(drc));

    child_name = object_get_canonical_path_component(OBJECT(drc));

    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);

    object_property_add_alias(root_container, link_name,

                              drc->owner, child_name, &err);

    g_free(child_name);

    if (err) {

        error_propagate(errp, err);

        return;

    }

    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,

                     drc);

    qemu_register_reset(drc_reset, drc);

    trace_spapr_drc_realize_complete(spapr_drc_index(drc));

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *qiv = to_qiv(v);

    StackObject *tos = QSLIST_FIRST(&qiv->stack);



    assert(tos && tos->qapi == obj);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    qmp_input_stack_object_free(tos);

}
",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_h264_free_context(H264Context *h)

{

    int i;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (i = 0; i < h->nb_slice_ctx; i++)

        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)

        av_freep(h->pps_buffers + i);

}
",0
Detect whether the following code contains vulnerabilities.,"static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    AVIOContext *pb = s->pb;

    PutBitContext bs;

    int i, len;

    uint8_t loas_header[] = ""\x56\xe0\x00"";

    uint8_t *buf = NULL;



    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)

        return ff_raw_write_packet(s, pkt);



    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {

        av_log(s, AV_LOG_ERROR, ""ADTS header detected - ADTS will not be incorrectly muxed into LATM\n"");

        return AVERROR_INVALIDDATA;

    }

    if (pkt->size > 0x1fff)

        goto too_large;



    buf = av_malloc(pkt->size+1024);

    if (!buf)

        return AVERROR(ENOMEM);



    init_put_bits(&bs, buf, pkt->size+1024);



    latm_write_frame_header(s, &bs);



    /* PayloadLengthInfo() */

    for (i = 0; i <= pkt->size-255; i+=255)

        put_bits(&bs, 8, 255);



    put_bits(&bs, 8, pkt->size-i);



    /* The LATM payload is written unaligned */



    /* PayloadMux() */

    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {

        // Convert byte-aligned DSE to non-aligned.

        // Due to the input format encoding we know that

        // it is naturally byte-aligned in the input stream,

        // so there are no padding bits to account for.

        // To avoid having to add padding bits and rearrange

        // the whole stream we just remove the byte-align flag.

        // This allows us to remux our FATE AAC samples into latm

        // files that are still playable with minimal effort.

        put_bits(&bs, 8, pkt->data[0] & 0xfe);

        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);

    } else

        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);



    avpriv_align_put_bits(&bs);

    flush_put_bits(&bs);



    len = put_bits_count(&bs) >> 3;



    if (len > 0x1fff)

        goto too_large;



    loas_header[1] |= (len >> 8) & 0x1f;

    loas_header[2] |= len & 0xff;



    avio_write(pb, loas_header, 3);

    avio_write(pb, buf, len);



    av_free(buf);



    return 0;



too_large:

    av_log(s, AV_LOG_ERROR, ""LATM packet size larger than maximum size 0x1fff\n"");

    av_free(buf);

    return AVERROR_INVALIDDATA;

}
",1
Detect whether the following code contains vulnerabilities.,"static void aio_read_done(void *opaque, int ret)

{

    struct aio_ctx *ctx = opaque;

    struct timeval t2;



    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""readv failed: %s\n"", strerror(-ret));

        goto out;

    }



    if (ctx->Pflag) {

        void *cmp_buf = g_malloc(ctx->qiov.size);



        memset(cmp_buf, ctx->pattern, ctx->qiov.size);

        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);

        }

        g_free(cmp_buf);

    }



    if (ctx->qflag) {

        goto out;

    }



    if (ctx->vflag) {

        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, ctx->t1);

    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,

                 ctx->qiov.size, 1, ctx->Cflag);

out:

    qemu_io_free(ctx->buf);


    g_free(ctx);

}",1
Detect whether the following code contains vulnerabilities.,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"void spapr_pci_rtas_init(void)

{

    spapr_rtas_register(""read-pci-config"", rtas_read_pci_config);

    spapr_rtas_register(""write-pci-config"", rtas_write_pci_config);

    spapr_rtas_register(""ibm,read-pci-config"", rtas_ibm_read_pci_config);

    spapr_rtas_register(""ibm,write-pci-config"", rtas_ibm_write_pci_config);

    if (msi_supported) {

        spapr_rtas_register(""ibm,query-interrupt-source-number"",

                            rtas_ibm_query_interrupt_source_number);

        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
",1
Detect whether the following code contains vulnerabilities.,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",1
Detect whether the following code contains vulnerabilities.,"static char *scsibus_get_dev_path(DeviceState *dev)

{

    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);

    DeviceState *hba = dev->parent_bus->parent;

    char *id = NULL;



    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {

        id = hba->parent_bus->info->get_dev_path(hba);

    }

    if (id) {

        return g_strdup_printf(""%s/%d:%d:%d"", id, d->channel, d->id, d->lun);

    } else {

        return g_strdup_printf(""%d:%d:%d"", d->channel, d->id, d->lun);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",1
Detect whether the following code contains vulnerabilities.,"static void xlnx_ep108_init(MachineState *machine)

{

    XlnxEP108 *s = g_new0(XlnxEP108, 1);

    Error *err = NULL;



    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);

    object_property_add_child(OBJECT(machine), ""soc"", OBJECT(&s->soc),

                              &error_abort);



    object_property_set_bool(OBJECT(&s->soc), true, ""realized"", &err);

    if (err) {

        error_report(""%s"", error_get_pretty(err));

        exit(1);

    }



    if (machine->ram_size > EP108_MAX_RAM_SIZE) {

        error_report(""WARNING: RAM size "" RAM_ADDR_FMT "" above max supported, ""

                     ""reduced to %llx"", machine->ram_size, EP108_MAX_RAM_SIZE);

        machine->ram_size = EP108_MAX_RAM_SIZE;

    }



    if (machine->ram_size <= 0x08000000) {

        qemu_log(""WARNING: RAM size "" RAM_ADDR_FMT "" is small for EP108"",

                 machine->ram_size);

    }



    memory_region_allocate_system_memory(&s->ddr_ram, NULL, ""ddr-ram"",

                                         machine->ram_size);

    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);



    xlnx_ep108_binfo.ram_size = machine->ram_size;

    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;

    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;

    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;

    xlnx_ep108_binfo.loader_start = 0;

    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);

}
",1
Detect whether the following code contains vulnerabilities.,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += strspn(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
",1
Detect whether the following code contains vulnerabilities.,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
",0
Detect whether the following code contains vulnerabilities.,"static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,

                                                       const char *key,

                                                       Error **errp)

{

    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];

    char *accept = NULL, *response = NULL;

    size_t responselen;



    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);

    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,

              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);



    /* hash and encode it */

    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,

                            combined_key,

                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

                            QIO_CHANNEL_WEBSOCK_GUID_LEN,

                            &accept,

                            errp) < 0) {

        return -1;

    }



    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);

    responselen = strlen(response);

    buffer_reserve(&ioc->encoutput, responselen);

    buffer_append(&ioc->encoutput, response, responselen);



    g_free(accept);

    g_free(response);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,

                  int dst_x, int dst_y, int w, int h)

{

    DisplayState *s = con->ds;

    DisplayChangeListener *dcl;



    if (!qemu_console_is_visible(con)) {

        return;

    }

    QLIST_FOREACH(dcl, &s->listeners, next) {

        if (con != (dcl->con ? dcl->con : active_console)) {

            continue;

        }

        if (dcl->ops->dpy_gfx_copy) {

            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);

        } else { /* TODO */

            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_connect(VncDisplay *vd, int csock,

                        bool skipauth, bool websocket)

{

    VncState *vs = g_malloc0(sizeof(VncState));

    int i;



    vs->csock = csock;

    vs->vd = vd;



    if (skipauth) {

	vs->auth = VNC_AUTH_NONE;

	vs->subauth = VNC_AUTH_INVALID;

    } else {

        if (websocket) {

            vs->auth = vd->ws_auth;

            vs->subauth = VNC_AUTH_INVALID;

        } else {

            vs->auth = vd->auth;

            vs->subauth = vd->subauth;

        }

    }

    VNC_DEBUG(""Client sock=%d ws=%d auth=%d subauth=%d\n"",

              csock, websocket, vs->auth, vs->subauth);



    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));

    for (i = 0; i < VNC_STAT_ROWS; ++i) {

        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));

    }



    VNC_DEBUG(""New client on socket %d\n"", csock);

    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);

    qemu_set_nonblock(vs->csock);

    if (websocket) {

        vs->websocket = 1;

        if (vd->ws_tls) {

            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);

        } else {

            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);

        }

    } else

    {

        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);

    }



    vnc_client_cache_addr(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);

    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);



    if (!vs->websocket) {

        vnc_init_state(vs);

    }



    if (vd->num_connecting > vd->connections_limit) {

        QTAILQ_FOREACH(vs, &vd->clients, next) {

            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {

                vnc_disconnect_start(vs);

                return;

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_opts_print(QemuOpts *opts, void *dummy)

{

    QemuOpt *opt;



    fprintf(stderr, ""%s: %s:"", opts->list->name,

            opts->id ? opts->id : ""<noid>"");

    TAILQ_FOREACH(opt, &opts->head, next) {

        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);

    }

    fprintf(stderr, ""\n"");

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
",0
Detect whether the following code contains vulnerabilities.,"static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,

                                           struct XenDevOps *ops)

{

    struct XenDevice *xendev;



    xendev = xen_be_find_xendev(type, dom, dev);

    if (xendev) {

        return xendev;

    }



    /* init new xendev */

    xendev = g_malloc0(ops->size);

    xendev->type  = type;

    xendev->dom   = dom;

    xendev->dev   = dev;

    xendev->ops   = ops;



    snprintf(xendev->be, sizeof(xendev->be), ""backend/%s/%d/%d"",

             xendev->type, xendev->dom, xendev->dev);

    snprintf(xendev->name, sizeof(xendev->name), ""%s-%d"",

             xendev->type, xendev->dev);



    xendev->debug      = debug;

    xendev->local_port = -1;



    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);

    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {

        xen_be_printf(NULL, 0, ""can't open evtchn device\n"");

        g_free(xendev);

        return NULL;

    }

    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);



    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {

        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);

        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {

            xen_be_printf(NULL, 0, ""can't open gnttab device\n"");

            xc_evtchn_close(xendev->evtchndev);

            g_free(xendev);

            return NULL;

        }

    } else {

        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;

    }



    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);



    if (xendev->ops->alloc) {

        xendev->ops->alloc(xendev);

    }



    return xendev;

}
",0
Detect whether the following code contains vulnerabilities.,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff) {

            bs->bl.max_discard =

                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);

        }

        bs->bl.discard_alignment =

            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);

    } else {

        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
",0
Detect whether the following code contains vulnerabilities.,"void ide_atapi_cmd(IDEState *s)

{

    uint8_t *buf;



    buf = s->io_buffer;

#ifdef DEBUG_IDE_ATAPI

    {

        int i;

        printf(""ATAPI limit=0x%x packet:"", s->lcyl | (s->hcyl << 8));

        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {

            printf("" %02x"", buf[i]);

        }

        printf(""\n"");

    }

#endif

    /*

     * If there's a UNIT_ATTENTION condition pending, only command flagged with

     * ALLOW_UA are allowed to complete. with other commands getting a CHECK

     * condition response unless a higher priority status, defined by the drive

     * here, is pending.

     */

    if (s->sense_key == UNIT_ATTENTION &&

        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {

        ide_atapi_cmd_check_status(s);

        return;

    }

    /*

     * When a CD gets changed, we have to report an ejected state and

     * then a loaded state to guests so that they detect tray

     * open/close and media change events.  Guests that do not use

     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close

     * states rely on this behavior.

     */

    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&

        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {



        if (s->cdrom_changed == 1) {

            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);

            s->cdrom_changed = 2;

        } else {

            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);

            s->cdrom_changed = 0;

        }



        return;

    }



    /* Report a Not Ready condition if appropriate for the command */

    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&

        (!media_present(s) || !bdrv_is_inserted(s->bs)))

    {

        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);

        return;

    }



    /* Execute the command */

    if (atapi_cmd_table[s->io_buffer[0]].handler) {

        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);

        return;

    }



    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,

                                int nPbH, int log2_cb_size, int part_idx,

                                int merge_idx, MvField *mv)

{

    int singleMCLFlag = 0;

    int nCS = 1 << log2_cb_size;

    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);

    int nPbW2 = nPbW;

    int nPbH2 = nPbH;

    HEVCLocalContext *lc = &s->HEVClc;



    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));



    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {

        singleMCLFlag = 1;

        x0            = lc->cu.x;

        y0            = lc->cu.y;

        nPbW          = nCS;

        nPbH          = nCS;

        part_idx      = 0;

    }



    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);

    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,

                                    singleMCLFlag, part_idx,

                                    merge_idx, mergecand_list);



    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&

        mergecand_list[merge_idx].pred_flag[1] == 1 &&

        (nPbW2 + nPbH2) == 12) {

        mergecand_list[merge_idx].ref_idx[1]   = -1;

        mergecand_list[merge_idx].pred_flag[1] = 0;

    }



    *mv = mergecand_list[merge_idx];

}
",1
Detect whether the following code contains vulnerabilities.,"int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,

                              int cpuid, void *opaque)

{

    S390CPU *cpu = S390_CPU(cs);

    return s390x_write_all_elf64_notes(""CORE"", f, cpu, cpuid, opaque);

}
",1
Detect whether the following code contains vulnerabilities.,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",0
Detect whether the following code contains vulnerabilities.,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,

                                    sPAPRMachineState *spapr,

                                    uint32_t token, uint32_t nargs,

                                    target_ulong args, uint32_t nret,

                                    target_ulong rets)

{

    sPAPRPHBState *sphb;

    sPAPRPHBClass *spc;

    PCIDevice *pdev;

    uint32_t addr, option;

    uint64_t buid;

    int ret;



    if ((nargs != 4) || (nret != 1)) {

        goto param_error_exit;

    }



    buid = rtas_ldq(args, 1);

    addr = rtas_ld(args, 0);

    option = rtas_ld(args, 3);



    sphb = spapr_pci_find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,

                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);

    if (!pdev || !object_dynamic_cast(OBJECT(pdev), ""vfio-pci"")) {

        goto param_error_exit;

    }



    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);

    if (!spc->eeh_set_option) {

        goto param_error_exit;

    }



    ret = spc->eeh_set_option(sphb, addr, option);

    rtas_st(rets, 0, ret);

    return;



param_error_exit:

    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ac97_initfn (PCIDevice *dev)

{

    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);

    AC97LinkState *s = &d->ac97;

    uint8_t *c = d->dev.config;



    s->pci_dev = &d->dev;

    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */

    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */



    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */

    c[0x05] = 0x00;



    c[0x06] = 0x80;      /* pcists pci status rwc, ro */

    c[0x07] = 0x02;



    c[0x08] = 0x01;      /* rid revision ro */

    c[0x09] = 0x00;      /* pi programming interface ro */

    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */

    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */



    c[0x10] = 0x01;      /* nabmar native audio mixer base

                            address rw */

    c[0x11] = 0x00;

    c[0x12] = 0x00;

    c[0x13] = 0x00;



    c[0x14] = 0x01;      /* nabmbar native audio bus mastering

                            base address rw */

    c[0x15] = 0x00;

    c[0x16] = 0x00;

    c[0x17] = 0x00;



    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */

    c[0x2d] = 0x80;



    c[0x2e] = 0x00;      /* sid subsystem id rwo */

    c[0x2f] = 0x00;



    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */

    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */



    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);

    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);

    register_savevm (""ac97"", 0, 2, ac97_save, ac97_load, s);

    qemu_register_reset (ac97_on_reset, s);

    AUD_register_card (""ac97"", &s->card);

    ac97_on_reset (s);

}
",0
Detect whether the following code contains vulnerabilities.,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qmp_output_end_struct(Visitor *v, Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    QObject *value = qmp_output_pop(qov);

    assert(qobject_type(value) == QTYPE_QDICT);

}
",1
Detect whether the following code contains vulnerabilities.,"void compute_images_mse_16bit(PSNRContext *s,

                        const uint8_t *main_data[4], const int main_linesizes[4],

                        const uint8_t *ref_data[4], const int ref_linesizes[4],

                        int w, int h, double mse[4])

{

    int i, c, j;



    for (c = 0; c < s->nb_components; c++) {

        const int outw = s->planewidth[c];

        const int outh = s->planeheight[c];

        const uint16_t *main_line = (uint16_t *)main_data[c];

        const uint16_t *ref_line = (uint16_t *)ref_data[c];

        const int ref_linesize = ref_linesizes[c] / 2;

        const int main_linesize = main_linesizes[c] / 2;

        uint64_t m = 0;



        for (i = 0; i < outh; i++) {

            for (j = 0; j < outw; j++)

                m += pow2(main_line[j] - ref_line[j]);

            ref_line += ref_linesize;

            main_line += main_linesize;

        }

        mse[c] = m / (double)(outw * outh);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);

        stw_be_p(data + sloc, net_checksum_finish(sum));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,

                       uint32_t r3)

{

    uintptr_t ra = GETPC();

    uint64_t destlen = get_length(env, r1 + 1);

    uint64_t dest = get_address(env, r1);

    uint64_t srclen = get_length(env, r3 + 1);

    uint64_t src = get_address(env, r3);

    uint8_t pad = a2 & 0xff;

    uint32_t cc = 0;



    if (!(destlen || srclen)) {

        return cc;

    }



    if (srclen > destlen) {

        srclen = destlen;

    }



    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {

        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;

        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;

        if (v1 != v2) {

            cc = (v1 < v2) ? 1 : 2;

            break;

        }

    }



    set_length(env, r1 + 1, destlen);

    /* can't use srclen here, we trunc'ed it */

    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);

    set_address(env, r1, dest);

    set_address(env, r3, src);



    return cc;

}
",0
Detect whether the following code contains vulnerabilities.,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,

                                             hwaddr ptex, int n)

{

    ppc_hash_pte64_t *hptes = NULL;

    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;



    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {

        /*

         * HTAB is controlled by KVM. Fetch into temporary buffer

         */

        hptes = g_malloc(HASH_PTEG_SIZE_64);

        kvmppc_read_hptes(hptes, ptex, n);

    } else if (cpu->env.external_htab) {

        /*

         * HTAB is controlled by QEMU. Just point to the internally

         * accessible PTEG.

         */

        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);

    } else if (cpu->env.htab_base) {

        hwaddr plen = n * HASH_PTE_SIZE_64;

        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,

                                 &plen, false);

        if (plen < (n * HASH_PTE_SIZE_64)) {

            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);

        }

    }

    return hptes;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline bool regime_translation_disabled(CPUARMState *env,

                                               ARMMMUIdx mmu_idx)

{

    if (arm_feature(env, ARM_FEATURE_M)) {

        switch (env->v7m.mpu_ctrl &

                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {

        case R_V7M_MPU_CTRL_ENABLE_MASK:

            /* Enabled, but not for HardFault and NMI */

            return mmu_idx == ARMMMUIdx_MNegPri ||

                mmu_idx == ARMMMUIdx_MSNegPri;

        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:

            /* Enabled for all cases */

            return false;

        case 0:

        default:

            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but

             * we warned about that in armv7m_nvic.c when the guest set it.

             */

            return true;

        }

    }



    if (mmu_idx == ARMMMUIdx_S2NS) {

        return (env->cp15.hcr_el2 & HCR_VM) == 0;

    }

    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;

}
",0
Detect whether the following code contains vulnerabilities.,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    E1000State *s = opaque;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](s, index);

    }

    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,

                                               abi_ulong target_addr)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))

        return -TARGET_EFAULT;

    host_ts->tv_sec = tswapal(target_ts->tv_sec);

    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 0);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xff);

}
",0
Detect whether the following code contains vulnerabilities.,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
",0
Detect whether the following code contains vulnerabilities.,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)

{

    switch (drc->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return RTAS_OUT_SUCCESS; /* Nothing to do */

    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return RTAS_OUT_PARAM_ERROR; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    g_free(drc->ccs);

    drc->ccs = NULL;



    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (drc->unplug_requested) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_isolation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",0
Detect whether the following code contains vulnerabilities.,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int float64_eq( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {

            float_raise( float_flag_invalid STATUS_VAR);

        }

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
",0
Detect whether the following code contains vulnerabilities.,"static always_inline void gen_cmp(TCGCond cond,

                                  int ra, int rb, int rc,

                                  int islit, uint8_t lit)

{

    int l1, l2;

    TCGv tmp;



    if (unlikely(rc == 31))

    return;



    l1 = gen_new_label();

    l2 = gen_new_label();



    if (ra != 31) {

        tmp = tcg_temp_new(TCG_TYPE_I64);

        tcg_gen_mov_i64(tmp, cpu_ir[ra]);

    } else

        tmp = tcg_const_i64(0);

    if (islit)

        tcg_gen_brcondi_i64(cond, tmp, lit, l1);

    else

        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);



    tcg_gen_movi_i64(cpu_ir[rc], 0);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_movi_i64(cpu_ir[rc], 1);

    gen_set_label(l2);

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
",1
Detect whether the following code contains vulnerabilities.,"static int pci_vpb_init(SysBusDevice *dev)

{

    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);

    PCIBus *bus;

    int i;



    for (i = 0; i < 4; i++) {

        sysbus_init_irq(dev, &s->irq[i]);

    }

    bus = pci_register_bus(&dev->qdev, ""pci"",

                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,

                           get_system_memory(), get_system_io(),

                           PCI_DEVFN(11, 0), 4);



    /* ??? Register memory space.  */



    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,

                          ""pci-vpb-selfconfig"", 0x1000000);

    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,

                          ""pci-vpb-config"", 0x1000000);

    if (s->realview) {

        isa_mmio_setup(&s->isa, 0x0100000);

    }



    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);



    pci_create_simple(bus, -1, ""versatile_pci_host"");

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
",0
Detect whether the following code contains vulnerabilities.,"static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,

                                           sPAPRMachineState *spapr,

                                           uint32_t token, uint32_t nargs,

                                           target_ulong args, uint32_t nret,

                                           target_ulong rets)

{

    sPAPRPHBState *sphb;

    PCIDevice *pdev;

    uint32_t addr, option;

    uint64_t buid;



    if ((nargs != 4) || (nret != 2)) {

        goto param_error_exit;

    }



    buid = rtas_ldq(args, 1);

    sphb = spapr_pci_find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    if (!spapr_phb_eeh_available(sphb)) {

        goto param_error_exit;

    }



    /*

     * We always have PE address of form ""00BB0001"". ""BB""

     * represents the bus number of PE's primary bus.

     */

    option = rtas_ld(args, 3);

    switch (option) {

    case RTAS_GET_PE_ADDR:

        addr = rtas_ld(args, 0);

        pdev = spapr_pci_find_dev(spapr, buid, addr);

        if (!pdev) {

            goto param_error_exit;

        }



        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);

        break;

    case RTAS_GET_PE_MODE:

        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);

        break;

    default:

        goto param_error_exit;

    }



    rtas_st(rets, 0, RTAS_OUT_SUCCESS);

    return;



param_error_exit:

    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);

}
",0
Detect whether the following code contains vulnerabilities.,"static void migrate_fd_completed(MigrationState *s)

{

    DPRINTF(""setting completed state\n"");

    migrate_fd_cleanup(s);

    if (s->state == MIG_STATE_ACTIVE) {

        s->state = MIG_STATE_COMPLETED;

        runstate_set(RUN_STATE_POSTMIGRATE);

    }

    notifier_list_notify(&migration_state_notifiers, s);

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
",0
Detect whether the following code contains vulnerabilities.,"static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *floors = vc->floors;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        floors[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  floors[floor_number].data.t0.map[blockflag];

        vf  = &floors[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void usb_uas_task(UASDevice *uas, uas_ui *ui)

{

    uint16_t tag = be16_to_cpu(ui->hdr.tag);

    uint64_t lun64 = be64_to_cpu(ui->task.lun);

    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);

    int lun = usb_uas_get_lun(lun64);

    UASRequest *req;

    uint16_t task_tag;



    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));

    if (req) {

        goto overlapped_tag;

    }



    switch (ui->task.function) {

    case UAS_TMF_ABORT_TASK:

        task_tag = be16_to_cpu(ui->task.task_tag);

        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);

        if (dev == NULL) {

            goto bad_target;

        }

        if (dev->lun != lun) {

            goto incorrect_lun;

        }

        req = usb_uas_find_request(uas, task_tag);

        if (req && req->dev == dev) {

            scsi_req_cancel(req->req);

        }

        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);

        break;



    case UAS_TMF_LOGICAL_UNIT_RESET:

        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);

        if (dev == NULL) {

            goto bad_target;

        }

        if (dev->lun != lun) {

            goto incorrect_lun;

        }

        qdev_reset_all(&dev->qdev);

        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);

        break;



    default:

        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);

        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);

        break;

    }

    return;



overlapped_tag:

    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);

    return;



bad_target:

    /* FIXME: correct?  [see long comment in usb_uas_command()] */

    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);

    return;



incorrect_lun:

    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int tcg_match_ori(TCGType type, tcg_target_long val)

{

    if (facilities & FACILITY_EXT_IMM) {

        if (type == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */

            return 1;

        }

    }



    /* Look for negative values.  These are best to load with LGHI.  */

    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        }

        if (facilities & FACILITY_EXT_IMM) {

            if (val == (int32_t)val) {

                return 0;

            }

        }

    }



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"void OPPROTO op_addq_EDI_T0(void)

{

    EDI = (EDI + T0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void hypercall_register_types(void)

{

    /* hcall-pft */

    spapr_register_hypercall(H_ENTER, h_enter);

    spapr_register_hypercall(H_REMOVE, h_remove);

    spapr_register_hypercall(H_PROTECT, h_protect);

    spapr_register_hypercall(H_READ, h_read);



    /* hcall-bulk */

    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);



    /* hcall-dabr */

    spapr_register_hypercall(H_SET_DABR, h_set_dabr);



    /* hcall-splpar */

    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);

    spapr_register_hypercall(H_CEDE, h_cede);



    /* processor register resource access h-calls */

    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);

    spapr_register_hypercall(H_SET_MODE, h_set_mode);



    /* ""debugger"" hcalls (also used by SLOF). Note: We do -not- differenciate

     * here between the ""CI"" and the ""CACHE"" variants, they will use whatever

     * mapping attributes qemu is using. When using KVM, the kernel will

     * enforce the attributes more strongly

     */

    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);

    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);

    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);

    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);

    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);

    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);

    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);



    /* qemu/KVM-PPC specific hcalls */

    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);



    /* ibm,client-architecture-support support */

    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    BlockConf *conf = &s->conf.conf;

    struct virtio_blk_config blkcfg;

    uint64_t capacity;

    int blk_size = conf->logical_block_size;



    bdrv_get_geometry(s->bs, &capacity);

    memset(&blkcfg, 0, sizeof(blkcfg));

    virtio_stq_p(vdev, &blkcfg.capacity, capacity);

    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);

    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);

    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);

    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);

    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);

    blkcfg.heads = conf->heads;

    /*

     * We must ensure that the block device capacity is a multiple of

     * the logical block size. If that is not the case, let's use

     * sector_mask to adopt the geometry to have a correct picture.

     * For those devices where the capacity is ok for the given geometry

     * we don't touch the sector value of the geometry, since some devices

     * (like s390 dasd) need a specific value. Here the capacity is already

     * cyls*heads*secs*blk_size and the sector value is not block size

     * divided by 512 - instead it is the amount of blk_size blocks

     * per track (cylinder).

     */

    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {

        blkcfg.sectors = conf->secs & ~s->sector_mask;

    } else {

        blkcfg.sectors = conf->secs;

    }

    blkcfg.size_max = 0;

    blkcfg.physical_block_exp = get_physical_block_exp(conf);

    blkcfg.alignment_offset = 0;

    blkcfg.wce = bdrv_enable_write_cache(s->bs);

    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));

}
",0
Detect whether the following code contains vulnerabilities.,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int tdsc_init(AVCodecContext *avctx)

{

    TDSCContext *ctx = avctx->priv_data;

    const AVCodec *codec;

    int ret;



    avctx->pix_fmt = AV_PIX_FMT_BGR24;



    /* These needs to be set to estimate buffer and frame size */

    if (!(avctx->width && avctx->height)) {

        av_log(avctx, AV_LOG_ERROR, ""Video size not set.\n"");

        return AVERROR_INVALIDDATA;

    }



    /* This value should be large enough for a RAW-only frame plus headers */

    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);

    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);

    if (ret < 0)

        return ret;



    /* Allocate reference and JPEG frame */

    ctx->refframe = av_frame_alloc();

    ctx->jpgframe = av_frame_alloc();

    if (!ctx->refframe || !ctx->jpgframe)

        return AVERROR(ENOMEM);



    /* Prepare everything needed for JPEG decoding */

    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);

    if (!codec)

        return AVERROR_BUG;

    ctx->jpeg_avctx = avcodec_alloc_context3(codec);

    if (!ctx->jpeg_avctx)

        return AVERROR(ENOMEM);

    ctx->jpeg_avctx->flags = avctx->flags;

    ctx->jpeg_avctx->flags2 = avctx->flags2;

    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;

    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;

    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);

    if (ret < 0)

        return ret;



    /* Set the output pixel format on the reference frame */

    ctx->refframe->format = avctx->pix_fmt;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int intel_h263_decode_picture_header(MpegEncContext *s)

{

    int format;



    /* picture header */

    if (get_bits_long(&s->gb, 22) != 0x20) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad picture start code\n"");

        return -1;

    }

    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */



    if (get_bits1(&s->gb) != 1) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad marker\n"");

        return -1;	/* marker */

    }

    if (get_bits1(&s->gb) != 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad H263 id\n"");

        return -1;	/* h263 id */

    }

    skip_bits1(&s->gb);	/* split screen off */

    skip_bits1(&s->gb);	/* camera  off */

    skip_bits1(&s->gb);	/* freeze picture release off */



    format = get_bits(&s->gb, 3);

    if (format != 7) {

        av_log(s->avctx, AV_LOG_ERROR, ""Intel H263 free format not supported\n"");

        return -1;

    }

    s->h263_plus = 0;



    s->pict_type = I_TYPE + get_bits1(&s->gb);

    

    s->unrestricted_mv = get_bits1(&s->gb); 

    s->h263_long_vectors = s->unrestricted_mv;



    if (get_bits1(&s->gb) != 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""SAC not supported\n"");

        return -1;	/* SAC: off */

    }

    if (get_bits1(&s->gb) != 0) {

        s->obmc= 1;

        av_log(s->avctx, AV_LOG_ERROR, ""Advanced Prediction Mode not supported\n"");

//        return -1;	/* advanced prediction mode: off */

    }

    if (get_bits1(&s->gb) != 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""PB frame mode no supported\n"");

        return -1;	/* PB frame mode */

    }



    /* skip unknown header garbage */

    skip_bits(&s->gb, 41);



    s->qscale = get_bits(&s->gb, 5);

    skip_bits1(&s->gb);	/* Continuous Presence Multipoint mode: off */



    /* PEI */

    while (get_bits1(&s->gb) != 0) {

        skip_bits(&s->gb, 8);

    }

    s->f_code = 1;



    s->y_dc_scale_table=

    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}
",1
Detect whether the following code contains vulnerabilities.,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
",0
Detect whether the following code contains vulnerabilities.,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
",0
Detect whether the following code contains vulnerabilities.,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void hmp_cont_cb(void *opaque, int err)

{

    if (!err) {

        qmp_cont(NULL);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){

    ThreadContext *c = avctx->internal->frame_thread_encoder;

    Task task;

    int ret;



    av_assert1(!*got_packet_ptr);



    if(frame){

        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){

            AVFrame *new = avcodec_alloc_frame();

            if(!new)

                return AVERROR(ENOMEM);

            pthread_mutex_lock(&c->buffer_mutex);

            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);

            pthread_mutex_unlock(&c->buffer_mutex);

            if(ret<0)

                return ret;

            new->pts = frame->pts;

            new->quality = frame->quality;

            new->pict_type = frame->pict_type;

            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,

                          avctx->pix_fmt, avctx->width, avctx->height);

            frame = new;

        }



        task.index = c->task_index;

        task.indata = (void*)frame;

        pthread_mutex_lock(&c->task_fifo_mutex);

        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);

        pthread_cond_signal(&c->task_fifo_cond);

        pthread_mutex_unlock(&c->task_fifo_mutex);



        c->task_index = (c->task_index+1) % BUFFER_SIZE;



        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)

            return 0;

    }



    if(c->task_index == c->finished_task_index)

        return 0;



    pthread_mutex_lock(&c->finished_task_mutex);

    while (!c->finished_tasks[c->finished_task_index].outdata) {

        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);

    }

    task = c->finished_tasks[c->finished_task_index];

    *pkt = *(AVPacket*)(task.outdata);

    av_freep(&c->finished_tasks[c->finished_task_index].outdata);

    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;

    pthread_mutex_unlock(&c->finished_task_mutex);



    *got_packet_ptr = 1;



    return task.return_code;

}
",1
Detect whether the following code contains vulnerabilities.,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,

                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)

{

    TCGReg tmp0 = TCG_TMP0;

    TCGReg tmp1 = ret;



    assert(ret != TCG_TMP0);

    if (ret == ah || ret == bh) {

        assert(ret != TCG_TMP1);

        tmp1 = TCG_TMP1;

    }



    switch (cond) {

    case TCG_COND_EQ:

    case TCG_COND_NE:

        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);

        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);

        break;



    default:

        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);

        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);

        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);

        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);

        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void display_mouse_define(DisplayChangeListener *dcl,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);



    qemu_mutex_lock(&ssd->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(ssd->cursor);

    ssd->cursor = c;

    ssd->hot_x = c->hot_x;

    ssd->hot_y = c->hot_y;

    g_free(ssd->ptr_move);

    ssd->ptr_move = NULL;

    g_free(ssd->ptr_define);

    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);

    qemu_mutex_unlock(&ssd->lock);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void stw_phys_internal(hwaddr addr, uint32_t val,

                                     enum device_endian endian)

{

    uint8_t *ptr;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!memory_region_is_ram(section->mr) || section->readonly) {

        addr = memory_region_section_addr(section, addr);

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

#if defined(TARGET_WORDS_BIGENDIAN)

        if (endian == DEVICE_LITTLE_ENDIAN) {

            val = bswap16(val);

        }

#else

        if (endian == DEVICE_BIG_ENDIAN) {

            val = bswap16(val);

        }

#endif

        io_mem_write(section->mr, addr, val, 2);

    } else {

        unsigned long addr1;

        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)

            + memory_region_section_addr(section, addr);

        /* RAM case */

        ptr = qemu_get_ram_ptr(addr1);

        switch (endian) {

        case DEVICE_LITTLE_ENDIAN:

            stw_le_p(ptr, val);

            break;

        case DEVICE_BIG_ENDIAN:

            stw_be_p(ptr, val);

            break;

        default:

            stw_p(ptr, val);

            break;

        }

        invalidate_and_set_dirty(addr1, 2);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int srcStride)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<height; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			""pcmpeqw %%mm7, %%mm7		\n\t""

			""psrlw $8, %%mm7		\n\t"" // FF,00,FF,00...

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		\n\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		\n\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		\n\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%1, %%""REG_a"", 2)\n\t""



			""movq 16(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(12)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(8)

			""movq %%mm2, %%mm4		\n\t"" // YUYV YUYV(12)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(8)

			""psrlw $8, %%mm2		\n\t"" // U0V0 U0V0(12)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm4		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm2, %%mm1		\n\t"" // UVUV UVUV(8)

			""packuswb %%mm4, %%mm3		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm3, 8(%1, %%""REG_a"", 2)\n\t""



			""movq %%mm0, %%mm2		\n\t"" // UVUV UVUV(0)

			""movq %%mm1, %%mm3		\n\t"" // UVUV UVUV(8)

			""psrlw $8, %%mm0		\n\t"" // V0V0 V0V0(0)

			""psrlw $8, %%mm1		\n\t"" // V0V0 V0V0(8)

			""pand %%mm7, %%mm2		\n\t"" // U0U0 U0U0(0)

			""pand %%mm7, %%mm3		\n\t"" // U0U0 U0U0(8)

			""packuswb %%mm1, %%mm0		\n\t"" // VVVV VVVV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // UUUU UUUU(0)



			MOVNTQ"" %%mm0, (%3, %%""REG_a"")	\n\t""

			MOVNTQ"" %%mm2, (%2, %%""REG_a"")	\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""

			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);



		ydst += lumStride;

		src  += srcStride;



		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq 16(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm3\n\t"" // YUYV YUYV(12)

			""pand %%mm7, %%mm0		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm1		\n\t"" // Y0Y0 Y0Y0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm1, %%mm0		\n\t"" // YYYY YYYY(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm0, (%1, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm2, 8(%1, %%""REG_a"", 2)\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""



			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);

#else

		unsigned i;

		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			udst[i] 	= src[4*i+1];

			ydst[2*i+1] 	= src[4*i+2];

			vdst[i] 	= src[4*i+3];

		}

		ydst += lumStride;

		src  += srcStride;



		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			ydst[2*i+1] 	= src[4*i+2];

		}

#endif

		udst += chromStride;

		vdst += chromStride;

		ydst += lumStride;

		src  += srcStride;

	}

#ifdef HAVE_MMX

asm volatile(   EMMS"" \n\t""

        	SFENCE"" \n\t""

        	:::""memory"");

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int huf_uncompress(GetByteContext *gb,

                          uint16_t *dst, int dst_size)

{

    int32_t src_size, im, iM;

    uint32_t nBits;

    uint64_t *freq;

    HufDec *hdec;

    int ret, i;



    src_size = bytestream2_get_le32(gb);

    im = bytestream2_get_le32(gb);

    iM = bytestream2_get_le32(gb);

    bytestream2_skip(gb, 4);

    nBits = bytestream2_get_le32(gb);

    if (im < 0 || im >= HUF_ENCSIZE ||

        iM < 0 || iM >= HUF_ENCSIZE ||

        src_size < 0)

        return AVERROR_INVALIDDATA;



    bytestream2_skip(gb, 4);



    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));

    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));

    if (!freq || !hdec) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)

        goto fail;



    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {

        ret = AVERROR_INVALIDDATA;

        goto fail;

    }



    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)

        goto fail;

    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);



fail:

    for (i = 0; i < HUF_DECSIZE; i++) {

        if (hdec[i].p)

            av_freep(&hdec[i].p);

    }



    av_free(freq);

    av_free(hdec);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int hevc_frame_start(HEVCContext *s)

{

    HEVCLocalContext *lc = &s->HEVClc;

    int ret;



    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);

    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);



    lc->start_of_tiles_x = 0;

    s->is_decoded        = 0;




    if (s->pps->tiles_enabled_flag)

        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;



    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,

                              s->poc);

    if (ret < 0)

        goto fail;



    ret = ff_hevc_frame_rps(s);

    if (ret < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Error constructing the frame RPS.\n"");

        goto fail;

    }



    ret = set_side_data(s);

    if (ret < 0)

        goto fail;



    av_frame_unref(s->output_frame);

    ret = ff_hevc_output_frame(s, s->output_frame, 0);

    if (ret < 0)

        goto fail;



    ff_thread_finish_setup(s->avctx);



    return 0;



fail:

    if (s->ref)

        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);

    s->ref = NULL;

    return ret;

}",1
Detect whether the following code contains vulnerabilities.,"static void gen_mtdcrx(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],

                         cpu_gpr[rS(ctx->opcode)]);

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"int usb_packet_map(USBPacket *p, QEMUSGList *sgl)

{

    int is_write = (p->pid == USB_TOKEN_IN);

    target_phys_addr_t len;

    void *mem;

    int i;



    for (i = 0; i < sgl->nsg; i++) {

        len = sgl->sg[i].len;

        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,

                                      is_write);

        if (!mem) {

            goto err;

        }

        qemu_iovec_add(&p->iov, mem, len);

        if (len != sgl->sg[i].len) {

            goto err;

        }

    }

    return 0;



err:

    usb_packet_unmap(p);

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])

{

    int i;

    if (s->chroma_format == CHROMA_444) {

        encode_block(s, block[0], 0);

        encode_block(s, block[2], 2);

        encode_block(s, block[4], 4);

        encode_block(s, block[8], 8);

        encode_block(s, block[5], 5);

        encode_block(s, block[9], 9);



        if (16*s->mb_x+8 < s->width) {

            encode_block(s, block[1], 1);

            encode_block(s, block[3], 3);

            encode_block(s, block[6], 6);

            encode_block(s, block[10], 10);

            encode_block(s, block[7], 7);

            encode_block(s, block[11], 11);

        }

    } else {

        for(i=0;i<5;i++) {

            encode_block(s, block[i], i);

        }

        if (s->chroma_format == CHROMA_420) {

            encode_block(s, block[5], 5);

        } else {

            encode_block(s, block[6], 6);

            encode_block(s, block[5], 5);

            encode_block(s, block[7], 7);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",0
Detect whether the following code contains vulnerabilities.,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
",0
Detect whether the following code contains vulnerabilities.,"static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sc->sc_fpscr);

    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",1
Detect whether the following code contains vulnerabilities.,"static bool ept_emulation_fault(uint64_t ept_qual)

{

    int read, write;



    /* EPT fault on an instruction fetch doesn't make sense here */

    if (ept_qual & EPT_VIOLATION_INST_FETCH) {

        return false;

    }



    /* EPT fault must be a read fault or a write fault */

    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;

    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;

    if ((read | write) == 0) {

        return false;

    }



    /*

     * The EPT violation must have been caused by accessing a

     * guest-physical address that is a translation of a guest-linear

     * address.

     */

    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||

        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {

        return false;

    }



    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_calculate_timeout(void)

{

#ifndef CONFIG_IOTHREAD

    int timeout;



    if (!vm_running)

        timeout = 5000;

    else {

     /* XXX: use timeout computed from timers */

        int64_t add;

        int64_t delta;

        /* Advance virtual time to the next event.  */

	delta = qemu_icount_delta();

        if (delta > 0) {

            /* If virtual time is ahead of real time then just

               wait for IO.  */

            timeout = (delta + 999999) / 1000000;

        } else {

            /* Wait for either IO to occur or the next

               timer event.  */

            add = qemu_next_deadline();

            /* We advance the timer before checking for IO.

               Limit the amount we advance so that early IO

               activity won't get the guest too far ahead.  */

            if (add > 10000000)

                add = 10000000;

            delta += add;

            qemu_icount += qemu_icount_round (add);

            timeout = delta / 1000000;

            if (timeout < 0)

                timeout = 0;

        }

    }



    return timeout;

#else /* CONFIG_IOTHREAD */

    return 1000;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int ftp_abort(URLContext *h)

{

    static const char *command = ""ABOR\r\n"";

    int err;

    static const int abor_codes[] = {225, 226, 0};

    FTPContext *s = h->priv_data;



    /* According to RCF 959:

       ""ABOR command tells the server to abort the previous FTP

       service command and any associated transfer of data.""



       There are FTP server implementations that don't response

       to any commands during data transfer in passive mode (including ABOR).



       This implementation closes data connection by force.

    */



    if (ftp_send_command(s, command, NULL, NULL) < 0) {

        ftp_close_both_connections(s);

        if ((err = ftp_connect_control_connection(h)) < 0) {

            av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n"");

            return err;

        }

    } else {

        ftp_close_data_connection(s);

    }



    if (ftp_status(s, NULL, abor_codes) < 225) {

        /* wu-ftpd also closes control connection after data connection closing */

        ffurl_closep(&s->conn_control);

        if ((err = ftp_connect_control_connection(h)) < 0) {

            av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n"");

            return err;

        }

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);



    mr = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(mr);



    visit_type_int(v, name, &value, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)

{

    return s->ops->chmod(&s->ctx, path->data, mode);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_xvmc_field_end(MpegEncContext *s)

{

    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];

    assert(render);



    if (render->filled_mv_blocks_num > 0)

        ff_mpeg_draw_horiz_band(s, 0, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"void set_system_memory_map(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
",1
Detect whether the following code contains vulnerabilities.,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)

{

    uintptr_t host_start, host_map_start, host_end;



    last_bss = TARGET_PAGE_ALIGN(last_bss);



    /* ??? There is confusion between qemu_real_host_page_size and

       qemu_host_page_size here and elsewhere in target_mmap, which

       may lead to the end of the data section mapping from the file

       not being mapped.  At least there was an explicit test and

       comment for that here, suggesting that ""the file size must

       be known"".  The comment probably pre-dates the introduction

       of the fstat system call in target_mmap which does in fact

       find out the size.  What isn't clear is if the workaround

       here is still actually needed.  For now, continue with it,

       but merge it with the ""normal"" mmap that would allocate the bss.  */



    host_start = (uintptr_t) g2h(elf_bss);

    host_end = (uintptr_t) g2h(last_bss);

    host_map_start = (host_start + qemu_real_host_page_size - 1);

    host_map_start &= -qemu_real_host_page_size;



    if (host_map_start < host_end) {

        void *p = mmap((void *)host_map_start, host_end - host_map_start,

                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

        if (p == MAP_FAILED) {

            perror(""cannot mmap brk"");

            exit(-1);

        }



        /* Since we didn't use target_mmap, make sure to record

           the validity of the pages with qemu.  */

        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);

    }



    if (host_start < host_map_start) {

        memset((void *)host_start, 0, host_map_start - host_start);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,

                              TCGReg arg1, intptr_t arg2)

{

    int opi, opx;



    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);

    if (type == TCG_TYPE_I32) {

        opi = LWZ, opx = LWZX;

    } else {

        opi = LD, opx = LDX;

    }

    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);

}
",0
Detect whether the following code contains vulnerabilities.,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
",0
Detect whether the following code contains vulnerabilities.,"static void collie_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    StrongARMState *s;

    DriveInfo *dinfo;

    MemoryRegion *sysmem = get_system_memory();



    if (!cpu_model) {

        cpu_model = ""sa1110"";

    }



    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    dinfo = drive_get(IF_PFLASH, 0, 1);

    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    sysbus_create_simple(""scoop"", 0x40800000, NULL);



    collie_binfo.kernel_filename = kernel_filename;

    collie_binfo.kernel_cmdline = kernel_cmdline;

    collie_binfo.initrd_filename = initrd_filename;

    collie_binfo.board_id = 0x208;

    arm_load_kernel(s->cpu, &collie_binfo);

}
",0
Detect whether the following code contains vulnerabilities.,"void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)

{

POWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);

#ifdef ALTIVEC_USE_REFERENCE_C_CODE

    int i;



POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);



    for(i=0; i<h; i++) {

      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));

      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));

      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));

      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));

      pixels+=line_size;

      block +=line_size;

    }



POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);



#else /* ALTIVEC_USE_REFERENCE_C_CODE */

    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;

    register vector unsigned char perm = vec_lvsl(0, pixels);

    int i;



POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);



    for(i=0; i<h; i++) {

      pixelsv1 = vec_ld(0, (unsigned char*)pixels);

      pixelsv2 = vec_ld(16, (unsigned char*)pixels);

      blockv = vec_ld(0, block);

      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);

      blockv = vec_avg(blockv,pixelsv);

      vec_st(blockv, 0, (unsigned char*)block);

      pixels+=line_size;

      block +=line_size;

    }



POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);



#endif /* ALTIVEC_USE_REFERENCE_C_CODE */

}
",0
Detect whether the following code contains vulnerabilities.,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
",0
Detect whether the following code contains vulnerabilities.,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
",0
Detect whether the following code contains vulnerabilities.,"static void cpu_ioreq_pio(ioreq_t *req)

{

    int i, sign;



    sign = req->df ? -1 : 1;



    if (req->dir == IOREQ_READ) {

        if (!req->data_is_ptr) {

            req->data = do_inp(req->addr, req->size);

        } else {

            uint32_t tmp;



            for (i = 0; i < req->count; i++) {

                tmp = do_inp(req->addr, req->size);

                cpu_physical_memory_write(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t *) &tmp, req->size);

            }

        }

    } else if (req->dir == IOREQ_WRITE) {

        if (!req->data_is_ptr) {

            do_outp(req->addr, req->size, req->data);

        } else {

            for (i = 0; i < req->count; i++) {

                uint32_t tmp = 0;



                cpu_physical_memory_read(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t*) &tmp, req->size);

                do_outp(req->addr, req->size, tmp);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static char *choose_pixel_fmts(OutputStream *ost)

{

    if (ost->keep_pix_fmt) {

        if (ost->filter)

            avfilter_graph_set_auto_convert(ost->filter->graph->graph,

                                            AVFILTER_AUTO_CONVERT_NONE);

        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)

            return NULL;

        ost->pix_fmts[0] = ost->st->codec->pix_fmt;

        return ost->pix_fmts;

    }

    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {

        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));

    } else if (ost->enc->pix_fmts) {

        const enum PixelFormat *p;

        AVIOContext *s = NULL;

        uint8_t *ret;

        int len;



        if (avio_open_dyn_buf(&s) < 0)

            exit_program(1);



        p = ost->enc->pix_fmts;

        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {

            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {

                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };

            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {

                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,

                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };

            }

        }



        for (; *p != PIX_FMT_NONE; p++)

            avio_printf(s, ""%s:"", av_get_pix_fmt_name(*p));

        len = avio_close_dyn_buf(s, &ret);

        ret[len - 1] = 0;

        return ret;

    } else

        return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char buffer[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void usb_claim_port(USBDevice *dev, Error **errp)

{

    USBBus *bus = usb_bus_from_device(dev);

    USBPort *port;



    assert(dev->port == NULL);



    if (dev->port_path) {

        QTAILQ_FOREACH(port, &bus->free, next) {

            if (strcmp(port->path, dev->port_path) == 0) {

                break;

            }

        }

        if (port == NULL) {

            error_setg(errp, ""usb port %s (bus %s) not found (in use?)"",

                       dev->port_path, bus->qbus.name);

            return;

        }

    } else {

        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), ""usb-hub"") != 0) {

            /* Create a new hub and chain it on */

            usb_create_simple(bus, ""usb-hub"");

        }

        if (bus->nfree == 0) {

            error_setg(errp, ""tried to attach usb device %s to a bus ""

                       ""with no free ports"", dev->product_desc);

            return;

        }

        port = QTAILQ_FIRST(&bus->free);

    }

    trace_usb_port_claim(bus->busnr, port->path);



    QTAILQ_REMOVE(&bus->free, port, next);

    bus->nfree--;



    dev->port = port;

    port->dev = dev;



    QTAILQ_INSERT_TAIL(&bus->used, port, next);

    bus->nused++;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vmxnet3_update_features(VMXNET3State *s)

{

    uint32_t guest_features;

    int rxcso_supported;



    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,

                                               devRead.misc.uptFeatures);



    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);

    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);

    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);



    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",

              s->lro_supported, rxcso_supported,

              s->rx_vlan_stripping);

    if (s->peer_has_vhdr) {

        qemu_peer_set_offload(qemu_get_queue(s->nic),

                        rxcso_supported,

                        s->lro_supported,

                        s->lro_supported,

                        0,

                        0);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
",0
Detect whether the following code contains vulnerabilities.,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void parse_numa_distance(NumaDistOptions *dist, Error **errp)

{

    uint16_t src = dist->src;

    uint16_t dst = dist->dst;

    uint8_t val = dist->val;



    if (src >= MAX_NODES || dst >= MAX_NODES) {

        error_setg(errp,

                   ""Invalid node %"" PRIu16

                   "", max possible could be %"" PRIu16,

                   MAX(src, dst), MAX_NODES);

        return;

    }



    if (!numa_info[src].present || !numa_info[dst].present) {

        error_setg(errp, ""Source/Destination NUMA node is missing. ""

                   ""Please use '-numa node' option to declare it first."");

        return;

    }



    if (val < NUMA_DISTANCE_MIN) {

        error_setg(errp, ""NUMA distance (%"" PRIu8 "") is invalid, ""

                   ""it shouldn't be less than %d."",

                   val, NUMA_DISTANCE_MIN);

        return;

    }



    if (src == dst && val != NUMA_DISTANCE_MIN) {

        error_setg(errp, ""Local distance of node %d should be %d."",

                   src, NUMA_DISTANCE_MIN);

        return;

    }



    numa_info[src].distance[dst] = val;

    have_numa_distance = true;

}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,

                         uint32_t *pal, int colors)

{

    int i;



    for (i = 0; i <= colors; i++) {

        uint8_t r, g, b;

        unsigned int idx = bytestream2_get_be16(gbc); /* color index */

        if (idx > 255) {

            av_log(avctx, AV_LOG_WARNING,

                   ""Palette index out of range: %u\n"", idx);

            bytestream2_skip(gbc, 6);

            continue;

        }

        r = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        g = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        b = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        pal[idx] = (r << 16) | (g << 8) | b;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,

                          uint8_t **bufptr, DumpState *s)

{

    GuestPhysBlock *block = *blockptr;

    hwaddr addr;

    uint8_t *buf;



    /* block == NULL means the start of the iteration */

    if (!block) {

        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);

        *blockptr = block;

        assert(block->target_start % s->page_size == 0);

        assert(block->target_end % s->page_size == 0);

        *pfnptr = paddr_to_pfn(block->target_start);

        if (bufptr) {

            *bufptr = block->host_addr;

        }

        return true;

    }



    *pfnptr = *pfnptr + 1;

    addr = pfn_to_paddr(*pfnptr);



    if ((addr >= block->target_start) &&

        (addr + s->page_size <= block->target_end)) {

        buf = block->host_addr + (addr - block->target_start);

    } else {

        /* the next page is in the next block */

        block = QTAILQ_NEXT(block, next);

        *blockptr = block;

        if (!block) {

            return false;

        }

        assert(block->target_start % s->page_size == 0);

        assert(block->target_end % s->page_size == 0);

        *pfnptr = paddr_to_pfn(block->target_start);

        buf = block->host_addr;

    }



    if (bufptr) {

        *bufptr = buf;

    }



    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)

{

    const USBDesc *desc = dev->info->usb_desc;

    uint8_t buf[256];

    uint8_t type = value >> 8;

    uint8_t index = value & 0xff;

    int ret = -1;



    switch(type) {

    case USB_DT_DEVICE:

        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));

        trace_usb_desc_device(dev->addr, len, ret);

        break;

    case USB_DT_CONFIG:

        if (index < desc->full->bNumConfigurations) {

            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));

        }

        trace_usb_desc_config(dev->addr, index, len, ret);

        break;

    case USB_DT_STRING:

        ret = usb_desc_string(dev, index, buf, sizeof(buf));

        trace_usb_desc_string(dev->addr, index, len, ret);

        break;

    default:

        fprintf(stderr, ""%s: %d unknown type %d (len %zd)\n"", __FUNCTION__,

                dev->addr, type, len);

        break;

    }



    if (ret > 0) {

        if (ret > len) {

            ret = len;

        }

        memcpy(dest, buf, ret);

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void connex_init(MachineState *machine)

{

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t connex_rom = 0x01000000;

    uint32_t connex_ram = 0x04000000;



    cpu = pxa255_init(address_space_mem, connex_ram);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""connext.rom"", connex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, connex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 36 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(cpu->gpio, 36));

}
",0
Detect whether the following code contains vulnerabilities.,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
",0
Detect whether the following code contains vulnerabilities.,"void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,

                   uint8_t *iv, int decrypt)

{

    int i;



    while (count > 0) {

        if (decrypt) {

            xtea_crypt_ecb(ctx, dst, src, decrypt);



            if (iv) {

                for (i = 0; i < 8; i++)

                    dst[i] = dst[i] ^ iv[i];

                memcpy(iv, src, 8);

            }

        } else {

            if (iv) {

                for (i = 0; i < 8; i++)

                    dst[i] = src[i] ^ iv[i];

                xtea_crypt_ecb(ctx, dst, dst, decrypt);

                memcpy(iv, dst, 8);

            } else {

                xtea_crypt_ecb(ctx, dst, src, decrypt);

            }

        }



        src   += 8;

        dst   += 8;

        count -= 8;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)

{

    AVRational time_base = {1, 1000};

    uint32_t start, end;

    AVChapter *chapter;

    uint8_t *dst = NULL;

    int taglen;

    char tag[5];



    decode_str(s, pb, 0, &dst, &len);

    if (len < 16)

        return;



    start = avio_rb32(pb);

    end   = avio_rb32(pb);

    avio_skip(pb, 8);



    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);

    if (!chapter) {

        av_free(dst);

        return;

    }



    len -= 16;

    while (len > 10) {

        avio_read(pb, tag, 4);

        tag[4] = 0;

        taglen = avio_rb32(pb);

        avio_skip(pb, 2);

        len -= 10;

        if (taglen < 0 || taglen > len) {

            av_free(dst);

            return;

        }

        if (tag[0] == 'T')

            read_ttag(s, pb, taglen, &chapter->metadata, tag);

        else

            avio_skip(pb, taglen);

        len -= taglen;

    }



    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);

    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);

    av_free(dst);

}
",0
Detect whether the following code contains vulnerabilities.,"void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)

{

    unsigned long page_index;

    int ret;

#ifdef _WIN32

    DWORD temp;

#endif



    page_index = ram_addr >> TARGET_PAGE_BITS;

    if (!modified_ram_pages_table[page_index]) {

#if 0

        printf(""%d: modify_page=%08lx\n"", nb_modified_ram_pages, ram_addr);

#endif

        modified_ram_pages_table[page_index] = 1;

        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;

        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {

            /* flush */

#ifdef _WIN32

            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,

                                  &nb_modified_ram_pages,

                                  sizeof(nb_modified_ram_pages),

                                  NULL, 0, &temp, NULL);

#else

            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,

                        &nb_modified_ram_pages);

#endif

            kqemu_reset_modified_ram_pages();

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,

                               uint64_t value, unsigned size)

{

    musicpal_lcd_state *s = opaque;



    switch (offset) {

    case MP_LCD_IRQCTRL:

        s->irqctrl = value;

        break;



    case MP_LCD_SPICTRL:

        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {

            s->mode = value;

        } else {

            s->mode = MP_LCD_SPI_INVALID;

        }

        break;



    case MP_LCD_INST:

        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {

            s->page = value - MP_LCD_INST_SETPAGE0;

            s->page_off = 0;

        }

        break;



    case MP_LCD_DATA:

        if (s->mode == MP_LCD_SPI_CMD) {

            if (value >= MP_LCD_INST_SETPAGE0 &&

                value <= MP_LCD_INST_SETPAGE7) {

                s->page = value - MP_LCD_INST_SETPAGE0;

                s->page_off = 0;

            }

        } else if (s->mode == MP_LCD_SPI_DATA) {

            s->video_ram[s->page*128 + s->page_off] = value;

            s->page_off = (s->page_off + 1) & 127;

        }

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_eventfd(int fds[2])

{

#ifdef CONFIG_EVENTFD

    int ret;



    ret = eventfd(0, 0);

    if (ret >= 0) {

        fds[0] = ret;

        qemu_set_cloexec(ret);

        if ((fds[1] = dup(ret)) == -1) {

            close(ret);

            return -1;

        }

        qemu_set_cloexec(fds[1]);

        return 0;

    }



    if (errno != ENOSYS) {

        return -1;

    }

#endif



    return qemu_pipe(fds);

}
",0
Detect whether the following code contains vulnerabilities.,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    return -ENOTSUP;

}
",0
Detect whether the following code contains vulnerabilities.,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)

{

    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(occ);

    DeviceClass *dc = DEVICE_CLASS(oc);



    occ->parent_realize = dc->realize;

    dc->realize = openrisc_cpu_realizefn;



    occ->parent_reset = cc->reset;

    cc->reset = openrisc_cpu_reset;



    cc->class_by_name = openrisc_cpu_class_by_name;

    cc->has_work = openrisc_cpu_has_work;

    cc->do_interrupt = openrisc_cpu_do_interrupt;

    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;

    cc->dump_state = openrisc_cpu_dump_state;

    cc->set_pc = openrisc_cpu_set_pc;

    cc->gdb_read_register = openrisc_cpu_gdb_read_register;

    cc->gdb_write_register = openrisc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;

    dc->vmsd = &vmstate_openrisc_cpu;

#endif

    cc->gdb_num_core_regs = 32 + 3;



    /*

     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves

     * the object in cpus -> dangling pointer after final

     * object_unref().

     */

    dc->cannot_destroy_with_object_finalize_yet = true;

}
",1
Detect whether the following code contains vulnerabilities.,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)opaque;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
",1
Detect whether the following code contains vulnerabilities.,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
",0
Detect whether the following code contains vulnerabilities.,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *s = opaque;

    uint32_t saddr;



    saddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (saddr) {

    case 0:

        s->leds = val;

        break;

    default:

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
",0
Detect whether the following code contains vulnerabilities.,"void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,

                  bool smm_enabled,

                  qemu_irq sci_irq)

{

    memory_region_init(&pm->io, OBJECT(lpc_pci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&pm->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_pci),

                                0, &pm->io);



    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,

                      pm->s4_val);



    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);



    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,

                          ""acpi-smi"", 8);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);



    pm->smm_enabled = smm_enabled;



    pm->enable_tco = true;

    acpi_pm_tco_init(&pm->tco_regs, &pm->io);



    pm->irq = sci_irq;

    qemu_register_reset(pm_reset, pm);

    pm->powerdown_notifier.notify = pm_powerdown_req;

    qemu_register_powerdown_notifier(&pm->powerdown_notifier);



    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),

        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);



    if (pm->acpi_memory_hotplug.is_enabled) {

        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),

                                 &pm->acpi_memory_hotplug);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,

                                    const uint8_t *key, size_t nkey,

                                    Error **errp)

{

    uint8_t *salt;

    size_t nhash;

    size_t nsalt;

    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);



    /* Not necessarily the same as nkey */

    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);



    nhash = qcrypto_hash_digest_len(ivgen->hash);

    /* Salt must be larger of hash size or key size */

    salt = g_new0(uint8_t, MAX(nhash, nsalt));



    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,

                           &salt, &nhash,

                           errp) < 0) {

        g_free(essiv);


        return -1;

    }



    /* Now potentially truncate salt to match cipher key len */

    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,

                                       QCRYPTO_CIPHER_MODE_ECB,

                                       salt, MIN(nhash, nsalt),

                                       errp);

    if (!essiv->cipher) {

        g_free(essiv);


        return -1;

    }




    ivgen->private = essiv;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
",0
Detect whether the following code contains vulnerabilities.,"static void handle_ti(ESPState *s)

{

    uint32_t dmalen, minlen;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_ti;

        return;

    }



    dmalen = s->rregs[ESP_TCLO];

    dmalen |= s->rregs[ESP_TCMID] << 8;

    dmalen |= s->rregs[ESP_TCHI] << 16;

    if (dmalen==0) {

      dmalen=0x10000;

    }

    s->dma_counter = dmalen;



    if (s->do_cmd)

        minlen = (dmalen < 32) ? dmalen : 32;

    else if (s->ti_size < 0)

        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;

    else

        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;

    trace_esp_handle_ti(minlen);

    if (s->dma) {

        s->dma_left = minlen;

        s->rregs[ESP_RSTAT] &= ~STAT_TC;

        esp_do_dma(s);

    }

    if (s->do_cmd) {

        trace_esp_handle_ti_cmd(s->cmdlen);

        s->ti_size = 0;

        s->cmdlen = 0;

        s->do_cmd = 0;

        do_cmd(s, s->cmdbuf);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
",0
Detect whether the following code contains vulnerabilities.,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",1
Detect whether the following code contains vulnerabilities.,"static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *dev = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(dev);

        return;

    }



    if (usb_device_attach(&dev->dev) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(dev);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",0
Detect whether the following code contains vulnerabilities.,"static void xtensa_kc705_init(MachineState *machine)

{

    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    lx_init(&kc705_board, machine);

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,

                               unsigned int len)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
",0
Detect whether the following code contains vulnerabilities.,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)

{

    TCGLabel *l = &s->labels[label_index];



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);

        tcg_out_goto_noaddr(s);

    } else {

        tcg_out_goto(s, l->u.value_ptr);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void ac97_map (PCIDevice *pci_dev, int region_num,

                      uint32_t addr, uint32_t size, int type)

{

    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;

    AC97LinkState *s = &d->ac97;



    if (!region_num) {

        s->base[0] = addr;

        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);

        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);

        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);

        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);

        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);

        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);

    }

    else {

        s->base[1] = addr;

        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);

        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);

        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);

        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);

        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);

        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int xenfb_send_motion(struct XenInput *xenfb,

			     int rel_x, int rel_y, int rel_z)

{

    union xenkbd_in_event event;



    memset(&event, 0, XENKBD_IN_EVENT_SIZE);

    event.type = XENKBD_TYPE_MOTION;

    event.motion.rel_x = rel_x;

    event.motion.rel_y = rel_y;

#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207

    event.motion.rel_z = rel_z;

#endif



    return xenfb_kbd_event(xenfb, &event);

}
",0
Detect whether the following code contains vulnerabilities.,"static int slirp_socket_load(QEMUFile *f, struct socket *so)

{

    if (tcp_attach(so) < 0)

        return -ENOMEM;



    so->so_urgc = qemu_get_be32(f);

    so->so_ffamily = qemu_get_be16(f);

    switch (so->so_ffamily) {

    case AF_INET:

        so->so_faddr.s_addr = qemu_get_be32(f);

        so->so_fport = qemu_get_be16(f);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to restore so_faddr and so_lport\n"");

    }

    so->so_lfamily = qemu_get_be16(f);

    switch (so->so_lfamily) {

    case AF_INET:

        so->so_laddr.s_addr = qemu_get_be32(f);

        so->so_lport = qemu_get_be16(f);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to restore so_laddr and so_lport\n"");

    }

    so->so_iptos = qemu_get_byte(f);

    so->so_emu = qemu_get_byte(f);

    so->so_type = qemu_get_byte(f);

    so->so_state = qemu_get_be32(f);

    if (slirp_sbuf_load(f, &so->so_rcv) < 0)

        return -ENOMEM;

    if (slirp_sbuf_load(f, &so->so_snd) < 0)

        return -ENOMEM;

    slirp_tcp_load(f, so->so_tcpcb);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
",0
Detect whether the following code contains vulnerabilities.,"static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}",1
Detect whether the following code contains vulnerabilities.,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,

                        const AVFrame *ref)

{

    PSNRContext *s = ctx->priv;

    double comp_mse[4], mse = 0;

    int j, c;

    AVDictionary **metadata = avpriv_frame_get_metadatap(main);



    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,

                      (const uint8_t **)ref->data, ref->linesize,

                       main->width, main->height, comp_mse);



    for (j = 0; j < s->nb_components; j++)

        mse += comp_mse[j] * s->planeweight[j];



    s->min_mse = FFMIN(s->min_mse, mse);

    s->max_mse = FFMAX(s->max_mse, mse);



    s->mse += mse;

    for (j = 0; j < s->nb_components; j++)

        s->mse_comp[j] += comp_mse[j];

    s->nb_frames++;



    for (j = 0; j < s->nb_components; j++) {

        c = s->is_rgb ? s->rgba_map[j] : j;

        set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);

        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));

    }

    set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);

    set_meta(metadata, ""lavfi.psnr.psnr_avg"", 0, get_psnr(mse, 1, s->average_max));



    if (s->stats_file) {

        fprintf(s->stats_file, ""n:%""PRId64"" mse_avg:%0.2f "", s->nb_frames, mse);

        for (j = 0; j < s->nb_components; j++) {

            c = s->is_rgb ? s->rgba_map[j] : j;

            fprintf(s->stats_file, ""mse_%c:%0.2f "", s->comps[j], comp_mse[c]);

        }

        for (j = 0; j < s->nb_components; j++) {

            c = s->is_rgb ? s->rgba_map[j] : j;

            fprintf(s->stats_file, ""psnr_%c:%0.2f "", s->comps[j],

                    get_psnr(comp_mse[c], 1, s->max[c]));

        }

        fprintf(s->stats_file, ""\n"");

    }



    return main;

}
",1
Detect whether the following code contains vulnerabilities.,"static void matroska_add_index_entries(MatroskaDemuxContext *matroska)

{

    EbmlList *index_list;

    MatroskaIndex *index;

    int index_scale = 1;

    int i, j;



    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)

        return;



    index_list = &matroska->index;

    index      = index_list->elem;

    if (index_list->nb_elem &&

        index[0].time > 1E14 / matroska->time_scale) {

        av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.\n"");

        index_scale = matroska->time_scale;

    }

    for (i = 0; i < index_list->nb_elem; i++) {

        EbmlList *pos_list    = &index[i].pos;

        MatroskaIndexPos *pos = pos_list->elem;

        for (j = 0; j < pos_list->nb_elem; j++) {

            MatroskaTrack *track = matroska_find_track_by_num(matroska,

                                                              pos[j].track);

            if (track && track->stream)

                av_add_index_entry(track->stream,

                                   pos[j].pos + matroska->segment_start,

                                   index[i].time / index_scale, 0, 0,

                                   AVINDEX_KEYFRAME);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)

{

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);



    /* Currently Intel IOMMU IR only support ""kernel-irqchip={off|split}"" */

    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&

        !kvm_irqchip_is_split()) {

        error_setg(errp, ""Intel Interrupt Remapping cannot work with ""

                         ""kernel-irqchip=on, please use 'split|off'."");

        return false;

    }

    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {

        error_setg(errp, ""eim=on cannot be selected without intremap=on"");

        return false;

    }



    if (s->intr_eim == ON_OFF_AUTO_AUTO) {

        s->intr_eim = x86_iommu->intr_supported ?

                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;

    }



    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    audio_pcm_init_info (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
",1
Detect whether the following code contains vulnerabilities.,"static int ftp_connect_control_connection(URLContext *h)

{

    char buf[CONTROL_BUFFER_SIZE], opts_format[20];

    int err;

    AVDictionary *opts = NULL;

    FTPContext *s = h->priv_data;

    const int connect_codes[] = {220, 0};



    s->conn_control_block_flag = 0;



    if (!s->conn_control) {

        ff_url_join(buf, sizeof(buf), ""tcp"", NULL,

                    s->hostname, s->server_control_port, NULL);

        if (s->rw_timeout != -1) {

            snprintf(opts_format, sizeof(opts_format), ""%d"", s->rw_timeout);

            av_dict_set(&opts, ""timeout"", opts_format, 0);

        } /* if option is not given, don't pass it and let tcp use its own default */

        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,

                         &s->conn_control_interrupt_cb, &opts);

        av_dict_free(&opts);

        if (err < 0) {

            av_log(h, AV_LOG_ERROR, ""Cannot open control connection\n"");

            return err;

        }



        /* consume all messages from server */

        if (!ftp_status(s, NULL, connect_codes)) {

            av_log(h, AV_LOG_ERROR, ""FTP server not ready for new users\n"");

            err = AVERROR(EACCES);

            return err;

        }



        if ((err = ftp_auth(s)) < 0) {

            av_log(h, AV_LOG_ERROR, ""FTP authentication failed\n"");

            return err;

        }



        if ((err = ftp_type(s)) < 0) {

            av_dlog(h, ""Set content type failed\n"");

            return err;

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
",1
Detect whether the following code contains vulnerabilities.,"void Release(void *ctx)

{

    ContextInfo *ci;

    ci = (ContextInfo *) ctx;



    if (ci->cache) {

        imlib_context_set_image(ci->cache->image);

        imlib_free_image();

        av_free(ci->cache);

    }

    if (ctx) {

        if (ci->imageOverlaid) {

            imlib_context_set_image(ci->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(ci->expr_x);

        ff_eval_free(ci->expr_y);

        ff_eval_free(ci->expr_R);

        ff_eval_free(ci->expr_G);

        ff_eval_free(ci->expr_B);

        sws_freeContext(ci->toRGB_convert_ctx);

        sws_freeContext(ci->fromRGB_convert_ctx);

        av_free(ctx);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_aio_flush(void)

{

    AioHandler *node;

    int ret;



    do {

        ret = 0;



	/*

	 * If there are pending emulated aio start them now so flush

	 * will be able to return 1.

	 */

        qemu_aio_wait();



        LIST_FOREACH(node, &aio_handlers, node) {

            ret |= node->io_flush(node->opaque);

        }

    } while (ret > 0);

}
",1
Detect whether the following code contains vulnerabilities.,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = XEN_PLATFORM(dev);
    uint8_t *pci_conf;
    pci_conf = dev->config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    platform_ioport_bar_setup(d);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);
    /* reserve 16MB mmio address for share memory*/
    platform_mmio_setup(d);
    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,
                     &d->mmio_bar);
    platform_fixed_ioport_init(d);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
",1
Detect whether the following code contains vulnerabilities.,"static void show_packets(AVFormatContext *fmt_ctx)

{

    AVPacket pkt;



    av_init_packet(&pkt);

    probe_array_header(""packets"", 0);

    while (!av_read_frame(fmt_ctx, &pkt))

        show_packet(fmt_ctx, &pkt);

    probe_array_footer(""packets"", 0);

}
",1
Detect whether the following code contains vulnerabilities.,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;

    uint16_t ret;



    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    switch (addr) {

    case 0x14:	/* IT_STATUS */

        ret = s->ulpd_pm_regs[addr >> 2];

        s->ulpd_pm_regs[addr >> 2] = 0;

        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);

        return ret;



    case 0x18:	/* Reserved */

    case 0x1c:	/* Reserved */

    case 0x20:	/* Reserved */

    case 0x28:	/* Reserved */

    case 0x2c:	/* Reserved */

        OMAP_BAD_REG(addr);

    case 0x00:	/* COUNTER_32_LSB */

    case 0x04:	/* COUNTER_32_MSB */

    case 0x08:	/* COUNTER_HIGH_FREQ_LSB */

    case 0x0c:	/* COUNTER_HIGH_FREQ_MSB */

    case 0x10:	/* GAUGING_CTRL */

    case 0x24:	/* SETUP_ANALOG_CELL3_ULPD1 */

    case 0x30:	/* CLOCK_CTRL */

    case 0x34:	/* SOFT_REQ */

    case 0x38:	/* COUNTER_32_FIQ */

    case 0x3c:	/* DPLL_CTRL */

    case 0x40:	/* STATUS_REQ */

        /* XXX: check clk::usecount state for every clock */

    case 0x48:	/* LOCL_TIME */

    case 0x4c:	/* APLL_CTRL */

    case 0x50:	/* POWER_CTRL */

        return s->ulpd_pm_regs[addr >> 2];

    }



    OMAP_BAD_REG(addr);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_riff(AVFormatContext *s, AVIOContext *pb)

{

    AVIContext *avi = s->priv_data;

    char header[8];

    int i;



    /* check RIFF header */

    avio_read(pb, header, 4);

    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */

    avi->riff_end += avio_tell(pb); /* RIFF chunk end */

    avio_read(pb, header+4, 4);



    for(i=0; avi_headers[i][0]; i++)

        if(!memcmp(header, avi_headers[i], 8))

            break;

    if(!avi_headers[i][0])

        return -1;



    if(header[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int altivec_uyvy_rgb32 (SwsContext *c,

			       unsigned char **in, int *instrides,

			       int srcSliceY,	int srcSliceH,

			       unsigned char **oplanes, int *outstrides)

{

  int w = c->srcW;

  int h = srcSliceH;

  int i,j;

  vector unsigned char uyvy;

  vector signed   short Y,U,V;

  vector signed   short vx,ux,uvx;

  vector signed   short R0,G0,B0,R1,G1,B1;

  vector unsigned char  R,G,B;

  vector unsigned char *out;

  ubyte *img;



  img = in[0];

  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);



  for (i=0;i<h;i++) {

    for (j=0;j<w/16;j++) {

      uyvy = vec_ld (0, img);

      U = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_u);



      V = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_v);



      Y = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_y);



      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);



      uyvy = vec_ld (16, img);

      U = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_u);



      V = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_v);



      Y = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_y);



      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);



      R  = vec_packclp (R0,R1);

      G  = vec_packclp (G0,G1);

      B  = vec_packclp (B0,B1);



      //      vec_mstbgr24 (R,G,B, out);

      out_rgba (R,G,B,out);



      img += 32;

    }

  }

  return srcSliceH;

}
",0
Detect whether the following code contains vulnerabilities.,"static void inc_refcounts(BlockDriverState *bs,

                          BdrvCheckResult *res,

                          uint16_t *refcount_table,

                          int refcount_table_size,

                          int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0)

        return;



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""\n"", cluster_offset);

                res->corruptions++;

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
",0
Detect whether the following code contains vulnerabilities.,"void slirp_cleanup(Slirp *slirp)

{

    TAILQ_REMOVE(&slirp_instances, slirp, entry);



    unregister_savevm(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
",0
Detect whether the following code contains vulnerabilities.,"void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
",0
Detect whether the following code contains vulnerabilities.,"rdt_free_extradata (PayloadContext *rdt)

{

    int i;



    for (i = 0; i < MAX_STREAMS; i++)

        if (rdt->rmst[i]) {

            ff_rm_free_rmstream(rdt->rmst[i]);

            av_freep(&rdt->rmst[i]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",0
Detect whether the following code contains vulnerabilities.,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->nvdimm;

}
",0
Detect whether the following code contains vulnerabilities.,"build_header(GArray *linker, GArray *table_data,

             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,

             const char *oem_table_id)

{

    memcpy(&h->signature, sig, 4);

    h->length = cpu_to_le32(len);

    h->revision = rev;

    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);



    if (oem_table_id) {

        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));

    } else {

        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);

        memcpy(h->oem_table_id + 4, sig, 4);

    }



    h->oem_revision = cpu_to_le32(1);

    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);

    h->asl_compiler_revision = cpu_to_le32(1);

    h->checksum = 0;

    /* Checksum to be filled in by Guest linker */

    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,

                                    table_data->data, h, len, &h->checksum);

}
",0
Detect whether the following code contains vulnerabilities.,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        return 1;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int svq1_decode_init(AVCodecContext *avctx)

{

    MpegEncContext *s = avctx->priv_data;

    int i;



    MPV_decode_defaults(s);



    s->avctx = avctx;

    s->width = (avctx->width+3)&~3;

    s->height = (avctx->height+3)&~3;

    s->codec_id= avctx->codec->id;

    avctx->pix_fmt = PIX_FMT_YUV410P;

    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames

    s->flags= avctx->flags;

    if (MPV_common_init(s) < 0) return -1;



    init_vlc(&svq1_block_type, 2, 4,

        &svq1_block_type_vlc[0][1], 2, 1,

        &svq1_block_type_vlc[0][0], 2, 1);



    init_vlc(&svq1_motion_component, 7, 33,

        &mvtab[0][1], 2, 1,

        &mvtab[0][0], 2, 1);



    for (i = 0; i < 6; i++) {

        init_vlc(&svq1_intra_multistage[i], 3, 8,

            &svq1_intra_multistage_vlc[i][0][1], 2, 1,

            &svq1_intra_multistage_vlc[i][0][0], 2, 1);

        init_vlc(&svq1_inter_multistage[i], 3, 8,

            &svq1_inter_multistage_vlc[i][0][1], 2, 1,

            &svq1_inter_multistage_vlc[i][0][0], 2, 1);

    }



    init_vlc(&svq1_intra_mean, 8, 256,

        &svq1_intra_mean_vlc[0][1], 4, 2,

        &svq1_intra_mean_vlc[0][0], 4, 2);



    init_vlc(&svq1_inter_mean, 9, 512,

        &svq1_inter_mean_vlc[0][1], 4, 2,

        &svq1_inter_mean_vlc[0][0], 4, 2);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int parse_fmtp(AVFormatContext *s,

                      AVStream *stream, PayloadContext *data,

                      const char *attr, const char *value)

{

    AVCodecParameters *par = stream->codecpar;

    int res, i;



    if (!strcmp(attr, ""config"")) {

        res = parse_fmtp_config(par, value);



        if (res < 0)

            return res;

    }



    if (par->codec_id == AV_CODEC_ID_AAC) {

        /* Looking for a known attribute */

        for (i = 0; attr_names[i].str; ++i) {

            if (!av_strcasecmp(attr, attr_names[i].str)) {

                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {

                    *(int *)((char *)data+

                        attr_names[i].offset) = atoi(value);

                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)

                    *(char **)((char *)data+

                        attr_names[i].offset) = av_strdup(value);

            }

        }

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",0
Detect whether the following code contains vulnerabilities.,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_6REGS && HAVE_INLINE_ASM

    if (INLINE_AMD3DNOWEXT(cpu_flags)) {

        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;

    }

    if (INLINE_SSE(cpu_flags)) {

        fdsp->vector_fmul_window = vector_fmul_window_sse;

    }

#endif

    if (EXTERNAL_SSE(cpu_flags)) {

        fdsp->vector_fmul = ff_vector_fmul_sse;

        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;

        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;

        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;

        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;

        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;

        fdsp->butterflies_float   = ff_butterflies_float_sse;

    }

    if (EXTERNAL_SSE2(cpu_flags)) {

        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;

    }

    if (EXTERNAL_AVX(cpu_flags)) {

        fdsp->vector_fmul = ff_vector_fmul_avx;

        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;

        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;

        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;

        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void lsi_soft_reset(LSIState *s)

{

    lsi_request *p;



    DPRINTF(""Reset\n"");

    s->carry = 0;



    s->msg_action = 0;

    s->msg_len = 0;

    s->waiting = 0;

    s->dsa = 0;

    s->dnad = 0;

    s->dbc = 0;

    s->temp = 0;

    memset(s->scratch, 0, sizeof(s->scratch));

    s->istat0 = 0;

    s->istat1 = 0;

    s->dcmd = 0x40;

    s->dstat = LSI_DSTAT_DFE;

    s->dien = 0;

    s->sist0 = 0;

    s->sist1 = 0;

    s->sien0 = 0;

    s->sien1 = 0;

    s->mbox0 = 0;

    s->mbox1 = 0;

    s->dfifo = 0;

    s->ctest2 = LSI_CTEST2_DACK;

    s->ctest3 = 0;

    s->ctest4 = 0;

    s->ctest5 = 0;

    s->ccntl0 = 0;

    s->ccntl1 = 0;

    s->dsp = 0;

    s->dsps = 0;

    s->dmode = 0;

    s->dcntl = 0;

    s->scntl0 = 0xc0;

    s->scntl1 = 0;

    s->scntl2 = 0;

    s->scntl3 = 0;

    s->sstat0 = 0;

    s->sstat1 = 0;

    s->scid = 7;

    s->sxfer = 0;

    s->socl = 0;

    s->sdid = 0;

    s->ssid = 0;

    s->stest1 = 0;

    s->stest2 = 0;

    s->stest3 = 0;

    s->sidl = 0;

    s->stime0 = 0;

    s->respid0 = 0x80;

    s->respid1 = 0;

    s->mmrs = 0;

    s->mmws = 0;

    s->sfs = 0;

    s->drs = 0;

    s->sbms = 0;

    s->dbms = 0;

    s->dnad64 = 0;

    s->pmjad1 = 0;

    s->pmjad2 = 0;

    s->rbc = 0;

    s->ua = 0;

    s->ia = 0;

    s->sbc = 0;

    s->csbc = 0;

    s->sbr = 0;

    while (!QTAILQ_EMPTY(&s->queue)) {

        p = QTAILQ_FIRST(&s->queue);

        QTAILQ_REMOVE(&s->queue, p, next);

        g_free(p);

    }

    if (s->current) {

        g_free(s->current);

        s->current = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)

{

    VncDisplay *vd = ds->opaque;

    VncState *vs = vd->clients;

    while (vs != NULL) {

        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))

            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);

        else /* TODO */

            vnc_update(vs, dst_x, dst_y, w, h);

        vs = vs->next;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);

    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(vevent); /* stop vevent thread */

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,

                      &card->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int get_chroma_qp(H264Context *h, int qscale){

    return h->pps.chroma_qp_table[qscale & 0xff];

}
",1
Detect whether the following code contains vulnerabilities.,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static int movie_request_frame(AVFilterLink *outlink)

{

    AVFilterBufferRef *outpicref;

    MovieContext *movie = outlink->src->priv;

    int ret;



    if (movie->is_done)

        return AVERROR_EOF;

    if ((ret = movie_get_frame(outlink)) < 0)

        return ret;



    outpicref = avfilter_ref_buffer(movie->picref, ~0);

    ff_start_frame(outlink, outpicref);

    ff_draw_slice(outlink, 0, outlink->h, 1);

    ff_end_frame(outlink);

    avfilter_unref_buffer(movie->picref);

    movie->picref = NULL;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void process_client(AVIOContext *client, const char *in_uri)

{

    AVIOContext *input = NULL;

    uint8_t buf[1024];

    int ret, n, reply_code;

    uint8_t *resource = NULL;

    while ((ret = avio_handshake(client)) > 0) {

        av_opt_get(client, ""resource"", AV_OPT_SEARCH_CHILDREN, &resource);

        // check for strlen(resource) is necessary, because av_opt_get()

        // may return empty string.

        if (resource && strlen(resource))

            break;


    }

    if (ret < 0)

        goto end;

    av_log(client, AV_LOG_TRACE, ""resource=%p\n"", resource);

    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {

        reply_code = 200;

    } else {

        reply_code = AVERROR_HTTP_NOT_FOUND;

    }

    if ((ret = av_opt_set_int(client, ""reply_code"", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {

        av_log(client, AV_LOG_ERROR, ""Failed to set reply_code: %s.\n"", av_err2str(ret));

        goto end;

    }

    av_log(client, AV_LOG_TRACE, ""Set reply code to %d\n"", reply_code);



    while ((ret = avio_handshake(client)) > 0);



    if (ret < 0)

        goto end;



    fprintf(stderr, ""Handshake performed.\n"");

    if (reply_code != 200)

        goto end;

    fprintf(stderr, ""Opening input file.\n"");

    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {

        av_log(input, AV_LOG_ERROR, ""Failed to open input: %s: %s.\n"", in_uri,

               av_err2str(ret));

        goto end;

    }

    for(;;) {

        n = avio_read(input, buf, sizeof(buf));

        if (n < 0) {

            if (n == AVERROR_EOF)

                break;

            av_log(input, AV_LOG_ERROR, ""Error reading from input: %s.\n"",

                   av_err2str(n));

            break;

        }

        avio_write(client, buf, n);

        avio_flush(client);

    }

end:

    fprintf(stderr, ""Flushing client\n"");

    avio_flush(client);

    fprintf(stderr, ""Closing client\n"");

    avio_close(client);

    fprintf(stderr, ""Closing input\n"");

    avio_close(input);


}",1
Detect whether the following code contains vulnerabilities.,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_pipe(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    ChardevHostdev *opts = backend->u.pipe;

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_new0(WinCharState, 1);

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename, errp) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",0
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,

                                        unsigned int queue_no,

                                        unsigned int vector,

                                        MSIMessage msg)

{

    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);

    EventNotifier *n = virtio_queue_get_guest_notifier(vq);

    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];

    int ret;



    if (irqfd->users == 0) {

        ret = kvm_irqchip_add_msi_route(kvm_state, msg);

        if (ret < 0) {

            return ret;

        }

        irqfd->virq = ret;

    }

    irqfd->users++;



    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);

    if (ret < 0) {

        if (--irqfd->users == 0) {

            kvm_irqchip_release_virq(kvm_state, irqfd->virq);

        }

        return ret;

    }



    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)

{

    int ret = -EIO;



    /* Add footer to total size */

    total_size += 512;

    if (ftruncate(fd, total_size) != 0) {

        ret = -errno;

        goto fail;

    }

    if (lseek(fd, -512, SEEK_END) < 0) {

        goto fail;

    }

    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    ret = 0;



 fail:

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    return ide_status_read(&s->bus, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_slice_thread_free(AVCodecContext *avctx)

{

    ThreadContext *c = avctx->thread_opaque;

    int i;



    pthread_mutex_lock(&c->current_job_lock);

    c->done = 1;

    pthread_cond_broadcast(&c->current_job_cond);

    pthread_mutex_unlock(&c->current_job_lock);



    for (i=0; i<avctx->thread_count; i++)

         pthread_join(c->workers[i], NULL);



    pthread_mutex_destroy(&c->current_job_lock);

    pthread_cond_destroy(&c->current_job_cond);

    pthread_cond_destroy(&c->last_job_cond);

    av_free(c->workers);

    av_freep(&avctx->thread_opaque);

}
",0
Detect whether the following code contains vulnerabilities.,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",1
Detect whether the following code contains vulnerabilities.,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_dispatch_cmd_failure(void)

{

    QDict *req = qdict_new();


    QObject *resp;



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);



    /* check that with extra arguments it throws an error */

    req = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(req, ""arguments"", args);



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);

}",1
Detect whether the following code contains vulnerabilities.,"static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
",1
Detect whether the following code contains vulnerabilities.,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
",0
Detect whether the following code contains vulnerabilities.,"void kqemu_record_dump(void)

{

    PCRecord **pr, *r;

    int i, h;

    FILE *f;

    int64_t total, sum;



    pr = malloc(sizeof(PCRecord *) * nb_pc_records);

    i = 0;

    total = 0;

    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {

            pr[i++] = r;

            total += r->count;

        }

    }

    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);



    f = fopen(""/tmp/kqemu.stats"", ""w"");

    if (!f) {

        perror(""/tmp/kqemu.stats"");

        exit(1);

    }

    fprintf(f, ""total: %"" PRId64 ""\n"", total);

    sum = 0;

    for(i = 0; i < nb_pc_records; i++) {

        r = pr[i];

        sum += r->count;

        fprintf(f, ""%08lx: %"" PRId64 "" %0.2f%% %0.2f%%\n"",

                r->pc,

                r->count,

                (double)r->count / (double)total * 100.0,

                (double)sum / (double)total * 100.0);

    }

    fclose(f);

    free(pr);



    kqemu_record_flush();

}
",0
Detect whether the following code contains vulnerabilities.,"static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,

                struct vmsvga_cursor_definition_s *c)

{

    QEMUCursor *qc;

    int i, pixels;



    qc = cursor_alloc(c->width, c->height);

    qc->hot_x = c->hot_x;

    qc->hot_y = c->hot_y;

    switch (c->bpp) {

    case 1:

        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,

                        1, (void*)c->mask);

#ifdef DEBUG

        cursor_print_ascii_art(qc, ""vmware/mono"");

#endif

        break;

    case 32:

        /* fill alpha channel from mask, set color to zero */

        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,

                        1, (void*)c->mask);

        /* add in rgb values */

        pixels = c->width * c->height;

        for (i = 0; i < pixels; i++) {

            qc->data[i] |= c->image[i] & 0xffffff;

        }

#ifdef DEBUG

        cursor_print_ascii_art(qc, ""vmware/32bit"");

#endif

        break;

    default:

        fprintf(stderr, ""%s: unhandled bpp %d, using fallback cursor\n"",

                __FUNCTION__, c->bpp);

        cursor_put(qc);

        qc = cursor_builtin_left_ptr();

    }



    dpy_cursor_define(s->vga.ds, qc);

    cursor_put(qc);

}
",0
Detect whether the following code contains vulnerabilities.,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
",0
Detect whether the following code contains vulnerabilities.,"int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
",1
Detect whether the following code contains vulnerabilities.,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    unsigned int i, entries;



    if (c->fc->nb_streams < 1)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];

    sc = st->priv_data;



    avio_r8(pb); /* version */

    avio_rb24(pb); /* flags */



    entries = avio_rb32(pb);



    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);



    if (!entries)

        return 0;

    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))

        return AVERROR_INVALIDDATA;

    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));

    if (!sc->stsc_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < entries && !pb->eof_reached; i++) {

        sc->stsc_data[i].first = avio_rb32(pb);

        sc->stsc_data[i].count = avio_rb32(pb);

        sc->stsc_data[i].id = avio_rb32(pb);

        if (sc->stsc_data[i].id > sc->stsd_count)

            return AVERROR_INVALIDDATA;

    }



    sc->stsc_count = i;



    if (pb->eof_reached)

        return AVERROR_EOF;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t size)

{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    size += (size & 1);



    if (size == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(size + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, size);

    value[size] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
",0
Detect whether the following code contains vulnerabilities.,"static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)

{

    int i, j;

    for (i = 0; i < 5; i++) {

        for (j = 0; j < 38; j++) {

            in[i][j+6][0] = L[0][j][i];

            in[i][j+6][1] = L[1][j][i];

        }

    }

    if (is34) {

        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);

        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);

        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);

        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);

        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);

        for (i = 0; i < 59; i++) {

            for (j = 0; j < len; j++) {

                out[i+32][j][0] = L[0][j][i+5];

                out[i+32][j][1] = L[1][j][i+5];

            }

        }

    } else {

        hybrid6_cx(in[0], out, f20_0_8, len);

        hybrid2_re(in[1], out+6, g1_Q2, len, 1);

        hybrid2_re(in[2], out+8, g1_Q2, len, 0);

        for (i = 0; i < 61; i++) {

            for (j = 0; j < len; j++) {

                out[i+10][j][0] = L[0][j][i+3];

                out[i+10][j][1] = L[1][j][i+3];

            }

        }

    }

    //update in_buf

    for (i = 0; i < 5; i++) {

        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",1
Detect whether the following code contains vulnerabilities.,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);

    VirtQueueElement elem;

    MemoryRegionSection section;



    while (virtqueue_pop(vq, &elem)) {

        size_t offset = 0;

        uint32_t pfn;



        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {

            ram_addr_t pa;

            ram_addr_t addr;

            int p = virtio_ldl_p(vdev, &pfn);



            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;

            offset += 4;



            /* FIXME: remove get_system_memory(), but how? */

            section = memory_region_find(get_system_memory(), pa, 1);

            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))

                continue;



            trace_virtio_balloon_handle_output(memory_region_name(section.mr),

                                               pa);

            /* Using memory_region_get_ram_ptr is bending the rules a bit, but

               should be OK because we only want a single page.  */

            addr = section.offset_within_region;

            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,

                         !!(vq == s->dvq));

            memory_region_unref(section.mr);

        }



        virtqueue_push(vq, &elem, offset);

        virtio_notify(vdev, vq);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int vorbis_decode_init(AVCodecContext *avccontext)

{

    vorbis_context *vc = avccontext->priv_data;

    uint8_t *headers   = avccontext->extradata;

    int headers_len    = avccontext->extradata_size;

    uint8_t *header_start[3];

    int header_len[3];

    GetBitContext *gb = &vc->gb;

    int hdr_type, ret;



    vc->avccontext = avccontext;

    ff_dsputil_init(&vc->dsp, avccontext);

    ff_fmt_convert_init(&vc->fmt_conv, avccontext);



    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {

        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;

        vc->scale_bias = 1.0f;

    } else {

        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;

        vc->scale_bias = 32768.0f;

    }



    if (!headers_len) {

        av_log(avccontext, AV_LOG_ERROR, ""Extradata missing.\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {

        av_log(avccontext, AV_LOG_ERROR, ""Extradata corrupt.\n"");

        return ret;

    }



    init_get_bits(gb, header_start[0], header_len[0]*8);

    hdr_type = get_bits(gb, 8);

    if (hdr_type != 1) {

        av_log(avccontext, AV_LOG_ERROR, ""First header is not the id header.\n"");

        return AVERROR_INVALIDDATA;

    }

    if ((ret = vorbis_parse_id_hdr(vc))) {

        av_log(avccontext, AV_LOG_ERROR, ""Id header corrupt.\n"");

        vorbis_free(vc);

        return ret;

    }



    init_get_bits(gb, header_start[2], header_len[2]*8);

    hdr_type = get_bits(gb, 8);

    if (hdr_type != 5) {

        av_log(avccontext, AV_LOG_ERROR, ""Third header is not the setup header.\n"");

        vorbis_free(vc);

        return AVERROR_INVALIDDATA;

    }

    if ((ret = vorbis_parse_setup_hdr(vc))) {

        av_log(avccontext, AV_LOG_ERROR, ""Setup header corrupt.\n"");

        vorbis_free(vc);

        return ret;

    }



    if (vc->audio_channels > 8)

        avccontext->channel_layout = 0;

    else

        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];



    avccontext->channels    = vc->audio_channels;

    avccontext->sample_rate = vc->audio_samplerate;

    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;



    avcodec_get_frame_defaults(&vc->frame);

    avccontext->coded_frame = &vc->frame;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
",1
Detect whether the following code contains vulnerabilities.,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
",1
Detect whether the following code contains vulnerabilities.,"static void external_snapshot_commit(BlkActionState *common)

{

    ExternalSnapshotState *state =

                             DO_UPCAST(ExternalSnapshotState, common, common);



    bdrv_set_aio_context(state->new_bs, state->aio_context);



    /* This removes our old bs and adds the new bs */

    bdrv_append(state->new_bs, state->old_bs);

    /* We don't need (or want) to use the transactional

     * bdrv_reopen_multiple() across all the entries at once, because we

     * don't want to abort all of them if one of them fails the reopen */

    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,

                NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    uint8_t *buf;



    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)

        return ret;

    buf = av_malloc(ret + align);

    if (!buf)

        return AVERROR(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }

    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
",1
Detect whether the following code contains vulnerabilities.,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
",1
Detect whether the following code contains vulnerabilities.,"static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)

{

    AVFormatContext *is = ifile->ctx;

    AVFormatContext *os = ofile->ctx;

    int i;



    for (i = 0; i < is->nb_chapters; i++) {

        AVChapter *in_ch = is->chapters[i], *out_ch;

        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,

                                       AV_TIME_BASE_Q, in_ch->time_base);

        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :

                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);





        if (in_ch->end < ts_off)

            continue;

        if (rt != INT64_MAX && in_ch->start > rt + ts_off)

            break;



        out_ch = av_mallocz(sizeof(AVChapter));

        if (!out_ch)

            return AVERROR(ENOMEM);



        out_ch->id        = in_ch->id;

        out_ch->time_base = in_ch->time_base;

        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);

        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);



        if (copy_metadata)

            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);



        os->nb_chapters++;

        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);

        if (!os->chapters)

            return AVERROR(ENOMEM);

        os->chapters[os->nb_chapters - 1] = out_ch;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)

{

    unsigned int idx, rec_off, old_idx, new_idx;

    uint32_t rec_len = sizeof(TraceRecord) + datasize;

    uint64_t event_u64 = event;

    uint64_t timestamp_ns = get_clock();



    do {

        old_idx = g_atomic_int_get(&trace_idx);

        smp_rmb();

        new_idx = old_idx + rec_len;



        if (new_idx - writeout_idx > TRACE_BUF_LEN) {

            /* Trace Buffer Full, Event dropped ! */

            g_atomic_int_inc(&dropped_events);

            return -ENOSPC;

        }

    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));



    idx = old_idx % TRACE_BUF_LEN;



    rec_off = idx;

    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));

    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));

    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));

    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));



    rec->tbuf_idx = idx;

    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void xen_remap_bucket(MapCacheEntry *entry,

                             hwaddr size,

                             hwaddr address_index)

{

    uint8_t *vaddr_base;

    xen_pfn_t *pfns;

    int *err;

    unsigned int i;

    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;



    trace_xen_remap_bucket(address_index);



    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));

    err = g_malloc0(nb_pfn * sizeof (int));



    if (entry->vaddr_base != NULL) {

        if (munmap(entry->vaddr_base, entry->size) != 0) {

            perror(""unmap fails"");

            exit(-1);

        }

    }

    g_free(entry->valid_mapping);

    entry->valid_mapping = NULL;



    for (i = 0; i < nb_pfn; i++) {

        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;

    }



    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,

                                     pfns, err, nb_pfn);

    if (vaddr_base == NULL) {

        perror(""xc_map_foreign_bulk"");

        exit(-1);

    }



    entry->vaddr_base = vaddr_base;

    entry->paddr_index = address_index;

    entry->size = size;

    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *

            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));



    bitmap_zero(entry->valid_mapping, nb_pfn);

    for (i = 0; i < nb_pfn; i++) {

        if (!err[i]) {

            bitmap_set(entry->valid_mapping, i, 1);

        }

    }



    g_free(pfns);

    g_free(err);

}
",1
Detect whether the following code contains vulnerabilities.,"void usb_packet_complete(USBDevice *dev, USBPacket *p)

{

    USBEndpoint *ep = p->ep;

    int ret;



    assert(p->state == USB_PACKET_ASYNC);

    assert(QTAILQ_FIRST(&ep->queue) == p);

    usb_packet_set_state(p, USB_PACKET_COMPLETE);

    QTAILQ_REMOVE(&ep->queue, p, queue);

    dev->port->ops->complete(dev->port, p);



    while (!QTAILQ_EMPTY(&ep->queue)) {

        p = QTAILQ_FIRST(&ep->queue);

        if (p->state == USB_PACKET_ASYNC) {

            break;

        }

        assert(p->state == USB_PACKET_QUEUED);

        ret = usb_process_one(p);

        if (ret == USB_RET_ASYNC) {

            usb_packet_set_state(p, USB_PACKET_ASYNC);

            break;

        }

        p->result = ret;

        usb_packet_set_state(p, USB_PACKET_COMPLETE);

        QTAILQ_REMOVE(&ep->queue, p, queue);

        dev->port->ops->complete(dev->port, p);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
",0
Detect whether the following code contains vulnerabilities.,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
",0
Detect whether the following code contains vulnerabilities.,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);",1
Detect whether the following code contains vulnerabilities.,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",0
Detect whether the following code contains vulnerabilities.,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}
",0
Detect whether the following code contains vulnerabilities.,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",1
Detect whether the following code contains vulnerabilities.,"static int vc1_filter_line(uint8_t* src, int stride, int pq){

    int a0, a1, a2, a3, d, clip, filt3 = 0;

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;



    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;

    if(FFABS(a0) < pq){

        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;

        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;

        a3 = FFMIN(FFABS(a1), FFABS(a2));

        if(a3 < FFABS(a0)){

            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;

            clip = (src[-1*stride] - src[ 0*stride])/2;

            if(clip){

                filt3 = 1;

                if(clip > 0)

                    d = av_clip(d, 0, clip);

                else

                    d = av_clip(d, clip, 0);

                src[-1*stride] = cm[src[-1*stride] - d];

                src[ 0*stride] = cm[src[ 0*stride] + d];

            }

        }

    }

    return filt3;

}
",0
Detect whether the following code contains vulnerabilities.,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

                      int src_count, int src_size, int dest_len)

{

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;

    GetByteContext gb;



    bytestream2_init(&gb, src, src_size);

    pd = dest;

    if (src_count & 1) {

        if (bytestream2_get_bytes_left(&gb) < 1)

            return 0;

        *pd++ = bytestream2_get_byteu(&gb);

    }



    src_count >>= 1;

    i = 0;

    do {

        if (bytestream2_get_bytes_left(&gb) < 1)

            break;

        l = bytestream2_get_byteu(&gb);

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)

                return bytestream2_tell(&gb);

            bytestream2_get_bufferu(&gb, pd, l);

            pd += l;

        } else {

            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)

                return bytestream2_tell(&gb);

            for (i = 0; i < l; i++) {

                *pd++ = bytestream2_get_byteu(&gb);

                *pd++ = bytestream2_get_byteu(&gb);

            }

            bytestream2_skip(&gb, 2);

        }

        i += l;

    } while (i < src_count);



    return bytestream2_tell(&gb);

}
",0
Detect whether the following code contains vulnerabilities.,"static int recheck_discard_flags(AVFormatContext *s, int first)

{

    HLSContext *c = s->priv_data;

    int i, changed = 0;



    /* Check if any new streams are needed */

    for (i = 0; i < c->n_playlists; i++)

        c->playlists[i]->cur_needed = 0;



    for (i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        struct playlist *pls = c->playlists[s->streams[i]->id];

        if (st->discard < AVDISCARD_ALL)

            pls->cur_needed = 1;

    }

    for (i = 0; i < c->n_playlists; i++) {

        struct playlist *pls = c->playlists[i];

        if (pls->cur_needed && !pls->needed) {

            pls->needed = 1;

            changed = 1;

            pls->cur_seq_no = select_cur_seq_no(c, pls);

            pls->pb.eof_reached = 0;

            if (c->cur_timestamp != AV_NOPTS_VALUE) {

                /* catch up */

                pls->seek_timestamp = c->cur_timestamp;

                pls->seek_flags = AVSEEK_FLAG_ANY;

                pls->seek_stream_index = -1;

            }

            av_log(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d\n"", i, pls->cur_seq_no);

        } else if (first && !pls->cur_needed && pls->needed) {

            if (pls->input)

                ff_format_io_close(pls->parent, &pls->input);

            pls->needed = 0;

            changed = 1;

            av_log(s, AV_LOG_INFO, ""No longer receiving playlist %d\n"", i);

        }

    }

    return changed;

}
",0
Detect whether the following code contains vulnerabilities.,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
",0
Detect whether the following code contains vulnerabilities.,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)

{

    AVCodec *codec;

    AVCodecContext *c;

    AVStream *st;



    st = av_new_stream(oc, 1);

    if (!st) {

        fprintf(stderr, ""Could not alloc stream\n"");

        exit(1);

    }



    /* find the MP2 encoder */

    codec = avcodec_find_encoder(codec_id);

    if (!codec) {

        fprintf(stderr, ""codec not found\n"");

        exit(1);

    }

    c = &st->codec;

    c->codec_type = CODEC_TYPE_AUDIO;



    /* put sample parameters */

    c->bit_rate = 64000;

    c->sample_rate = 44100;

    c->channels = 2;



    /* open it */

    if (avcodec_open(c, codec) < 0) {

        fprintf(stderr, ""could not open codec\n"");

        exit(1);

    }



    /* init signal generator */

    t = 0;

    tincr = 2 * M_PI * 440.0 / c->sample_rate;



    audio_outbuf_size = 10000;

    audio_outbuf = malloc(audio_outbuf_size);



    /* ugly hack for PCM codecs (will be removed ASAP with new PCM

       support to compute the input frame size in samples */

    if (c->frame_size <= 1) {

        audio_input_frame_size = audio_outbuf_size / c->channels;

        switch(st->codec.codec_id) {

        case CODEC_ID_PCM_S16LE:

        case CODEC_ID_PCM_S16BE:

        case CODEC_ID_PCM_U16LE:

        case CODEC_ID_PCM_U16BE:

            audio_input_frame_size >>= 1;

            break;

        default:

            break;

        }

    } else {

        audio_input_frame_size = c->frame_size;

    }

    samples = malloc(audio_input_frame_size * 2 * c->channels);



    return st;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)

{

    LibOpenJPEGContext *ctx = avctx->priv_data;

    int err = AVERROR(ENOMEM);



    opj_set_default_encoder_parameters(&ctx->enc_params);



    ctx->enc_params.cp_rsiz = ctx->profile;

    ctx->enc_params.mode = !!avctx->global_quality;

    ctx->enc_params.cp_cinema = ctx->cinema_mode;

    ctx->enc_params.prog_order = ctx->prog_order;

    ctx->enc_params.numresolution = ctx->numresolution;

    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;

    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;

    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;

    ctx->enc_params.tcp_numlayers = ctx->numlayers;

    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;



    if (ctx->cinema_mode > 0) {

        cinema_parameters(&ctx->enc_params);

    }



    ctx->compress = opj_create_compress(ctx->format);

    if (!ctx->compress) {

        av_log(avctx, AV_LOG_ERROR, ""Error creating the compressor\n"");

        return AVERROR(ENOMEM);

    }



    ctx->image = mj2_create_image(avctx, &ctx->enc_params);

    if (!ctx->image) {

        av_log(avctx, AV_LOG_ERROR, ""Error creating the mj2 image\n"");

        err = AVERROR(EINVAL);

        goto fail;

    }



    avctx->coded_frame = av_frame_alloc();

    if (!avctx->coded_frame) {

        av_log(avctx, AV_LOG_ERROR, ""Error allocating coded frame\n"");

        goto fail;

    }



    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));

    ctx->event_mgr.info_handler    = info_callback;

    ctx->event_mgr.error_handler = error_callback;

    ctx->event_mgr.warning_handler = warning_callback;

    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);



    return 0;



fail:

    opj_destroy_compress(ctx->compress);

    ctx->compress = NULL;

    opj_image_destroy(ctx->image);

    ctx->image = NULL;

    av_freep(&avctx->coded_frame);

    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",0
Detect whether the following code contains vulnerabilities.,"static void openrisc_sim_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    OpenRISCCPU *cpu = NULL;

    MemoryRegion *ram;

    int n;



    if (!cpu_model) {

        cpu_model = ""or1200"";

    }



    for (n = 0; n < smp_cpus; n++) {

        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));

        qemu_register_reset(main_cpu_reset, cpu);

        main_cpu_reset(cpu);

    }



    ram = g_malloc(sizeof(*ram));

    memory_region_init_ram(ram, NULL, ""openrisc.ram"", ram_size, &error_fatal);

    memory_region_add_subregion(get_system_memory(), 0, ram);



    cpu_openrisc_pic_init(cpu);

    cpu_openrisc_clock_init(cpu);



    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],

                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);



    if (nd_table[0].used) {

        openrisc_sim_net_init(get_system_memory(), 0x92000000,

                              0x92000400, cpu->env.irq[4], nd_table);

    }



    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ohci_reset(void *opaque)

{

    OHCIState *ohci = opaque;

    OHCIPort *port;

    int i;



    ohci_bus_stop(ohci);

    ohci->ctl = 0;

    ohci->old_ctl = 0;

    ohci->status = 0;

    ohci->intr_status = 0;

    ohci->intr = OHCI_INTR_MIE;



    ohci->hcca = 0;

    ohci->ctrl_head = ohci->ctrl_cur = 0;

    ohci->bulk_head = ohci->bulk_cur = 0;

    ohci->per_cur = 0;

    ohci->done = 0;

    ohci->done_count = 7;



    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?

     * I took the value linux sets ...

     */

    ohci->fsmps = 0x2778;

    ohci->fi = 0x2edf;

    ohci->fit = 0;

    ohci->frt = 0;

    ohci->frame_number = 0;

    ohci->pstart = 0;

    ohci->lst = OHCI_LS_THRESH;



    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;

    ohci->rhdesc_b = 0x0; /* Impl. specific */

    ohci->rhstatus = 0;



    for (i = 0; i < ohci->num_ports; i++)

      {

        port = &ohci->rhport[i];

        port->ctrl = 0;

        if (port->port.dev) {

            usb_attach(&port->port, port->port.dev);

        }

      }

    if (ohci->async_td) {

        usb_cancel_packet(&ohci->usb_packet);

        ohci->async_td = 0;

    }

    DPRINTF(""usb-ohci: Reset %s\n"", ohci->name);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&

                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {

        /* Magnitude subtraction of infinities */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN subtraction */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
",0
Detect whether the following code contains vulnerabilities.,"static int vhost_virtqueue_init(struct vhost_dev *dev,

                                struct vhost_virtqueue *vq, int n)

{

    struct vhost_vring_file file = {

        .index = n,

    };

    int r = event_notifier_init(&vq->masked_notifier, 0);

    if (r < 0) {

        return r;

    }



    file.fd = event_notifier_get_fd(&vq->masked_notifier);

    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);

    if (r) {

        r = -errno;

        goto fail_call;

    }

    return 0;

fail_call:

    event_notifier_cleanup(&vq->masked_notifier);

    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)

{

    AVFilterContext  *ctx = inlink->dst;

    ATempoContext *atempo = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];



    int ret = 0;

    int n_in = src_buffer->nb_samples;

    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);



    const uint8_t *src = src_buffer->data[0];

    const uint8_t *src_end = src + n_in * atempo->stride;



    while (src < src_end) {

        if (!atempo->dst_buffer) {

            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);

            if (!atempo->dst_buffer)

                return AVERROR(ENOMEM);

            av_frame_copy_props(atempo->dst_buffer, src_buffer);



            atempo->dst = atempo->dst_buffer->data[0];

            atempo->dst_end = atempo->dst + n_out * atempo->stride;

        }



        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);



        if (atempo->dst == atempo->dst_end) {

            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /

                             atempo->stride);

            ret = push_samples(atempo, outlink, n_samples);

            if (ret < 0)

                goto end;

        }

    }



    atempo->nsamples_in += n_in;

end:

    av_frame_free(&src_buffer);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"struct vhost_net *vhost_net_init(VhostNetOptions *options)

{

    int r;

    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;

    struct vhost_net *net = g_malloc(sizeof *net);



    if (!options->net_backend) {

        fprintf(stderr, ""vhost-net requires net backend to be setup\n"");

        goto fail;

    }



    if (backend_kernel) {

        r = vhost_net_get_fd(options->net_backend);

        if (r < 0) {

            goto fail;

        }

        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)

            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);

        net->backend = r;

    } else {

        net->dev.backend_features = 0;

        net->backend = -1;

    }

    net->nc = options->net_backend;



    net->dev.nvqs = 2;

    net->dev.vqs = net->vqs;

    net->dev.vq_index = net->nc->queue_index;



    r = vhost_dev_init(&net->dev, options->opaque,

                       options->backend_type, options->force);

    if (r < 0) {

        goto fail;

    }

    if (backend_kernel) {

        if (!qemu_has_vnet_hdr_len(options->net_backend,

                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {

            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);

        }

        if (~net->dev.features & net->dev.backend_features) {

            fprintf(stderr, ""vhost lacks feature mask %"" PRIu64

                   "" for backend\n"",

                   (uint64_t)(~net->dev.features & net->dev.backend_features));

            vhost_dev_cleanup(&net->dev);

            goto fail;

        }

    }

    /* Set sane init value. Override when guest acks. */

    vhost_net_ack_features(net, 0);

    return net;

fail:

    g_free(net);

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static USBDevice *usb_msd_init(const char *filename)

{

    static int nr=0;

    char id[8];

    QemuOpts *opts;

    DriveInfo *dinfo;

    USBDevice *dev;

    int fatal_error;

    const char *p1;

    char fmt[32];



    /* parse -usbdevice disk: syntax into drive opts */

    snprintf(id, sizeof(id), ""usb%d"", nr++);

    opts = qemu_opts_create(&qemu_drive_opts, id, 0);



    p1 = strchr(filename, ':');

    if (p1++) {

        const char *p2;



        if (strstart(filename, ""format="", &p2)) {

            int len = MIN(p1 - p2, sizeof(fmt));

            pstrcpy(fmt, len, p2);

            qemu_opt_set(opts, ""format"", fmt);

        } else if (*filename != ':') {

            printf(""unrecognized USB mass-storage option %s\n"", filename);



        filename = p1;


    if (!*filename) {

        printf(""block device specification needed\n"");



    qemu_opt_set(opts, ""file"", filename);

    qemu_opt_set(opts, ""if"", ""none"");



    /* create host drive */

    dinfo = drive_init(opts, NULL, &fatal_error);

    if (!dinfo) {

        qemu_opts_del(opts);





    /* create guest device */

    dev = usb_create(NULL /* FIXME */, ""usb-storage"");




    qdev_prop_set_drive(&dev->qdev, ""drive"", dinfo);

    if (qdev_init(&dev->qdev) < 0)




    return dev;
",1
Detect whether the following code contains vulnerabilities.,"void migrate_fd_connect(MigrationState *s)

{

    s->state = MIG_STATE_SETUP;

    trace_migrate_set_state(MIG_STATE_SETUP);



    /* This is a best 1st approximation. ns to ms */

    s->expected_downtime = max_downtime/1000000;

    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);



    qemu_file_set_rate_limit(s->file,

                             s->bandwidth_limit / XFER_LIMIT_RATIO);



    qemu_thread_create(&s->thread, migration_thread, s,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, s);

}
",1
Detect whether the following code contains vulnerabilities.,"static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)

{

    uint64_t VCO_out, PLL_out;

    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;

    int M, D0, D1, D2;



    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */

    if (cpc->pllmr & 0x80000000) {

        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */

        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */

        M = D0 * D1 * D2;

        VCO_out = cpc->sysclk * M;

        if (VCO_out < 400000000 || VCO_out > 800000000) {

            /* PLL cannot lock */

            cpc->pllmr &= ~0x80000000;

            goto bypass_pll;

        }

        PLL_out = VCO_out / D2;

    } else {

        /* Bypass PLL */

    bypass_pll:

        M = D0;

        PLL_out = cpc->sysclk * M;

    }

    CPU_clk = PLL_out;

    if (cpc->cr1 & 0x00800000)

        TMR_clk = cpc->sysclk; /* Should have a separate clock */

    else

        TMR_clk = CPU_clk;

    PLB_clk = CPU_clk / D0;

    SDRAM_clk = PLB_clk;

    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;

    OPB_clk = PLB_clk / D0;

    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;

    EXT_clk = PLB_clk / D0;

    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;

    UART_clk = CPU_clk / D0;

    /* Setup CPU clocks */

    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);

    /* Setup time-base clock */

    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);

    /* Setup PLB clock */

    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);

    /* Setup SDRAM clock */

    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);

    /* Setup OPB clock */

    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);

    /* Setup external clock */

    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);

    /* Setup UART clock */

    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (addr != 2 || size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;

    }

    return ide_status_read(cmd646bar->bus, addr + 2);

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,

                            uint16_t vendor, uint16_t device,

                            uint16_t class_code, uint8_t pif)

{

    uint8_t *config;

    uint32_t size;



    proxy->vdev = vdev;



    config = proxy->pci_dev.config;

    pci_config_set_vendor_id(config, vendor);

    pci_config_set_device_id(config, device);



    config[0x08] = VIRTIO_PCI_ABI_VERSION;



    config[0x09] = pif;

    pci_config_set_class(config, class_code);



    config[0x2c] = vendor & 0xFF;

    config[0x2d] = (vendor >> 8) & 0xFF;

    config[0x2e] = vdev->device_id & 0xFF;

    config[0x2f] = (vdev->device_id >> 8) & 0xFF;



    config[0x3d] = 1;



    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {

        pci_register_bar(&proxy->pci_dev, 1,

                         msix_bar_size(&proxy->pci_dev),

                         PCI_BASE_ADDRESS_SPACE_MEMORY,

                         msix_mmio_map);

    } else

        vdev->nvectors = 0;



    proxy->pci_dev.config_write = virtio_write_config;



    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;

    if (size & (size-1))

        size = 1 << qemu_fls(size);



    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,

                           virtio_map);



    if (!kvm_has_many_ioeventfds()) {

        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;

    }



    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);

    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;

    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;

    proxy->host_features = vdev->get_features(vdev, proxy->host_features);

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_device_add(const char *devname, int is_hotplug)

{

    const char *p;

    USBDevice *dev;



    if (!free_usb_ports)

        return -1;



    if (strstart(devname, ""host:"", &p)) {

        dev = usb_host_device_open(p);

    } else if (!strcmp(devname, ""mouse"")) {

        dev = usb_mouse_init();

    } else if (!strcmp(devname, ""tablet"")) {

        dev = usb_tablet_init();

    } else if (!strcmp(devname, ""keyboard"")) {

        dev = usb_keyboard_init();

    } else if (strstart(devname, ""disk:"", &p)) {

        BlockDriverState *bs;



        dev = usb_msd_init(p, &bs);

        if (!dev)

            return -1;

        if (bdrv_key_required(bs)) {

            autostart = 0;

            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {

                dev->handle_destroy(dev);

                return -1;

            }

        }

    } else if (!strcmp(devname, ""wacom-tablet"")) {

        dev = usb_wacom_init();

    } else if (strstart(devname, ""serial:"", &p)) {

        dev = usb_serial_init(p);

#ifdef CONFIG_BRLAPI

    } else if (!strcmp(devname, ""braille"")) {

        dev = usb_baum_init();

#endif

    } else if (strstart(devname, ""net:"", &p)) {

        int nic = nb_nics;



        if (net_client_init(""nic"", p) < 0)

            return -1;

        nd_table[nic].model = ""usb"";

        dev = usb_net_init(&nd_table[nic]);

    } else if (!strcmp(devname, ""bt"") || strstart(devname, ""bt:"", &p)) {

        dev = usb_bt_init(devname[2] ? hci_init(p) :

                        bt_new_hci(qemu_find_bt_vlan(0)));

    } else {

        return -1;

    }

    if (!dev)

        return -1;



    return usb_device_add_dev(dev);

}
",0
Detect whether the following code contains vulnerabilities.,"void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)

{

    int cssid, ssid, schid, m;

    SubchDev *sch;

    SCHIB schib;

    uint64_t addr;

    int ret = -ENODEV;

    int cc;

    CPUS390XState *env = &cpu->env;

    uint8_t ar;



    addr = decode_basedisp_s(env, ipb, &ar);

    if (addr & 3) {

        program_interrupt(env, PGM_SPECIFICATION, 2);

        return;

    }

    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {

        return;

    }

    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||

        !ioinst_schib_valid(&schib)) {

        program_interrupt(env, PGM_OPERAND, 2);

        return;

    }

    trace_ioinst_sch_id(""msch"", cssid, ssid, schid);

    sch = css_find_subch(m, cssid, ssid, schid);

    if (sch && css_subch_visible(sch)) {

        ret = css_do_msch(sch, &schib);

    }

    switch (ret) {

    case -ENODEV:

        cc = 3;

        break;

    case -EBUSY:

        cc = 2;

        break;

    case 0:

        cc = 0;

        break;

    default:

        cc = 1;

        break;

    }

    setcc(cpu, cc);

}
",0
Detect whether the following code contains vulnerabilities.,"static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    MPCContext *c = s->priv_data;

    int ret, size, size2, curbits, cur = c->curframe;

    int64_t tmp, pos;



    if (c->curframe >= c->fcount)

        return -1;



    if(c->curframe != c->lastframe + 1){

        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);

        c->curbits = c->frames[c->curframe].skip;

    }

    c->lastframe = c->curframe;

    c->curframe++;

    curbits = c->curbits;

    pos = url_ftell(s->pb);

    tmp = get_le32(s->pb);

    if(curbits <= 12){

        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;

    }else{

        tmp = (tmp << 32) | get_le32(s->pb);

        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;

    }

    curbits += 20;

    url_fseek(s->pb, pos, SEEK_SET);



    size = ((size2 + curbits + 31) & ~31) >> 3;

    if(cur == c->frames_noted){

        c->frames[cur].pos = pos;

        c->frames[cur].size = size;

        c->frames[cur].skip = curbits - 20;

        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);

        c->frames_noted++;

    }

    c->curbits = (curbits + size2) & 0x1F;



    if (av_new_packet(pkt, size) < 0)

        return AVERROR(EIO);



    pkt->data[0] = curbits;

    pkt->data[1] = (c->curframe > c->fcount);





    pkt->stream_index = 0;

    pkt->pts = cur;

    ret = get_buffer(s->pb, pkt->data + 4, size);

    if(c->curbits)

        url_fseek(s->pb, -4, SEEK_CUR);

    if(ret < size){

        av_free_packet(pkt);

        return AVERROR(EIO);

    }

    pkt->size = ret + 4;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    struct pxa2xx_pic_state_s *s;

    int iomemtype;

    qemu_irq *qi;



    s = (struct pxa2xx_pic_state_s *)

            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));

    if (!s)

        return NULL;



    s->cpu_env = env;

    s->base = base;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s);

    cpu_register_physical_memory(base, 0x000fffff, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);



    return qi;

}
",1
Detect whether the following code contains vulnerabilities.,"static InetSocketAddress *ssh_config(QDict *options, Error **errp)

{

    InetSocketAddress *inet = NULL;

    QDict *addr = NULL;

    QObject *crumpled_addr = NULL;

    Visitor *iv = NULL;

    Error *local_error = NULL;



    qdict_extract_subqdict(options, &addr, ""server."");

    if (!qdict_size(addr)) {

        error_setg(errp, ""SSH server address missing"");

        goto out;

    }



    crumpled_addr = qdict_crumple(addr, errp);

    if (!crumpled_addr) {

        goto out;

    }











    iv = qobject_input_visitor_new(crumpled_addr);

    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);

    if (local_error) {

        error_propagate(errp, local_error);

        goto out;

    }



out:

    QDECREF(addr);

    qobject_decref(crumpled_addr);

    visit_free(iv);

    return inet;

}",1
Detect whether the following code contains vulnerabilities.,"sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)

{

    if ((s->data_count & 0x3) != byte_num) {

        ERRPRINT(""Non-sequential access to Buffer Data Port register""

                ""is prohibited\n"");

        return false;

    }

    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t ret;

    guint watch;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    watch = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(ioc, buffer, size, NULL);

    g_source_remove(watch);

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void aio_read_done(void *opaque, int ret)

{

    struct aio_ctx *ctx = opaque;

    struct timeval t2;



    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""readv failed: %s\n"", strerror(-ret));

        goto out;

    }



    if (ctx->Pflag) {

        void *cmp_buf = malloc(ctx->qiov.size);



        memset(cmp_buf, ctx->pattern, ctx->qiov.size);

        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);

        }

        free(cmp_buf);

    }



    if (ctx->qflag) {

        goto out;

    }



    if (ctx->vflag) {

        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, ctx->t1);

    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,

                 ctx->qiov.size, 1, ctx->Cflag);

out:

    qemu_io_free(ctx->buf);

    free(ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void nvdimm_build_common_dsm(Aml *dev)

{

    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;

    uint8_t byte_list[1];



    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);

    function = aml_arg(2);

    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);



    /*

     * do not support any method if DSM memory address has not been

     * patched.

     */

    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));



    /*

     * function 0 is called to inquire what functions are supported by

     * OSPM

     */

    ifctx = aml_if(aml_equal(function, aml_int(0)));

    byte_list[0] = 0 /* No function Supported */;

    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));

    aml_append(unpatched, ifctx);



    /* No function is supported yet. */

    byte_list[0] = 1 /* Not Supported */;

    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));

    aml_append(method, unpatched);



    /*

     * The HDLE indicates the DSM function is issued from which device,

     * it is not used at this time as no function is supported yet.

     * Currently we make it always be 0 for all the devices and will set

     * the appropriate value once real function is implemented.

     */

    aml_append(method, aml_store(aml_int(0x0), aml_name(""HDLE"")));

    aml_append(method, aml_store(aml_arg(1), aml_name(""REVS"")));

    aml_append(method, aml_store(aml_arg(2), aml_name(""FUNC"")));



    /*

     * tell QEMU about the real address of DSM memory, then QEMU

     * gets the control and fills the result in DSM memory.

     */

    aml_append(method, aml_store(dsm_mem, aml_name(""NTFI"")));



    result_size = aml_local(1);

    aml_append(method, aml_store(aml_name(""RLEN""), result_size));

    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),

                                 result_size));

    aml_append(method, aml_create_field(aml_name(""ODAT""), aml_int(0),

                                        result_size, ""OBUF""));

    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(""OBUF""),

                                       aml_arg(6)));

    aml_append(method, aml_return(aml_arg(6)));

    aml_append(dev, method);

}
",0
Detect whether the following code contains vulnerabilities.,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int ret;



    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
",0
Detect whether the following code contains vulnerabilities.,"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,

    unsigned int nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l2_table;

    int l2_index;

    int ret;

    int i;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);

    if (ret < 0) {

        return ret;

    }



    /* Limit nb_clusters to one L2 table */

    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    for (i = 0; i < nb_clusters; i++) {

        uint64_t old_offset;



        old_offset = be64_to_cpu(l2_table[l2_index + i]);



        /* Update L2 entries */

        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);

        if (old_offset & QCOW_OFLAG_COMPRESSED) {

            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);

            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);

        } else {

            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);

        }

    }



    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);

    if (ret < 0) {

        return ret;

    }



    return nb_clusters;

}
",0
Detect whether the following code contains vulnerabilities.,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",0
Detect whether the following code contains vulnerabilities.,"static int do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;

    int ret = 0;



    assert(p->devep == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            ret = usb_device_handle_control(s, p, request, value, index,

                                            s->setup_len, s->data_buf);

            if (ret == USB_RET_ASYNC) {

                return USB_RET_ASYNC;

            }

            s->setup_state = SETUP_STATE_IDLE;

            if (ret > 0)

                return 0;

            return ret;

        }



        /* return 0 byte */

        return 0;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len)

                s->setup_state = SETUP_STATE_ACK;

            return len;

        }



        s->setup_state = SETUP_STATE_IDLE;

        return USB_RET_STALL;



    default:

        return USB_RET_STALL;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_init_vcpu(CPUState *cpu)

{

    KVMState *s = kvm_state;

    long mmap_size;

    int ret;



    DPRINTF(""kvm_init_vcpu\n"");



    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));

    if (ret < 0) {

        DPRINTF(""kvm_create_vcpu failed\n"");

        goto err;

    }



    cpu->kvm_fd = ret;

    cpu->kvm_state = s;

    cpu->kvm_vcpu_dirty = true;



    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);

    if (mmap_size < 0) {

        ret = mmap_size;

        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed\n"");

        goto err;

    }



    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,

                        cpu->kvm_fd, 0);

    if (cpu->kvm_run == MAP_FAILED) {

        ret = -errno;

        DPRINTF(""mmap'ing vcpu state failed\n"");

        goto err;

    }



    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {

        s->coalesced_mmio_ring =

            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;

    }



    ret = kvm_arch_init_vcpu(cpu);

err:

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void arm_cpu_do_interrupt(CPUState *cs)
{
    ARMCPU *cpu = ARM_CPU(cs);
    CPUARMState *env = &cpu->env;
    unsigned int new_el = env->exception.target_el;
    assert(!arm_feature(env, ARM_FEATURE_M));
    arm_log_exception(cs->exception_index);
    qemu_log_mask(CPU_LOG_INT, ""...from EL%d to EL%d\n"", arm_current_el(env),
                  new_el);
    if (qemu_loglevel_mask(CPU_LOG_INT)
        && !excp_is_internal(cs->exception_index)) {
        qemu_log_mask(CPU_LOG_INT, ""...with ESR %x/0x%"" PRIx32 ""\n"",
                      env->exception.syndrome >> ARM_EL_EC_SHIFT,
                      env->exception.syndrome);
    }
    if (arm_is_psci_call(cpu, cs->exception_index)) {
        arm_handle_psci_call(cpu);
        qemu_log_mask(CPU_LOG_INT, ""...handled as PSCI call\n"");
        return;
    }
    /* Semihosting semantics depend on the register width of the
     * code that caused the exception, not the target exception level,
     * so must be handled here.
    if (check_for_semihosting(cs)) {
        return;
    }
    assert(!excp_is_internal(cs->exception_index));
    if (arm_el_is_aa64(env, new_el)) {
        arm_cpu_do_interrupt_aarch64(cs);
    } else {
        arm_cpu_do_interrupt_aarch32(cs);
    }
    arm_call_el_change_hook(cpu);
    if (!kvm_enabled()) {
        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;
    }
}",1
Detect whether the following code contains vulnerabilities.,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
",1
Detect whether the following code contains vulnerabilities.,"int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)

{

    Location loc;

    DriveInfo *dinfo;

    int res = 0, unit;



    loc_push_none(&loc);

    for (unit = 0; unit < bus->info->max_target; unit++) {

        dinfo = drive_get(IF_SCSI, bus->busnr, unit);

        if (dinfo == NULL) {

            continue;

        }

        qemu_opts_loc_restore(dinfo->opts);

        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {

            res = -1;

            break;

        }

    }

    loc_pop(&loc);

    return res;

}
",1
Detect whether the following code contains vulnerabilities.,"static int link_filter_inouts(AVFilterContext *filt_ctx,

                              AVFilterInOut **curr_inputs,

                              AVFilterInOut **open_inputs, AVClass *log_ctx)

{

    int pad = filt_ctx->input_count, ret;



    while (pad--) {

        AVFilterInOut *p = *curr_inputs;

        if (!p) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Not enough inputs specified for the \""%s\"" filter.\n"",

                   filt_ctx->filter->name);

            return AVERROR(EINVAL);

        }



        *curr_inputs = (*curr_inputs)->next;



        if (p->filter) {

            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)

                return ret;

            av_free(p->name);

            av_free(p);

        } else {

            p->filter = filt_ctx;

            p->pad_idx = pad;

            insert_inout(open_inputs, p);

        }

    }



    if (*curr_inputs) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Too many inputs specified for the \""%s\"" filter.\n"",

               filt_ctx->filter->name);

        return AVERROR(EINVAL);

    }



    pad = filt_ctx->output_count;

    while (pad--) {

        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));



        currlinkn->filter  = filt_ctx;

        currlinkn->pad_idx = pad;

        insert_inout(curr_inputs, currlinkn);

    }



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void x86_cpu_common_class_init(ObjectClass *oc, void *data)

{

    X86CPUClass *xcc = X86_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    xcc->parent_realize = dc->realize;

    dc->realize = x86_cpu_realizefn;

    dc->bus_type = TYPE_ICC_BUS;

    dc->props = x86_cpu_properties;



    xcc->parent_reset = cc->reset;

    cc->reset = x86_cpu_reset;

    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;



    cc->class_by_name = x86_cpu_class_by_name;

    cc->parse_features = x86_cpu_parse_featurestr;

    cc->has_work = x86_cpu_has_work;

    cc->do_interrupt = x86_cpu_do_interrupt;

    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;

    cc->dump_state = x86_cpu_dump_state;

    cc->set_pc = x86_cpu_set_pc;

    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;

    cc->gdb_read_register = x86_cpu_gdb_read_register;

    cc->gdb_write_register = x86_cpu_gdb_write_register;

    cc->get_arch_id = x86_cpu_get_arch_id;

    cc->get_paging_enabled = x86_cpu_get_paging_enabled;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;

#else

    cc->get_memory_mapping = x86_cpu_get_memory_mapping;

    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;

    cc->write_elf64_note = x86_cpu_write_elf64_note;

    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;

    cc->write_elf32_note = x86_cpu_write_elf32_note;

    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;

    cc->vmsd = &vmstate_x86_cpu;

#endif

    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;

#ifndef CONFIG_USER_ONLY

    cc->debug_excp_handler = breakpoint_handler;

#endif

    cc->cpu_exec_enter = x86_cpu_exec_enter;

    cc->cpu_exec_exit = x86_cpu_exec_exit;

}
",0
Detect whether the following code contains vulnerabilities.,"static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)

{

    int error;

    static pa_sample_spec ss;

    audsettings_t obt_as = *as;

    PAVoiceIn *pa = (PAVoiceIn *) hw;



    ss.format = audfmt_to_pa (as->fmt, as->endianness);

    ss.channels = as->nchannels;

    ss.rate = as->freq;



    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);



    pa->s = pa_simple_new (

        conf.server,

        ""qemu"",

        PA_STREAM_RECORD,

        conf.source,

        ""pcm.capture"",

        &ss,

        NULL,                   /* channel map */

        NULL,                   /* buffering attributes */

        &error

        );

    if (!pa->s) {

        qpa_logerr (error, ""pa_simple_new for capture failed\n"");

        goto fail1;

    }



    audio_pcm_init_info (&hw->info, &obt_as);

    hw->samples = conf.samples;

    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!pa->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)\n"",

               hw->samples << hw->info.shift);

        goto fail2;

    }



    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    return 0;



 fail3:

    free (pa->pcm_buf);

    pa->pcm_buf = NULL;

 fail2:

    pa_simple_free (pa->s);

    pa->s = NULL;

 fail1:

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
",0
Detect whether the following code contains vulnerabilities.,"static void dhcp_decode(const uint8_t *buf, int size,

                        int *pmsg_type)

{

    const uint8_t *p, *p_end;

    int len, tag;



    *pmsg_type = 0;



    p = buf;

    p_end = buf + size;

    if (size < 5)

        return;

    if (memcmp(p, rfc1533_cookie, 4) != 0)

        return;

    p += 4;

    while (p < p_end) {

        tag = p[0];

        if (tag == RFC1533_PAD) {

            p++;

        } else if (tag == RFC1533_END) {

            break;

        } else {

            p++;

            if (p >= p_end)

                break;

            len = *p++;

            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);



            switch(tag) {

            case RFC2132_MSG_TYPE:

                if (len >= 1)

                    *pmsg_type = p[0];

                break;

            default:

                break;

            }

            p += len;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)

{

    XHCITRB *trb_setup, *trb_status;

    uint8_t bmRequestType;



    trb_setup = &xfer->trbs[0];

    trb_status = &xfer->trbs[xfer->trb_count-1];



    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,

                              xfer->epctx->epid, xfer->streamid);



    /* at most one Event Data TRB allowed after STATUS */

    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {

        trb_status--;

    }



    /* do some sanity checks */

    if (TRB_TYPE(*trb_setup) != TR_SETUP) {

        DPRINTF(""xhci: ep0 first TD not SETUP: %d\n"",

                TRB_TYPE(*trb_setup));

        return -1;

    }

    if (TRB_TYPE(*trb_status) != TR_STATUS) {

        DPRINTF(""xhci: ep0 last TD not STATUS: %d\n"",

                TRB_TYPE(*trb_status));

        return -1;

    }

    if (!(trb_setup->control & TRB_TR_IDT)) {

        DPRINTF(""xhci: Setup TRB doesn't have IDT set\n"");

        return -1;

    }

    if ((trb_setup->status & 0x1ffff) != 8) {

        DPRINTF(""xhci: Setup TRB has bad length (%d)\n"",

                (trb_setup->status & 0x1ffff));

        return -1;

    }



    bmRequestType = trb_setup->parameter;



    xfer->in_xfer = bmRequestType & USB_DIR_IN;

    xfer->iso_xfer = false;

    xfer->timed_xfer = false;



    if (xhci_setup_packet(xfer) < 0) {

        return -1;

    }

    xfer->packet.parameter = trb_setup->parameter;



    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);



    xhci_try_complete_packet(xfer);

    if (!xfer->running_async && !xfer->running_retry) {

        xhci_kick_epctx(xfer->epctx, 0);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
",0
Detect whether the following code contains vulnerabilities.,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);



    /* USB misc control 1/2 */

    pci_set_long(pci_conf + 0x40,0x00001000);

    /* PM capability */

    pci_set_long(pci_conf + 0x80,0x00020001);

    /* USB legacy support  */

    pci_set_long(pci_conf + 0xc0,0x00002000);



    return usb_uhci_common_initfn(s);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)

{

    VFIOQuirk *quirk;

    VFIONvidia3d0Quirk *data;



    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||

        !vdev->bars[1].region.size) {

        return;

    }



    quirk = g_malloc0(sizeof(*quirk));

    quirk->data = data = g_malloc0(sizeof(*data));

    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);

    quirk->nr_mem = 2;

    data->vdev = vdev;



    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,

                          data, ""vfio-nvidia-3d4-quirk"", 2);

    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,

                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);



    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,

                          data, ""vfio-nvidia-3d0-quirk"", 2);

    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,

                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);



    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,

                      quirk, next);



    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);

}
",1
Detect whether the following code contains vulnerabilities.,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qobject_input_start_list(Visitor *v, const char *name,

                                     GenericList **list, size_t size,

                                     Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    const QListEntry *entry;



    if (list) {

        *list = NULL;

    }

    if (!qobj) {

        return;

    }

    if (qobject_type(qobj) != QTYPE_QLIST) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""list"");

        return;

    }



    entry = qobject_input_push(qiv, qobj, list);

    if (entry && list) {

        *list = g_malloc0(size);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);

}
",0
Detect whether the following code contains vulnerabilities.,"static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,

                            TCGArg dst, TCGArg src)

{

    if (temps_are_copies(dst, src)) {

        tcg_op_remove(s, op);

        return;

    }



    if (temp_is_const(src)) {

        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);

        return;

    }



    TCGOpcode new_op = op_to_mov(op->opc);

    tcg_target_ulong mask;



    op->opc = new_op;



    reset_temp(dst);

    mask = temps[src].mask;

    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {

        /* High bits of the destination are now garbage.  */

        mask |= ~0xffffffffull;

    }

    temps[dst].mask = mask;



    assert(!temp_is_const(src));



    if (s->temps[src].type == s->temps[dst].type) {

        temps[dst].next_copy = temps[src].next_copy;

        temps[dst].prev_copy = src;

        temps[temps[dst].next_copy].prev_copy = dst;

        temps[src].next_copy = dst;

        temps[dst].is_const = false;

    }



    args[0] = dst;

    args[1] = src;

}
",0
Detect whether the following code contains vulnerabilities.,"av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)

{

  /* VIS-specific optimizations */

  int accel = vis_level ();

  const int high_bit_depth = avctx->bits_per_raw_sample > 8;



  if (accel & ACCEL_SPARC_VIS) {

      if (avctx->bits_per_raw_sample <= 8 &&

          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {

          c->idct_put = ff_simple_idct_put_vis;

          c->idct_add = ff_simple_idct_add_vis;

          c->idct     = ff_simple_idct_vis;

          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;

      }



      if (!high_bit_depth) {

      c->put_pixels_tab[0][0] = MC_put_o_16_vis;

      c->put_pixels_tab[0][1] = MC_put_x_16_vis;

      c->put_pixels_tab[0][2] = MC_put_y_16_vis;

      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;



      c->put_pixels_tab[1][0] = MC_put_o_8_vis;

      c->put_pixels_tab[1][1] = MC_put_x_8_vis;

      c->put_pixels_tab[1][2] = MC_put_y_8_vis;

      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;



      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;

      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;

      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;

      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;



      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;

      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;

      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;

      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;



      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;

      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;

      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;

      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;



      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;

      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;

      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;

      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;



      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;

      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;

      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;

      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;

      }

  }

}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
",1
Detect whether the following code contains vulnerabilities.,"static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)
{
    const char *sec_model = qemu_opt_get(opts, ""security_model"");
    const char *path = qemu_opt_get(opts, ""path"");
    if (sec_model) {
        error_report(""Invalid argument security_model specified with handle fsdriver"");
        return -1;
    }
    if (!path) {
        error_report(""fsdev: No path specified"");
        return -1;
    }
    fse->path = g_strdup(path);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int integratorcm_init(SysBusDevice *dev)

{

    IntegratorCMState *s = INTEGRATOR_CM(dev);



    s->cm_osc = 0x01000048;

    /* ??? What should the high bits of this value be?  */

    s->cm_auxosc = 0x0007feff;

    s->cm_sdram = 0x00011122;

    if (s->memsz >= 256) {

        integrator_spd[31] = 64;

        s->cm_sdram |= 0x10;

    } else if (s->memsz >= 128) {

        integrator_spd[31] = 32;

        s->cm_sdram |= 0x0c;

    } else if (s->memsz >= 64) {

        integrator_spd[31] = 16;

        s->cm_sdram |= 0x08;

    } else if (s->memsz >= 32) {

        integrator_spd[31] = 4;

        s->cm_sdram |= 0x04;

    } else {

        integrator_spd[31] = 2;

    }

    memcpy(integrator_spd + 73, ""QEMU-MEMORY"", 11);

    s->cm_init = 0x00000112;

    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,

                                   1000);

    memory_region_init_ram(&s->flash, OBJECT(s), ""integrator.flash"", 0x100000,

                           &error_abort);

    vmstate_register_ram_global(&s->flash);



    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,

                          ""integratorcm"", 0x00800000);

    sysbus_init_mmio(dev, &s->iomem);



    integratorcm_do_remap(s);

    /* ??? Save/restore.  */

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}
",1
Detect whether the following code contains vulnerabilities.,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
",1
Detect whether the following code contains vulnerabilities.,"static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q); /* Frees the packet! */
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);",1
Detect whether the following code contains vulnerabilities.,"static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,

                           int base, int16_t offset)

{

    const char *opn = ""ldst_pair"";

    TCGv t0, t1;



    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {

        generate_exception(ctx, EXCP_RI);

        return;

    }



    t0 = tcg_temp_new();

    t1 = tcg_temp_new();



    gen_base_offset_addr(ctx, t0, base, offset);



    switch (opc) {

    case LWP:

        save_cpu_state(ctx, 0);

        op_ld_lw(t1, t0, ctx);

        gen_store_gpr(t1, rd);

        tcg_gen_movi_tl(t1, 4);

        gen_op_addr_add(ctx, t0, t0, t1);

        op_ld_lw(t1, t0, ctx);

        gen_store_gpr(t1, rd+1);

        opn = ""lwp"";

        break;

    case SWP:

        save_cpu_state(ctx, 0);

        gen_load_gpr(t1, rd);

        op_st_sw(t1, t0, ctx);

        tcg_gen_movi_tl(t1, 4);

        gen_op_addr_add(ctx, t0, t0, t1);

        gen_load_gpr(t1, rd+1);

        op_st_sw(t1, t0, ctx);

        opn = ""swp"";

        break;

#ifdef TARGET_MIPS64

    case LDP:

        save_cpu_state(ctx, 0);

        op_ld_ld(t1, t0, ctx);

        gen_store_gpr(t1, rd);

        tcg_gen_movi_tl(t1, 8);

        gen_op_addr_add(ctx, t0, t0, t1);

        op_ld_ld(t1, t0, ctx);

        gen_store_gpr(t1, rd+1);

        opn = ""ldp"";

        break;

    case SDP:

        save_cpu_state(ctx, 0);

        gen_load_gpr(t1, rd);

        op_st_sd(t1, t0, ctx);

        tcg_gen_movi_tl(t1, 8);

        gen_op_addr_add(ctx, t0, t0, t1);

        gen_load_gpr(t1, rd+1);

        op_st_sd(t1, t0, ctx);

        opn = ""sdp"";

        break;

#endif

    }

    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s, %s, %d(%s)"", opn, regnames[rd], offset, regnames[base]);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",1
Detect whether the following code contains vulnerabilities.,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}",1
Detect whether the following code contains vulnerabilities.,"static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)

{

    VAAPIEncodeContext      *ctx = avctx->priv_data;

    VAAPIEncodeH264Context *priv = ctx->priv_data;

    int hrd_buffer_size;

    int hrd_initial_buffer_fullness;



    if (avctx->bit_rate > INT32_MAX) {

        av_log(avctx, AV_LOG_ERROR, ""Target bitrate of 2^31 bps or ""

               ""higher is not supported.\n"");

        return AVERROR(EINVAL);

    }



    if (avctx->rc_buffer_size)

        hrd_buffer_size = avctx->rc_buffer_size;

    else

        hrd_buffer_size = avctx->bit_rate;

    if (avctx->rc_initial_buffer_occupancy)

        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;

    else

        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;



    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;

    priv->rc_params.rc = (VAEncMiscParameterRateControl) {

        .bits_per_second   = avctx->bit_rate,

        .target_percentage = 66,

        .window_size       = 1000,

        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),

        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),

        .basic_unit_size   = 0,

    };

    ctx->global_params[ctx->nb_global_params] =

        &priv->rc_params.misc;

    ctx->global_params_size[ctx->nb_global_params++] =

        sizeof(priv->rc_params);



    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;

    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {

        .initial_buffer_fullness = hrd_initial_buffer_fullness,

        .buffer_size             = hrd_buffer_size,

    };

    ctx->global_params[ctx->nb_global_params] =

        &priv->hrd_params.misc;

    ctx->global_params_size[ctx->nb_global_params++] =

        sizeof(priv->hrd_params);



    // These still need to be  set for pic_init_qp/slice_qp_delta.

    priv->fixed_qp_idr = 26;

    priv->fixed_qp_p   = 26;

    priv->fixed_qp_b   = 26;



    av_log(avctx, AV_LOG_DEBUG, ""Using constant-bitrate = %""PRId64"" bps.\n"",

           avctx->bit_rate);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)

{

	long x,y;



	dst[0]= src[0];



	// first line

	for(x=0; x<srcWidth-1; x++){

		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;

		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];



        dst+= dstStride;



	for(y=1; y<srcHeight; y++){

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

		const long mmxSize= srcWidth&~15;

		asm volatile(

			""mov %4, %%""REG_a""		\n\t""

			""1:				\n\t""

			""movq (%0, %%""REG_a""), %%mm0	\n\t""

			""movq (%1, %%""REG_a""), %%mm1	\n\t""

			""movq 1(%0, %%""REG_a""), %%mm2	\n\t""

			""movq 1(%1, %%""REG_a""), %%mm3	\n\t""

			""movq -1(%0, %%""REG_a""), %%mm4	\n\t""

			""movq -1(%1, %%""REG_a""), %%mm5	\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %%mm1, %%mm2		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %%mm1, %%mm2		\n\t""

			""movq %%mm5, %%mm7		\n\t""

			""movq %%mm4, %%mm6		\n\t""

			""punpcklbw %%mm3, %%mm5		\n\t""

			""punpckhbw %%mm3, %%mm7		\n\t""

			""punpcklbw %%mm2, %%mm4		\n\t""

			""punpckhbw %%mm2, %%mm6		\n\t""

#if 1

			MOVNTQ"" %%mm5, (%2, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm7, 8(%2, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm4, (%3, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm6, 8(%3, %%""REG_a"", 2)\n\t""

#else

			""movq %%mm5, (%2, %%""REG_a"", 2)	\n\t""

			""movq %%mm7, 8(%2, %%""REG_a"", 2)\n\t""

			""movq %%mm4, (%3, %%""REG_a"", 2)	\n\t""

			""movq %%mm6, 8(%3, %%""REG_a"", 2)\n\t""

#endif

			""add $8, %%""REG_a""		\n\t""

			"" js 1b				\n\t""

			:: ""r"" (src + mmxSize  ), ""r"" (src + srcStride + mmxSize  ),

			   ""r"" (dst + mmxSize*2), ""r"" (dst + dstStride + mmxSize*2),

			   ""g"" (-mmxSize)

			: ""%""REG_a



		);

#else

		const long mmxSize=1;

#endif

		dst[0        ]= (3*src[0] +   src[srcStride])>>2;

		dst[dstStride]= (  src[0] + 3*src[srcStride])>>2;



		for(x=mmxSize-1; x<srcWidth-1; x++){

			dst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;

			dst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;

			dst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;

			dst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;

		}

		dst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;

		dst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;



		dst+=dstStride*2;

		src+=srcStride;

	}



	// last line

#if 1

	dst[0]= src[0];



	for(x=0; x<srcWidth-1; x++){

		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;

		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];

#else

	for(x=0; x<srcWidth; x++){

		dst[2*x+0]=

		dst[2*x+1]= src[x];

	}

#endif



#ifdef HAVE_MMX

asm volatile(   EMMS"" \n\t""

        	SFENCE"" \n\t""

        	:::""memory"");

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void gen_mtmsr(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    if (ctx->opcode & 0x00010000) {

        /* Special form that does not need any synchronisation */

        TCGv t0 = tcg_temp_new();

        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));

        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));

        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);

        tcg_temp_free(t0);

    } else {

        TCGv msr = tcg_temp_new();



        /* XXX: we need to update nip before the store

         *      if we enter power saving mode, we will exit the loop

         *      directly from ppc_store_msr

         */

        gen_update_nip(ctx, ctx->nip);

#if defined(TARGET_PPC64)

        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);

#else

        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);

#endif

        gen_helper_store_msr(cpu_env, msr);

        tcg_temp_free(msr);

        /* Must stop the translation as machine state (may have) changed */

        /* Note that mtmsr is not always defined as context-synchronizing */

        gen_stop_exception(ctx);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",1
Detect whether the following code contains vulnerabilities.,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",1
Detect whether the following code contains vulnerabilities.,"static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    NUTContext *nut = s->priv_data;

    ByteIOContext *bc = &s->pb;

    int64_t pos;

    int inited_stream_count;



    nut->avf= s;

    

    av_set_pts_info(s, 60, 1, AV_TIME_BASE);



    /* main header */

    pos=0;

    for(;;){

        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){

            av_log(s, AV_LOG_ERROR, ""no main startcode found\n"");

            return -1;

        }

        pos= url_ftell(bc);

        if(decode_main_header(nut) >= 0)

            break;

    }

    

    

    s->bit_rate = 0;



    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);



    /* stream headers */

    pos=0;

    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){

        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){

            av_log(s, AV_LOG_ERROR, ""not all stream headers found\n"");

            return -1;

        }

        pos= url_ftell(bc);

        if(decode_stream_header(nut) >= 0)

            inited_stream_count++;

    }



    /* info headers */

    pos=0;

    for(;;){

        uint64_t startcode= find_any_startcode(bc, pos);

        pos= url_ftell(bc);



        if(startcode==0){

            av_log(s, AV_LOG_ERROR, ""EOF before video frames\n"");

            return -1;

        }else if(startcode == KEYFRAME_STARTCODE){

            url_fseek(bc, -8, SEEK_CUR); //FIXME

            break;

        }else if(startcode != INFO_STARTCODE){

            continue;

        }



        decode_info_header(nut);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)

{

    int ret;



    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");



    /* 1. streamoff */

    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);

    if (ret)

        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");



    /* 2. unmap the capture buffers (v4l2 and ffmpeg):

     *    we must wait for all references to be released before being allowed

     *    to queue new buffers.

     */

    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");

    if (atomic_load(&s->refcount))

        while(sem_wait(&s->refsync) == -1 && errno == EINTR);



    ff_v4l2_context_release(&s->capture);



    /* 3. get the new capture format */

    ret = ff_v4l2_context_get_format(&s->capture);

    if (ret) {

        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");

        return ret;

    }



    /* 4. set the capture format */

    ret = ff_v4l2_context_set_format(&s->capture);

    if (ret) {

        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");

        return ret;

    }



    /* 5. complete reinit */

    sem_destroy(&s->refsync);

    sem_init(&s->refsync, 0, 0);

    s->draining = 0;

    s->reinit = 0;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,

                              const char *default_model)

{

    int i, exit_status = 0;



    if (!nd->model)

        nd->model = strdup(default_model);



    if (strcmp(nd->model, ""?"") != 0) {

        for (i = 0 ; models[i]; i++)

            if (strcmp(nd->model, models[i]) == 0)

                return i;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s\n"", nd->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (i = 0 ; models[i]; i++)

        fprintf(stderr, ""%s%c"", models[i], models[i+1] ? ',' : '\n');



    exit(exit_status);

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_s390_notify(void *opaque, uint16_t vector)

{

    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;

    uint64_t token = s390_virtio_device_vq_token(dev, vector);



    /* XXX kvm dependency! */

    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);

}
",0
Detect whether the following code contains vulnerabilities.,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
",0
Detect whether the following code contains vulnerabilities.,"static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,

                                 const uint8_t *buf, int size, int64_t pts)

{

    MpegMuxContext *s = ctx->priv_data;

    AVStream *st = ctx->streams[stream_index];

    StreamInfo *stream = st->priv_data;

    int64_t dts;

    int len;



    /* XXX: system clock should be computed precisely, especially for

       CBR case. The current mode gives at least something coherent */

    if (stream_index == s->scr_stream_index)

        s->last_scr = pts;

    

#if 0

    printf(""%d: pts=%0.3f scr=%0.3f\n"", 

           stream_index, pts / 90000.0, s->last_scr / 90000.0);

#endif

    

    /* XXX: currently no way to pass dts, will change soon */

    dts = AV_NOPTS_VALUE;



    /* we assume here that pts != AV_NOPTS_VALUE */

    if (stream->start_pts == AV_NOPTS_VALUE) {

        stream->start_pts = pts;

        stream->start_dts = dts;

    }

    while (size > 0) {

        len = s->packet_data_max_size - stream->buffer_ptr;

        if (len > size)

            len = size;

        memcpy(stream->buffer + stream->buffer_ptr, buf, len);

        stream->buffer_ptr += len;

        buf += len;

        size -= len;

        while (stream->buffer_ptr >= s->packet_data_max_size) {

            /* output the packet */

            flush_packet(ctx, stream_index,

                         stream->start_pts, stream->start_dts, s->last_scr);

            /* Make sure only the FIRST pes packet for this frame has

               a timestamp */

            stream->start_pts = AV_NOPTS_VALUE;

            stream->start_dts = AV_NOPTS_VALUE;

        }

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
",0
Detect whether the following code contains vulnerabilities.,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)

{

    int i;



    if ((p[1] & 0xF) == 3) {

        /* NAA designator type */

        if (p[3] != 8) {

            return -EINVAL;

        }

        *p_wwn = ldq_be_p(p + 4);

        return 0;

    }



    if ((p[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (p[3] > 20 && p[24] != ',') {

            return -EINVAL;

        }

        *p_wwn = 0;

        for (i = 8; i < 24; i++) {

            char c = toupper(p[i]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwn = (*p_wwn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void encode_block(MpegEncContext *s, int16_t *block, int n)

{

    int i, j, table_id;

    int component, dc, last_index, val, run;

    MJpegContext *m = s->mjpeg_ctx;



    /* DC coef */

    component = (n <= 3 ? 0 : (n&1) + 1);

    table_id = (n <= 3 ? 0 : 1);

    dc = block[0]; /* overflow is impossible */

    val = dc - s->last_dc[component];



    ff_mjpeg_encode_coef(m, table_id, val, 0);



    s->last_dc[component] = dc;



    /* AC coefs */



    run = 0;

    last_index = s->block_last_index[n];

    table_id |= 2;



    for(i=1;i<=last_index;i++) {

        j = s->intra_scantable.permutated[i];

        val = block[j];



        if (val == 0) {

            run++;

        } else {

            while (run >= 16) {

                ff_mjpeg_encode_code(m, table_id, 0xf0);

                run -= 16;

            }

            ff_mjpeg_encode_coef(m, table_id, val, run);

            run = 0;

        }

    }



    /* output EOB only if not already 64 values */

    if (last_index < 63 || run != 0)

        ff_mjpeg_encode_code(m, table_id, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)

{

    union srp_iu *srp = &req->iu.srp;

    SCSIDevice *sdev;

    int n, id, lun;



    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);



    /* Qemu vs. linux issue with LUNs to be sorted out ... */

    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;

    if (!sdev) {

        dprintf(""VSCSI: Command for id %d with no drive\n"", id);

        if (srp->cmd.cdb[0] == INQUIRY) {

            vscsi_inquiry_no_target(s, req);

        } else {

            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);

            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

        } return 1;

    }



    req->sdev = sdev;

    req->lun = lun;

    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);



    dprintf(""VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\n"",

            req->qtag, srp->cmd.cdb[0], id, lun, n);



    if (n) {

        /* Transfer direction must be set before preprocessing the

         * descriptors

         */

        req->writing = (n < 1);



        /* Preprocess RDMA descriptors */

        vscsi_preprocess_desc(req);

    }



    /* Get transfer direction and initiate transfer */

    if (n > 0) {

        req->data_len = n;

        sdev->info->read_data(sdev, req->qtag);

    } else if (n < 0) {

        req->data_len = -n;

        sdev->info->write_data(sdev, req->qtag);

    }

    /* Don't touch req here, it may have been recycled already */



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)

{

    QemuOpt *opt;



    opt = qemu_opt_find(opts, name);

    if (!opt) {

        QemuOptDesc *desc = opts->list->desc;

        int i;



        for (i = 0; desc[i].name != NULL; i++) {

            if (strcmp(desc[i].name, name) == 0) {

                break;

            }

        }

        if (desc[i].name == NULL) {

            if (i == 0) {

                /* empty list -> allow any */;

            } else {

                fprintf(stderr, ""option \""%s\"" is not valid for %s\n"",

                        name, opts->list->name);

                return -1;

            }

        }

        opt = qemu_mallocz(sizeof(*opt));

        opt->name = qemu_strdup(name);

        opt->opts = opts;

        TAILQ_INSERT_TAIL(&opts->head, opt, next);

        if (desc[i].name != NULL) {

            opt->desc = desc+i;

        }

    }

    qemu_free((/* !const */ char*)opt->str);

    opt->str = NULL;

    if (value) {

        opt->str = qemu_strdup(value);

    }

    if (qemu_opt_parse(opt) < 0) {

        fprintf(stderr, ""Failed to parse \""%s\"" for \""%s.%s\""\n"", opt->str,

                opts->list->name, opt->name);

        qemu_opt_del(opt);

        return -1;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int scsi_initfn(SCSIDevice *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);

    Error *err = NULL;



    if (!s->qdev.conf.bs) {

        error_report(""drive property not set"");

        return -1;

    }



    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&

        !bdrv_is_inserted(s->qdev.conf.bs)) {

        error_report(""Device needs media, but drive is empty"");

        return -1;

    }



    blkconf_serial(&s->qdev.conf, &s->serial);

    if (dev->type == TYPE_DISK) {

        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);

        if (err) {

            error_report(""%s"", error_get_pretty(err));

            error_free(err);

            return -1;

        }

    }



    if (s->qdev.conf.discard_granularity == -1) {

        s->qdev.conf.discard_granularity =

            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);

    }



    if (!s->version) {

        s->version = g_strdup(qemu_get_version());

    }

    if (!s->vendor) {

        s->vendor = g_strdup(""QEMU"");

    }



    if (bdrv_is_sg(s->qdev.conf.bs)) {

        error_report(""unwanted /dev/sg*"");

        return -1;

    }



    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&

            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {

        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);

    } else {

        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);

    }

    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);



    bdrv_iostatus_enable(s->qdev.conf.bs);

    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
",1
Detect whether the following code contains vulnerabilities.,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)

{

    CPU_DoubleU farg1, farg2, farg3;



    farg1.ll = arg1;

    farg2.ll = arg2;

    farg3.ll = arg3;



    if (unlikely(float64_is_signaling_nan(farg1.d) ||

                 float64_is_signaling_nan(farg2.d) ||

                 float64_is_signaling_nan(farg3.d))) {

        /* sNaN operation */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);

    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||

                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {

        /* Multiplication of zero by infinity */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);

    } else {

#if USE_PRECISE_EMULATION

#ifdef FLOAT128

        /* This is the way the PowerPC specification defines it */

        float128 ft0_128, ft1_128;



        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);

        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);

        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);

        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&

                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {

            /* Magnitude subtraction of infinities */

            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);

        } else {

            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);

            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);

            farg1.d = float128_to_float64(ft0_128, &env->fp_status);

        }

#else

        /* This is OK on x86 hosts */

        farg1.d = (farg1.d * farg2.d) + farg3.d;

#endif

#else

        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);

        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);

#endif

        if (likely(!float64_is_nan(farg1.d)))

            farg1.d = float64_chs(farg1.d);

    }

    return farg1.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)

{

    const struct cow_header_v2 *cow_header = (const void *)buf;



    if (buf_size >= sizeof(struct cow_header_v2) &&

        be32_to_cpu(cow_header->magic) == COW_MAGIC &&

        be32_to_cpu(cow_header->version) == COW_VERSION)

        return 100;

    else

        return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {

    Pulse pulse;

    TemporalNoiseShaping * tns = &sce->tns;

    IndividualChannelStream * ics = &sce->ics;

    float * out = sce->coeffs;

    int global_gain, pulse_present = 0;



    /* This assignment is to silence a GCC warning about the variable being used

     * uninitialized when in fact it always is.

     */

    pulse.num_pulse = 0;



    global_gain = get_bits(gb, 8);



    if (!common_window && !scale_flag) {

        if (decode_ics_info(ac, ics, gb, 0) < 0)

            return -1;

    }



    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)

        return -1;

    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)

        return -1;



    pulse_present = 0;

    if (!scale_flag) {

        if ((pulse_present = get_bits1(gb))) {

            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

                av_log(ac->avccontext, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n"");

                return -1;

            }

            decode_pulses(&pulse, gb, ics->swb_offset);

        }

        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))

            return -1;

        if (get_bits1(gb)) {

            av_log_missing_feature(ac->avccontext, ""SSR"", 1);

            return -1;

        }

    }



    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)

        return -1;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
",0
Detect whether the following code contains vulnerabilities.,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
",0
Detect whether the following code contains vulnerabilities.,"static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->dev.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);

}
",0
Detect whether the following code contains vulnerabilities.,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,

                                int mmu_idx, int is_softmmu)

{

    target_ulong phys;

    int prot;



    /* XXX: implement mmu */



    phys = address;

    prot = PAGE_READ | PAGE_WRITE;



    return tlb_set_page(env, address & TARGET_PAGE_MASK,

                        phys & TARGET_PAGE_MASK, prot,

                        mmu_idx, is_softmmu);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,

                             uint64_t value, unsigned size)

{

    GICState **backref = (GICState **)opaque;

    GICState *s = *backref;

    int id = (backref - s->backref);

    gic_cpu_write(s, id, addr, value);

}
",0
Detect whether the following code contains vulnerabilities.,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
",0
Detect whether the following code contains vulnerabilities.,"static int fb_initialise(struct XenDevice *xendev)

{

    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);

    struct xenfb_page *fb_page;

    int videoram;

    int rc;



    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)

	videoram = 0;



    rc = common_bind(&fb->c);

    if (rc != 0)

	return rc;



    fb_page = fb->c.page;

    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,

			    fb_page->width, fb_page->height, fb_page->depth,

			    fb_page->mem_length, 0, fb_page->line_length);

    if (rc != 0)

	return rc;



    rc = xenfb_map_fb(fb);

    if (rc != 0)

	return rc;



#if 0  /* handled in xen_init_display() for now */

    if (!fb->have_console) {

        fb->c.ds = graphic_console_init(xenfb_update,

                                        xenfb_invalidate,

                                        NULL,

                                        NULL,

                                        fb);

        fb->have_console = 1;

    }

#endif



    if (xenstore_read_fe_int(xendev, ""feature-update"", &fb->feature_update) == -1)

	fb->feature_update = 0;

    if (fb->feature_update)

	xenstore_write_be_int(xendev, ""request-update"", 1);



    xen_pv_printf(xendev, 1, ""feature-update=%d, videoram=%d\n"",

		  fb->feature_update, videoram);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(buf);

    return result;

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_h264_alloc_tables(H264Context *h){

    MpegEncContext * const s = &h->s;

    const int big_mb_num= s->mb_stride * (s->mb_height+1);

    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;

    int x,y;



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)



    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));

    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);

    for(y=0; y<s->mb_height; y++){

        for(x=0; x<s->mb_width; x++){

            const int mb_xy= x + y*s->mb_stride;

            const int b_xy = 4*x + 4*y*h->b_stride;



            h->mb2b_xy [mb_xy]= b_xy;

            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));

        }

    }



    s->obmc_scratchpad = NULL;



    if(!h->dequant4_coeff[0])

        init_dequant_tables(h);



    return 0;

fail:

    free_tables(h, 1);

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",1
Detect whether the following code contains vulnerabilities.,"static AioHandler *find_aio_handler(int fd)

{

    AioHandler *node;



    LIST_FOREACH(node, &aio_handlers, node) {

        if (node->fd == fd)

            return node;

    }



    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
",0
Detect whether the following code contains vulnerabilities.,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
",1
Detect whether the following code contains vulnerabilities.,"static void breakpoint_handler(CPUState *env)

{

    CPUBreakpoint *bp;



    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;

            if (check_hw_breakpoints(env, 0))

                raise_exception(EXCP01_DB);

            else

                cpu_resume_from_signal(env, NULL);

        }

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)

            if (bp->pc == env->eip) {

                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(env);

}
",0
Detect whether the following code contains vulnerabilities.,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",0
Detect whether the following code contains vulnerabilities.,"static void * attribute_align_arg worker(void *v){

    AVCodecContext *avctx = v;

    ThreadContext *c = avctx->internal->frame_thread_encoder;

    AVPacket *pkt = NULL;



    while(!c->exit){

        int got_packet, ret;

        AVFrame *frame;

        Task task;



        if(!pkt) pkt= av_mallocz(sizeof(*pkt));

        if(!pkt) continue;

        av_init_packet(pkt);



        pthread_mutex_lock(&c->task_fifo_mutex);

        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {

            if(c->exit){

                pthread_mutex_unlock(&c->task_fifo_mutex);

                goto end;

            }

            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);

        }

        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);

        pthread_mutex_unlock(&c->task_fifo_mutex);

        frame = task.indata;



        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);

        pthread_mutex_lock(&c->buffer_mutex);

        av_frame_unref(frame);

        pthread_mutex_unlock(&c->buffer_mutex);

        av_frame_free(&frame);

        if(got_packet) {

            int ret2 = av_dup_packet(pkt);

            if (ret >= 0 && ret2 < 0)

                ret = ret2;

        } else {

            pkt->data = NULL;

            pkt->size = 0;

        }

        pthread_mutex_lock(&c->finished_task_mutex);

        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;

        c->finished_tasks[task.index].return_code = ret;

        pthread_cond_signal(&c->finished_task_cond);

        pthread_mutex_unlock(&c->finished_task_mutex);

    }

end:

    av_free(pkt);

    pthread_mutex_lock(&c->buffer_mutex);

    avcodec_close(avctx);

    pthread_mutex_unlock(&c->buffer_mutex);

    av_freep(&avctx);

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
",1
Detect whether the following code contains vulnerabilities.,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
",0
Detect whether the following code contains vulnerabilities.,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)

{

    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);

    IntelIOMMUState *s = vtd_as->iommu_state;

    uint8_t bus_n = pci_bus_num(vtd_as->bus);

    VTDContextEntry ce;



    /*

     * The replay can be triggered by either a invalidation or a newly

     * created entry. No matter what, we release existing mappings

     * (it means flushing caches for UNMAP-only registers).

     */

    vtd_address_space_unmap(vtd_as, n);



    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {

        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),

                                  PCI_FUNC(vtd_as->devfn),

                                  VTD_CONTEXT_ENTRY_DID(ce.hi),

                                  ce.hi, ce.lo);

        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);

    } else {

        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),

                                    PCI_FUNC(vtd_as->devfn));

    }



    return;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",0
Detect whether the following code contains vulnerabilities.,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,

                              int element, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);

    switch (memop) {

    case MO_8:

        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_16:

        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_32:

        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_64:

        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),

                                    int ra, int rb, int rc,

                                    int islit, uint8_t lit)

{

    if (unlikely(rc == 31))

        return;



    if (ra != 31) {

        if (islit) {

            if (lit != 0)

                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));

            else

                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);

        } else {

            TCGv tmp1, tmp2;

            tmp1 = tcg_temp_new(TCG_TYPE_I64);

            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);

            tcg_gen_shli_i64(tmp1, tmp1, 3);

            tmp2 = tcg_const_i64(64);

            tcg_gen_sub_i64(tmp1, tmp2, tmp1);

            tcg_temp_free(tmp2);

            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);

            tcg_temp_free(tmp1);

        }

        if (tcg_gen_ext_i64)

            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);

    } else

        tcg_gen_movi_i64(cpu_ir[rc], 0);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
",0
Detect whether the following code contains vulnerabilities.,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
",0
Detect whether the following code contains vulnerabilities.,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,

                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],

                      GetBitContext *gb)

{

    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;

    int comment_len;



    skip_bits(gb, 2);  // object_type



    sampling_index = get_bits(gb, 4);

    if (m4ac->sampling_index != sampling_index)

        av_log(avctx, AV_LOG_WARNING, ""Sample rate index in program config element does not match the sample rate index configured by the container.\n"");



    num_front       = get_bits(gb, 4);

    num_side        = get_bits(gb, 4);

    num_back        = get_bits(gb, 4);

    num_lfe         = get_bits(gb, 2);

    num_assoc_data  = get_bits(gb, 3);

    num_cc          = get_bits(gb, 4);



    if (get_bits1(gb))

        skip_bits(gb, 4); // mono_mixdown_tag

    if (get_bits1(gb))

        skip_bits(gb, 4); // stereo_mixdown_tag



    if (get_bits1(gb))

        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround







    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);

    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );

    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );

    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );



    skip_bits_long(gb, 4 * num_assoc_data);



    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );



    align_get_bits(gb);



    /* comment field, first byte is length */

    comment_len = get_bits(gb, 8) * 8;

    if (get_bits_left(gb) < comment_len) {




    skip_bits_long(gb, comment_len);

    return 0;
",1
Detect whether the following code contains vulnerabilities.,"static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,

                                     const uint8_t *src_in[4], int srcW, int xInc,

                                     const int16_t *hLumFilter,

                                     const int16_t *hLumFilterPos, int hLumFilterSize,

                                     uint8_t *formatConvBuffer,

                                     uint32_t *pal, int isAlpha)

{

    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;

    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;

    const uint8_t *src = src_in[isAlpha ? 3 : 0];



    if (toYV12) {

        toYV12(formatConvBuffer, src, srcW, pal);

        src= formatConvBuffer;

    } else if (c->readLumPlanar && !isAlpha) {

        c->readLumPlanar(formatConvBuffer, src_in, srcW);

        src = formatConvBuffer;

    }



    if (!c->hyscale_fast) {

        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);

    }



    if (convertRange)

        convertRange(dst, dstWidth);

}
",1
Detect whether the following code contains vulnerabilities.,"static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)

{

    int i, d;

    for( i = 0; i < 4; i++ ) {

        const int tc = tc0[i];

        if( tc <= 0 ) {

            pix += 2*ystride;

            continue;

        }

        for( d = 0; d < 2; d++ ) {

            const int p0 = pix[-1*xstride];

            const int p1 = pix[-2*xstride];

            const int q0 = pix[0];

            const int q1 = pix[1*xstride];



            if( FFABS( p0 - q0 ) < alpha &&

                FFABS( p1 - p0 ) < beta &&

                FFABS( q1 - q0 ) < beta ) {



                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );



                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */

                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */

            }

            pix += ystride;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
",1
Detect whether the following code contains vulnerabilities.,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);",1
Detect whether the following code contains vulnerabilities.,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void put_payload_header(

                                AVFormatContext *s,

                                ASFStream       *stream,

                                int             presentation_time,

                                int             m_obj_size,

                                int             m_obj_offset,

                                int             payload_len

            )

{

    ASFContext *asf = s->priv_data;

    ByteIOContext *pb = &asf->pb;

    int val;

    

    val = stream->num;

    if (s->streams[val - 1]->codec.coded_frame->key_frame)

        val |= ASF_PL_FLAG_KEY_FRAME;

    put_byte(pb, val);

        

    put_byte(pb, stream->seq);  //Media object number

    put_le32(pb, m_obj_offset); //Offset Into Media Object

         

    // Replicated Data shall be at least 8 bytes long.

    // The first 4 bytes of data shall contain the 

    // Size of the Media Object that the payload belongs to.

    // The next 4 bytes of data shall contain the 

    // Presentation Time for the media object that the payload belongs to.

    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);



    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size

    put_le32(pb, presentation_time);//Replicated Data - Presentation Time

    

    if (asf->multi_payloads_present){

        put_le16(pb, payload_len);   //payload length

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",1
Detect whether the following code contains vulnerabilities.,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"void address_space_write(AddressSpace *as, target_phys_addr_t addr,

                         const uint8_t *buf, int len)

{

    address_space_rw(as, addr, (uint8_t *)buf, len, true);

}
",0
Detect whether the following code contains vulnerabilities.,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}",1
Detect whether the following code contains vulnerabilities.,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
",0
Detect whether the following code contains vulnerabilities.,"static always_inline void gen_store_spr(int reg, TCGv t)

{

    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));

}
",0
Detect whether the following code contains vulnerabilities.,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    PCIBus *b = opaque;

    pci_data_write(b, addr, val, size);

}
",0
Detect whether the following code contains vulnerabilities.,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
",1
Detect whether the following code contains vulnerabilities.,"block_crypto_create_opts_init(QCryptoBlockFormat format,

                              QemuOpts *opts,

                              Error **errp)

{

    OptsVisitor *ov;

    QCryptoBlockCreateOptions *ret = NULL;

    Error *local_err = NULL;



    ret = g_new0(QCryptoBlockCreateOptions, 1);

    ret->format = format;



    ov = opts_visitor_new(opts);



    visit_start_struct(opts_get_visitor(ov),

                       NULL, NULL, 0, &local_err);

    if (local_err) {

        goto out;

    }



    switch (format) {

    case Q_CRYPTO_BLOCK_FORMAT_LUKS:

        visit_type_QCryptoBlockCreateOptionsLUKS_members(

            opts_get_visitor(ov), &ret->u.luks, &local_err);

        break;



    default:

        error_setg(&local_err, ""Unsupported block format %d"", format);

        break;

    }

    error_propagate(errp, local_err);

    local_err = NULL;



    visit_end_struct(opts_get_visitor(ov), &local_err);



 out:

    if (local_err) {

        error_propagate(errp, local_err);

        qapi_free_QCryptoBlockCreateOptions(ret);

        ret = NULL;

    }

    opts_visitor_cleanup(ov);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *chrFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int chrFilterSize, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t *aDest, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",0
Detect whether the following code contains vulnerabilities.,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ftp_status(FTPContext *s, char **line, const int response_codes[])

{

    int err, i, dash = 0, result = 0, code_found = 0;

    char buf[CONTROL_BUFFER_SIZE];

    AVBPrint line_buffer;



    if (line)

        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);



    while (!code_found || dash) {

        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {

            av_bprint_finalize(&line_buffer, NULL);

            return err;

        }



        av_log(s, AV_LOG_DEBUG, ""%s\n"", buf);



        if (strlen(buf) < 4)

            continue;



        err = 0;

        for (i = 0; i < 3; ++i) {

            if (buf[i] < '0' || buf[i] > '9')

                continue;

            err *= 10;

            err += buf[i] - '0';

        }

        dash = !!(buf[3] == '-');



        for (i = 0; response_codes[i]; ++i) {

            if (err == response_codes[i]) {

                if (line)

                    av_bprintf(&line_buffer, ""%s"", buf);

                code_found = 1;

                result = err;

                break;

            }

        }

    }



    if (line)

        av_bprint_finalize(&line_buffer, line);

    return result;

}
",1
Detect whether the following code contains vulnerabilities.,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"double avpriv_strtod(char *restrict nptr, char **restrict endptr)

{

    char *end;

    double res;



    /* Skip leading spaces */

    while (isspace(*nptr))

        nptr++;



    if (!av_strncasecmp(nptr, ""infinity"", 8)) {

        end = nptr + 8;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {

        end = nptr + 3;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {

        end = nptr + 9;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {

        end = nptr + 4;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {

        end = nptr + 9;

        res = -INFINITY;

    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {

        end = nptr + 4;

        res = -INFINITY;

    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {

        end = check_nan_suffix(nptr + 3);

        res = NAN;

    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||

               !av_strncasecmp(nptr, ""-nan"", 4)) {

        end = check_nan_suffix(nptr + 4);

        res = NAN;

    } else if (!av_strncasecmp(nptr, ""0x"", 2) ||

               !av_strncasecmp(nptr, ""-0x"", 3) ||

               !av_strncasecmp(nptr, ""+0x"", 3)) {

        /* FIXME this doesn't handle exponents, non-integers (float/double)

         * and numbers too large for long long */

        res = strtoll(nptr, &end, 16);

    } else {

        res = strtod(nptr, &end);

    }



    if (endptr)

        *endptr = end;



    return res;

}
",0
Detect whether the following code contains vulnerabilities.,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {

    double time = av_gettime() / 1000000.0;

    /* update current video pts */

    is->video_current_pts = pts;

    is->video_current_pts_drift = is->video_current_pts - time;

    is->video_current_pos = pos;

    is->frame_last_pts = pts;

    check_external_clock_sync(is, is->video_current_pts);

}
",0
Detect whether the following code contains vulnerabilities.,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int event_status_media(IDEState *s,

                                       uint8_t *buf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->events.eject_request = false;

        }

    }



    buf[4] = event_code;

    buf[5] = media_status;



    /* These fields are reserved, just clear them. */

    buf[6] = 0;

    buf[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,

                                  Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);

    VirtIOSCSI *s = VIRTIO_SCSI(vdev);

    SCSIDevice *sd = SCSI_DEVICE(dev);



    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {

        virtio_scsi_push_event(s, sd,

                               VIRTIO_SCSI_T_TRANSPORT_RESET,

                               VIRTIO_SCSI_EVT_RESET_REMOVED);

    }



    if (s->ctx) {

        blk_op_unblock_all(sd->conf.blk, s->blocker);

    }

    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *addr,

                                    Error **errp)

{

    int fd;



    trace_qio_channel_socket_connect_sync(ioc, addr);

    fd = socket_connect(addr, NULL, NULL, errp);

    if (fd < 0) {

        trace_qio_channel_socket_connect_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,
                      int append)
{
    int buflen;
    /** when the frame data does not need to be concatenated, the input buffer
        is resetted and additional bits from the previous frame are copyed
        and skipped later so that a fast byte copy is possible */
    if (!append) {
        s->frame_offset = get_bits_count(gb) & 7;
        s->num_saved_bits = s->frame_offset;
        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
    buflen = (s->num_saved_bits + len + 8) >> 3;
    if (len <= 0 || buflen > MAX_FRAMESIZE) {
        avpriv_request_sample(s->avctx, ""Too small input buffer"");
    s->num_saved_bits += len;
    if (!append) {
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),
                     s->num_saved_bits);
    } else {
        int align = 8 - (get_bits_count(gb) & 7);
        align = FFMIN(align, len);
        put_bits(&s->pb, align, get_bits(gb, align));
        len -= align;
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);
    skip_bits_long(gb, len);
    {
        PutBitContext tmp = s->pb;
        flush_put_bits(&tmp);
    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);
    skip_bits(&s->gb, s->frame_offset);",1
Detect whether the following code contains vulnerabilities.,"static void host_cpuid(uint32_t function, uint32_t count,

                       uint32_t *eax, uint32_t *ebx,

                       uint32_t *ecx, uint32_t *edx)

{

#if defined(CONFIG_KVM)

    uint32_t vec[4];



#ifdef __x86_64__

    asm volatile(""cpuid""

                 : ""=a""(vec[0]), ""=b""(vec[1]),

                   ""=c""(vec[2]), ""=d""(vec[3])

                 : ""0""(function), ""c""(count) : ""cc"");

#else

    asm volatile(""pusha \n\t""

                 ""cpuid \n\t""

                 ""mov %%eax, 0(%1) \n\t""

                 ""mov %%ebx, 4(%1) \n\t""

                 ""mov %%ecx, 8(%1) \n\t""

                 ""mov %%edx, 12(%1) \n\t""

                 ""popa""

                 : : ""a""(function), ""c""(count), ""S""(vec)

                 : ""memory"", ""cc"");

#endif



    if (eax)

	*eax = vec[0];

    if (ebx)

	*ebx = vec[1];

    if (ecx)

	*ecx = vec[2];

    if (edx)

	*edx = vec[3];

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,

                           int flags)

{

    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];

    DXVA2Mapping      *map;

    D3DSURFACE_DESC    surfaceDesc;

    D3DLOCKED_RECT     LockedRect;

    HRESULT            hr;

    int i, err, nb_planes;

    int lock_flags = 0;



    nb_planes = av_pix_fmt_count_planes(dst->format);



    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Error getting a surface description\n"");

        return AVERROR_UNKNOWN;

    }



    if (!(flags & AV_HWFRAME_MAP_WRITE))

        lock_flags |= D3DLOCK_READONLY;

    if (flags & AV_HWFRAME_MAP_OVERWRITE)

        lock_flags |= D3DLOCK_DISCARD;



    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Unable to lock DXVA2 surface\n"");

        return AVERROR_UNKNOWN;

    }



    map = av_mallocz(sizeof(*map));

    if (!map)

        goto fail;



    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,

                                dxva2_unmap_frame, map);

    if (err < 0) {

        av_freep(&map);

        goto fail;

    }



    for (i = 0; i < nb_planes; i++)

        dst->linesize[i] = LockedRect.Pitch;



    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,

                           (uint8_t*)LockedRect.pBits, dst->linesize);



    if (dst->format == AV_PIX_FMT_PAL8)

        dst->data[1] = (uint8_t*)map->palette_dummy;



    return 0;

fail:

    IDirect3DSurface9_UnlockRect(surface);

    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"void show_help(void)

{

    const char *prog;

    const OptionDef *po;

    int i, expert;

    

    prog = do_play ? ""ffplay"" : ""ffmpeg"";



    printf(""%s version "" FFMPEG_VERSION "", Copyright (c) 2000, 2001, 2002 Gerard Lantau\n"", 

           prog);

    

    if (!do_play) {

        printf(""usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n""

               ""Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\n"");

    } else {

        printf(""usage: ffplay [options] input_file...\n""

               ""Simple audio player\n"");

    }

           

    printf(""\n""

           ""Main options are:\n"");

    for(i=0;i<2;i++) {

        if (i == 1)

            printf(""\nAdvanced options are:\n"");

        for(po = options; po->name != NULL; po++) {

            char buf[64];

            expert = (po->flags & OPT_EXPERT) != 0;

            if (expert == i) {

                strcpy(buf, po->name);

                if (po->flags & HAS_ARG) {

                    strcat(buf, "" "");

                    strcat(buf, po->argname);

                }

                printf(""-%-17s  %s\n"", buf, po->help);

            }

        }

    }



    exit(1);

}
",1
Detect whether the following code contains vulnerabilities.,"av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void platform_mmio_map(PCIDevice *d, int region_num,

                              pcibus_t addr, pcibus_t size, int type)

{

    int mmio_io_addr;



    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,

                                                 DEVICE_NATIVE_ENDIAN);



    cpu_register_physical_memory(addr, size, mmio_io_addr);

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,

                                        uint8_t isc, bool swap,

                                        bool is_maskable)

{

    struct kvm_s390_io_adapter adapter = {

        .id = id,

        .isc = isc,

        .maskable = is_maskable,

        .swap = swap,

    };

    KVMS390FLICState *flic = KVM_S390_FLIC(fs);

    int r, ret;

    struct kvm_device_attr attr = {

        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,

        .addr = (uint64_t)&adapter,

    };



    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {

        /* nothing to do */

        return 0;

    }



    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);



    ret = r ? -errno : 0;

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
",1
Detect whether the following code contains vulnerabilities.,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,

                                    int alpha, int beta, int8_t *tc)

{

    uint8_t bs0 = 1;

    uint8_t bs1 = 1;

    uint8_t bs2 = 1;

    uint8_t bs3 = 1;



    if (tc[0] < 0)

        bs0 = 0;

    if (tc[1] < 0)

        bs1 = 0;

    if (tc[2] < 0)

        bs2 = 0;

    if (tc[3] < 0)

        bs3 = 0;



    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,

                                               bs0, bs1, bs2, bs3,

                                               tc[0], tc[1], tc[2], tc[3],

                                               alpha, beta,

                                               img_width);

}
",0
Detect whether the following code contains vulnerabilities.,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
",0
Detect whether the following code contains vulnerabilities.,"static int virtcon_parse(const char *devname)

{

    QemuOptsList *device = qemu_find_opts(""device"");

    static int index = 0;

    char label[32];

    QemuOpts *bus_opts, *dev_opts;



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_VIRTIO_CONSOLES) {

        fprintf(stderr, ""qemu: too many virtio consoles\n"");

        exit(1);

    }



    bus_opts = qemu_opts_create(device, NULL, 0);

    if (arch_type == QEMU_ARCH_S390X) {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-s390"");

    } else {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-pci"");

    } 



    dev_opts = qemu_opts_create(device, NULL, 0);

    qemu_opt_set(dev_opts, ""driver"", ""virtconsole"");



    snprintf(label, sizeof(label), ""virtcon%d"", index);

    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!virtcon_hds[index]) {

        fprintf(stderr, ""qemu: could not open virtio console '%s': %s\n"",

                devname, strerror(errno));

        return -1;

    }

    qemu_opt_set(dev_opts, ""chardev"", label);



    index++;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    unsigned int i, entries;



    if (c->fc->nb_streams < 1)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];

    sc = st->priv_data;



    avio_r8(pb); /* version */

    avio_rb24(pb); /* flags */



    entries = avio_rb32(pb);



    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);



    if (!entries)

        return 0;

    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))

        return AVERROR_INVALIDDATA;

    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));

    if (!sc->stsc_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < entries && !pb->eof_reached; i++) {

        sc->stsc_data[i].first = avio_rb32(pb);

        sc->stsc_data[i].count = avio_rb32(pb);

        sc->stsc_data[i].id = avio_rb32(pb);

        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {

            sc->stsc_data[i].id = 0;

            if (c->fc->error_recognition & AV_EF_EXPLODE) {

                av_log(c->fc, AV_LOG_ERROR, ""Invalid stsc index.\n"");

                return AVERROR_INVALIDDATA;

            }

        }

    }



    sc->stsc_count = i;



    if (pb->eof_reached)

        return AVERROR_EOF;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void avfilter_link_free(AVFilterLink **link)

{

    if (!*link)

        return;



    if ((*link)->pool) {

        int i;

        for (i = 0; i < POOL_SIZE; i++) {

            if ((*link)->pool->pic[i]) {

                AVFilterBufferRef *picref = (*link)->pool->pic[i];

                /* free buffer: picrefs stored in the pool are not

                 * supposed to contain a free callback */

                av_freep(&picref->buf->data[0]);

                av_freep(&picref->buf);



                av_freep(&picref->audio);

                av_freep(&picref->video);

                av_freep(&picref);

            }

        }

        av_freep(&(*link)->pool);

    }

    av_freep(link);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint64_t pl110_read(void *opaque, hwaddr offset,

                           unsigned size)

{

    pl110_state *s = (pl110_state *)opaque;



    if (offset >= 0xfe0 && offset < 0x1000) {

        return idregs[s->version][(offset - 0xfe0) >> 2];

    }

    if (offset >= 0x200 && offset < 0x400) {

        return s->raw_palette[(offset - 0x200) >> 2];

    }

    switch (offset >> 2) {

    case 0: /* LCDTiming0 */

        return s->timing[0];

    case 1: /* LCDTiming1 */

        return s->timing[1];

    case 2: /* LCDTiming2 */

        return s->timing[2];

    case 3: /* LCDTiming3 */

        return s->timing[3];

    case 4: /* LCDUPBASE */

        return s->upbase;

    case 5: /* LCDLPBASE */

        return s->lpbase;

    case 6: /* LCDIMSC */

        if (s->version != PL110) {

            return s->cr;

        }

        return s->int_mask;

    case 7: /* LCDControl */

        if (s->version != PL110) {

            return s->int_mask;

        }

        return s->cr;

    case 8: /* LCDRIS */

        return s->int_status;

    case 9: /* LCDMIS */

        return s->int_status & s->int_mask;

    case 11: /* LCDUPCURR */

        /* TODO: Implement vertical refresh.  */

        return s->upbase;

    case 12: /* LCDLPCURR */

        return s->lpbase;

    default:

        hw_error(""pl110_read: Bad offset %x\n"", (int)offset);

        return 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t sig[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
",1
Detect whether the following code contains vulnerabilities.,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

",1
Detect whether the following code contains vulnerabilities.,"void qemu_spice_display_init(DisplayState *ds)

{

    assert(sdpy.ds == NULL);

    qemu_spice_display_init_common(&sdpy, ds);

    register_displaychangelistener(ds, &display_listener);



    sdpy.qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_interface(&sdpy.qxl.base);

    assert(sdpy.worker);



    qemu_spice_create_host_memslot(&sdpy);

    qemu_spice_create_host_primary(&sdpy);

}
",1
Detect whether the following code contains vulnerabilities.,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void migrate_params_test_apply(MigrateSetParameters *params,

                                      MigrationParameters *dest)

{

    *dest = migrate_get_current()->parameters;



    /* TODO use QAPI_CLONE() instead of duplicating it inline */



    if (params->has_compress_level) {

        dest->compress_level = params->compress_level;

    }



    if (params->has_compress_threads) {

        dest->compress_threads = params->compress_threads;

    }



    if (params->has_decompress_threads) {

        dest->decompress_threads = params->decompress_threads;

    }



    if (params->has_cpu_throttle_initial) {

        dest->cpu_throttle_initial = params->cpu_throttle_initial;

    }



    if (params->has_cpu_throttle_increment) {

        dest->cpu_throttle_increment = params->cpu_throttle_increment;

    }



    if (params->has_tls_creds) {

        dest->tls_creds = g_strdup(params->tls_creds);

    }



    if (params->has_tls_hostname) {

        dest->tls_hostname = g_strdup(params->tls_hostname);

    }



    if (params->has_max_bandwidth) {

        dest->max_bandwidth = params->max_bandwidth;

    }



    if (params->has_downtime_limit) {

        dest->downtime_limit = params->downtime_limit;

    }



    if (params->has_x_checkpoint_delay) {

        dest->x_checkpoint_delay = params->x_checkpoint_delay;

    }



    if (params->has_block_incremental) {

        dest->block_incremental = params->block_incremental;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
",0
Detect whether the following code contains vulnerabilities.,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    BlockBackend *blk;

    BlockDriverState *bs;



    *aio_context = NULL;



    blk = blk_by_name(device);

    if (!blk) {

        goto notfound;

    }



    *aio_context = blk_get_aio_context(blk);

    aio_context_acquire(*aio_context);



    if (!blk_is_available(blk)) {

        goto notfound;

    }

    bs = blk_bs(blk);



    if (!bs->job) {

        goto notfound;

    }



    return bs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int cris_mmu_translate_page(struct cris_mmu_result *res,

				   CPUState *env, uint32_t vaddr,

				   int rw, int usermode, int debug)

{

	unsigned int vpage;

	unsigned int idx;

	uint32_t pid, lo, hi;

	uint32_t tlb_vpn, tlb_pfn = 0;

	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;

	int cfg_v, cfg_k, cfg_w, cfg_x;	

	int set, match = 0;

	uint32_t r_cause;

	uint32_t r_cfg;

	int rwcause;

	int mmu = 1; /* Data mmu is default.  */

	int vect_base;



	r_cause = env->sregs[SFR_R_MM_CAUSE];

	r_cfg = env->sregs[SFR_RW_MM_CFG];

	pid = env->pregs[PR_PID] & 0xff;



	switch (rw) {

		case 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;

		case 1: rwcause = CRIS_MMU_ERR_WRITE; break;

		default:

		case 0: rwcause = CRIS_MMU_ERR_READ; break;

	}



	/* I exception vectors 4 - 7, D 8 - 11.  */

	vect_base = (mmu + 1) * 4;



	vpage = vaddr >> 13;



	/* We know the index which to check on each set.

	   Scan both I and D.  */

#if 0

	for (set = 0; set < 4; set++) {

		for (idx = 0; idx < 16; idx++) {

			lo = env->tlbsets[mmu][set][idx].lo;

			hi = env->tlbsets[mmu][set][idx].hi;

			tlb_vpn = EXTRACT_FIELD(hi, 13, 31);

			tlb_pfn = EXTRACT_FIELD(lo, 13, 31);



			printf (""TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\n"", 

					set, idx, hi, lo, tlb_vpn, tlb_pfn);

		}

	}

#endif



	idx = vpage & 15;

	for (set = 0; set < 4; set++)

	{

		lo = env->tlbsets[mmu][set][idx].lo;

		hi = env->tlbsets[mmu][set][idx].hi;



		tlb_vpn = hi >> 13;

		tlb_pid = EXTRACT_FIELD(hi, 0, 7);

		tlb_g  = EXTRACT_FIELD(lo, 4, 4);



		D_LOG(""TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\n"", 

			 mmu, set, idx, tlb_vpn, vpage, lo, hi);

		if ((tlb_g || (tlb_pid == pid))

		    && tlb_vpn == vpage) {

			match = 1;

			break;

		}

	}



	res->bf_vec = vect_base;

	if (match) {

		cfg_w  = EXTRACT_FIELD(r_cfg, 19, 19);

		cfg_k  = EXTRACT_FIELD(r_cfg, 18, 18);

		cfg_x  = EXTRACT_FIELD(r_cfg, 17, 17);

		cfg_v  = EXTRACT_FIELD(r_cfg, 16, 16);



		tlb_pfn = EXTRACT_FIELD(lo, 13, 31);

		tlb_v = EXTRACT_FIELD(lo, 3, 3);

		tlb_k = EXTRACT_FIELD(lo, 2, 2);

		tlb_w = EXTRACT_FIELD(lo, 1, 1);

		tlb_x = EXTRACT_FIELD(lo, 0, 0);



		/*

		set_exception_vector(0x04, i_mmu_refill);

		set_exception_vector(0x05, i_mmu_invalid);

		set_exception_vector(0x06, i_mmu_access);

		set_exception_vector(0x07, i_mmu_execute);

		set_exception_vector(0x08, d_mmu_refill);

		set_exception_vector(0x09, d_mmu_invalid);

		set_exception_vector(0x0a, d_mmu_access);

		set_exception_vector(0x0b, d_mmu_write);

		*/

		if (cfg_k && tlb_k && usermode) {

			D(printf (""tlb: kernel protected %x lo=%x pc=%x\n"", 

				  vaddr, lo, env->pc));

			match = 0;

			res->bf_vec = vect_base + 2;

		} else if (rw == 1 && cfg_w && !tlb_w) {

			D(printf (""tlb: write protected %x lo=%x pc=%x\n"", 

				  vaddr, lo, env->pc));

			match = 0;

			/* write accesses never go through the I mmu.  */

			res->bf_vec = vect_base + 3;

		} else if (rw == 2 && cfg_x && !tlb_x) {

			D(printf (""tlb: exec protected %x lo=%x pc=%x\n"", 

				 vaddr, lo, env->pc));

			match = 0;

			res->bf_vec = vect_base + 3;

		} else if (cfg_v && !tlb_v) {

			D(printf (""tlb: invalid %x\n"", vaddr));

			match = 0;

			res->bf_vec = vect_base + 1;

		}



		res->prot = 0;

		if (match) {

			res->prot |= PAGE_READ;

			if (tlb_w)

				res->prot |= PAGE_WRITE;

			if (tlb_x)

				res->prot |= PAGE_EXEC;

		}

		else

			D(dump_tlb(env, mmu));

	} else {

		/* If refill, provide a randomized set.  */

		set = env->mmu_rand_lfsr & 3;

	}



	if (!match && !debug) {

		cris_mmu_update_rand_lfsr(env);



		/* Compute index.  */

		idx = vpage & 15;



		/* Update RW_MM_TLB_SEL.  */

		env->sregs[SFR_RW_MM_TLB_SEL] = 0;

		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);

		set_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);



		/* Update RW_MM_CAUSE.  */

		set_field(&r_cause, rwcause, 8, 2);

		set_field(&r_cause, vpage, 13, 19);

		set_field(&r_cause, pid, 0, 8);

		env->sregs[SFR_R_MM_CAUSE] = r_cause;

		D(printf(""refill vaddr=%x pc=%x\n"", vaddr, env->pc));

	}



	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""

		  "" %x cause=%x sel=%x sp=%x %x %x\n"",

		  __func__, rw, match, env->pc,

		  vaddr, vpage,

		  tlb_vpn, tlb_pfn, tlb_pid, 

		  pid,

		  r_cause,

		  env->sregs[SFR_RW_MM_TLB_SEL],

		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));



	res->phy = tlb_pfn << TARGET_PAGE_BITS;

	return !match;

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void x86_cpu_enable_xsave_components(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    int i;



    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {

        return;

    }



    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);

    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {

        const ExtSaveArea *esa = &x86_ext_save_areas[i];

        if (env->features[esa->feature] & esa->bits) {

            env->xsave_components |= (1ULL << i);

        }

    }



    if (kvm_enabled()) {

        KVMState *s = kvm_state;

        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);

        kvm_mask <<= 32;

        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);

        env->xsave_components &= kvm_mask;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
",0
Detect whether the following code contains vulnerabilities.,"void pci_bridge_reset_reg(PCIDevice *dev)

{

    uint8_t *conf = dev->config;



    conf[PCI_PRIMARY_BUS] = 0;

    conf[PCI_SECONDARY_BUS] = 0;

    conf[PCI_SUBORDINATE_BUS] = 0;

    conf[PCI_SEC_LATENCY_TIMER] = 0;



    conf[PCI_IO_BASE] = 0;

    conf[PCI_IO_LIMIT] = 0;

    pci_set_word(conf + PCI_MEMORY_BASE, 0);

    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);

    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);

    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);

    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);

    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);



    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,

                                        target_phys_addr_t start_addr,

                                        target_phys_addr_t end_addr)

{

    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void nbd_client_close(NBDClient *client)

{

    if (client->closing) {

        return;

    }



    client->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    shutdown(client->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (client->close) {

        client->close(client);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",0
Detect whether the following code contains vulnerabilities.,"static int put_cod(Jpeg2000EncoderContext *s)

{

    Jpeg2000CodingStyle *codsty = &s->codsty;



    if (s->buf_end - s->buf < 14)

        return -1;



    bytestream_put_be16(&s->buf, JPEG2000_COD);

    bytestream_put_be16(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    bytestream_put_be16(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }

    // SPcod

    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, codsty->transform); // transformation

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
",0
Detect whether the following code contains vulnerabilities.,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void qemu_savevm_state_complete(QEMUFile *f)

{

    QJSON *vmdesc;

    int vmdesc_len;

    SaveStateEntry *se;

    int ret;



    trace_savevm_state_complete();



    cpu_synchronize_all_states();



    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {

        if (!se->ops || !se->ops->save_live_complete) {

            continue;

        }

        if (se->ops && se->ops->is_active) {

            if (!se->ops->is_active(se->opaque)) {

                continue;

            }

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        save_section_header(f, se, QEMU_VM_SECTION_END);



        ret = se->ops->save_live_complete(f, se->opaque);

        trace_savevm_section_end(se->idstr, se->section_id, ret);


        if (ret < 0) {

            qemu_file_set_error(f, ret);

            return;

        }

    }



    vmdesc = qjson_new();

    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);

    json_start_array(vmdesc, ""devices"");

    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {



        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {

            continue;

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        json_start_object(vmdesc, NULL);

        json_prop_str(vmdesc, ""name"", se->idstr);

        json_prop_int(vmdesc, ""instance_id"", se->instance_id);



        save_section_header(f, se, QEMU_VM_SECTION_FULL);



        vmstate_save(f, se, vmdesc);



        json_end_object(vmdesc);

        trace_savevm_section_end(se->idstr, se->section_id, 0);


    }



    qemu_put_byte(f, QEMU_VM_EOF);



    json_end_array(vmdesc);

    qjson_finish(vmdesc);

    vmdesc_len = strlen(qjson_get_str(vmdesc));



    if (should_send_vmdesc()) {

        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);

        qemu_put_be32(f, vmdesc_len);

        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);

    }

    object_unref(OBJECT(vmdesc));



    qemu_fflush(f);

}",1
Detect whether the following code contains vulnerabilities.,"static void mvp_init (CPUMIPSState *env, const mips_def_t *def)

{

    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));



    /* MVPConf1 implemented, TLB sharable, no gating storage support,

       programmable cache partitioning implemented, number of allocatable

       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs

       implemented, 5 TCs implemented. */

    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |

                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |

// TODO: actually do 2 VPEs.

//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |

//                             (0x04 << CP0MVPC0_PTC);

                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |

                             (0x00 << CP0MVPC0_PTC);

#if !defined(CONFIG_USER_ONLY)

    /* Usermode has no TLB support */

    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);

#endif



    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,

       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */

    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |

                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |

                             (0x1 << CP0MVPC1_PCP1);

}
",1
Detect whether the following code contains vulnerabilities.,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,

                                  void (*resized)(const char*,

                                                  uint64_t length,

                                                  void *host),

                                  void *host, bool resizeable,

                                  MemoryRegion *mr, Error **errp)

{

    RAMBlock *new_block;

    Error *local_err = NULL;



    size = HOST_PAGE_ALIGN(size);

    max_size = HOST_PAGE_ALIGN(max_size);

    new_block = g_malloc0(sizeof(*new_block));

    new_block->mr = mr;

    new_block->resized = resized;

    new_block->used_length = size;

    new_block->max_length = max_size;

    assert(max_size >= size);

    new_block->fd = -1;

    new_block->host = host;

    if (host) {

        new_block->flags |= RAM_PREALLOC;

    }

    if (resizeable) {

        new_block->flags |= RAM_RESIZEABLE;

    }

    ram_block_add(new_block, &local_err);

    if (local_err) {

        g_free(new_block);

        error_propagate(errp, local_err);

        return NULL;

    }

    mr->ram_block = new_block;

    return new_block;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int swf_write_trailer(AVFormatContext *s)

{

    SWFContext *swf = s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVCodecContext *enc, *video_enc;

    int file_size, i;



    video_enc = NULL;

    for(i=0;i<s->nb_streams;i++) {

        enc = &s->streams[i]->codec;

        if (enc->codec_type == CODEC_TYPE_VIDEO)

            video_enc = enc;

    }



    put_swf_tag(s, TAG_END);

    put_swf_end_tag(s);

    

    put_flush_packet(&s->pb);



    /* patch file size and number of frames if not streamed */

    if (!url_is_streamed(&s->pb) && video_enc) {

        file_size = url_ftell(pb);

        url_fseek(pb, 4, SEEK_SET);

        put_le32(pb, file_size);

        url_fseek(pb, swf->duration_pos, SEEK_SET);

        put_le16(pb, video_enc->frame_number);

    }

    av_free(swf);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int sdl_write_trailer(AVFormatContext *s)

{

    SDLContext *sdl = s->priv_data;



    sdl->quit = 1;



    if (sdl->overlay)

        SDL_FreeYUVOverlay(sdl->overlay);


    if (sdl->event_thread)

        SDL_WaitThread(sdl->event_thread, NULL);


    if (sdl->mutex)

        SDL_DestroyMutex(sdl->mutex);


    if (sdl->init_cond)

        SDL_DestroyCond(sdl->init_cond);




    if (!sdl->sdl_was_already_inited)

        SDL_Quit();



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void kvm_hwpoison_page_add(ram_addr_t ram_addr)

{

    HWPoisonPage *page;



    QLIST_FOREACH(page, &hwpoison_page_list, list) {

        if (page->ram_addr == ram_addr) {

            return;

        }

    }

    page = g_malloc(sizeof(HWPoisonPage));

    page->ram_addr = ram_addr;

    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_i_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           v->pq, v->halfpq);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
",1
Detect whether the following code contains vulnerabilities.,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)

{

    char *str = NULL;

    int size;

    uint16_t str_size;



    if (c->itunes_metadata) {

        int data_size = get_be32(pb);

        int tag = get_le32(pb);

        if (tag == MKTAG('d','a','t','a')) {

            get_be32(pb); // type

            get_be32(pb); // unknown

            str_size = data_size - 16;

        } else return 0;

    } else {

        str_size = get_be16(pb); // string length

        get_be16(pb); // language

    }

    switch (atom.type) {

    case MKTAG(0xa9,'n','a','m'):

        str = c->fc->title; size = sizeof(c->fc->title); break;

    case MKTAG(0xa9,'A','R','T'):

    case MKTAG(0xa9,'w','r','t'):

        str = c->fc->author; size = sizeof(c->fc->author); break;

    case MKTAG(0xa9,'c','p','y'):

        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;

    case MKTAG(0xa9,'c','m','t'):

    case MKTAG(0xa9,'i','n','f'):

        str = c->fc->comment; size = sizeof(c->fc->comment); break;

    case MKTAG(0xa9,'a','l','b'):

        str = c->fc->album; size = sizeof(c->fc->album); break;

    }

    if (!str)

        return 0;

    get_buffer(pb, str, FFMIN(size, str_size));

    dprintf(c->fc, ""%.4s %s\n"", (char*)&atom.type, str);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void aio_context_setup(AioContext *ctx, Error **errp)

{

#ifdef CONFIG_EPOLL

    assert(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
",1
Detect whether the following code contains vulnerabilities.,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){

    int w_align= 1;

    int h_align= 1;



    switch(s->pix_fmt){

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUYV422:

    case PIX_FMT_UYVY422:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_GRAY8:

    case PIX_FMT_GRAY16BE:

    case PIX_FMT_GRAY16LE:

    case PIX_FMT_YUVJ420P:

    case PIX_FMT_YUVJ422P:

    case PIX_FMT_YUVJ444P:

    case PIX_FMT_YUVA420P:

        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment

        h_align= 16;



        break;

    case PIX_FMT_YUV411P:

    case PIX_FMT_UYYVYY411:

        w_align=32;

        h_align=8;

        break;

    case PIX_FMT_YUV410P:

        if(s->codec_id == CODEC_ID_SVQ1){

            w_align=64;

            h_align=64;

        }

    case PIX_FMT_RGB555:

        if(s->codec_id == CODEC_ID_RPZA){

            w_align=4;

            h_align=4;

        }

    case PIX_FMT_PAL8:

    case PIX_FMT_BGR8:

    case PIX_FMT_RGB8:

        if(s->codec_id == CODEC_ID_SMC){

            w_align=4;

            h_align=4;

        }

        break;

    case PIX_FMT_BGR24:

        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){

            w_align=4;

            h_align=4;

        }

        break;

    default:

        w_align= 1;

        h_align= 1;

        break;

    }



    *width = ALIGN(*width , w_align);

    *height= ALIGN(*height, h_align);

    if(s->codec_id == CODEC_ID_H264)

        *height+=2; // some of the optimized chroma MC reads one line too much

}",1
Detect whether the following code contains vulnerabilities.,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",1
Detect whether the following code contains vulnerabilities.,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)

{

    int index;



    for (index = 0; index < nb_drives; index++)

        if (drives_table[index].bdrv == bdrv)

            return drives_table[index].onerror;



    return BLOCK_ERR_REPORT;

}
",1
Detect whether the following code contains vulnerabilities.,"static void netfilter_finalize(Object *obj)

{

    NetFilterState *nf = NETFILTER(obj);

    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);



    if (nfc->cleanup) {

        nfc->cleanup(nf);

    }



    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {

        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);

    }


}",1
Detect whether the following code contains vulnerabilities.,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
",1
Detect whether the following code contains vulnerabilities.,"static void amdvi_realize(DeviceState *dev, Error **err)

{

    int ret = 0;

    AMDVIState *s = AMD_IOMMU_DEVICE(dev);

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);

    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;

    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,

                                     amdvi_uint64_equal, g_free, g_free);



    /* This device should take care of IOMMU PCI properties */

    x86_iommu->type = TYPE_AMD;

    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);

    object_property_set_bool(OBJECT(&s->pci), true, ""realized"", err);

    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,

                                         AMDVI_CAPAB_SIZE);

    assert(s->capab_offset > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);



    /* set up MMIO */

    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, ""amdvi-mmio"",

                          AMDVI_MMIO_SIZE);



    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);

    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);

    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);

    s->devid = object_property_get_int(OBJECT(&s->pci), ""addr"", err);

    msi_init(&s->pci.dev, 0, 1, true, false, err);

    amdvi_init(s);

}
",1
Detect whether the following code contains vulnerabilities.,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    DynBuffer *d = s->opaque;

    int size;

    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *pbuffer = d->buffer;

    size = d->size;

    av_free(d);

    av_free(s);

    return size - padding;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qemu_net_queue_append(NetQueue *queue,

                                  NetClientState *sender,

                                  unsigned flags,

                                  const uint8_t *buf,

                                  size_t size,

                                  NetPacketSent *sent_cb)

{

    NetPacket *packet;



    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {

        return; /* drop if queue full and no callback */

    }

    packet = g_malloc(sizeof(NetPacket) + size);

    packet->sender = sender;

    packet->flags = flags;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);




    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);

}",1
Detect whether the following code contains vulnerabilities.,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",1
Detect whether the following code contains vulnerabilities.,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(ret, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",1
Detect whether the following code contains vulnerabilities.,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",1
Detect whether the following code contains vulnerabilities.,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
",0
Detect whether the following code contains vulnerabilities.,"static void format_line(void *ptr, int level, const char *fmt, va_list vl,

                        AVBPrint part[3], int *print_prefix, int type[2])

{

    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;

    av_bprint_init(part+0, 0, 1);

    av_bprint_init(part+1, 0, 1);

    av_bprint_init(part+2, 0, 65536);



    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;

    if (*print_prefix && avc) {

        if (avc->parent_log_context_offset) {

            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +

                                   avc->parent_log_context_offset);

            if (parent && *parent) {

                av_bprintf(part+0, ""[%s @ %p] "",

                         (*parent)->item_name(parent), parent);

                if(type) type[0] = get_category(parent);

            }

        }

        av_bprintf(part+1, ""[%s @ %p] "",

                 avc->item_name(ptr), ptr);

        if(type) type[1] = get_category(ptr);

    }



    av_vbprintf(part+2, fmt, vl);



    if(*part[0].str || *part[1].str || *part[2].str) {

        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;

        *print_prefix = lastc == '\n' || lastc == '\r';

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)

{

    if (cid != ctx->cid) {

        int index;



        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {

            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %d\n"", cid);

            return AVERROR(ENOSYS);

        }

        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {

            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);

            return AVERROR_INVALIDDATA;

        }

        ctx->cid_table = &ff_dnxhd_cid_table[index];

        av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %d.\n"", cid);



        ff_free_vlc(&ctx->ac_vlc);

        ff_free_vlc(&ctx->dc_vlc);

        ff_free_vlc(&ctx->run_vlc);



        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,

                 ctx->cid_table->ac_bits, 1, 1,

                 ctx->cid_table->ac_codes, 2, 2, 0);

        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,

                 ctx->cid_table->dc_bits, 1, 1,

                 ctx->cid_table->dc_codes, 1, 1, 0);

        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,

                 ctx->cid_table->run_bits, 1, 1,

                 ctx->cid_table->run_codes, 2, 2, 0);



        ctx->cid = cid;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mpeg_decode_frame(AVCodecContext *avctx,

                             void *data, int *data_size,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    Mpeg1Context *s = avctx->priv_data;

    AVFrame *picture = data;

    MpegEncContext *s2 = &s->mpeg_enc_ctx;

    av_dlog(avctx, ""fill_buffer\n"");



    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {

        /* special case for last picture */

        if (s2->low_delay == 0 && s2->next_picture_ptr) {

            *picture = s2->next_picture_ptr->f;

            s2->next_picture_ptr = NULL;



            *data_size = sizeof(AVFrame);

        }

        return buf_size;

    }



    if (s2->flags & CODEC_FLAG_TRUNCATED) {

        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);



        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)

            return buf_size;

    }



    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);

    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(""VCR2"")

                                           || s2->codec_tag == AV_RL32(""BW10"")

                                          ))

        vcr2_init_sequence(avctx);



    s->slice_count = 0;



    if (avctx->extradata && !avctx->frame_number) {

        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);

        if(*data_size) {

            av_log(avctx, AV_LOG_ERROR, ""picture in extradata\n"");

            *data_size = 0;

        }

        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))

            return ret;

    }



    return decode_chunks(avctx, picture, data_size, buf, buf_size);

}
",0
Detect whether the following code contains vulnerabilities.,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void smbios_build_type_1_fields(QemuOpts *opts)

{

    const char *val;



    val = qemu_opt_get(opts, ""manufacturer"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""product"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""version"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""serial"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""uuid"");

    if (val) {

        if (qemu_uuid_parse(val, qemu_uuid) != 0) {

            error_report(""Invalid UUID"");

            exit(1);

        }

    }

    val = qemu_opt_get(opts, ""sku"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""family"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),

                         val, strlen(val) + 1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int hdev_get_max_segments(const struct stat *st)

{

#ifdef CONFIG_LINUX

    char buf[32];

    const char *end;

    char *sysfspath;

    int ret;

    int fd = -1;

    long max_segments;



    sysfspath = g_strdup_printf(""/sys/dev/block/%u:%u/queue/max_segments"",

                                major(st->st_rdev), minor(st->st_rdev));

    fd = open(sysfspath, O_RDONLY);

    if (fd == -1) {

        ret = -errno;

        goto out;

    }

    do {

        ret = read(fd, buf, sizeof(buf));

    } while (ret == -1 && errno == EINTR);

    if (ret < 0) {

        ret = -errno;

        goto out;

    } else if (ret == 0) {

        ret = -EIO;

        goto out;

    }

    buf[ret] = 0;

    /* The file is ended with '\n', pass 'end' to accept that. */

    ret = qemu_strtol(buf, &end, 10, &max_segments);

    if (ret == 0 && end && *end == '\n') {

        ret = max_segments;

    }



out:

    g_free(sysfspath);

    return ret;

#else

    return -ENOTSUP;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)

{

    uint8_t retval;

    MACIOIDEState *d = opaque;



    addr = (addr & 0xFFF) >> 4;

    switch (addr) {

    case 1 ... 7:

        retval = ide_ioport_read(&d->bus, addr);

        break;

    case 8:

    case 22:

        retval = ide_status_read(&d->bus, 0);

        break;

    default:

        retval = 0xFF;

        break;

    }

    return retval;

}
",0
Detect whether the following code contains vulnerabilities.,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
",0
Detect whether the following code contains vulnerabilities.,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void thread_pool_cancel(BlockAIOCB *acb)

{

    ThreadPoolElement *elem = (ThreadPoolElement *)acb;

    ThreadPool *pool = elem->pool;



    trace_thread_pool_cancel(elem, elem->common.opaque);



    qemu_mutex_lock(&pool->lock);

    if (elem->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&pool->sem, 0) == 0) {

        QTAILQ_REMOVE(&pool->request_list, elem, reqs);

        qemu_bh_schedule(pool->completion_bh);



        elem->state = THREAD_DONE;

        elem->ret = -ECANCELED;

    }



    qemu_mutex_unlock(&pool->lock);

}
",0
Detect whether the following code contains vulnerabilities.,"static void monitor_protocol_event_init(void)

{

    qemu_mutex_init(&monitor_event_state_lock);

    /* Limit RTC & BALLOON events to 1 per second */

    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);

    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);

    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,

                                       const int16_t **lumSrc, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrFilterSize, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long dstW, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
",0
Detect whether the following code contains vulnerabilities.,"static void drive_backup_prepare(BlkActionState *common, Error **errp)

{

    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);

    BlockDriverState *bs;

    DriveBackup *backup;

    Error *local_err = NULL;



    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);

    backup = common->action->u.drive_backup.data;



    bs = qmp_get_root_bs(backup->device, errp);

    if (!bs) {

        return;

    }



    /* AioContext is released in .clean() */

    state->aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(state->aio_context);

    bdrv_drained_begin(bs);

    state->bs = bs;



    do_drive_backup(backup, common->block_job_txn, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    state->job = state->bs->job;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void RET_STOP (DisasContext *ctx)

{

    gen_op_update_nip((ctx)->nip);

    ctx->exception = EXCP_MTMSR;

}
",1
Detect whether the following code contains vulnerabilities.,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_receivefd(int sockfd, int *status)

{

    struct iovec iov;

    struct msghdr msg;

    struct cmsghdr *cmsg;

    int retval, data, fd;

    union MsgControl msg_control;



    iov.iov_base = &data;

    iov.iov_len = sizeof(data);



    memset(&msg, 0, sizeof(msg));

    msg.msg_iov = &iov;

    msg.msg_iovlen = 1;

    msg.msg_control = &msg_control;

    msg.msg_controllen = sizeof(msg_control);



    do {

        retval = recvmsg(sockfd, &msg, 0);

    } while (retval < 0 && errno == EINTR);

    if (retval <= 0) {

        return retval;

    }

    /*

     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this

     * request doesn't need ancillary data (fd) or an error occurred,

     * data is set to negative errno value.

     */

    if (data != V9FS_FD_VALID) {

        *status = data;

        return 0;

    }

    /*

     * File descriptor (fd) is sent in the ancillary data. Check if we

     * indeed received it. One of the reasons to fail to receive it is if

     * we exceeded the maximum number of file descriptors!

     */

    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {

        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||

            cmsg->cmsg_level != SOL_SOCKET ||

            cmsg->cmsg_type != SCM_RIGHTS) {

            continue;

        }

        fd = *((int *)CMSG_DATA(cmsg));

        *status = fd;

        return 0;

    }

    *status = -ENFILE;  /* Ancillary data sent but not received */

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
",0
Detect whether the following code contains vulnerabilities.,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"uint64_t helper_efdctuidz (uint64_t val)

{

    CPU_DoubleU u;



    u.ll = val;

    /* NaN are not treated the same way IEEE 754 does */

    if (unlikely(float64_is_nan(u.d)))

        return 0;



    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);

}
",0
Detect whether the following code contains vulnerabilities.,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
",0
Detect whether the following code contains vulnerabilities.,"void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)

{

    PerThreadContext *p = avctx->internal->thread_ctx;

    FrameThreadContext *fctx;

    AVFrame *dst, *tmp;

FF_DISABLE_DEPRECATION_WARNINGS

    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||

                          avctx->thread_safe_callbacks                   ||

                          (

#if FF_API_GET_BUFFER

                           !avctx->get_buffer &&

#endif

                           avctx->get_buffer2 == avcodec_default_get_buffer2);

FF_ENABLE_DEPRECATION_WARNINGS



    if (!f->f->buf[0])

        return;



    if (avctx->debug & FF_DEBUG_BUFFERS)

        av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p\n"", f);



    av_buffer_unref(&f->progress);

    f->owner    = NULL;



    if (can_direct_free) {

        av_frame_unref(f->f);

        return;

    }



    fctx = p->parent;

    pthread_mutex_lock(&fctx->buffer_mutex);



    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))

        goto fail;

    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,

                          (p->num_released_buffers + 1) *

                          sizeof(*p->released_buffers));

    if (!tmp)

        goto fail;

    p->released_buffers = tmp;



    dst = &p->released_buffers[p->num_released_buffers];

    av_frame_move_ref(dst, f->f);



    p->num_released_buffers++;



fail:

    pthread_mutex_unlock(&fctx->buffer_mutex);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
",1
Detect whether the following code contains vulnerabilities.,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_addl_ESP_im(int32_t val)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

#endif

    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
",0
Detect whether the following code contains vulnerabilities.,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,

                                      int mm_flags)

{

#if HAVE_SSE2_INLINE

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {

        c->idct_put              = ff_idct_xvid_sse2_put;

        c->idct_add              = ff_idct_xvid_sse2_add;

        c->idct                  = ff_idct_xvid_sse2;

        c->idct_permutation_type = FF_SSE2_IDCT_PERM;

    }

#endif /* HAVE_SSE2_INLINE */



#if HAVE_SSE2_EXTERNAL

    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;

    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;

    if (mm_flags & AV_CPU_FLAG_ATOM) {

        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;

    } else {

        c->vector_clip_int32 = ff_vector_clip_int32_sse2;

    }

    if (avctx->flags & CODEC_FLAG_BITEXACT) {

        c->apply_window_int16 = ff_apply_window_int16_sse2;

    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {

        c->apply_window_int16 = ff_apply_window_int16_round_sse2;

    }

    c->bswap_buf = ff_bswap32_buf_sse2;

#endif /* HAVE_SSE2_EXTERNAL */

}
",1
Detect whether the following code contains vulnerabilities.,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *opts;

    QEMUMachine *machine;

    char *filename;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");



    g_free(filename);



    if (opts == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(opts, machine->use_scsi);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,

                        int *duration)

{

    int64_t out_pts = AV_NOPTS_VALUE;

    int removed_samples = 0;



#ifdef DEBUG

    ff_af_queue_log_state(afq);

#endif



    /* get output pts from the next frame or generated pts */

    if (afq->frame_queue) {

        if (afq->frame_queue->pts != AV_NOPTS_VALUE)

            out_pts = afq->frame_queue->pts - afq->remaining_delay;

    } else {

        if (afq->next_pts != AV_NOPTS_VALUE)

            out_pts = afq->next_pts - afq->remaining_delay;

    }

    if (pts) {

        if (out_pts != AV_NOPTS_VALUE)

            *pts = ff_samples_to_time_base(afq->avctx, out_pts);

        else

            *pts = AV_NOPTS_VALUE;

    }



    /* if the delay is larger than the packet duration, we use up delay samples

       for the output packet and leave all frames in the queue */

    if (afq->remaining_delay >= nb_samples) {

        removed_samples      += nb_samples;

        afq->remaining_delay -= nb_samples;

    }

    /* remove frames from the queue until we have enough to cover the

       requested number of samples or until the queue is empty */

    while (removed_samples < nb_samples && afq->frame_queue) {

        removed_samples += afq->frame_queue->duration;

        delete_next_frame(afq);

    }

    afq->remaining_samples -= removed_samples;



    /* if there are no frames left and we have room for more samples, use

       any remaining delay samples */

    if (removed_samples < nb_samples && afq->remaining_samples > 0) {

        int add_samples = FFMIN(afq->remaining_samples,

                                nb_samples - removed_samples);

        removed_samples        += add_samples;

        afq->remaining_samples -= add_samples;

    }

    if (removed_samples > nb_samples)

        av_log(afq->avctx, AV_LOG_WARNING, ""frame_size is too large\n"");

    if (duration)

        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);

}
",0
Detect whether the following code contains vulnerabilities.,"void stream_start(BlockDriverState *bs, BlockDriverState *base,

                  const char *base_id, int64_t speed,

                  BlockDriverCompletionFunc *cb,

                  void *opaque, Error **errp)

{

    StreamBlockJob *s;

    Coroutine *co;



    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    if (base_id) {

        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);

    }



    co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, co, opaque);

    qemu_coroutine_enter(co, s);

}
",1
Detect whether the following code contains vulnerabilities.,"static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){

    RateControlContext *rcc= &s->rc_context;

    AVCodecContext *a= s->avctx;

    const int pict_type= rce->new_pict_type;

    const double last_p_q    = rcc->last_qscale_for[P_TYPE];

    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];



    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))

        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;

    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)

        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;




    /* last qscale / qdiff stuff */

    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){

        double last_q= rcc->last_qscale_for[pict_type];

        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;



        if     (q > last_q + maxdiff) q= last_q + maxdiff;

        else if(q < last_q - maxdiff) q= last_q - maxdiff;

    }



    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring



    if(pict_type!=B_TYPE)

        rcc->last_non_b_pict_type= pict_type;



    return q;

}",1
Detect whether the following code contains vulnerabilities.,"static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)

{

    const char *hdlr, *descr = NULL, *hdlr_type = NULL;

    int64_t pos = avio_tell(pb);



    if (!track) { /* no media --> data handler */

        hdlr      = ""dhlr"";

        hdlr_type = ""url "";

        descr     = ""DataHandler"";

    } else {

        hdlr = (track->mode == MODE_MOV) ? ""mhlr"" : ""\0\0\0\0"";

        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            hdlr_type = ""vide"";

            descr     = ""VideoHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {

            hdlr_type = ""soun"";

            descr     = ""SoundHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {

            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = ""sbtl"";

            else                                      hdlr_type = ""text"";

            descr = ""SubtitleHandler"";

        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {

            hdlr_type = ""hint"";

            descr     = ""HintHandler"";

        }

    }



    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""hdlr"");

    avio_wb32(pb, 0); /* Version & flags */

    avio_write(pb, hdlr, 4); /* handler */

    ffio_wfourcc(pb, hdlr_type); /* handler type */

    avio_wb32(pb, 0); /* reserved */

    avio_wb32(pb, 0); /* reserved */

    avio_wb32(pb, 0); /* reserved */

    if (!track || track->mode == MODE_MOV)

        avio_w8(pb, strlen(descr)); /* pascal string */

    avio_write(pb, descr, strlen(descr)); /* handler description */

    if (track && track->mode != MODE_MOV)

        avio_w8(pb, 0); /* c string */

    return update_size(pb, pos);

}
",0
Detect whether the following code contains vulnerabilities.,"PPC_OP(srawi)

{

    T1 = T0;

    T0 = (Ts0 >> PARAM(1));

    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
",1
Detect whether the following code contains vulnerabilities.,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void piix4_update_hotplug(PIIX4PMState *s)

{

    PCIDevice *dev = &s->dev;

    BusState *bus = qdev_get_parent_bus(&dev->qdev);

    DeviceState *qdev, *next;



    s->pci0_hotplug_enable = ~0;



    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {

        PCIDevice *pdev = PCI_DEVICE(qdev);

        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);

        int slot = PCI_SLOT(pdev->devfn);



        if (pc->no_hotplug) {

            s->pci0_hotplug_enable &= ~(1 << slot);

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    StreamBlockJob *s = container_of(job, StreamBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
",1
Detect whether the following code contains vulnerabilities.,"static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)

{

    int16_t input[MDCT_SAMPLES];

    int32_t output[AC3_MAX_COEFS];

    float input1[MDCT_SAMPLES];

    float output1[AC3_MAX_COEFS];

    float s, a, err, e, emax;

    int i, k, n;



    for (i = 0; i < MDCT_SAMPLES; i++) {

        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;

        input1[i] = input[i];

    }



    mdct512(mdct, output, input);



    /* do it by hand */

    for (k = 0; k < AC3_MAX_COEFS; k++) {

        s = 0;

        for (n = 0; n < MDCT_SAMPLES; n++) {

            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));

            s += input1[n] * cos(a);

        }

        output1[k] = -2 * s / MDCT_SAMPLES;

    }



    err  = 0;

    emax = 0;

    for (i = 0; i < AC3_MAX_COEFS; i++) {

        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);

        e = output[i] - output1[i];

        if (e > emax)

            emax = e;

        err += e * e;

    }

    av_log(NULL, AV_LOG_DEBUG, ""err2=%f emax=%f\n"", err / AC3_MAX_COEFS, emax);

}
",0
Detect whether the following code contains vulnerabilities.,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
",1
Detect whether the following code contains vulnerabilities.,"static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)

{

    if (err == 0) {

        v9fs_string_copy(&vs->fidp->path, &vs->fullname);

        stat_to_qid(&vs->stbuf, &vs->qid);

        vs->offset += pdu_marshal(vs->pdu, vs->offset, ""Qd"", &vs->qid,

                &vs->iounit);

        err = vs->offset;

    } else {

        vs->fidp->fid_type = P9_FID_NONE;

        close(vs->fidp->fs.fd);

        err = -errno;

    }



    complete_pdu(s, vs->pdu, err);

    v9fs_string_free(&vs->name);

    v9fs_string_free(&vs->fullname);

    qemu_free(vs);

}
",1
Detect whether the following code contains vulnerabilities.,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}
",1
Detect whether the following code contains vulnerabilities.,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
",0
Detect whether the following code contains vulnerabilities.,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;



    if (avctx->bit_rate > 0) {

        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;

    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {

        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;

    }



    if (avctx->rc_max_rate > 0)

        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;



    if (ctx->rc < 0) {

        if (ctx->flags & NVENC_ONE_PASS)

            ctx->twopass = 0;

        if (ctx->flags & NVENC_TWO_PASSES)

            ctx->twopass = 1;



        if (ctx->twopass < 0)

            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;



        if (ctx->cbr) {

            if (ctx->twopass) {

                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;

            } else {

                ctx->rc = NV_ENC_PARAMS_RC_CBR;

            }

        } else if (avctx->global_quality > 0) {

            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;

        } else if (ctx->twopass) {

            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;

        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {

            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;

        }

    }



    if (ctx->flags & NVENC_LOSSLESS) {

        set_lossless(avctx);

    } else if (ctx->rc > 0) {

        nvenc_override_rate_control(avctx);

    } else {

        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;

        set_vbr(avctx);

    }



    if (avctx->rc_buffer_size > 0) {

        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;

    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {

        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int vp3_decode_end(AVCodecContext *avctx)

{

    Vp3DecodeContext *s = avctx->priv_data;

    int i;



    if (avctx->is_copy && !s->current_frame.data[0])

        return 0;



    av_free(s->superblock_coding);

    av_free(s->all_fragments);

    av_free(s->coded_fragment_list[0]);

    av_free(s->dct_tokens_base);

    av_free(s->superblock_fragments);

    av_free(s->macroblock_coding);

    av_free(s->motion_val[0]);

    av_free(s->motion_val[1]);

    av_free(s->edge_emu_buffer);



    if (avctx->is_copy) return 0;



    for (i = 0; i < 16; i++) {

        free_vlc(&s->dc_vlc[i]);

        free_vlc(&s->ac_vlc_1[i]);

        free_vlc(&s->ac_vlc_2[i]);

        free_vlc(&s->ac_vlc_3[i]);

        free_vlc(&s->ac_vlc_4[i]);

    }



    free_vlc(&s->superblock_run_length_vlc);

    free_vlc(&s->fragment_run_length_vlc);

    free_vlc(&s->mode_code_vlc);

    free_vlc(&s->motion_vector_vlc);



    /* release all frames */

    if (s->golden_frame.data[0])

        ff_thread_release_buffer(avctx, &s->golden_frame);

    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)

        ff_thread_release_buffer(avctx, &s->last_frame);

    /* no need to release the current_frame since it will always be pointing

     * to the same frame as either the golden or last frame */



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void vnc_disconnect_finish(VncState *vs)
{
    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);
    buffer_free(&vs->input);
    buffer_free(&vs->output);
    qobject_decref(vs->info);
#ifdef CONFIG_VNC_TLS
    vnc_tls_client_cleanup(vs);
#endif /* CONFIG_VNC_TLS */
#ifdef CONFIG_VNC_SASL
    vnc_sasl_client_cleanup(vs);
#endif /* CONFIG_VNC_SASL */
    audio_del(vs);
    QTAILQ_REMOVE(&vs->vd->clients, vs, next);
    if (QTAILQ_EMPTY(&vs->vd->clients)) {
        dcl->idle = 1;
    }
    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);
    vnc_remove_timer(vs->vd);
    if (vs->vd->lock_key_sync)
        qemu_remove_led_event_handler(vs->led);
    qemu_free(vs);
}",1
Detect whether the following code contains vulnerabilities.,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",0
Detect whether the following code contains vulnerabilities.,"static void nbd_close(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    qemu_opts_del(s->socket_opts);

    nbd_client_session_close(&s->client);

}
",0
Detect whether the following code contains vulnerabilities.,"static void reset(DeviceState *d)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    trace_spapr_drc_reset(spapr_drc_index(drc));



    g_free(drc->ccs);

    drc->ccs = NULL;



    /* immediately upon reset we can safely assume DRCs whose devices

     * are pending removal can be safely removed, and that they will

     * subsequently be left in an ISOLATED state. move the DRC to this

     * state in these cases (which will in turn complete any pending

     * device removals)

     */

    if (drc->awaiting_release) {

        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);

        /* generally this should also finalize the removal, but if the device

         * hasn't yet been configured we normally defer removal under the

         * assumption that this transition is taking place as part of device

         * configuration. so check if we're still waiting after this, and

         * force removal if we are

         */

        if (drc->awaiting_release) {

            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);

        }



        /* non-PCI devices may be awaiting a transition to UNUSABLE */

        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&

            drc->awaiting_release) {

            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)

{

    int relation;



    set_float_exception_flags(0, &env->fp_status);

    relation = float64_compare(t0, t1, &env->fp_status);

    if (unlikely(relation == float_relation_unordered)) {

        update_fpscr(env, GETPC());

    } else {

        env->sr_t = (relation == float_relation_greater);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int ftp_restart(FTPContext *s, int64_t pos)

{

    char command[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
",0
Detect whether the following code contains vulnerabilities.,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,

                  target_ulong *raddr, int *flags)

{

    int r = -1;

    uint8_t *sk;



    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;

    vaddr &= TARGET_PAGE_MASK;



    if (!(env->psw.mask & PSW_MASK_DAT)) {

        *raddr = vaddr;

        r = 0;

        goto out;

    }



    switch (asc) {

    case PSW_ASC_PRIMARY:

    case PSW_ASC_HOME:

        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);

        break;

    case PSW_ASC_SECONDARY:

        /*

         * Instruction: Primary

         * Data: Secondary

         */

        if (rw == 2) {

            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,

                                  rw);

            *flags &= ~(PAGE_READ | PAGE_WRITE);

        } else {

            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,

                                  rw);

            *flags &= ~(PAGE_EXEC);

        }

        break;

    case PSW_ASC_ACCREG:

    default:

        hw_error(""guest switched to unknown asc mode\n"");

        break;

    }



 out:

    /* Convert real address -> absolute address */

    *raddr = mmu_real2abs(env, *raddr);



    if (*raddr <= ram_size) {

        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];

        if (*flags & PAGE_READ) {

            *sk |= SK_R;

        }



        if (*flags & PAGE_WRITE) {

            *sk |= SK_C;

        }

    }



    return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,

                                   int blocks_per_slice,

                                   int plane_size_factor,

                                   const uint8_t *scan)

{

    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;

    int max_coeffs, bits_left;



    /* set initial prediction values */

    run   = 4;

    level = 2;



    max_coeffs = blocks_per_slice << 6;

    block_mask = blocks_per_slice - 1;



    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {

        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];

        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];



        bits_left = get_bits_left(gb);

        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))

            return 0;



        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);

        if (run < 0)

            return AVERROR_INVALIDDATA;



        bits_left = get_bits_left(gb);

        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))

            return AVERROR_INVALIDDATA;



        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;

        if (level < 0)

            return AVERROR_INVALIDDATA;



        pos += run + 1;

        if (pos >= max_coeffs)

            break;



        sign = get_sbits(gb, 1);

        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =

            (level ^ sign) - sign;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int local_opendir(FsContext *ctx,

                         V9fsPath *fs_path, V9fsFidOpenState *fs)

{

    int dirfd;

    DIR *stream;



    dirfd = local_opendir_nofollow(ctx, fs_path->data);

    if (dirfd == -1) {

        return -1;

    }



    stream = fdopendir(dirfd);

    if (!stream) {


        return -1;

    }

    fs->dir.stream = stream;

    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"get_net_error_message(gint error)

{

    HMODULE module = NULL;

    gchar *retval = NULL;

    wchar_t *msg = NULL;

    int flags;

    size_t nchars;



    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |

        FORMAT_MESSAGE_IGNORE_INSERTS |

        FORMAT_MESSAGE_FROM_SYSTEM;



    if (error >= NERR_BASE && error <= MAX_NERR) {

        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);



        if (module != NULL) {

            flags |= FORMAT_MESSAGE_FROM_HMODULE;

        }

    }



    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);



    if (msg != NULL) {

        nchars = wcslen(msg);



        if (nchars > 2 &&

            msg[nchars - 1] == L'\n' &&

            msg[nchars - 2] == L'\r') {

            msg[nchars - 2] = L'\0';

        }



        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);



        LocalFree(msg);

    }



    if (module != NULL) {

        FreeLibrary(module);

    }



    return retval;

}
",1
Detect whether the following code contains vulnerabilities.,"static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

                s->transparent_color_be[i] = v;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&s->gb, 4); /* crc */

    s->has_trns = 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
",1
Detect whether the following code contains vulnerabilities.,"target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,

                        target_ulong arg2, int mem_idx)

{

    uint64_t tmp;



    tmp = do_lbu(env, arg2, mem_idx);

    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);



    if (GET_LMASK64(arg2) <= 6) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);

        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);

    }



    if (GET_LMASK64(arg2) <= 5) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);

        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);

    }



    if (GET_LMASK64(arg2) <= 4) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);

        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);

    }



    if (GET_LMASK64(arg2) <= 3) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);

    }



    if (GET_LMASK64(arg2) <= 2) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);

    }



    if (GET_LMASK64(arg2) <= 1) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);

    }



    if (GET_LMASK64(arg2) == 0) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;

    }



    return arg1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void child_handler(int sig)

{

    int status;

    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;

}
",1
Detect whether the following code contains vulnerabilities.,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",0
Detect whether the following code contains vulnerabilities.,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
",0
Detect whether the following code contains vulnerabilities.,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    }

    return pes;

}
",0
Detect whether the following code contains vulnerabilities.,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)

{

    int i;

    static const uint8_t LUT[256] = {

        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

    };



    /* Read all the lengths in first */

    for (i = 0; i < ctx->size; i++) {

        /* At most we need to read 9 bits total to get indices up to 8 */

        int val = show_bits(gb, 8);



        // read reverse unary

        if (val) {

            val = LUT[val];

            skip_bits(gb, val + 1);

            ctx->len[i] = val;

        } else {

            skip_bits(gb, 8);

            if (!get_bits1(gb))

                return -1;

            ctx->len[i] = 8;

        }

    }



    /* For any values that have length 0 */

    memset(ctx->val, 0, ctx->size);



    for (i = 0; i < ctx->size; i++) {

        /* Check we have enough bits left */

        if (get_bits_left(gb) < ctx->len[i])

            return -1;



        /* get_bits can't take a length of 0 */

        if (ctx->len[i])

            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
",0
Detect whether the following code contains vulnerabilities.,"BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return QTAILQ_NEXT(bs, device_list);

}
",0
Detect whether the following code contains vulnerabilities.,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *s = (mcf_uart_state *)opaque;

    switch (addr & 0x3f) {

    case 0x00:

        s->mr[s->current_mr] = val;

        s->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(s, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        mcf_uart_do_tx(s);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(s);

}
",0
Detect whether the following code contains vulnerabilities.,"MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)

{

    ARMCPU *cpu;

    uint32_t switched_level;



    if (kvm_irqchip_in_kernel()) {

        /*

         * We only need to sync timer states with user-space interrupt

         * controllers, so return early and save cycles if we don't.

         */

        return MEMTXATTRS_UNSPECIFIED;

    }



    cpu = ARM_CPU(cs);



    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */

    if (run->s.regs.device_irq_level != cpu->device_irq_level) {

        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;



        qemu_mutex_lock_iothread();



        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {

            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],

                         !!(run->s.regs.device_irq_level &

                            KVM_ARM_DEV_EL1_VTIMER));

            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;

        }



        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {

            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],

                         !!(run->s.regs.device_irq_level &

                            KVM_ARM_DEV_EL1_PTIMER));

            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;

        }



        /* XXX PMU IRQ is missing */



        if (switched_level) {

            qemu_log_mask(LOG_UNIMP, ""%s: unhandled in-kernel device IRQ %x\n"",

                          __func__, switched_level);

        }



        /* We also mark unknown levels as processed to not waste cycles */

        cpu->device_irq_level = run->s.regs.device_irq_level;

        qemu_mutex_unlock_iothread();

    }



    return MEMTXATTRS_UNSPECIFIED;

}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    if (addr == OMAP_MPUI_BASE)	/* CMR */

        return 0xfe4d;



    OMAP_BAD_REG(addr);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}
",0
Detect whether the following code contains vulnerabilities.,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
",0
Detect whether the following code contains vulnerabilities.,"void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
",1
Detect whether the following code contains vulnerabilities.,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chardev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
",1
Detect whether the following code contains vulnerabilities.,"static int do_bit_allocation(AC3DecodeContext *ctx, int flags)

{

    ac3_audio_block *ab = &ctx->audio_block;

    int i, snroffst = 0;



    if (!flags) /* bit allocation is not required */

        return 0;



    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */

        snroffst += ab->csnroffst;

        if (ab->flags & AC3_AB_CPLINU)

            snroffst += ab->cplfsnroffst;

        for (i = 0; i < ctx->bsi.nfchans; i++)

            snroffst += ab->fsnroffst[i];

        if (ctx->bsi.flags & AC3_BSI_LFEON)

            snroffst += ab->lfefsnroffst;

        if (!snroffst) {

            memset(ab->cplbap, 0, sizeof (ab->cplbap));

            for (i = 0; i < ctx->bsi.nfchans; i++)

                memset(ab->bap[i], 0, sizeof (ab->bap[i]));

            memset(ab->lfebap, 0, sizeof (ab->lfebap));



            return 0;

        }

    }



    /* perform bit allocation */

    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))

        if (_do_bit_allocation(ctx, 5))

            return -1;

    for (i = 0; i < ctx->bsi.nfchans; i++)

        if (flags & (1 << i))

            if (_do_bit_allocation(ctx, i))

                return -1;

    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))

        if (_do_bit_allocation(ctx, 6))

            return -1;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"build_hpet(GArray *table_data, GArray *linker)

{

    Acpi20Hpet *hpet;



    hpet = acpi_data_push(table_data, sizeof(*hpet));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    hpet->timer_block_id = cpu_to_le32(0x8086a201);

    hpet->addr.address = cpu_to_le64(HPET_BASE);

    build_header(linker, table_data,

                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,

                                         VirtIOPCIRegion *region,

                                         struct virtio_pci_cap *cap)

{

    memory_region_add_subregion(&proxy->modern_bar,

                                region->offset,

                                &region->mr);



    cap->cfg_type = region->type;

    cap->offset = cpu_to_le32(region->offset);

    cap->length = cpu_to_le32(memory_region_size(&region->mr));

    virtio_pci_add_mem_cap(proxy, cap);

}
",0
Detect whether the following code contains vulnerabilities.,"static void mixer_reset (AC97LinkState *s)

{

    uint8_t active[LAST_INDEX];



    dolog (""mixer_reset\n"");

    memset (s->mixer_data, 0, sizeof (s->mixer_data));

    memset (active, 0, sizeof (active));

    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */

    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);

    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);



    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);

    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);

    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);

    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);

    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);

    mixer_store (s, AC97_General_Purpose         , 0x0000);

    mixer_store (s, AC97_3D_Control              , 0x0000);

    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);



    /*

     * Sigmatel 9700 (STAC9700)

     */

    mixer_store (s, AC97_Vendor_ID1              , 0x8384);

    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */



    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);

    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);

    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);

    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);

    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);

    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);

    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);



    record_select (s, 0);

    set_volume (s, AC97_Master_Volume_Mute, 0x8000);

    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);

    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);



    reset_voices (s, active);

}
",0
Detect whether the following code contains vulnerabilities.,"int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)

{

    Coroutine *co;

    DiscardCo rwco = {

        .bs = bs,

        .offset = offset,

        .count = count,

        .ret = NOT_DONE,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_pdiscard_co_entry(&rwco);

    } else {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);

        qemu_coroutine_enter(co);

        while (rwco.ret == NOT_DONE) {

            aio_poll(aio_context, true);

        }

    }



    return rwco.ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",1
Detect whether the following code contains vulnerabilities.,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
",1
Detect whether the following code contains vulnerabilities.,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",1
Detect whether the following code contains vulnerabilities.,"static void conditional_branch(DBDMA_channel *ch)

{

    dbdma_cmd *current = &ch->current;

    uint16_t br;

    uint16_t sel_mask, sel_value;

    uint32_t status;

    int cond;



    DBDMA_DPRINTF(""conditional_branch\n"");



    /* check if we must branch */



    br = le16_to_cpu(current->command) & BR_MASK;



    switch(br) {

    case BR_NEVER:  /* don't branch */

        next(ch);

        return;

    case BR_ALWAYS: /* always branch */

        branch(ch);

        return;

    }



    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;



    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;

    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;



    cond = (status & sel_mask) == (sel_value & sel_mask);



    switch(br) {

    case BR_IFSET:  /* branch if condition bit is 1 */

        if (cond)

            branch(ch);

        else

            next(ch);

        return;

    case BR_IFCLR:  /* branch if condition bit is 0 */

        if (!cond)

            branch(ch);

        else

            next(ch);

        return;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
",0
Detect whether the following code contains vulnerabilities.,"static void rdft_calc_c(RDFTContext *s, FFTSample *data)

{

    int i, i1, i2;

    FFTComplex ev, od;

    const int n = 1 << s->nbits;

    const float k1 = 0.5;

    const float k2 = 0.5 - s->inverse;

    const FFTSample *tcos = s->tcos;

    const FFTSample *tsin = s->tsin;



    if (!s->inverse) {

        s->fft.fft_permute(&s->fft, (FFTComplex*)data);

        s->fft.fft_calc(&s->fft, (FFTComplex*)data);

    }

    /* i=0 is a special case because of packing, the DC term is real, so we

       are going to throw the N/2 term (also real) in with it. */

    ev.re = data[0];

    data[0] = ev.re+data[1];

    data[1] = ev.re-data[1];

    for (i = 1; i < (n>>2); i++) {

        i1 = 2*i;

        i2 = n-i1;

        /* Separate even and odd FFTs */

        ev.re =  k1*(data[i1  ]+data[i2  ]);

        od.im = -k2*(data[i1  ]-data[i2  ]);

        ev.im =  k1*(data[i1+1]-data[i2+1]);

        od.re =  k2*(data[i1+1]+data[i2+1]);

        /* Apply twiddle factors to the odd FFT and add to the even FFT */

        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];

        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];

        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];

        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];

    }

    data[2*i+1]=s->sign_convention*data[2*i+1];

    if (s->inverse) {

        data[0] *= k1;

        data[1] *= k1;

        s->fft.fft_permute(&s->fft, (FFTComplex*)data);

        s->fft.fft_calc(&s->fft, (FFTComplex*)data);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int g726_init(AVCodecContext * avctx)

{

    AVG726Context* c = (AVG726Context*)avctx->priv_data;

    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;



    if (

        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&

         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {

        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");

        return -1;

    }

    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {

        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");

        return -1;

    }

    if(avctx->channels != 1){

        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");

        return -1;

    }

    if(index>3){

        av_log(avctx, AV_LOG_ERROR, ""Unsupported number of bits %d\n"", index+2);

        return -1;

    }

    g726_reset(&c->c, index);

    c->code_size = c->c.tbls->bits;

    c->bit_buffer = 0;

    c->bits_left = 0;



    avctx->coded_frame = avcodec_alloc_frame();

    if (!avctx->coded_frame)

        return AVERROR(ENOMEM);

    avctx->coded_frame->key_frame = 1;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",1
Detect whether the following code contains vulnerabilities.,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
",1
Detect whether the following code contains vulnerabilities.,"static int usb_host_open(USBHostDevice *s, libusb_device *dev)

{

    USBDevice *udev = USB_DEVICE(s);

    int bus_num = libusb_get_bus_number(dev);

    int addr    = libusb_get_device_address(dev);

    int rc;



    trace_usb_host_open_started(bus_num, addr);



    if (s->dh != NULL) {

        goto fail;

    }

    rc = libusb_open(dev, &s->dh);

    if (rc != 0) {

        goto fail;

    }



    s->dev     = dev;

    s->bus_num = bus_num;

    s->addr    = addr;



    usb_host_detach_kernel(s);



    libusb_get_device_descriptor(dev, &s->ddesc);

    usb_host_get_port(s->dev, s->port, sizeof(s->port));



    usb_ep_init(udev);

    usb_host_ep_update(s);



    udev->speed     = speed_map[libusb_get_device_speed(dev)];

    usb_host_speed_compat(s);



    if (s->ddesc.iProduct) {

        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,

                                           (unsigned char *)udev->product_desc,

                                           sizeof(udev->product_desc));

    } else {

        snprintf(udev->product_desc, sizeof(udev->product_desc),

                 ""host:%d.%d"", bus_num, addr);

    }



    rc = usb_device_attach(udev);

    if (rc) {

        goto fail;

    }



    trace_usb_host_open_success(bus_num, addr);

    return 0;



fail:

    trace_usb_host_open_failure(bus_num, addr);

    if (s->dh != NULL) {

        libusb_close(s->dh);

        s->dh = NULL;

        s->dev = NULL;

    }

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)

{

    PageCache *new_cache;

    int64_t ret;



    /* Check for truncation */

    if (new_size != (size_t)new_size) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeding address space"");

        return -1;

    }



    /* Cache should not be larger than guest ram size */

    if (new_size > ram_bytes_total()) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeds guest ram size"");

        return -1;

    }



    XBZRLE_cache_lock();



    if (XBZRLE.cache != NULL) {

        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {

            goto out_new_size;

        }

        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);

        if (!new_cache) {

            ret = -1;

            goto out;

        }



        cache_fini(XBZRLE.cache);

        XBZRLE.cache = new_cache;

    }



out_new_size:

    ret = pow2floor(new_size);

out:

    XBZRLE_cache_unlock();

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *set, CPUAlphaState *env)

{

    abi_ulong frame_addr, r26;

    struct target_rt_sigframe *frame;

    int i, err = 0;



    frame_addr = get_sigframe(ka, env, sizeof(*frame));

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&frame->info, info);



    __put_user(0, &frame->uc.tuc_flags);

    __put_user(0, &frame->uc.tuc_link);

    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(env->ir[IR_SP]),

               &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &frame->uc.tuc_stack.ss_size);

    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);

    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {

        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);

    }



    if (ka->sa_restorer) {

        r26 = ka->sa_restorer;

    } else {

        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);

        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,

                   &frame->retcode[1]);

        __put_user(INSN_CALLSYS, &frame->retcode[2]);

        /* imb(); */

        r26 = frame_addr;

    }



    if (err) {

    give_sigsegv:

       if (sig == TARGET_SIGSEGV) {

            ka->_sa_handler = TARGET_SIG_DFL;

        }

        force_sig(TARGET_SIGSEGV);

    }



    env->ir[IR_RA] = r26;

    env->ir[IR_PV] = env->pc = ka->_sa_handler;

    env->ir[IR_A0] = sig;

    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);

    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);

    env->ir[IR_SP] = frame_addr;

}
",0
Detect whether the following code contains vulnerabilities.,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,

                                    uint32_t fid, uint64_t faddr, uint32_t e)

{

    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));

    S390pciState *s = S390_PCI_HOST_BRIDGE(

        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));



    if (!s) {

        return;

    }



    sei_cont->fh = fh;

    sei_cont->fid = fid;

    sei_cont->cc = cc;

    sei_cont->pec = pec;

    sei_cont->faddr = faddr;

    sei_cont->e = e;



    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);

    css_generate_css_crws(0);

}
",1
Detect whether the following code contains vulnerabilities.,"static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)

{

    VFIOQuirk *quirk;

    VFIOConfigMirrorQuirk *mirror;



    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||

        !vfio_is_vga(vdev) || nr != 0) {

        return;

    }



    quirk = g_malloc0(sizeof(*quirk));

    mirror = quirk->data = g_malloc0(sizeof(*mirror));

    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));

    quirk->nr_mem = 1;

    mirror->vdev = vdev;

    mirror->offset = 0x88000;

    mirror->bar = nr;



    memory_region_init_io(mirror->mem, OBJECT(vdev),

                          &vfio_nvidia_mirror_quirk, mirror,

                          ""vfio-nvidia-bar0-88000-mirror-quirk"",

                          PCIE_CONFIG_SPACE_SIZE);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        mirror->offset, mirror->mem, 1);



    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);



    /* The 0x1800 offset mirror only seems to get used by legacy VGA */

    if (vdev->has_vga) {

        quirk = g_malloc0(sizeof(*quirk));

        mirror = quirk->data = g_malloc0(sizeof(*mirror));

        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));

        quirk->nr_mem = 1;

        mirror->vdev = vdev;

        mirror->offset = 0x1800;

        mirror->bar = nr;



        memory_region_init_io(mirror->mem, OBJECT(vdev),

                              &vfio_nvidia_mirror_quirk, mirror,

                              ""vfio-nvidia-bar0-1800-mirror-quirk"",

                              PCI_CONFIG_SPACE_SIZE);

        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                            mirror->offset, mirror->mem, 1);



        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);

    }



    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",1
Detect whether the following code contains vulnerabilities.,"static void cpu_common_reset(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);



    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);

        log_cpu_state(cpu, cc->reset_dump_flags);

    }



    cpu->interrupt_request = 0;

    cpu->halted = 0;

    cpu->mem_io_pc = 0;

    cpu->mem_io_vaddr = 0;

    cpu->icount_extra = 0;

    cpu->icount_decr.u32 = 0;

    cpu->can_do_io = 1;

    cpu->exception_index = -1;

    cpu->crash_occurred = false;



    if (tcg_enabled()) {

        cpu_tb_jmp_cache_clear(cpu);



#ifdef CONFIG_SOFTMMU

        tlb_flush(cpu, 0);

#endif

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",0
Detect whether the following code contains vulnerabilities.,"static void subpage_write(void *opaque, target_phys_addr_t addr,

                          uint64_t value, unsigned len)

{

    subpage_t *mmio = opaque;

    unsigned int idx = SUBPAGE_IDX(addr);

    MemoryRegionSection *section;

#if defined(DEBUG_SUBPAGE)

    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx

           "" idx %d value %""PRIx64""\n"",

           __func__, mmio, len, addr, idx, value);

#endif



    section = &phys_sections[mmio->sub_section[idx]];

    addr += mmio->base;

    addr -= section->offset_within_address_space;

    addr += section->offset_within_region;

    io_mem_write(section->mr, addr, value, len);

}
",0
Detect whether the following code contains vulnerabilities.,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
",0
Detect whether the following code contains vulnerabilities.,"void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)

{

    unsigned int i;



    /* Discard jump cache entries for any tb which might potentially

       overlap the flushed page.  */

    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);

    memset(&cpu->tb_jmp_cache[i], 0,

           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));



    i = tb_jmp_cache_hash_page(addr);

    memset(&cpu->tb_jmp_cache[i], 0,

           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));

}
",1
Detect whether the following code contains vulnerabilities.,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
",0
Detect whether the following code contains vulnerabilities.,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    void *p;



    size *= items;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    p = qemu_mallocz(size);



    return (p);

}
",0
Detect whether the following code contains vulnerabilities.,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
",1
Detect whether the following code contains vulnerabilities.,"static void megasas_scsi_uninit(PCIDevice *d)

{

    MegasasState *s = MEGASAS(d);



    if (megasas_use_msix(s)) {

        msix_uninit(d, &s->mmio_io, &s->mmio_io);

    }

    if (megasas_use_msi(s)) {

        msi_uninit(d);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,

                                 int *got_frame, AVPacket *avpkt)

{

    Jpeg2000DecoderContext *s = avctx->priv_data;

    ThreadFrame frame = { .f = data };

    AVFrame *picture = data;

    int tileno, ret;



    s->avctx     = avctx;

    s->buf       = s->buf_start = avpkt->data;

    s->buf_end   = s->buf_start + avpkt->size;

    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles



    // reduction factor, i.e number of resolution levels to skip

    s->reduction_factor = s->lowres;



    ff_jpeg2000_init_tier1_luts();



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    // check if the image is in jp2 format

    if ((AV_RB32(s->buf) == 12) &&

        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&

        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {

        if (!jp2_find_codestream(s)) {

            av_log(avctx, AV_LOG_ERROR,

                   ""couldn't find jpeg2k codestream atom\n"");

            return -1;

        }

    }



    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {

        av_log(avctx, AV_LOG_ERROR, ""SOC marker not present\n"");

        return -1;

    }

    if (ret = jpeg2000_read_main_headers(s))

        goto end;



    /* get picture buffer */

    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""ff_thread_get_buffer() failed.\n"");

        goto end;

    }

    picture->pict_type = AV_PICTURE_TYPE_I;

    picture->key_frame = 1;



    if (ret = jpeg2000_read_bitstream_packets(s))

        goto end;

    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)

        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))

            goto end;



    *got_frame = 1;



end:

    jpeg2000_dec_cleanup(s);

    return ret ? ret : s->buf - s->buf_start;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vfio_platform_eoi(VFIODevice *vbasedev)

{

    VFIOINTp *intp;

    VFIOPlatformDevice *vdev =

        container_of(vbasedev, VFIOPlatformDevice, vbasedev);



    qemu_mutex_lock(&vdev->intp_mutex);

    QLIST_FOREACH(intp, &vdev->intp_list, next) {

        if (intp->state == VFIO_IRQ_ACTIVE) {

            trace_vfio_platform_eoi(intp->pin,

                                event_notifier_get_fd(&intp->interrupt));

            intp->state = VFIO_IRQ_INACTIVE;



            /* deassert the virtual IRQ */

            qemu_set_irq(intp->qemuirq, 0);



            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {

                /* unmasks the physical level-sensitive IRQ */

                vfio_unmask_single_irqindex(vbasedev, intp->pin);

            }



            /* a single IRQ can be active at a time */

            break;

        }

    }

    /* in case there are pending IRQs, handle the first one */

    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {

        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);

        vfio_intp_inject_pending_lockheld(intp);

        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);

    }

    qemu_mutex_unlock(&vdev->intp_mutex);

}
",0
Detect whether the following code contains vulnerabilities.,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",0
Detect whether the following code contains vulnerabilities.,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
",0
Detect whether the following code contains vulnerabilities.,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
",0
Detect whether the following code contains vulnerabilities.,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void test_visitor_out_int(TestOutputVisitorData *data,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *obj;



    visit_type_int(data->ov, NULL, &value, &error_abort);



    obj = visitor_get(data);

    g_assert(qobject_type(obj) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);

}
",0
Detect whether the following code contains vulnerabilities.,"void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)

{

    struct in_addr host_addr = { .s_addr = INADDR_ANY };

    int host_port;

    char buf[256] = """";

    const char *p = src_str;

    int is_udp = 0;

    int n;



    if (!slirp_inited) {

        monitor_printf(mon, ""user mode network stack not in use\n"");

        return;

    }



    if (!src_str || !src_str[0])

        goto fail_syntax;



    get_str_sep(buf, sizeof(buf), &p, ':');



    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {

        is_udp = 0;

    } else if (!strcmp(buf, ""udp"")) {

        is_udp = 1;

    } else {

        goto fail_syntax;

    }



    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {

        goto fail_syntax;

    }

    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {

        goto fail_syntax;

    }



    host_port = atoi(p);



    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);



    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,

                   src_str);

    return;



 fail_syntax:

    monitor_printf(mon, ""invalid format\n"");

}
",0
Detect whether the following code contains vulnerabilities.,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
",0
Detect whether the following code contains vulnerabilities.,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

",1
Detect whether the following code contains vulnerabilities.,"static void main_loop(void)

{

    bool nonblocking;

    int last_io __attribute__ ((unused)) = 0;

#ifdef CONFIG_PROFILER

    int64_t ti;

#endif

    int r;



    qemu_main_loop_start();



    for (;;) {

#ifdef CONFIG_IOTHREAD

        nonblocking = !kvm_enabled() && last_io > 0;

#else

        nonblocking = cpu_exec_all();

        if (vm_request_pending()) {

            nonblocking = true;

        }

#endif

#ifdef CONFIG_PROFILER

        ti = profile_getclock();

#endif

        last_io = main_loop_wait(nonblocking);

#ifdef CONFIG_PROFILER

        dev_time += profile_getclock() - ti;

#endif



        if (qemu_debug_requested()) {

            vm_stop(VMSTOP_DEBUG);

        }

        if (qemu_shutdown_requested()) {

            qemu_kill_report();

            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);

            if (no_shutdown) {

                vm_stop(VMSTOP_SHUTDOWN);

            } else

                break;

        }

        if (qemu_reset_requested()) {

            pause_all_vcpus();

            cpu_synchronize_all_states();

            qemu_system_reset(VMRESET_REPORT);

            resume_all_vcpus();

        }

        if (qemu_powerdown_requested()) {

            monitor_protocol_event(QEVENT_POWERDOWN, NULL);

            qemu_irq_raise(qemu_system_powerdown);

        }

        if ((r = qemu_vmstop_requested())) {

            vm_stop(r);

        }

    }

    bdrv_close_all();

    pause_all_vcpus();

}
",1
Detect whether the following code contains vulnerabilities.,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
",0
Detect whether the following code contains vulnerabilities.,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",1
Detect whether the following code contains vulnerabilities.,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;",1
Detect whether the following code contains vulnerabilities.,"bool ftrace_init(void)

{

    char mount_point[PATH_MAX];

    char path[PATH_MAX];

    int debugfs_found;

    int trace_fd = -1;



    debugfs_found = find_mount(mount_point, ""debugfs"");

    if (debugfs_found) {

        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);

        trace_fd = open(path, O_WRONLY);

        if (trace_fd < 0) {

            if (errno == EACCES) {

                trace_marker_fd = open(""/dev/null"", O_WRONLY);

                if (trace_marker_fd != -1) {

                    return true;

                }

            }

            perror(""Could not open ftrace 'tracing_on' file"");

            return false;

        } else {

            if (write(trace_fd, ""1"", 1) < 0) {

                perror(""Could not write to 'tracing_on' file"");

                close(trace_fd);

                return false;

            }

            close(trace_fd);

        }

        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);

        trace_marker_fd = open(path, O_WRONLY);

        if (trace_marker_fd < 0) {

            perror(""Could not open ftrace 'trace_marker' file"");

            return false;

        }

    } else {

        fprintf(stderr, ""debugfs is not mounted\n"");

        return false;

    }



    return true;

}
",1
Detect whether the following code contains vulnerabilities.,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)

{

    OggVorbisContext *context = avccontext->priv_data;

    double cfreq;



    if (avccontext->flags & CODEC_FLAG_QSCALE) {

        /* variable bitrate */

        if (vorbis_encode_setup_vbr(vi, avccontext->channels,

                                    avccontext->sample_rate,

                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))

            return -1;

    } else {

        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;

        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;



        /* constant bitrate */

        if (vorbis_encode_setup_managed(vi, avccontext->channels,

                                        avccontext->sample_rate, minrate,

                                        avccontext->bit_rate, maxrate))

            return -1;



        /* variable bitrate by estimate, disable slow rate management */

        if (minrate == -1 && maxrate == -1)

            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))

                return -1;

    }



    /* cutoff frequency */

    if (avccontext->cutoff > 0) {

        cfreq = avccontext->cutoff / 1000.0;

        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))

            return -1;

    }



    if (context->iblock) {

        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);

    }



    return vorbis_encode_setup_init(vi);

}
",0
Detect whether the following code contains vulnerabilities.,"static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                        const AVFrame *frame, int *got_packet_ptr)

{

    NellyMoserEncodeContext *s = avctx->priv_data;

    int ret;



    if (s->last_frame)

        return 0;



    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));

    if (frame) {

        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],

               frame->nb_samples * sizeof(*s->buf));

        if (frame->nb_samples < NELLY_SAMPLES) {

            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,

                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));

            if (frame->nb_samples >= NELLY_BUF_LEN)

                s->last_frame = 1;

        }

        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))

            return ret;

    } else {

        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));

        s->last_frame = 1;

    }



    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet\n"");

        return ret;

    }

    encode_block(s, avpkt->data, avpkt->size);



    /* Get the next frame pts/duration */

    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,

                       &avpkt->duration);



    *got_packet_ptr = 1;

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)

{

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (!high_bit_depth) {

    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;

    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;

    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;



    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;

    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;

    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;



    c->avg_pixels_tab[0][0] = avg_pixels16_axp;

    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;

    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;

    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;



    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;

    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;

    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;

    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;



    c->put_pixels_tab[1][0] = put_pixels_axp_asm;

    c->put_pixels_tab[1][1] = put_pixels_x2_axp;

    c->put_pixels_tab[1][2] = put_pixels_y2_axp;

    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;



    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;

    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;

    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;

    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;



    c->avg_pixels_tab[1][0] = avg_pixels_axp;

    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;

    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;

    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;



    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;

    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;

    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;

    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;



    c->clear_blocks = clear_blocks_axp;

    }



    /* amask clears all bits that correspond to present features.  */

    if (amask(AMASK_MVI) == 0) {

        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;

        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;



        if (!high_bit_depth)

            c->get_pixels   = get_pixels_mvi;

        c->diff_pixels      = diff_pixels_mvi;

        c->sad[0]           = pix_abs16x16_mvi_asm;

        c->sad[1]           = pix_abs8x8_mvi;

        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;

        c->pix_abs[1][0]    = pix_abs8x8_mvi;

        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;

        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;

        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;

    }



    put_pixels_clamped_axp_p = c->put_pixels_clamped;

    add_pixels_clamped_axp_p = c->add_pixels_clamped;



    if (avctx->bits_per_raw_sample <= 8 &&

        (avctx->idct_algo == FF_IDCT_AUTO ||

         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {

        c->idct_put = ff_simple_idct_put_axp;

        c->idct_add = ff_simple_idct_add_axp;

        c->idct =     ff_simple_idct_axp;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
",0
Detect whether the following code contains vulnerabilities.,"static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){

    long i;

#if !HAVE_FAST_UNALIGNED

    if((long)src2 & (sizeof(long)-1)){

        for(i=0; i+7<w; i+=8){

            dst[i+0] = src1[i+0]-src2[i+0];

            dst[i+1] = src1[i+1]-src2[i+1];

            dst[i+2] = src1[i+2]-src2[i+2];

            dst[i+3] = src1[i+3]-src2[i+3];

            dst[i+4] = src1[i+4]-src2[i+4];

            dst[i+5] = src1[i+5]-src2[i+5];

            dst[i+6] = src1[i+6]-src2[i+6];

            dst[i+7] = src1[i+7]-src2[i+7];

        }

    }else

#endif

    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){

        long a = *(long*)(src1+i);

        long b = *(long*)(src2+i);

        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);

    }

    for(; i<w; i++)

        dst[i+0] = src1[i+0]-src2[i+0];

}
",1
Detect whether the following code contains vulnerabilities.,"int ff_filter_frame(AVFilterLink *link, AVFrame *frame)

{

    int (*filter_frame)(AVFilterLink *, AVFrame *);

    AVFilterPad *dst = link->dstpad;

    AVFrame *out;



    FF_DPRINTF_START(NULL, filter_frame);

    ff_dlog_link(NULL, link, 1);



    if (!(filter_frame = dst->filter_frame))

        filter_frame = default_filter_frame;



    /* copy the frame if needed */

    if (dst->needs_writable && !av_frame_is_writable(frame)) {

        av_log(link->dst, AV_LOG_DEBUG, ""Copying data in avfilter.\n"");



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            out = ff_get_video_buffer(link, link->w, link->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            out = ff_get_audio_buffer(link, frame->nb_samples);

            break;

        default: return AVERROR(EINVAL);

        }

        if (!out) {

            av_frame_free(&frame);

            return AVERROR(ENOMEM);

        }

        av_frame_copy_props(out, frame);



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,

                          frame->format, frame->width, frame->height);

            break;

        case AVMEDIA_TYPE_AUDIO:

            av_samples_copy(out->extended_data, frame->extended_data,

                            0, 0, frame->nb_samples,

                            av_get_channel_layout_nb_channels(frame->channel_layout),

                            frame->format);

            break;

        default: return AVERROR(EINVAL);

        }



        av_frame_free(&frame);

    } else

        out = frame;



    return filter_frame(link, out);

}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
",0
Detect whether the following code contains vulnerabilities.,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_monitor_def(target_long *pval, const char *name)

{

    const MonitorDef *md;

    void *ptr;



    for(md = monitor_defs; md->name != NULL; md++) {

        if (compare_cmd(name, md->name)) {

            if (md->get_value) {

                *pval = md->get_value(md, md->offset);

            } else {

                CPUState *env = mon_get_cpu();

                if (!env)

                    return -2;

                ptr = (uint8_t *)env + md->offset;

                switch(md->type) {

                case MD_I32:

                    *pval = *(int32_t *)ptr;

                    break;

                case MD_TLONG:

                    *pval = *(target_long *)ptr;

                    break;

                default:

                    *pval = 0;

                    break;

                }

            }

            return 0;

        }

    }

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",1
Detect whether the following code contains vulnerabilities.,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",0
Detect whether the following code contains vulnerabilities.,"static void s390_virtio_device_sync(VirtIOS390Device *dev)

{

    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    ram_addr_t cur_offs;

    uint8_t num_vq;

    int i;



    virtio_reset(dev->vdev);



    /* Sync dev space */

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);



    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);



    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);



    num_vq = s390_virtio_device_num_vq(dev);

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);



    /* Sync virtqueues */

    for (i = 0; i < num_vq; i++) {

        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +

                        (i * VIRTIO_VQCONFIG_LEN);

        ram_addr_t vring;



        vring = s390_virtio_next_ring(bus);

        virtio_queue_set_addr(dev->vdev, i, vring);

        virtio_queue_set_vector(dev->vdev, i, i);

        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);

        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));

    }



    cur_offs = dev->dev_offs;

    cur_offs += VIRTIO_DEV_OFFS_CONFIG;

    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;



    /* Sync feature bitmap */

    if (dev->vdev->get_features) {

        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));

    }



    dev->feat_offs = cur_offs + dev->feat_len;

    cur_offs += dev->feat_len * 2;



    /* Sync config space */

    if (dev->vdev->get_config) {

        dev->vdev->get_config(dev->vdev, dev->vdev->config);

    }



    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);

    cur_offs += dev->vdev->config_len;

}
",0
Detect whether the following code contains vulnerabilities.,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)

{

    ROQDPCMContext *context = avctx->priv_data;



    if (avctx->channels > 2) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be mono or stereo\n"");

        return -1;

    }

    if (avctx->sample_rate != 22050) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be 22050 Hz\n"");

        return -1;

    }

    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be signed 16-bit\n"");

        return -1;

    }



    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;



    context->lastSample[0] = context->lastSample[1] = 0;



    avctx->coded_frame= avcodec_alloc_frame();





    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void test_function(const TestStruct test_sample)

{

    int ret, i;

    void **output_data  = NULL;

    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,

                                            test_sample.nb_samples_pch);

    if (!afifo) {

        ERROR(""ERROR: av_audio_fifo_alloc returned NULL!"");

    }

    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);



    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_read failed!"");

    }

    printf(""read: %d\n"", ret);

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    /* test av_audio_fifo_peek */

    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_peek failed!"");

    }

    printf(""peek:\n"");

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""\n"");



    /* test av_audio_fifo_peek_at */

    printf(""peek_at:\n"");

    for (i = 0; i < afifo->nb_samples; ++i){

        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);

        if (ret < 0){

            ERROR(""ERROR: av_audio_fifo_peek_at failed!"");

        }

        printf(""%d:\n"", i);

        print_audio_bytes(&test_sample, output_data, ret);

    }

    printf(""\n"");



    /* test av_audio_fifo_drain */

    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_drain failed!"");

    }

    if (afifo->nb_samples){

        ERROR(""drain failed to flush all samples in audio_fifo!"");

    }



    /* deallocate */

    for (i = 0; i < afifo->nb_buffers; ++i){

        av_freep(&output_data[i]);

    }

    av_freep(&output_data);

    av_audio_fifo_free(afifo);

}
",1
Detect whether the following code contains vulnerabilities.,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
",1
Detect whether the following code contains vulnerabilities.,"static void setup_frame(int sig, struct emulated_sigaction *ka,

			target_sigset_t *set, CPUX86State *env)

{

	struct sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif

	err |= __put_user((/*current->exec_domain

		           && current->exec_domain->signal_invmap

		           && sig < 32

		           ? current->exec_domain->signal_invmap[sig]

		           : */ sig),

		          &frame->sig);

	if (err)

		goto give_sigsegv;



	setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);

	if (err)

		goto give_sigsegv;



	if (TARGET_NSIG_WORDS > 1) {

		err |= __copy_to_user(frame->extramask, &set->sig[1],

				      sizeof(frame->extramask));

	}

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);

	} else {

		err |= __put_user(frame->retcode, &frame->pretcode);

		/* This is popl %eax ; movl $,%eax ; int $0x80 */

		err |= __put_user(0xb858, (short *)(frame->retcode+0));

		err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));

		err |= __put_user(0x80cd, (short *)(frame->retcode+6));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	env->regs[R_ESP] = (unsigned long) frame;

	env->eip = (unsigned long) ka->sa._sa_handler;



        cpu_x86_load_seg(env, R_DS, __USER_DS);

        cpu_x86_load_seg(env, R_ES, __USER_DS);

        cpu_x86_load_seg(env, R_SS, __USER_DS);

        cpu_x86_load_seg(env, R_CS, __USER_CS);

	env->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (sig == TARGET_SIGSEGV)

		ka->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",0
Detect whether the following code contains vulnerabilities.,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
",1
Detect whether the following code contains vulnerabilities.,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    /* calculate size of remaining data */
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    /* Now for that packet */
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    /* Only one stream in an AIFF file */
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",1
Detect whether the following code contains vulnerabilities.,"uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)

{

    CPU_DoubleU farg1, farg2, farg3;



    farg1.ll = arg1;

    farg2.ll = arg2;

    farg3.ll = arg3;



    if (unlikely(float64_is_signaling_nan(farg1.d) ||

                 float64_is_signaling_nan(farg2.d) ||

                 float64_is_signaling_nan(farg3.d))) {

        /* sNaN operation */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);

    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||

                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {

        /* Multiplication of zero by infinity */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);

    } else {

#if USE_PRECISE_EMULATION

#ifdef FLOAT128

        /* This is the way the PowerPC specification defines it */

        float128 ft0_128, ft1_128;



        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);

        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);

        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);

        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&

                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {

            /* Magnitude subtraction of infinities */

            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);

        } else {

            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);

            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);

            farg1.d = float128_to_float64(ft0_128, &env->fp_status);

        }

#else

        /* This is OK on x86 hosts */

        farg1.d = (farg1.d * farg2.d) - farg3.d;

#endif

#else

        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);

        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);

#endif

        if (likely(!float64_is_nan(farg1.d)))

            farg1.d = float64_chs(farg1.d);

    }

    return farg1.ll;

}
",0
Detect whether the following code contains vulnerabilities.,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
",0
Detect whether the following code contains vulnerabilities.,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,

                uint32_t value)

{

    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;



    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);

}
",0
Detect whether the following code contains vulnerabilities.,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
",0
Detect whether the following code contains vulnerabilities.,"static void apply_tns_filter(float *out, float *in, int order, int direction,

                             float *tns_coefs, int ltp_used, int w, int filt,

                             int start_i, int len)

{

    int i, j, inc, start = start_i;

    float tmp[TNS_MAX_ORDER+1];

    if (direction) {

        inc = -1;

        start = (start + len) - 1;

    } else {

        inc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        for (i = 0; i < len; i++, start += inc)

            out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tns_coefs[j]*in[start - j*inc];

    } else {            /* MA filter */

        for (i = 0; i < len; i++, start += inc) {

            tmp[0] = out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tmp[j]*tns_coefs[j];

            for (j = order; j > 0; j--)

                tmp[j] = tmp[j - 1];

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",1
Detect whether the following code contains vulnerabilities.,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
",1
Detect whether the following code contains vulnerabilities.,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
",0
Detect whether the following code contains vulnerabilities.,"void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)

{

    switch(reg) {

    case 25:

        if (arg1 & 0xffffff00)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |

                     ((arg1 & 0x1) << 23);

        break;

    case 26:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);

        break;

    case 28:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |

                     ((arg1 & 0x4) << 22);

        break;

    case 31:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = arg1;

        break;

    default:

        return;

    }

    /* set rounding mode */

    restore_rounding_mode(env);

    /* set flush-to-zero mode */

    restore_flush_mode(env);

    set_float_exception_flags(0, &env->active_fpu.fp_status);

    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))

        do_raise_exception(env, EXCP_FPE, GETPC());

}
",0
Detect whether the following code contains vulnerabilities.,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;



    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);

    if (ret < 0 || io_header.driver_status || io_header.host_status) {

        return -1;

    }

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
",0
Detect whether the following code contains vulnerabilities.,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,

           u_int lport, int flags)

{

	struct sockaddr_in addr;

	struct socket *so;

	socklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;



	so = socreate(slirp);

	if (!so) {

	    return NULL;

	}

	so->s = socket(AF_INET,SOCK_DGRAM,0);

	so->so_expire = curtime + SO_EXPIRE;

	insque(so, &slirp->udb);



	addr.sin_family = AF_INET;

	addr.sin_addr.s_addr = haddr;

	addr.sin_port = hport;



	if (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {

		udp_detach(so);

		return NULL;

	}

	setsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));



	getsockname(so->s,(struct sockaddr *)&addr,&addrlen);

	so->so_fport = addr.sin_port;

	if (addr.sin_addr.s_addr == 0 ||

	    addr.sin_addr.s_addr == loopback_addr.s_addr) {

	   so->so_faddr = slirp->vhost_addr;

	} else {

	   so->so_faddr = addr.sin_addr;

	}

	so->so_lport = lport;

	so->so_laddr.s_addr = laddr;

	if (flags != SS_FACCEPTONCE)

	   so->so_expire = 0;



	so->so_state &= SS_PERSISTENT_MASK;

	so->so_state |= SS_ISFCONNECTED | flags;



	return so;

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)

{

    IRQMP      *irqmp = opaque;

    IRQMPState *state;



    assert(irqmp != NULL);

    state = irqmp->state;

    assert(state != NULL);



    addr &= 0xff;



    /* global registers */

    switch (addr) {

    case LEVEL_OFFSET:

        return state->level;



    case PENDING_OFFSET:

        return state->pending;



    case FORCE0_OFFSET:

        /* This register is an ""alias"" for the force register of CPU 0 */

        return state->force[0];



    case CLEAR_OFFSET:

    case MP_STATUS_OFFSET:

        /* Always read as 0 */

        return 0;



    case BROADCAST_OFFSET:

        return state->broadcast;



    default:

        break;

    }



    /* mask registers */

    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {

        int cpu = (addr - MASK_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->mask[cpu];

    }



    /* force registers */

    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {

        int cpu = (addr - FORCE_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->force[cpu];

    }



    /* extended (not supported) */

    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {

        int cpu = (addr - EXTENDED_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->extended[cpu];

    }



    trace_grlib_irqmp_unknown_register(""read"", addr);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)

{

    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {

        return;

    }

    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;



    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&

            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {

        if (s->stopped_state == sdhc_gap_read) {

            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;

            SDHCI_GET_CLASS(s)->read_block_from_card(s);

        } else {

            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;

            SDHCI_GET_CLASS(s)->write_block_to_card(s);

        }

        s->stopped_state = sdhc_not_stopped;

    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {

        if (s->prnsts & SDHC_DOING_READ) {

            s->stopped_state = sdhc_gap_read;

        } else if (s->prnsts & SDHC_DOING_WRITE) {

            s->stopped_state = sdhc_gap_write;

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int find_best(struct vf_instance *vf){

  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);

  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))

    return IMGFMT_YV12;

  else

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void idct_col(int16_t *blk, const uint8_t *quant)

{

    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * quant[0 * 8];

    s1 = (int) blk[1 * 8] * quant[1 * 8];

    s2 = (int) blk[2 * 8] * quant[2 * 8];

    s3 = (int) blk[3 * 8] * quant[3 * 8];

    s4 = (int) blk[4 * 8] * quant[4 * 8];

    s5 = (int) blk[5 * 8] * quant[5 * 8];

    s6 = (int) blk[6 * 8] * quant[6 * 8];

    s7 = (int) blk[7 * 8] * quant[7 * 8];



    t0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;

    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = t0 * 2 + t2;

    t5  = t1 * 2 + t3;

    t6  = t2 - t3;

    t7  = t3 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    tC  = (s0 >> 1) - (s4 >> 1);

    tD  = (s4 >> 1) * 2 + tC;

    tE  = tC - (tA >> 1);

    tF  = tD - (tB >> 1);

    t10 = tF - t5;

    t11 = tE - t8;

    t12 = tE + (tA >> 1) * 2 - t9;

    t13 = tF + (tB >> 1) * 2 - t4;



    blk[0 * 8] = t13 + t4 * 2;

    blk[1 * 8] = t12 + t9 * 2;

    blk[2 * 8] = t11 + t8 * 2;

    blk[3 * 8] = t10 + t5 * 2;

    blk[4 * 8] = t10;

    blk[5 * 8] = t11;

    blk[6 * 8] = t12;

    blk[7 * 8] = t13;

}
",1
Detect whether the following code contains vulnerabilities.,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",0
Detect whether the following code contains vulnerabilities.,"static void n8x0_nand_setup(struct n800_s *s)

{

    char *otp_region;

    DriveInfo *dinfo;



    s->nand = qdev_create(NULL, ""onenand"");

    qdev_prop_set_uint16(s->nand, ""manufacturer_id"", NAND_MFR_SAMSUNG);

    /* Either 0x40 or 0x48 are OK for the device ID */

    qdev_prop_set_uint16(s->nand, ""device_id"", 0x48);

    qdev_prop_set_uint16(s->nand, ""version_id"", 0);

    qdev_prop_set_int32(s->nand, ""shift"", 1);

    dinfo = drive_get(IF_MTD, 0, 0);

    if (dinfo) {

        qdev_prop_set_drive_nofail(s->nand, ""drive"",

                                   blk_bs(blk_by_legacy_dinfo(dinfo)));

    }

    qdev_init_nofail(s->nand);

    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,

                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));

    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,

                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));

    otp_region = onenand_raw_otp(s->nand);



    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));

    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));

    /* XXX: in theory should also update the OOB for both pages */

}
",0
Detect whether the following code contains vulnerabilities.,"void cpu_dump_state (CPUState *env, FILE *f, 

                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                     int flags)

{

    uint32_t c0_status;

    int i;

    

    cpu_fprintf(f, ""pc=0x"" TARGET_FMT_lx "" HI=0x"" TARGET_FMT_lx "" LO=0x"" TARGET_FMT_lx "" ds %04x "" TARGET_FMT_lx "" %d\n"",

                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);

    for (i = 0; i < 32; i++) {

        if ((i & 3) == 0)

            cpu_fprintf(f, ""GPR%02d:"", i);

        cpu_fprintf(f, "" %s "" TARGET_FMT_lx, regnames[i], env->gpr[i]);

        if ((i & 3) == 3)

            cpu_fprintf(f, ""\n"");

    }



    c0_status = env->CP0_Status;



    cpu_fprintf(f, ""CP0 Status  0x%08x Cause   0x%08x EPC    0x"" TARGET_FMT_lx ""\n"",

                c0_status, env->CP0_Cause, env->CP0_EPC);

    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",

                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);

    if (c0_status & (1 << CP0St_CU1))

        fpu_dump_state(env, f, cpu_fprintf, flags);

#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)

    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int rv40_decode_init(AVCodecContext *avctx)

{

    RV34DecContext *r = avctx->priv_data;



    r->rv30 = 0;

    ff_rv34_decode_init(avctx);

    if(!aic_top_vlc.bits)

        rv40_init_tables();

    r->parse_slice_header = rv40_parse_slice_header;

    r->decode_intra_types = rv40_decode_intra_types;

    r->decode_mb_info     = rv40_decode_mb_info;

    r->loop_filter        = rv40_loop_filter;

    r->luma_dc_quant_i = rv40_luma_dc_quant[0];

    r->luma_dc_quant_p = rv40_luma_dc_quant[1];

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",0
Detect whether the following code contains vulnerabilities.,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,

                                       int16_t *src2,

                                       int height, int denom, int wx0, int wx1,

                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)

{

    int x, y;

    pixel *src = (pixel *)_src;

    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);

    pixel *dst          = (pixel *)_dst;

    ptrdiff_t dststride = _dststride / sizeof(pixel);

    const int8_t *filter = ff_hevc_epel_filters[mx - 1];

    int shift = 14 + 1 - BIT_DEPTH;

    int log2Wd = denom + shift - 1;



    ox0     = ox0 * (1 << (BIT_DEPTH - 8));

    ox1     = ox1 * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {

        for (x = 0; x < width; x++)

            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +

                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));

        src  += srcstride;

        dst  += dststride;

        src2 += MAX_PB_SIZE;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void sdl2_gl_scanout(DisplayChangeListener *dcl,

                     uint32_t backing_id, bool backing_y_0_top,


                     uint32_t x, uint32_t y,

                     uint32_t w, uint32_t h)

{

    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);



    assert(scon->opengl);

    scon->x = x;

    scon->y = y;

    scon->w = w;

    scon->h = h;

    scon->tex_id = backing_id;

    scon->y0_top = backing_y_0_top;



    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);



    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {

        sdl2_set_scanout_mode(scon, false);

        return;

    }



    sdl2_set_scanout_mode(scon, true);

    if (!scon->fbo_id) {

        glGenFramebuffers(1, &scon->fbo_id);

    }



    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);

    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,

                              GL_TEXTURE_2D, scon->tex_id, 0);

}",1
Detect whether the following code contains vulnerabilities.,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",1
Detect whether the following code contains vulnerabilities.,"static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,

                            TCGMemOpIdx oi)

{

    TCGMemOp memop = get_memop(oi);

#ifdef CONFIG_SOFTMMU

    unsigned memi = get_mmuidx(oi);

    TCGReg addrz, param;

    tcg_insn_unit *func;

    tcg_insn_unit *label_ptr;



    addrz = tcg_out_tlb_load(s, addr, memi, memop,

                             offsetof(CPUTLBEntry, addr_write));



    /* The fast path is exactly one insn.  Thus we can perform the entire

       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */

    /* beq,a,pt %[xi]cc, label0 */

    label_ptr = s->code_ptr;

    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT

                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);

    /* delay slot */

    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,

                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);



    /* TLB Miss.  */



    param = TCG_REG_O1;

    if (!SPARC64 && TARGET_LONG_BITS == 64) {

        /* Skip the high-part; we'll perform the extract in the trampoline.  */

        param++;

    }

    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);

    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {

        /* Skip the high-part; we'll perform the extract in the trampoline.  */

        param++;

    }

    tcg_out_mov(s, TCG_TYPE_REG, param++, data);



    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];

    tcg_debug_assert(func != NULL);

    tcg_out_call_nodelay(s, func);

    /* delay slot */

    tcg_out_movi(s, TCG_TYPE_I32, param, oi);



    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));

#else

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);

        addr = TCG_REG_T1;

    }

    tcg_out_ldst_rr(s, data, addr,

                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),

                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);

#endif /* CONFIG_SOFTMMU */

}
",1
Detect whether the following code contains vulnerabilities.,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
",0
Detect whether the following code contains vulnerabilities.,"static void boston_lcd_event(void *opaque, int event)

{

    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"void add_command(const cmdinfo_t *ci)

{

    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));

    cmdtab[ncmds - 1] = *ci;

    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }



    /* TODO: do we need to loop? */

}
",1
Detect whether the following code contains vulnerabilities.,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",0
Detect whether the following code contains vulnerabilities.,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int ogg_get_length(AVFormatContext *s)

{

    struct ogg *ogg = s->priv_data;

    int i;

    int64_t size, end;

    int streams_left=0;



    if(!s->pb->seekable)

        return 0;



// already set

    if (s->duration != AV_NOPTS_VALUE)

        return 0;



    size = avio_size(s->pb);

    if(size < 0)

        return 0;

    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;



    ogg_save (s);

    avio_seek (s->pb, end, SEEK_SET);



    while (!ogg_read_page (s, &i)){

        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&

            ogg->streams[i].codec) {

            s->streams[i]->duration =

                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);

            if (s->streams[i]->start_time != AV_NOPTS_VALUE){

                s->streams[i]->duration -= s->streams[i]->start_time;

                streams_left-= (ogg->streams[i].got_start==-1);

                ogg->streams[i].got_start= 1;

            }else if(!ogg->streams[i].got_start){

                ogg->streams[i].got_start= -1;

                streams_left++;

            }

        }

    }



    ogg_restore (s, 0);



    ogg_save (s);

    avio_seek (s->pb, s->data_offset, SEEK_SET);

    ogg_reset(s);


    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {


        int64_t pts = ogg_calc_pts(s, i, NULL);

        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){

            s->streams[i]->duration -= pts;

            ogg->streams[i].got_start= 1;

            streams_left--;

        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){

            ogg->streams[i].got_start= 1;

            streams_left--;

        }

        }

            if(streams_left<=0)

                break;

    }

    ogg_restore (s, 0);



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
",1
Detect whether the following code contains vulnerabilities.,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, pkt);

}
",1
Detect whether the following code contains vulnerabilities.,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
",0
Detect whether the following code contains vulnerabilities.,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
",0
Detect whether the following code contains vulnerabilities.,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
",1
Detect whether the following code contains vulnerabilities.,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *s;

    int iomemtype;

    qemu_irq *qi;



    s = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    s->cpu_env = env;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, s);



    return qi;

}
",0
Detect whether the following code contains vulnerabilities.,"int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,

                 const char *name, VLANState *vlan)

{

    const char *sock;

    const char *group;

    int port, mode;



    sock  = qemu_opt_get(opts, ""sock"");

    group = qemu_opt_get(opts, ""group"");



    port = qemu_opt_get_number(opts, ""port"", 0);

    mode = qemu_opt_get_number(opts, ""mode"", 0700);



    if (net_vde_init(vlan, ""vde"", name, sock, port, group, mode) == -1) {

        return -1;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)

{

    int i = 0;

    while (ff_id3v2_extra_meta_funcs[i].tag3) {

        if (!memcmp(tag,

                    (isv34 ?

                        ff_id3v2_extra_meta_funcs[i].tag4 :

                        ff_id3v2_extra_meta_funcs[i].tag3),

                    (isv34 ? 4 : 3)))

            return &ff_id3v2_extra_meta_funcs[i];

        i++;

    }

    return NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"int av_buffersrc_add_ref(AVFilterContext *buffer_filter,

                         AVFilterBufferRef *picref, int flags)

{

    BufferSourceContext *c = buffer_filter->priv;

    AVFilterBufferRef *buf;

    int ret;



    if (!picref) {

        c->eof = 1;

        return 0;

    } else if (c->eof)

        return AVERROR(EINVAL);



    if (!av_fifo_space(c->fifo) &&

        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +

                                         sizeof(buf))) < 0)

        return ret;



    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {

        ret = check_format_change(buffer_filter, picref);

        if (ret < 0)

            return ret;

    }

    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)

        buf = picref;

    else

        buf = copy_buffer_ref(buffer_filter, picref);





    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {

        if (buf != picref)

            avfilter_unref_buffer(buf);

        return ret;

    }

    c->nb_failed_requests = 0;



    return 0;

}",1
Detect whether the following code contains vulnerabilities.,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
",0
Detect whether the following code contains vulnerabilities.,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
",0
Detect whether the following code contains vulnerabilities.,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)

{

    struct USBBtState *s = (struct USBBtState *) dev->opaque;

    int ret = 0;



    if (!s->config)

        goto fail;



    switch (p->pid) {

    case USB_TOKEN_IN:

        switch (p->devep & 0xf) {

        case USB_EVT_EP:

            ret = usb_bt_fifo_dequeue(&s->evt, p);

            break;



        case USB_ACL_EP:

            ret = usb_bt_fifo_dequeue(&s->acl, p);

            break;



        case USB_SCO_EP:

            ret = usb_bt_fifo_dequeue(&s->sco, p);

            break;



        default:

            goto fail;

        }

        break;



    case USB_TOKEN_OUT:

        switch (p->devep & 0xf) {

        case USB_ACL_EP:

            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,

                            usb_bt_hci_acl_complete, p->data, p->len);

            break;



        case USB_SCO_EP:

            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,

                            usb_bt_hci_sco_complete, p->data, p->len);

            break;



        default:

            goto fail;

        }

        break;



    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }



    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,

                                            sPAPREnvironment *spapr,

                                            uint32_t token, uint32_t nargs,

                                            target_ulong args, uint32_t nret,

                                            target_ulong rets)

{

    sPAPRPHBState *sphb;

    sPAPRPHBClass *spc;

    uint64_t buid;

    int state, ret;



    if ((nargs != 3) || (nret != 4 && nret != 5)) {

        goto param_error_exit;

    }



    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);

    sphb = find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);

    if (!spc->eeh_get_state) {

        goto param_error_exit;

    }



    ret = spc->eeh_get_state(sphb, &state);

    rtas_st(rets, 0, ret);

    if (ret != RTAS_OUT_SUCCESS) {

        return;

    }



    rtas_st(rets, 1, state);

    rtas_st(rets, 2, RTAS_EEH_SUPPORT);

    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);

    if (nret >= 5) {

        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);

    }

    return;



param_error_exit:

    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);

}
",0
Detect whether the following code contains vulnerabilities.,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(value);

}
",0
Detect whether the following code contains vulnerabilities.,"int path_is_absolute(const char *path)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"opts_end_struct(Visitor *v, Error **errp)

{

    OptsVisitor *ov = to_ov(v);

    GHashTableIter iter;

    GQueue *any;



    if (--ov->depth > 0) {

        return;

    }



    /* we should have processed all (distinct) QemuOpt instances */

    g_hash_table_iter_init(&iter, ov->unprocessed_opts);

    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {

        const QemuOpt *first;



        first = g_queue_peek_head(any);

        error_setg(errp, QERR_INVALID_PARAMETER, first->name);

    }

    g_hash_table_destroy(ov->unprocessed_opts);

    ov->unprocessed_opts = NULL;

    if (ov->fake_id_opt) {

        g_free(ov->fake_id_opt->name);

        g_free(ov->fake_id_opt->str);

        g_free(ov->fake_id_opt);

    }

    ov->fake_id_opt = NULL;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
",0
Detect whether the following code contains vulnerabilities.,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddressLegacy *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",0
Detect whether the following code contains vulnerabilities.,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,

                                           const char *name)

{

    const QObject *qobj;



    if (qiv->nb_stack == 0) {

        qobj = qiv->obj;

    } else {

        qobj = qiv->stack[qiv->nb_stack - 1].obj;

    }



    if (name && qobject_type(qobj) == QTYPE_QDICT) {

        return qdict_get(qobject_to_qdict(qobj), name);

    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {

        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);

    }



    return qobj;

}
",1
Detect whether the following code contains vulnerabilities.,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
",1
Detect whether the following code contains vulnerabilities.,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static int vpc_write(BlockDriverState *bs, int64_t sector_num,

    const uint8_t *buf, int nb_sectors)

{

    BDRVVPCState *s = bs->opaque;

    int64_t offset;

    int64_t sectors, sectors_per_block;

    int ret;

    VHDFooter *footer =  (VHDFooter *) s->footer_buf;



    if (cpu_to_be32(footer->type) == VHD_FIXED) {

        return bdrv_write(bs->file, sector_num, buf, nb_sectors);

    }

    while (nb_sectors > 0) {

        offset = get_sector_offset(bs, sector_num, 1);



        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;

        sectors = sectors_per_block - (sector_num % sectors_per_block);

        if (sectors > nb_sectors) {

            sectors = nb_sectors;

        }



        if (offset == -1) {

            offset = alloc_block(bs, sector_num);

            if (offset < 0)

                return -1;

        }



        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);

        if (ret != sectors * BDRV_SECTOR_SIZE) {

            return -1;

        }



        nb_sectors -= sectors;

        sector_num += sectors;

        buf += sectors * BDRV_SECTOR_SIZE;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int read_old_huffman_tables(HYuvContext *s){

#if 1

    GetBitContext gb;

    int i;



    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);

    if(read_len_table(s->len[0], &gb)<0)

        return -1;

    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);

    if(read_len_table(s->len[1], &gb)<0)

        return -1;



    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];

    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];



    if(s->bitstream_bpp >= 24){

        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));

        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));

    }

    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));

    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));



    for(i=0; i<3; i++){

        ff_free_vlc(&s->vlc[i]);

        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);

    }



    generate_joint_tables(s);



    return 0;

#else

    av_log(s->avctx, AV_LOG_DEBUG, ""v1 huffyuv is not supported \n"");

    return -1;

#endif

}
",1
Detect whether the following code contains vulnerabilities.,"exynos4_boards_init_common(MachineState *machine,

                           Exynos4BoardType board_type)

{

    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);

    MachineClass *mc = MACHINE_GET_CLASS(machine);



    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {

        error_report(""%s board supports only %d CPU cores, ignoring smp_cpus""

                     "" value"",

                     mc->name, EXYNOS4210_NCPUS);

    }



    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];

    exynos4_board_binfo.board_id = exynos4_board_id[board_type];

    exynos4_board_binfo.smp_bootreg_addr =

            exynos4_board_smp_bootreg_addr[board_type];

    exynos4_board_binfo.kernel_filename = machine->kernel_filename;

    exynos4_board_binfo.initrd_filename = machine->initrd_filename;

    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;

    exynos4_board_binfo.gic_cpu_if_addr =

            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;



    PRINT_DEBUG(""\n ram_size: %luMiB [0x%08lx]\n""

            "" kernel_filename: %s\n""

            "" kernel_cmdline: %s\n""

            "" initrd_filename: %s\n"",

            exynos4_board_ram_size[board_type] / 1048576,

            exynos4_board_ram_size[board_type],

            machine->kernel_filename,

            machine->kernel_cmdline,

            machine->initrd_filename);



    exynos4_boards_init_ram(s, get_system_memory(),

                            exynos4_board_ram_size[board_type]);



    s->soc = exynos4210_init(get_system_memory());



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static void json_print_section_header(WriterContext *wctx)

{

    JSONContext *json = wctx->priv;

    AVBPrint buf;

    const struct section *section = wctx->section[wctx->level];

    const struct section *parent_section = wctx->level ?

        wctx->section[wctx->level-1] : NULL;



    if (wctx->level && wctx->nb_item[wctx->level-1])

        printf("",\n"");



    if (section->flags & SECTION_FLAG_IS_WRAPPER) {

        printf(""{\n"");

        json->indent_level++;

    } else {

        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);

        json_escape_str(&buf, section->name, wctx);

        JSON_INDENT();



        json->indent_level++;

        if (section->flags & SECTION_FLAG_IS_ARRAY) {

            printf(""\""%s\"": [\n"", buf.str);

        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {

            printf(""\""%s\"": {%s"", buf.str, json->item_start_end);

        } else {

            printf(""{%s"", json->item_start_end);



            /* this is required so the parser can distinguish between packets and frames */

            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {

                if (!json->compact)

                    JSON_INDENT();

                printf(""\""type\"": \""%s\""%s"", section->name, json->item_sep);

            }

        }

        av_bprint_finalize(&buf, NULL);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
",1
Detect whether the following code contains vulnerabilities.,"static void test_dma_fragmented(void)

{

    AHCIQState *ahci;

    AHCICommand *cmd;

    uint8_t px;

    size_t bufsize = 4096;

    unsigned char *tx = g_malloc(bufsize);

    unsigned char *rx = g_malloc0(bufsize);

    uint64_t ptr;



    ahci = ahci_boot_and_enable(NULL);

    px = ahci_port_select(ahci);

    ahci_port_clear(ahci, px);



    /* create pattern */

    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);



    /* Create a DMA buffer in guest memory, and write our pattern to it. */

    ptr = guest_alloc(ahci->parent->alloc, bufsize);

    g_assert(ptr);

    bufwrite(ptr, tx, bufsize);



    cmd = ahci_command_create(CMD_WRITE_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd);

    ahci_command_verify(ahci, cmd);

    g_free(cmd);



    cmd = ahci_command_create(CMD_READ_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd);

    ahci_command_verify(ahci, cmd);

    g_free(cmd);



    /* Read back the guest's receive buffer into local memory */

    bufread(ptr, rx, bufsize);

    guest_free(ahci->parent->alloc, ptr);



    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);



    ahci_shutdown(ahci);



    g_free(rx);

    g_free(tx);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
",1
Detect whether the following code contains vulnerabilities.,"static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    int64_t size;

    AVIOContext *pb  = s->pb;

    WAVContext    *wav = s->priv_data;

    AVStream *st;

    uint8_t guid[16];



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_riff, 16))

        return -1;



    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */

        return -1;



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_wave, 16)) {

        av_log(s, AV_LOG_ERROR, ""could not find wave guid\n"");

        return -1;

    }



    size = find_guid(pb, guid_fmt);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find fmt guid\n"");

        return -1;

    }



    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);



    /* subtract chunk header size - normal wav file doesn't count it */

    ff_get_wav_header(pb, st->codec, size - 24);

    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);



    st->need_parsing = AVSTREAM_PARSE_FULL;



    av_set_pts_info(st, 64, 1, st->codec->sample_rate);



    size = find_guid(pb, guid_data);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find data guid\n"");

        return -1;

    }

    wav->data_end = avio_tell(pb) + size - 24;

    wav->w64      = 1;



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",1
Detect whether the following code contains vulnerabilities.,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",1
Detect whether the following code contains vulnerabilities.,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
",0
Detect whether the following code contains vulnerabilities.,"static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
",0
Detect whether the following code contains vulnerabilities.,"static int discard_f(BlockBackend *blk, int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, qflag = 0;

    int c, ret;

    int64_t offset, count;



    while ((c = getopt(argc, argv, ""Cq"")) != -1) {

        switch (c) {

        case 'C':

            Cflag = 1;

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return qemuio_command_usage(&discard_cmd);

        }

    }



    if (optind != argc - 2) {

        return qemuio_command_usage(&discard_cmd);

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        print_cvtnum_err(offset, argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        print_cvtnum_err(count, argv[optind]);

        return 0;

    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {

        printf(""length cannot exceed %""PRIu64"", given %s\n"",

               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,

               argv[optind]);

        return 0;

    }



    gettimeofday(&t1, NULL);

    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,

                      count >> BDRV_SECTOR_BITS);

    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""discard failed: %s\n"", strerror(-ret));

        goto out;

    }



    /* Finally, report back -- -C gives a parsable format */

    if (!qflag) {

        t2 = tsub(t2, t1);

        print_report(""discard"", &t2, offset, count, count, 1, Cflag);

    }



out:

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
",0
Detect whether the following code contains vulnerabilities.,"static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *addr;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {

        return;

    }



    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
",0
Detect whether the following code contains vulnerabilities.,"static int v9fs_synth_lstat(FsContext *fs_ctx,

                            V9fsPath *fs_path, struct stat *stbuf)

{

    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(node, stbuf);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}",1
Detect whether the following code contains vulnerabilities.,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)

{

    int resx = page->columns * BITMAP_CHAR_WIDTH;

    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;

    uint8_t ci, cmax = 0;

    int ret;

    vbi_char *vc = page->text + (chop_top * page->columns);

    vbi_char *vcend = page->text + (page->rows * page->columns);



    for (; vc < vcend; vc++) {

        if (vc->opacity != VBI_TRANSPARENT_SPACE) {

            cmax = VBI_NB_COLORS;

            break;

        }

    }



    if (cmax == 0) {

        av_log(ctx, AV_LOG_DEBUG, ""dropping empty page %3x\n"", page->pgno);

        sub_rect->type = SUBTITLE_NONE;

        return 0;

    }



    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)

        return ret;

    // Yes, we want to allocate the palette on our own because AVSubtitle works this way

    sub_rect->pict.data[1] = NULL;



    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,

                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],

                            0, chop_top, page->columns, page->rows - chop_top,

                            /*reveal*/ 1, /*flash*/ 1);



    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);

    sub_rect->x = ctx->x_offset;

    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;

    sub_rect->w = resx;

    sub_rect->h = resy;

    sub_rect->nb_colors = (int)cmax + 1;

    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);

    if (!sub_rect->pict.data[1]) {

        av_freep(&sub_rect->pict.data[0]);

        return AVERROR(ENOMEM);

    }

    for (ci = 0; ci < cmax; ci++) {

        int r, g, b, a;



        r = VBI_R(page->color_map[ci]);

        g = VBI_G(page->color_map[ci]);

        b = VBI_B(page->color_map[ci]);

        a = VBI_A(page->color_map[ci]);

        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);

        av_dlog(ctx, ""palette %0x\n"", ((uint32_t *)sub_rect->pict.data[1])[ci]);

    }

    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);

    sub_rect->type = SUBTITLE_BITMAP;

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int opt_default(const char *opt, const char *arg)

{

    const AVOption *oc, *of, *os, *oswr;

    char opt_stripped[128];

    const char *p;

    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;



    if (!(p = strchr(opt, ':')))

        p = opt + strlen(opt);

    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));



    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,

                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||

        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&

         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))

        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));

    if ((of = av_opt_find(&fc, opt, NULL, 0,

                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))

        av_dict_set(&format_opts, opt, arg, FLAGS(of));

#if CONFIG_SWSCALE

    sc = sws_get_class();

    if ((os = av_opt_find(&sc, opt, NULL, 0,

                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {

        // XXX we only support sws_flags, not arbitrary sws options

        int ret = av_opt_set(sws_opts, opt, arg, 0);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Error setting option %s.\n"", opt);

            return ret;

        }

    }

#endif

    swr_class = swr_get_class();

    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,

                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {

        int ret = av_opt_set(swr_opts, opt, arg, 0);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Error setting option %s.\n"", opt);

            return ret;

        }

    }



    if (oc || of || os || oswr)

        return 0;

    av_log(NULL, AV_LOG_ERROR, ""Unrecognized option '%s'\n"", opt);

    return AVERROR_OPTION_NOT_FOUND;

}
",1
Detect whether the following code contains vulnerabilities.,"static void slavio_misc_init(target_phys_addr_t base,

                             target_phys_addr_t aux1_base,

                             target_phys_addr_t aux2_base, qemu_irq irq,

                             qemu_irq fdc_tc)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""slavio_misc"");

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    if (base) {

        /* 8 bit registers */

        /* Slavio control */

        sysbus_mmio_map(s, 0, base + MISC_CFG);

        /* Diagnostics */

        sysbus_mmio_map(s, 1, base + MISC_DIAG);

        /* Modem control */

        sysbus_mmio_map(s, 2, base + MISC_MDM);

        /* 16 bit registers */

        /* ss600mp diag LEDs */

        sysbus_mmio_map(s, 3, base + MISC_LEDS);

        /* 32 bit registers */

        /* System control */

        sysbus_mmio_map(s, 4, base + MISC_SYS);

    }

    if (aux1_base) {

        /* AUX 1 (Misc System Functions) */

        sysbus_mmio_map(s, 5, aux1_base);

    }

    if (aux2_base) {

        /* AUX 2 (Software Powerdown Control) */

        sysbus_mmio_map(s, 6, aux2_base);

    }

    sysbus_connect_irq(s, 0, irq);

    sysbus_connect_irq(s, 1, fdc_tc);

    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);

}
",1
Detect whether the following code contains vulnerabilities.,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,

        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){

    soxr_error_t error;



    soxr_datatype_t type =

        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :

        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :

        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :

        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :

        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :

        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :

        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :

        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;



    soxr_io_spec_t io_spec = soxr_io_spec(type, type);



    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);

    q_spec.precision = linear? 0 : precision;

#if !defined SOXR_VERSION /* Deprecated @ March 2013: */

    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;

#else

    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;

#endif



    soxr_delete((soxr_t)c);

    c = (struct ResampleContext *)

        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);

    if (!c)

        av_log(NULL, AV_LOG_ERROR, ""soxr_create: %s\n"", error);

    return c;

}
",1
Detect whether the following code contains vulnerabilities.,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
",0
Detect whether the following code contains vulnerabilities.,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
",0
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)

{

    CharDriverState *chr;

    PtyCharDriver *s;

    struct termios tty;

    int master_fd, slave_fd, len;

#if defined(__OpenBSD__) || defined(__DragonFly__)

    char pty_name[PATH_MAX];

#define q_ptsname(x) pty_name

#else

    char *pty_name = NULL;

#define q_ptsname(x) ptsname(x)

#endif



    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {

        return NULL;

    }



    /* Set raw attributes on the pty. */

    tcgetattr(slave_fd, &tty);

    cfmakeraw(&tty);

    tcsetattr(slave_fd, TCSAFLUSH, &tty);

    close(slave_fd);



    chr = g_malloc0(sizeof(CharDriverState));



    len = strlen(q_ptsname(master_fd)) + 5;

    chr->filename = g_malloc(len);

    snprintf(chr->filename, len, ""pty:%s"", q_ptsname(master_fd));

    qemu_opt_set(opts, ""path"", q_ptsname(master_fd));

    fprintf(stderr, ""char device redirected to %s\n"", q_ptsname(master_fd));



    s = g_malloc0(sizeof(PtyCharDriver));

    chr->opaque = s;

    chr->chr_write = pty_chr_write;

    chr->chr_update_read_handler = pty_chr_update_read_handler;

    chr->chr_close = pty_chr_close;



    s->fd = master_fd;

    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);



    return chr;

}
",1
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,

                      uint64_t cpu_addr)

{

    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;



    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",

               __func__, order_code, r1, cpu_addr);



    /* Remember: Use ""R1 or R1 + 1, whichever is the odd-numbered register""

       as parameter (input). Status (output) is always R1. */



    switch (order_code) {

    case SIGP_SET_ARCH:

        /* switch arch */

        break;

    case SIGP_SENSE:

        /* enumerate CPU status */

        if (cpu_addr) {

            /* XXX implement when SMP comes */

            return 3;

        }

        env->regs[r1] &= 0xffffffff00000000ULL;

        cc = 1;

        break;

#if !defined(CONFIG_USER_ONLY)

    case SIGP_RESTART:

        qemu_system_reset_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

    case SIGP_STOP:

        qemu_system_shutdown_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

#endif

    default:

        /* unknown sigp */

        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);

        cc = SIGP_CC_NOT_OPERATIONAL;

    }



    return cc;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,

                void *src)

{

    int result = 0;



    if (secn > 0) {

        uint32_t size = (uint32_t)secn * 512;

        const uint8_t *sp = (const uint8_t *)src;

        uint8_t *dp = 0;

        if (s->bdrv_cur) {

            dp = g_malloc(size);

            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {

                result = 1;

            }

        } else {

            if (sec + secn > s->secs_cur) {

                result = 1;

            } else {

                dp = (uint8_t *)s->current + (sec << 9);

            }

        }

        if (!result) {

            uint32_t i;

            for (i = 0; i < size; i++) {

                dp[i] &= sp[i];

            }

            if (s->bdrv_cur) {

                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;

            }

        }

        if (dp && s->bdrv_cur) {

            g_free(dp);

        }

    }



    return result;

}
",0
Detect whether the following code contains vulnerabilities.,"static int hwupload_query_formats(AVFilterContext *avctx)

{

    HWUploadContext *ctx = avctx->priv;

    AVHWFramesConstraints *constraints = NULL;

    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;

    AVFilterFormats *input_formats = NULL;

    int err, i;



    if (!avctx->hw_device_ctx) {

        av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required ""

               ""to upload frames to.\n"");

        return AVERROR(EINVAL);

    }



    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);

    if (!ctx->hwdevice_ref)

        return AVERROR(ENOMEM);

    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;



    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);

    if (!constraints) {

        err = AVERROR(EINVAL);

        goto fail;

    }



    input_pix_fmts  = constraints->valid_sw_formats;

    output_pix_fmts = constraints->valid_hw_formats;



    input_formats = ff_make_format_list(output_pix_fmts);

    if (!input_formats) {

        err = AVERROR(ENOMEM);

        goto fail;

    }

    if (input_pix_fmts) {

        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {

            err = ff_add_format(&input_formats, input_pix_fmts[i]);

            if (err < 0) {

                ff_formats_unref(&input_formats);

                goto fail;

            }

        }

    }



    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);



    ff_formats_ref(ff_make_format_list(output_pix_fmts),

                   &avctx->outputs[0]->in_formats);



    av_hwframe_constraints_free(&constraints);

    return 0;



fail:

    av_buffer_unref(&ctx->hwdevice_ref);

    av_hwframe_constraints_free(&constraints);

    return err;

}
",1
Detect whether the following code contains vulnerabilities.,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
",1
Detect whether the following code contains vulnerabilities.,"int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)

{

    int size, l;



    if (f->is_write)

        abort();



    size = size1;

    while (size > 0) {

        l = f->buf_size - f->buf_index;

        if (l == 0) {

            qemu_fill_buffer(f);

            l = f->buf_size - f->buf_index;

            if (l == 0)

                break;

        }

        if (l > size)

            l = size;

        memcpy(buf, f->buf + f->buf_index, l);

        f->buf_index += l;

        buf += l;

        size -= l;

    }

    return size1 - size;

}
",0
Detect whether the following code contains vulnerabilities.,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
",0
Detect whether the following code contains vulnerabilities.,"static void *do_data_decompress(void *opaque)

{

    DecompressParam *param = opaque;

    unsigned long pagesize;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&param->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&param->cond, &param->mutex);

        }

        if (!quit_decomp_thread) {

            pagesize = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)param->des, &pagesize,

                       (const Bytef *)param->compbuf, param->len);

        }

        param->start = false;

        qemu_mutex_unlock(&param->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        param->done = true;

        qemu_cond_signal(&decomp_done_cond);

        qemu_mutex_unlock(&decomp_done_lock);

    }



    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
",0
Detect whether the following code contains vulnerabilities.,"int vnc_hextile_send_framebuffer_update(VncState *vs, int x,

                                        int y, int w, int h)

{

    int i, j;

    int has_fg, has_bg;

    uint8_t *last_fg, *last_bg;

    VncDisplay *vd = vs->vd;



    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);

    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);

    has_fg = has_bg = 0;

    for (j = y; j < (y + h); j += 16) {

        for (i = x; i < (x + w); i += 16) {

            vs->send_hextile_tile(vs, i, j,

                                  MIN(16, x + w - i), MIN(16, y + h - j),

                                  last_bg, last_fg, &has_bg, &has_fg);

        }

    }

    free(last_fg);

    free(last_bg);



    return 1;

}
",0
Detect whether the following code contains vulnerabilities.,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",0
Detect whether the following code contains vulnerabilities.,"static int kvmppc_get_books_sregs(PowerPCCPU *cpu)

{

    CPUPPCState *env = &cpu->env;

    struct kvm_sregs sregs;

    int ret;

    int i;



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);

    if (ret < 0) {

        return ret;

    }



    if (!env->external_htab) {

        ppc_store_sdr1(env, sregs.u.s.sdr1);

    }



    /* Sync SLB */

#ifdef TARGET_PPC64

    /*

     * The packed SLB array we get from KVM_GET_SREGS only contains

     * information about valid entries. So we flush our internal copy

     * to get rid of stale ones, then put all valid SLB entries back

     * in.

     */

    memset(env->slb, 0, sizeof(env->slb));

    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {

        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;

        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;

        /*

         * Only restore valid entries

         */

        if (rb & SLB_ESID_V) {

            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);

        }

    }

#endif



    /* Sync SRs */

    for (i = 0; i < 16; i++) {

        env->sr[i] = sregs.u.s.ppc32.sr[i];

    }



    /* Sync BATs */

    for (i = 0; i < 8; i++) {

        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;

        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;

        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;

        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;

    }



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void hmp_cont(Monitor *mon, const QDict *qdict)

{

    BlockInfoList *bdev_list, *bdev;

    Error *err = NULL;



    bdev_list = qmp_query_block(NULL);

    for (bdev = bdev_list; bdev; bdev = bdev->next) {

        if (key_is_missing(bdev->value)) {

            monitor_read_block_device_key(mon, bdev->value->device,

                                          hmp_cont_cb, NULL);

            goto out;

        }

    }



    qmp_cont(&err);

    hmp_handle_error(mon, &err);



out:

    qapi_free_BlockInfoList(bdev_list);

}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
",1
Detect whether the following code contains vulnerabilities.,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",1
Detect whether the following code contains vulnerabilities.,"static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    const char *protocol  = qdict_get_str(qdict, ""protocol"");

    const char *fdname = qdict_get_str(qdict, ""fdname"");

    CharDriverState *s;



    if (strcmp(protocol, ""spice"") == 0) {

        int fd = monitor_get_fd(mon, fdname, NULL);

        int skipauth = qdict_get_try_bool(qdict, ""skipauth"", 0);

        int tls = qdict_get_try_bool(qdict, ""tls"", 0);

        if (!using_spice) {

            /* correct one? spice isn't a device ,,, */

            qerror_report(QERR_DEVICE_NOT_ACTIVE, ""spice"");

            return -1;

        }

        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {

            close(fd);

        }

        return 0;

#ifdef CONFIG_VNC

    } else if (strcmp(protocol, ""vnc"") == 0) {

	int fd = monitor_get_fd(mon, fdname, NULL);

        int skipauth = qdict_get_try_bool(qdict, ""skipauth"", 0);

	vnc_display_add_client(NULL, fd, skipauth);

	return 0;

#endif

    } else if ((s = qemu_chr_find(protocol)) != NULL) {

	int fd = monitor_get_fd(mon, fdname, NULL);

	if (qemu_chr_add_client(s, fd) < 0) {

	    qerror_report(QERR_ADD_CLIENT_FAILED);

	    return -1;

	}

	return 0;

    }



    qerror_report(QERR_INVALID_PARAMETER, ""protocol"");

    return -1;

}
",1
Detect whether the following code contains vulnerabilities.,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pm_update_sci(VT686PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0);

    qemu_set_irq(s->dev.irq[0], sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
",1
Detect whether the following code contains vulnerabilities.,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= -1;

    h->prev_frame_num_offset= 0;

    h->prev_poc_msb= 1<<16;

    h->prev_poc_lsb= 0;

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)

        h->last_pocs[i] = INT_MIN;

}
",0
Detect whether the following code contains vulnerabilities.,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
",0
Detect whether the following code contains vulnerabilities.,"static void abort_codec_experimental(AVCodec *c, int encoder)

{

    const char *codec_string = encoder ? ""encoder"" : ""decoder"";

    AVCodec *codec;

    av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""

            ""results.\nAdd '-strict experimental' if you want to use it.\n"",

            codec_string, c->name);

    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);

    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))

        av_log(NULL, AV_LOG_FATAL, ""Or use the non experimental %s '%s'.\n"",

               codec_string, codec->name);

    exit(1);

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",1
Detect whether the following code contains vulnerabilities.,"static int standard_decode_i_mbs(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    MpegEncContext *s = &v->s;

    int current_mb = 0; /* MB/Block Position info */

    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,

        *p_cbpcy /* Pointer to skip some math */;



    /* Reset CBPCY predictors */

    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);



    /* Select ttmb table depending on pq */

    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];

    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];

    else v->ttmb_vlc = &vc9_ttmb_vlc[2];



    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)

    {

        /* Init CBPCY for line */

        *((uint32_t*)previous_cbpcy) = 0x00000000;

        p_cbpcy = v->previous_line_cbpcy+4;



        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)

        {

            /* Get CBPCY */

            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);



            s->ac_pred = get_bits(gb, 1);



            /* TODO: Decode blocks from that mb wrt cbpcy */



            /* Update for next block */

#if TRACE > 2

            av_log(s->avctx, AV_LOG_DEBUG, ""Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,""

                   "" cbpcy=%i%i%i%i\n"", current_mb,

                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],

                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],

                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);

#endif

            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);

            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);

            current_mb++;

        }

    }

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, s);



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)

{

        struct fs_dma_ctrl *ctrl = opaque;

	int c;

	uint32_t r = 0;



	if (size != 4) {

		dma_rinvalid(opaque, addr);

	}



	/* Make addr relative to this channel and bounded to nr regs.  */

	c = fs_channel(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)

	{

		case RW_STAT:

			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;



		default:

			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				  __func__, c, addr));

			break;

	}

	return r;

}
",0
Detect whether the following code contains vulnerabilities.,"static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)

{

    struct pxa_frame_descriptor_s desc;

    target_phys_addr_t descptr;

    int i;



    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {

        s->dma_ch[i].source = 0;



        if (!s->dma_ch[i].up)

            continue;



        if (s->dma_ch[i].branch & FBR_BRA) {

            descptr = s->dma_ch[i].branch & FBR_SRCADDR;

            if (s->dma_ch[i].branch & FBR_BINT)

                pxa2xx_dma_bs_set(s, i);

            s->dma_ch[i].branch &= ~FBR_BRA;

        } else

            descptr = s->dma_ch[i].descriptor;



        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +

                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))

            continue;



        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));

        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);

        s->dma_ch[i].source = tswap32(desc.fsaddr);

        s->dma_ch[i].id = tswap32(desc.fidr);

        s->dma_ch[i].command = tswap32(desc.ldcmd);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"void ppc_tlb_invalidate_all(CPUPPCState *env)

{

    switch (env->mmu_model) {

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

        ppc6xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_SOFT_4xx_Z:

        ppc4xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_REAL:

        cpu_abort(env, ""No TLB for PowerPC 4xx in real mode\n"");

        break;

    case POWERPC_MMU_MPC8xx:

        /* XXX: TODO */

        cpu_abort(env, ""MPC8xx MMU model is not implemented\n"");

        break;

    case POWERPC_MMU_BOOKE:

        tlb_flush(env, 1);

        break;

    case POWERPC_MMU_BOOKE206:

        booke206_flush_tlb(env, -1, 0);

        break;

    case POWERPC_MMU_32B:

    case POWERPC_MMU_601:

#if defined(TARGET_PPC64)

    case POWERPC_MMU_620:

    case POWERPC_MMU_64B:

    case POWERPC_MMU_2_06:


#endif /* defined(TARGET_PPC64) */

        tlb_flush(env, 1);

        break;

    default:

        /* XXX: TODO */

        cpu_abort(env, ""Unknown MMU model\n"");

        break;

    }

}",1
Detect whether the following code contains vulnerabilities.,"uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)

{

    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);



    return set_cc_nz_f32(env->fregs[f1].l.upper);

}
",0
Detect whether the following code contains vulnerabilities.,"int cksum(struct mbuf *m, int len)

{

	register uint16_t *w;

	register int sum = 0;

	register int mlen = 0;

	int byte_swapped = 0;



	union {

		uint8_t  c[2];

		uint16_t s;

	} s_util;

	union {

		uint16_t s[2];

		uint32_t l;

	} l_util;



	if (m->m_len == 0)

	   goto cont;

	w = mtod(m, uint16_t *);



	mlen = m->m_len;



	if (len < mlen)

	   mlen = len;

#ifdef DEBUG

	len -= mlen;

#endif

	/*

	 * Force to even boundary.

	 */

	if ((1 & (long) w) && (mlen > 0)) {

		REDUCE;

		sum <<= 8;

		s_util.c[0] = *(uint8_t *)w;

		w = (uint16_t *)((int8_t *)w + 1);

		mlen--;

		byte_swapped = 1;

	}

	/*

	 * Unroll the loop to make overhead from

	 * branches &c small.

	 */

	while ((mlen -= 32) >= 0) {

		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];

		sum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];

		sum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];

		sum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];

		w += 16;

	}

	mlen += 32;

	while ((mlen -= 8) >= 0) {

		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];

		w += 4;

	}

	mlen += 8;

	if (mlen == 0 && byte_swapped == 0)

	   goto cont;

	REDUCE;

	while ((mlen -= 2) >= 0) {

		sum += *w++;

	}



	if (byte_swapped) {

		REDUCE;

		sum <<= 8;

		if (mlen == -1) {

			s_util.c[1] = *(uint8_t *)w;

			sum += s_util.s;

			mlen = 0;

		} else



		   mlen = -1;

	} else if (mlen == -1)

	   s_util.c[0] = *(uint8_t *)w;



cont:

#ifdef DEBUG

	if (len) {

		DEBUG_ERROR((dfd, ""cksum: out of data\n""));

		DEBUG_ERROR((dfd, "" len = %d\n"", len));

	}

#endif

	if (mlen == -1) {

		/* The last mbuf has odd # of bytes. Follow the

		 standard (the odd byte may be shifted left by 8 bits

			   or not as determined by endian-ness of the machine) */

		s_util.c[1] = 0;

		sum += s_util.s;

	}

	REDUCE;

	return (~sum & 0xffff);

}
",0
Detect whether the following code contains vulnerabilities.,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
",1
Detect whether the following code contains vulnerabilities.,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
",0
Detect whether the following code contains vulnerabilities.,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
",0
Detect whether the following code contains vulnerabilities.,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
",0
Detect whether the following code contains vulnerabilities.,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
",1
Detect whether the following code contains vulnerabilities.,"static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)

{

    AVStream *st = s->streams[stream_index];

    int64_t seconds;

    MXFContext* mxf = s->priv_data;

    int64_t seekpos;

    int ret;

    MXFIndexTable *t;



    if (mxf->nb_index_tables <= 0) {

    if (!s->bit_rate)

        return AVERROR_INVALIDDATA;

    if (sample_time < 0)

        sample_time = 0;

    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);



    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)

        return ret;

    ff_update_cur_dts(s, st, sample_time);

    mxf->current_edit_unit = sample_time;

    } else {

        t = &mxf->index_tables[0];



        /* clamp above zero, else ff_index_search_timestamp() returns negative

         * this also means we allow seeking before the start */

        sample_time = FFMAX(sample_time, 0);



        if (t->fake_index) {

            /* behave as if we have a proper index */

            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)

                return sample_time;

        } else {

            /* no IndexEntryArray (one or more CBR segments)

             * make sure we don't seek past the end */

            sample_time = FFMIN(sample_time, st->duration - 1);

        }



        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)

            return ret;



        ff_update_cur_dts(s, st, sample_time);

        mxf->current_edit_unit = sample_time;

        avio_seek(s->pb, seekpos, SEEK_SET);

    }

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"if_start(Slirp *slirp)

{

    uint64_t now = qemu_get_clock_ns(rt_clock);

    int requeued = 0;

	struct mbuf *ifm, *ifqt;



	DEBUG_CALL(""if_start"");



	if (slirp->if_queued == 0)

	   return; /* Nothing to do */



 again:

        /* check if we can really output */

        if (!slirp_can_output(slirp->opaque))

            return;



	/*

	 * See which queue to get next packet from

	 * If there's something in the fastq, select it immediately

	 */

	if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {

		ifm = slirp->if_fastq.ifq_next;

	} else {

		/* Nothing on fastq, see if next_m is valid */

		if (slirp->next_m != &slirp->if_batchq)

		   ifm = slirp->next_m;

		else

		   ifm = slirp->if_batchq.ifq_next;



		/* Set which packet to send on next iteration */

		slirp->next_m = ifm->ifq_next;

	}

	/* Remove it from the queue */

	ifqt = ifm->ifq_prev;

	remque(ifm);

	slirp->if_queued--;



	/* If there are more packets for this session, re-queue them */

	if (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {

		insque(ifm->ifs_next, ifqt);

		ifs_remque(ifm);

	}



	/* Update so_queued */

	if (ifm->ifq_so) {

		if (--ifm->ifq_so->so_queued == 0)

		   /* If there's no more queued, reset nqueued */

		   ifm->ifq_so->so_nqueued = 0;

	}



        if (ifm->expiration_date < now) {

            /* Expired */

            m_free(ifm);

        } else {

            /* Encapsulate the packet for sending */

            if (if_encap(slirp, ifm)) {

                m_free(ifm);

            } else {

                /* re-queue */

                insque(ifm, ifqt);

                requeued++;

            }

        }



	if (slirp->if_queued)

	   goto again;



        slirp->if_queued = requeued;

}
",1
Detect whether the following code contains vulnerabilities.,"static void dump_human_image_check(ImageCheck *check)

{

    if (!(check->corruptions || check->leaks || check->check_errors)) {

        printf(""No errors were found on the image.\n"");

    } else {

        if (check->corruptions) {

            printf(""\n%"" PRId64 "" errors were found on the image.\n""

                ""Data may be corrupted, or further writes to the image ""

                ""may corrupt it.\n"",

                check->corruptions);

        }



        if (check->leaks) {

            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""

                ""This means waste of disk space, but no harm to data.\n"",

                check->leaks);

        }



        if (check->check_errors) {

            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",

                check->check_errors);

        }

    }



    if (check->total_clusters != 0 && check->allocated_clusters != 0) {

        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented\n"",

        check->allocated_clusters, check->total_clusters,

        check->allocated_clusters * 100.0 / check->total_clusters,

        check->fragmented_clusters * 100.0 / check->allocated_clusters);

    }



    if (check->image_end_offset) {

        printf(""Image end offset: %"" PRId64 ""\n"", check->image_end_offset);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
",0
Detect whether the following code contains vulnerabilities.,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
",1
Detect whether the following code contains vulnerabilities.,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
",0
Detect whether the following code contains vulnerabilities.,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_sub(a, b, &env->ucf64.fp_status);

}
",0
Detect whether the following code contains vulnerabilities.,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
",0
Detect whether the following code contains vulnerabilities.,"static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *ics = ICS_SIMPLE(dev);



    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
",0
Detect whether the following code contains vulnerabilities.,"static void do_subchannel_work(SubchDev *sch, ORB *orb)

{



    SCSW *s = &sch->curr_status.scsw;



    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {

        sch_handle_clear_func(sch);

    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {

        sch_handle_halt_func(sch);

    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {

        /* Triggered by both ssch and rsch. */

        sch_handle_start_func(sch, orb);

    } else {

        /* Cannot happen. */

        return;

    }

    css_inject_io_interrupt(sch);

}
",0
Detect whether the following code contains vulnerabilities.,"static int block_save_iterate(QEMUFile *f, void *opaque)

{

    int ret;

    int64_t last_ftell = qemu_ftell(f);



    DPRINTF(""Enter save live iterate submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* control the rate of transfer */

    blk_mig_lock();

    while ((block_mig_state.submitted +

            block_mig_state.read_done) * BLOCK_SIZE <

           qemu_file_get_rate_limit(f)) {

        blk_mig_unlock();

        if (block_mig_state.bulk_completed == 0) {

            /* first finish the bulk phase */

            if (blk_mig_save_bulked_block(f) == 0) {

                /* finished saving bulk on all devices */

                block_mig_state.bulk_completed = 1;

            }

            ret = 0;

        } else {

            /* Always called with iothread lock taken for

             * simplicity, block_save_complete also calls it.

             */

            qemu_mutex_lock_iothread();

            ret = blk_mig_save_dirty_block(f, 1);

            qemu_mutex_unlock_iothread();

        }

        if (ret < 0) {

            return ret;

        }

        blk_mig_lock();

        if (ret != 0) {

            /* no more dirty blocks */

            break;

        }

    }

    blk_mig_unlock();



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);

    return qemu_ftell(f) - last_ftell;

}
",1
Detect whether the following code contains vulnerabilities.,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)

{

    int i, n, n2;

    float alpha;



    n  = 1 << ln;

    n2 = n >> 1;



    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);



    for (i = 0; i < n2; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mdct->costab[i] = FIX15(cos(alpha));

        mdct->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mdct);

    return AVERROR(ENOMEM);

}
",0
Detect whether the following code contains vulnerabilities.,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",1
Detect whether the following code contains vulnerabilities.,"static void nbd_client_closed(NBDClient *client)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(client);

}
",1
Detect whether the following code contains vulnerabilities.,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)

{

    NvmeSQueue *sq;

    NvmeCreateSq *c = (NvmeCreateSq *)cmd;



    uint16_t cqid = le16_to_cpu(c->cqid);

    uint16_t sqid = le16_to_cpu(c->sqid);

    uint16_t qsize = le16_to_cpu(c->qsize);

    uint16_t qflags = le16_to_cpu(c->sq_flags);

    uint64_t prp1 = le64_to_cpu(c->prp1);



    if (!cqid || nvme_check_cqid(n, cqid)) {

        return NVME_INVALID_CQID | NVME_DNR;

    }

    if (!sqid || !nvme_check_sqid(n, sqid)) {

        return NVME_INVALID_QID | NVME_DNR;

    }

    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {

        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;

    }

    if (!prp1 || prp1 & (n->page_size - 1)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    if (!(NVME_SQ_FLAGS_PC(qflags))) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    sq = g_malloc0(sizeof(*sq));

    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);

    return NVME_SUCCESS;

}
",1
Detect whether the following code contains vulnerabilities.,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
",0
Detect whether the following code contains vulnerabilities.,"static void rtas_start_cpu(sPAPREnvironment *spapr,

                           uint32_t token, uint32_t nargs,

                           target_ulong args,

                           uint32_t nret, target_ulong rets)

{

    target_ulong id, start, r3;

    CPUState *cs;



    if (nargs != 3 || nret != 1) {

        rtas_st(rets, 0, -3);

        return;

    }



    id = rtas_ld(args, 0);

    start = rtas_ld(args, 1);

    r3 = rtas_ld(args, 2);



    cs = qemu_get_cpu(id);

    if (cs != NULL) {

        PowerPCCPU *cpu = POWERPC_CPU(cs);

        CPUPPCState *env = &cpu->env;



        if (!cs->halted) {

            rtas_st(rets, 0, -1);

            return;

        }



        /* This will make sure qemu state is up to date with kvm, and

         * mark it dirty so our changes get flushed back before the

         * new cpu enters */

        kvm_cpu_synchronize_state(cs);



        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);

        env->nip = start;

        env->gpr[3] = r3;

        cs->halted = 0;



        qemu_cpu_kick(cs);



        rtas_st(rets, 0, 0);

        return;

    }



    /* Didn't find a matching cpu */

    rtas_st(rets, 0, -3);

}
",0
Detect whether the following code contains vulnerabilities.,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)

{

    DeviceState *qdev;

    i2c_slave *slave = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        slave = I2C_SLAVE_FROM_QDEV(qdev);

        if (slave->address == address)

            break;

    }



    if (!slave)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = slave;

    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"int ff_h264_field_end(H264Context *h, int in_setup)
{
    AVCodecContext *const avctx = h->avctx;
    int err = 0;
    h->mb_y = 0;
    if (CONFIG_H264_VDPAU_DECODER &&
        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
        ff_vdpau_h264_set_reference_frames(h);
    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (!h->droppable) {
            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
            h->prev_poc_msb = h->poc_msb;
            h->prev_poc_lsb = h->poc_lsb;
        }
        h->prev_frame_num_offset = h->frame_num_offset;
        h->prev_frame_num        = h->frame_num;
        h->outputed_poc          = h->next_outputed_poc;
    }
    if (avctx->hwaccel) {
        if (avctx->hwaccel->end_frame(avctx) < 0)
            av_log(avctx, AV_LOG_ERROR,
                   ""hardware accelerator failed to decode picture\n"");
    }
    if (CONFIG_H264_VDPAU_DECODER &&
        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
        ff_vdpau_h264_picture_complete(h);
#if CONFIG_ERROR_RESILIENCE
    /*
     * FIXME: Error handling code does not seem to support interlaced
     * when slices span multiple rows
     * The ff_er_add_slice calls don't work right for bottom
     * fields; they cause massive erroneous error concealing
     * Error marking covers both fields (top and bottom).
     * This causes a mismatched s->error_count
     * and a bad error table. Further, the error count goes to
     * INT_MAX when called for bottom field, because mb_y is
     * past end by one (callers fault) and resync_mb_y != 0
     * causes problems for the first MB line, too.
     */
    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {
        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);
        ff_er_frame_end(&h->er);
    }
#endif /* CONFIG_ERROR_RESILIENCE */
    if (!in_setup && !h->droppable)
        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,
                                  h->picture_structure == PICT_BOTTOM_FIELD);
    emms_c();
    h->current_slice = 0;
    return err;
}",1
Detect whether the following code contains vulnerabilities.,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                sdhci_write_block_to_card(s);

            }

        }

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",1
Detect whether the following code contains vulnerabilities.,"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)

{

    int i, k, sb = 0;

    int msb = sbr->k[0];

    int usb = sbr->kx[1];

    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;



    sbr->num_patches = 0;



    if (goal_sb < sbr->kx[1] + sbr->m[1]) {

        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;

    } else

        k = sbr->n_master;



    do {

        int odd = 0;

        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {

            sb = sbr->f_master[i];

            odd = (sb + sbr->k[0]) & 1;

        }



        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);

        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];



        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {

            usb = sb;

            msb = sb;

            sbr->num_patches++;

        } else

            msb = sbr->kx[1];



        if (sbr->f_master[k] - sb < 3)

            k = sbr->n_master;

    } while (sb != sbr->kx[1] + sbr->m[1]);



    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)

        sbr->num_patches--;



    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5

    // However the Coding Technologies decoder check uses 6 patches

    if (sbr->num_patches > 6) {

        av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches);

        return -1;

    }



    return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"static void *thread_func(void *p)

{

    struct thread_info *info = p;



    rcu_register_thread();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        info->r = xorshift64star(info->r);

        info->func(info);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
",0
Detect whether the following code contains vulnerabilities.,"static int http_start_receive_data(HTTPContext *c)

{

    int fd;



    if (c->stream->feed_opened)

        return -1;



    /* Don't permit writing to this one */

    if (c->stream->readonly)

        return -1;



    /* open feed */

    fd = open(c->stream->feed_filename, O_RDWR);

    if (fd < 0) {

        http_log(""Error opening feeder file: %s\n"", strerror(errno));

        return -1;

    }

    c->feed_fd = fd;



    if (c->stream->truncate) {

        /* truncate feed file */

        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);

        ftruncate(c->feed_fd, FFM_PACKET_SIZE);

        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);

    } else {

        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {

            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));

            return -1;

        }

    }



    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

    c->stream->feed_size = lseek(fd, 0, SEEK_END);

    lseek(fd, 0, SEEK_SET);



    /* init buffer input */

    c->buffer_ptr = c->buffer;

    c->buffer_end = c->buffer + FFM_PACKET_SIZE;

    c->stream->feed_opened = 1;

    c->chunked_encoding = !!av_stristr(c->buffer, ""Transfer-Encoding: chunked"");

    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void ppc_cpu_class_init(ObjectClass *oc, void *data)

{

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    pcc->parent_realize = dc->realize;

    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;

    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    dc->realize = ppc_cpu_realizefn;

    dc->unrealize = ppc_cpu_unrealizefn;



    pcc->parent_reset = cc->reset;

    cc->reset = ppc_cpu_reset;



    cc->class_by_name = ppc_cpu_class_by_name;

    cc->has_work = ppc_cpu_has_work;

    cc->do_interrupt = ppc_cpu_do_interrupt;

    cc->dump_state = ppc_cpu_dump_state;

    cc->dump_statistics = ppc_cpu_dump_statistics;

    cc->set_pc = ppc_cpu_set_pc;

    cc->gdb_read_register = ppc_cpu_gdb_read_register;

    cc->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;

    cc->vmsd = &vmstate_ppc_cpu;

#if defined(TARGET_PPC64)

    cc->write_elf64_note = ppc64_cpu_write_elf64_note;

    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;

#endif

#endif



    cc->gdb_num_core_regs = 71;



#ifdef USE_APPLE_GDB

    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;

    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;

    cc->gdb_num_core_regs = 71 + 32;

#endif



#if defined(TARGET_PPC64)

    cc->gdb_core_xml_file = ""power64-core.xml"";

#else

    cc->gdb_core_xml_file = ""power-core.xml"";

#endif

#ifndef CONFIG_USER_ONLY

    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;

#endif



    dc->fw_name = ""PowerPC,UNKNOWN"";

}
",0
Detect whether the following code contains vulnerabilities.,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
",0
Detect whether the following code contains vulnerabilities.,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
",1
Detect whether the following code contains vulnerabilities.,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
",0
Detect whether the following code contains vulnerabilities.,"static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,

                                     bool secondary, target_ulong ptem,

                                     ppc_hash_pte64_t *pte)

{

    CPUPPCState *env = &cpu->env;

    int i;

    uint64_t token;

    target_ulong pte0, pte1;

    target_ulong pte_index;



    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;

    token = ppc_hash64_start_access(cpu, pte_index);

    if (!token) {

        return -1;

    }

    for (i = 0; i < HPTES_PER_GROUP; i++) {

        pte0 = ppc_hash64_load_hpte0(cpu, token, i);

        pte1 = ppc_hash64_load_hpte1(cpu, token, i);



        if ((pte0 & HPTE64_V_VALID)

            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))

            && HPTE64_V_COMPARE(pte0, ptem)) {

            pte->pte0 = pte0;

            pte->pte1 = pte1;

            ppc_hash64_stop_access(token);

            return (pte_index + i) * HASH_PTE_SIZE_64;

        }

    }

    ppc_hash64_stop_access(token);

    /*

     * We didn't find a valid entry.

     */

    return -1;

}
",0
Detect whether the following code contains vulnerabilities.,"static av_cold int dcadec_init(AVCodecContext *avctx)

{

    DCAContext *s = avctx->priv_data;



    s->avctx = avctx;

    s->core.avctx = avctx;

    s->exss.avctx = avctx;

    s->xll.avctx = avctx;

    s->lbr.avctx = avctx;



    ff_dca_init_vlcs();



    if (ff_dca_core_init(&s->core) < 0)

        return AVERROR(ENOMEM);



    if (ff_dca_lbr_init(&s->lbr) < 0)

        return AVERROR(ENOMEM);



    ff_dcadsp_init(&s->dcadsp);

    s->core.dcadsp = &s->dcadsp;

    s->xll.dcadsp = &s->dcadsp;

    s->lbr.dcadsp = &s->dcadsp;



    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);



    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {

    case 0:

        s->request_channel_layout = 0;

        break;

    case AV_CH_LAYOUT_STEREO:

    case AV_CH_LAYOUT_STEREO_DOWNMIX:

        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;

        break;

    case AV_CH_LAYOUT_5POINT0:

        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;

        break;

    case AV_CH_LAYOUT_5POINT1:

        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;

        break;

    default:

        av_log(avctx, AV_LOG_WARNING, ""Invalid request_channel_layout\n"");

        break;

    }



    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;

    avctx->bits_per_raw_sample = 24;



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
",1
Detect whether the following code contains vulnerabilities.,"test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}
",1
Detect whether the following code contains vulnerabilities.,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_update_msi_routes_all(void *private, bool global,

                                      uint32_t index, uint32_t mask)

{

    int cnt = 0;

    MSIRouteEntry *entry;

    MSIMessage msg;

    /* TODO: explicit route update */

    QLIST_FOREACH(entry, &msi_route_list, list) {

        cnt++;

        msg = pci_get_msi_message(entry->dev, entry->vector);

        kvm_irqchip_update_msi_route(kvm_state, entry->virq,

                                     msg, entry->dev);

    }

    kvm_irqchip_commit_routes(kvm_state);

    trace_kvm_x86_update_msi_routes(cnt);

}
",1
Detect whether the following code contains vulnerabilities.,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"static void ide_sector_write(IDEState *s)

{

    int64_t sector_num;

    int ret, n, n1;



    s->status = READY_STAT | SEEK_STAT;

    sector_num = ide_get_sector(s);

#if defined(DEBUG_IDE)

    printf(""write sector=%Ld\n"", sector_num);

#endif

    n = s->nsector;

    if (n > s->req_nb_sectors)

        n = s->req_nb_sectors;

    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);

    s->nsector -= n;

    if (s->nsector == 0) {

        /* no more sector to write */

        ide_transfer_stop(s);

    } else {

        n1 = s->nsector;

        if (n1 > s->req_nb_sectors)

            n1 = s->req_nb_sectors;

        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);

    }

    ide_set_sector(s, sector_num + n);

    

#ifdef TARGET_I386

    if (win2k_install_hack) {

        /* It seems there is a bug in the Windows 2000 installer HDD

           IDE driver which fills the disk with empty logs when the

           IDE write IRQ comes too early. This hack tries to correct

           that at the expense of slower write performances. Use this

           option _only_ to install Windows 2000. You must disable it

           for normal use. */

        qemu_mod_timer(s->sector_write_timer, 

                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));

    } else 

#endif

    {

        ide_set_irq(s);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
",0
Detect whether the following code contains vulnerabilities.,"void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)

{

    int i;

    INIT_CLIP

    pixel *dst = (pixel*)_dst;

    dctcoef *block = (dctcoef*)_block;

    stride /= sizeof(pixel);



    block[0] += 1 << 5;



    for(i=0; i<4; i++){

        const int z0=  block[i + 4*0]     +  block[i + 4*2];

        const int z1=  block[i + 4*0]     -  block[i + 4*2];

        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];

        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);



        block[i + 4*0]= z0 + z3;

        block[i + 4*1]= z1 + z2;

        block[i + 4*2]= z1 - z2;

        block[i + 4*3]= z0 - z3;

    }



    for(i=0; i<4; i++){

        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];

        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];

        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];

        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);



        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));

        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));

        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));

        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));

    }

}
",1
Detect whether the following code contains vulnerabilities.,"static void disas_fp_ccomp(DisasContext *s, uint32_t insn)

{

    unsigned int mos, type, rm, cond, rn, op, nzcv;

    TCGv_i64 tcg_flags;

    int label_continue = -1;



    mos = extract32(insn, 29, 3);

    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */

    rm = extract32(insn, 16, 5);

    cond = extract32(insn, 12, 4);

    rn = extract32(insn, 5, 5);

    op = extract32(insn, 4, 1);

    nzcv = extract32(insn, 0, 4);



    if (mos || type > 1) {

        unallocated_encoding(s);

        return;

    }



    if (!fp_access_check(s)) {

        return;

    }



    if (cond < 0x0e) { /* not always */

        int label_match = gen_new_label();

        label_continue = gen_new_label();

        arm_gen_test_cc(cond, label_match);

        /* nomatch: */

        tcg_flags = tcg_const_i64(nzcv << 28);

        gen_set_nzcv(tcg_flags);

        tcg_temp_free_i64(tcg_flags);

        tcg_gen_br(label_continue);

        gen_set_label(label_match);

    }



    handle_fp_compare(s, type, rn, rm, false, op);



    if (cond < 0x0e) {

        gen_set_label(label_continue);

    }

}
",0
Detect whether the following code contains vulnerabilities.,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
",0
Detect whether the following code contains vulnerabilities.,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
",0
Detect whether the following code contains vulnerabilities.,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",1
Detect whether the following code contains vulnerabilities.,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned long iv_decode_frame(Indeo3DecodeContext *s, 
                                     unsigned char *buf, int buf_size) 
{
  unsigned int hdr_width, hdr_height,
    chroma_width, chroma_height;
  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;
  unsigned char *hdr_pos, *buf_pos;
  buf_pos = buf;
  buf_pos += 18;
  fflags1 = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  fflags3 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  fflags2 = *buf_pos++;
  buf_pos += 3;
  hdr_height = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  hdr_width = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;
  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;
  offs1 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  offs2 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  offs3 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 8;
  hdr_pos = buf_pos;
  if(fflags3 == 0x80) return 4;
  if(fflags1 & 0x200) {
    s->cur_frame = s->iv_frame + 1;
    s->ref_frame = s->iv_frame;
  } else {
    s->cur_frame = s->iv_frame;
    s->ref_frame = s->iv_frame + 1;
  }
  buf_pos = buf + 16 + offs1;
  offs = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, 
    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, 
    min(hdr_width, 160));
  if (!(s->avctx->flags & CODEC_FLAG_GRAY))
  {
  buf_pos = buf + 16 + offs2;
  offs = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, 
    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, 
    min(chroma_width, 40));
  buf_pos = buf + 16 + offs3;
  offs = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, 
    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, 
    min(chroma_width, 40));
  }
  return 8;
}",1
Detect whether the following code contains vulnerabilities.,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",1
Detect whether the following code contains vulnerabilities.,"void ff_init_me(MpegEncContext *s){

    MotionEstContext * const c= &s->me;

    c->avctx= s->avctx;



    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);

    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);

    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);

    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);

    

    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);

    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);

    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);



/*FIXME s->no_rounding b_type*/

    if(s->flags&CODEC_FLAG_QPEL){

        c->sub_motion_search= qpel_motion_search;

        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;

        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;

        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;

    }else{

        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)

            c->sub_motion_search= hpel_motion_search;

        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD 

                && c->avctx->    me_cmp == FF_CMP_SAD 

                && c->avctx->    mb_cmp == FF_CMP_SAD)

            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles

        else

            c->sub_motion_search= hpel_motion_search;

    }

    c->hpel_avg= s->dsp.avg_pixels_tab;

    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;

    else               c->hpel_put= s->dsp.put_pixels_tab;



    if(s->linesize){

        c->stride  = s->linesize; 

        c->uvstride= s->uvlinesize;

    }else{

        c->stride  = 16*s->mb_width + 32;

        c->uvstride=  8*s->mb_width + 16;

    }



    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it

    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){

        s->dsp.me_cmp[2]= zero_cmp;

    }

    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){

        s->dsp.me_sub_cmp[2]= zero_cmp;

    }

    c->hpel_put[2][0]= c->hpel_put[2][1]=

    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;



    c->temp= c->scratchpad;

}
",0
Detect whether the following code contains vulnerabilities.,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
",0
Detect whether the following code contains vulnerabilities.,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
",0
Detect whether the following code contains vulnerabilities.,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
",0
Detect whether the following code contains vulnerabilities.,"static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    int ret;



    st = av_new_stream(c->fc, c->fc->nb_streams);

    if (!st) return AVERROR(ENOMEM);

    sc = av_mallocz(sizeof(MOVStreamContext));

    if (!sc) return AVERROR(ENOMEM);



    st->priv_data = sc;

    st->codec->codec_type = CODEC_TYPE_DATA;

    st->start_time = 0; /* XXX: check */



    if ((ret = mov_read_default(c, pb, atom)) < 0)

        return ret;



    /* sanity checks */

    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||

                           (!sc->sample_size && !sc->sample_count))){

        av_log(c->fc, AV_LOG_ERROR, ""stream %d, missing mandatory atoms, broken header\n"",

               st->index);

        sc->sample_count = 0; //ignore track

        return 0;

    }

    if(!sc->time_rate)

        sc->time_rate=1;

    if(!sc->time_scale)

        sc->time_scale= c->time_scale;

    av_set_pts_info(st, 64, sc->time_rate, sc->time_scale);



    if (st->codec->codec_type == CODEC_TYPE_AUDIO &&

        !st->codec->frame_size && sc->stts_count == 1)

        st->codec->frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);



    if(st->duration != AV_NOPTS_VALUE){

        assert(st->duration % sc->time_rate == 0);

        st->duration /= sc->time_rate;

    }

    sc->ffindex = st->index;

    mov_build_index(c, st);



    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {

        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)

            av_log(c->fc, AV_LOG_ERROR, ""stream %d, error opening file %s: %s\n"",

                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));

    } else

        sc->pb = c->fc->pb;



    switch (st->codec->codec_id) {

#ifdef CONFIG_H261_DECODER

    case CODEC_ID_H261:

#endif

#ifdef CONFIG_H263_DECODER

    case CODEC_ID_H263:

#endif

#ifdef CONFIG_MPEG4_DECODER

    case CODEC_ID_MPEG4:

#endif

        st->codec->width= 0; /* let decoder init width/height */

        st->codec->height= 0;

        break;

#ifdef CONFIG_VORBIS_DECODER

    case CODEC_ID_VORBIS:

#endif

        st->codec->sample_rate= 0; /* let decoder init parameters properly */

        break;

    }



    /* Do not need those anymore. */

    av_freep(&sc->chunk_offsets);

    av_freep(&sc->sample_to_chunk);

    av_freep(&sc->sample_sizes);

    av_freep(&sc->keyframes);

    av_freep(&sc->stts_data);



    return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,

                                            target_phys_addr_t base,

                                            qemu_irq txirq, qemu_irq rxirq,

                                            qemu_irq *dma, omap_clk clk)

{

    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)

            g_malloc0(sizeof(struct omap_mcbsp_s));



    s->txirq = txirq;

    s->rxirq = rxirq;

    s->txdrq = dma[0];

    s->rxdrq = dma[1];

    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);

    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);

    omap_mcbsp_reset(s);



    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",0
Detect whether the following code contains vulnerabilities.,"static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j;

    int mx, my;

    int avail_index = avail_indexes[subblock_no];

    int c_off = part_sizes_w[block_type];



    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;

    if(subblock_no == 3)

        c_off = -1;



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + c_off]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];

        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];

    }

    mx = mid_pred(A[0], B[0], C[0]);

    my = mid_pred(A[1], B[1], C[1]);

    mx += r->dmv[dmv_no][0];

    my += r->dmv[dmv_no][1];

    for(j = 0; j < part_sizes_h[block_type]; j++){

        for(i = 0; i < part_sizes_w[block_type]; i++){

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;

        }

    }

}
",0
